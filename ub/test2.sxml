MLton gd05531c-dirty (built Wed Jun 29 03:10:58 UTC 2016 on ip-10-11-0-169)
  created this file on Wed Jun 29 03:19:14 2016.
Do not edit this file.
Flag settings: 
   align: 8
   atMLtons: (@MLton, --)
   chunk: coalesce 4096
   closureConvertGlobalize: true
   closureConvertShrink: true
   codegen: c
   contifyIntoMain: false
   debug: true
   defaultChar: char8
   defaultWideChar: widechar32
   defaultInt: int32
   defaultReal: real64
   defaultWord: word32
   diag passes: []
   drop passes: []
   elaborate allowConstant (default): false
   elaborate allowConstant (enabled): true
   elaborate allowFFI (default): false
   elaborate allowFFI (enabled): true
   elaborate allowPrim (default): false
   elaborate allowPrim (enabled): true
   elaborate allowOverload (default): false
   elaborate allowOverload (enabled): true
   elaborate allowOptBar (default): false
   elaborate allowOptBar (enabled): true
   elaborate allowOptSemicolon (default): false
   elaborate allowOptSemicolon (enabled): true
   elaborate allowLineComments (default): false
   elaborate allowLineComments (enabled): true
   elaborate allowDoDecls (default): false
   elaborate allowDoDecls (enabled): true
   elaborate allowRecPunning (default): false
   elaborate allowRecPunning (enabled): true
   elaborate allowOrPats (default): false
   elaborate allowOrPats (enabled): true
   elaborate allowExtendedLiterals (default): false
   elaborate allowExtendedLiterals (enabled): true
   elaborate allowSigWithtype (default): false
   elaborate allowSigWithtype (enabled): true
   elaborate allowRebindEquals (default): false
   elaborate allowRebindEquals (enabled): true
   elaborate deadCode (default): false
   elaborate deadCode (enabled): true
   elaborate forceUsed (default): false
   elaborate forceUsed (enabled): true
   elaborate ffiStr (default): 
   elaborate ffiStr (enabled): true
   elaborate nonexhaustiveExnMatch (default): default
   elaborate nonexhaustiveExnMatch (enabled): true
   elaborate nonexhaustiveMatch (default): warn
   elaborate nonexhaustiveMatch (enabled): true
   elaborate redundantMatch (default): warn
   elaborate redundantMatch (enabled): true
   elaborate resolveScope (default): strdec
   elaborate resolveScope (enabled): true
   elaborate sequenceNonUnit (default): ignore
   elaborate sequenceNonUnit (enabled): true
   elaborate valrecConstr (default): warn
   elaborate valrecConstr (enabled): true
   elaborate warnUnused (default): false
   elaborate warnUnused (enabled): true
   elaborate only: false
   emit main: true
   export header: None
   exn history: false
   generated output format: executable
   gc check: Limit
   indentation: 3
   inlineIntoMain: true
   inlineLeafA: {loops = true, repeat = true, size = Some 20}
   inlineLeafB: {loops = true, repeat = true, size = Some 40}
   inlineNonRec: {small = 60, product = 320}
   input file: test2.sxml
   keep AST: false
   keep CoreML: true
   keep def use: true
   keep dot: false
   keep Machine: true
   keep passes: []
   keep RSSA: true
   keep SSA: true
   keep SSA2: true
   keep SXML: true
   keep XML: true
   extra_: false
   lib dir: /home/jcmurphy/MLton/build/lib
   lib target dir: /home/jcmurphy/MLton/build/lib/targets/self
   loop passes: 1
   mark cards: true
   max function size: 10000
   mlb path vars: [{var = MLTON_ROOT, path = $(LIB_MLTON_DIR)/sml}, {var = SML_LIB, path = $(LIB_MLTON_DIR)/sml}]
   native commented: 0
   native live stack: false
   native optimize: 1
   native move hoist: true
   native copy prop: true
   native copy prop cutoff: 1000
   native cutoff: 100
   native live transfer: 8
   native shuffle: true
   native ieee fp: false
   native split: Some 20000
   optimizationPasses: [<ssa2::default>, <ssa::default>, <sxml::default>, <xml::default>]
   polyvariance: Some {hofo = true, rounds = 2, small = 30, product = 300}
   prefer abs paths: false
   prof passes: []
   profile: None
   profile branch: false
   profile C: []
   profile IL: ProfileSource
   profile include/exclude: [(Seq [Star [.], Or [Seq [Seq [[$], [(], [S], [M], [L], [_], [L], [I], [B], [)]]]], Star [.]], false)]
   profile raise: false
   profile stack: false
   profile val: false
   show basis: None
   show def-use: None
   show types: true
   target: self
   target arch: AMD64
   target OS: Linux
   type check: false
   verbosity: Pass
   warn unrecognized annotation: true
   warn deprecated features: true
   zone cut depth: 100


Datatypes:
exn = UNKNOWN_0 of unit ref
      | Poll_0 of unit ref
      | DoublyRedirected_0 of unit ref
      | MisuseOfForget_0 of unit ref
      | DieFailed_1 of unit ref
      | DieFailed_0 of unit ref
      | Interrupt_0 of unit ref
      | Io_1 of unit ref * word8 vector
      | Ord_0 of unit ref
      | Ln_0 of unit ref
      | Sqrt_0 of unit ref
      | InvalidArc_0 of unit ref
      | Path_0 of unit ref
      | RandomAccessNotSupported_0 of unit ref
      | NonblockingNotSupported_0 of unit ref
      | Io_0 of unit ref * (exn * word8 vector * word8 vector)
      | ClosedStream_0 of unit ref
      | BlockingNotSupported_0 of unit ref
      | Date_0 of unit ref
      | Time_0 of unit ref
      | Bad_1 of unit ref
      | Bad_0 of unit ref
      | Unordered_0 of unit ref
      | SysErr_0 of unit ref * (word8 vector * Primitive.Option.t_0)
      | UnequalLengths_0 of unit ref
      | Empty_0 of unit ref
      | Option_0 of unit ref
      | Fail_0 of unit ref * word8 vector
      | Chr_0 of unit ref
      | GenerateVectorNotFull_1 of unit ref
      | GenerateAlreadyGotVector_1 of unit ref
      | GenerateVectorNotFull_0 of unit ref
      | GenerateAlreadyGotVector_0 of unit ref
      | Subscript_0 of unit ref
      | Span_0 of unit ref
      | Size_0 of unit ref
      | Overflow_0 of unit ref
      | Fail32_0 of unit ref * word32 vector
      | Fail16_0 of unit ref * word16 vector
      | Fail8_0 of unit ref * word8 vector
      | Domain_0 of unit ref
      | Div_0 of unit ref
      | Overflow of unit ref
      | Match_0 of unit ref
      | Bind_0 of unit ref
bool = false
       | true
Primitive.Option.t_0 = NONE_0
		       | SOME_0 of word32
Primitive.MLton.Platform.OS.t_0 = Linux_0
				  | MinGW_0
Primitive.IntInf.ans_0 = Big_0 of bool * bool * word8
			 | Small_0 of word64
Primitive.IntInf.ans_1 = Big_1 of bool * bool * word16
			 | Small_1 of word64
Primitive.IntInf.ans_2 = Big_2 of bool * bool * word32
			 | Small_2 of word64
Primitive.IntInf.ans_3 = Big_3 of bool * bool * word64
			 | Small_3 of word64
Primitive.Option.t_1 = NONE_1
		       | SOME_1 of word8 vector
list_0 = nil_0
	 | ::_0 of (exn -> Primitive.Option.t_1) * list_0
StringCvt.radix_0 = BIN_0
		    | OCT_0
		    | DEC_0
		    | HEX_0
list_1 = nil_1
	 | ::_1 of (word8 -> Primitive.Option.t_0) * list_1
One.t_0 = T_0 of (unit -> word8 array) * word8 array * bool ref
Primitive.Option.t_2 = NONE_2
		       | SOME_2 of word8 * word32
Primitive.Option.t_3 = NONE_3
		       | SOME_3 of word32 * word32
Primitive.Option.t_4 = NONE_4
		       | SOME_4 of intInf * word32
Primitive.Option.t_5 = NONE_5
		       | SOME_5 of intInf
Primitive.Option.t_6 = NONE_6
		       | SOME_6 of word8
list_2 = nil_2
	 | ::_2 of (unit -> unit) * list_2
list_3 = nil_3
	 | ::_3 of (word32 * word8 vector) * list_3
IEEEReal.RoundingMode.t_0 = TO_NEAREST_0
			    | TO_NEGINF_0
			    | TO_POSINF_0
			    | TO_ZERO_0
IEEEReal.float_class_0 = INF_0
			 | NAN_0
			 | NORMAL_0
			 | SUBNORMAL_0
			 | ZERO_0
One.t_1 = T_1 of (unit -> word32 ref) * word32 ref * bool ref
Time.time_0 = T_2 of intInf
list_4 = nil_4
	 | ::_4 of word32 * list_4
PosixFileSys.ST.stat_0 = T_3 of Time.time_0
				* Time.time_0
				* word64
				* word32
				* word64
				* word32
				* Time.time_0
				* word32
				* word64
				* word32
Primitive.Option.t_7 = NONE_7
		       | SOME_7 of unit -> unit
Primitive.Option.t_8 = NONE_8
		       | SOME_8 of unit -> bool
Primitive.Option.t_9 = NONE_9
		       | SOME_9 of unit -> word64
PrimSequence.Slice.t_0 = T_4 of word64 * word8 array * word64
Primitive.Option.t_10 = NONE_10
			| SOME_10 of PrimSequence.Slice.t_0 -> word32
Primitive.Option.t_11 = NONE_11
			| SOME_11 of PrimSequence.Slice.t_0
				     -> Primitive.Option.t_0
Primitive.Option.t_12 = SOME_12 of word32 -> word8 vector
Primitive.Option.t_13 = SOME_13 of word32 -> Primitive.Option.t_1
Primitive.Option.t_14 = NONE_12
			| SOME_14 of word64 -> unit
PrimIO.reader_0 = RD_0 of (unit -> Primitive.Option.t_0)
			  * Primitive.Option.t_7
			  * Primitive.Option.t_8
			  * word32
			  * (unit -> unit)
			  * Primitive.Option.t_9
			  * Primitive.Option.t_9
			  * Primitive.Option.t_0
			  * word8 vector
			  * Primitive.Option.t_10
			  * Primitive.Option.t_11
			  * Primitive.Option.t_12
			  * Primitive.Option.t_13
			  * Primitive.Option.t_14
			  * Primitive.Option.t_9
PrimSequence.Slice.t_1 = T_5 of word64 * word8 vector * word64
Primitive.Option.t_15 = NONE_13
			| SOME_15 of PrimSequence.Slice.t_1 -> word32
Primitive.Option.t_16 = NONE_14
			| SOME_16 of PrimSequence.Slice.t_1
				     -> Primitive.Option.t_0
PrimIO.writer_0 = WR_0 of Primitive.Option.t_7
			  * Primitive.Option.t_8
			  * word32
			  * (unit -> unit)
			  * Primitive.Option.t_9
			  * Primitive.Option.t_9
			  * Primitive.Option.t_0
			  * word8 vector
			  * Primitive.Option.t_14
			  * Primitive.Option.t_9
			  * Primitive.Option.t_10
			  * Primitive.Option.t_11
			  * Primitive.Option.t_15
			  * Primitive.Option.t_16
StreamIOExtra.outstream_0 = Out_0 of PrimIO.writer_0
				     * StreamIOExtra.bufferMode_0 ref
				     * StreamIOExtra.state_0 ref
				     * PrimIO.writer_0
list_5 = nil_5
	 | ::_5 of (StreamIOExtra.outstream_0 * bool) * list_5
IO.buffer_mode_0 = NO_BUF_0
		   | LINE_BUF_0
		   | BLOCK_BUF_0
ImperativeIOExtra.Outstream.t_0 = T_6 of StreamIOExtra.outstream_0 ref
Primitive.Option.t_17 = NONE_15
			| SOME_17 of thread
Primitive.Option.t_18 = NONE_16
			| SOME_18 of thread * Primitive.Option.t_17 ref
MLtonThread.t_0 = T_7 of MLtonThread.thread_0 ref
MLtonProfile.Data.t_0 = T_8 of bool ref * bool ref * cpointer
list_6 = nil_6
	 | ::_6 of MLtonProfile.Data.t_0 * list_6
MLtonThread.thread_0 = Dead_0
		       | Interrupted_0 of thread
		       | New_0 of unit -> unit
		       | Paused_0 of ((unit -> unit) -> unit) * thread
MLtonThread.t_1 = T_9 of MLtonThread.thread_1 ref
MLtonThread.thread_1 = Dead_1
		       | Interrupted_1 of thread
		       | New_1 of thread -> unit
		       | Paused_1 of ((unit -> thread) -> unit) * thread
list_7 = nil_7
	 | ::_7 of word8 vector * list_7
StreamIOExtra.state_0 = Active_0
			| Closed_0
StreamIOExtra.bufferMode_0 = NO_BUF_1
			     | LINE_BUF_1 of StreamIOExtra.buf_0
			     | BLOCK_BUF_1 of StreamIOExtra.buf_0
StreamIOExtra.buf_0 = Buf_0 of word8 array * word32 ref
PosixIO.whence_0 = SEEK_SET_0
		   | SEEK_CUR_0
		   | SEEK_END_0
list_8 = nil_8
	 | ::_8 of (word32 * (unit -> PosixFileSys.ST.stat_0)) * list_8
list_9 = nil_9
	 | ::_9 of (word32 * (unit -> word64)) * list_9
list_10 = nil_10
	  | ::_10 of (word32 * (unit -> word32)) * list_10
Primitive.Option.t_19 = NONE_17
			| SOME_19 of word32 * (unit -> word32)
Primitive.Option.t_20 = NONE_18
			| SOME_20 of word32 * (unit -> PosixFileSys.ST.stat_0)
Primitive.Option.t_21 = NONE_19
			| SOME_21 of word32 * (unit -> word64)
Primitive.Option.t_22 = NONE_20
			| SOME_22 of word32 * word8 vector
Primitive.Option.t_23 = NONE_21
			| SOME_23 of word64
Primitive.Option.t_24 = NONE_22
			| SOME_24 of word64 * word32
Primitive.Option.t_25 = NONE_23
			| SOME_25 of (word64 * bool * word64) * word32
list_11 = nil_11
	  | ::_11 of word8 * list_11
PrimSequence.Slice.t_2 = T_10 of word64 * (cpointer -> unit) array * word64
PrimSequence.Slice.t_3 = T_11 of word64 * Primitive.Option.t_0 array * word64
PrimSequence.Slice.t_4 = T_12 of word64 * bool array * word64
list_12 = nil_12
	  | ::_12 of PrimSequence.Slice.t_1 * list_12
list_13 = nil_13
	  | ::_13 of (word64 * word64) * list_13
Primitive.Option.t_26 = NONE_24
			| SOME_26 of word64 * word8
DynamicWind.try.t_0 = A_0 of word8 vector
		      | E_0 of exn
DynamicWind.try.t_1 = A_1 of word32
		      | E_1 of exn
DynamicWind.try.t_2 = A_2 of word64
		      | E_2 of exn
DynamicWind.try.t_3 = A_3 of PosixFileSys.ST.stat_0
		      | E_3 of exn


Overflow: Some x_8169


Body:
let
   val x_8170: unit = 
      let
	 val x_8171: exn -> unit = 
	    fn x_8172: exn => 
	    let
	       val x_8173: word8 vector = 
		  "toplevel handler not installed"
	       val x_8174: unit = 
		  MLton_bug (x_8173)
	    in
	       x_8174
	    end
	 val x_8175: (exn -> unit) ref = 
	    Ref_ref[exn -> unit] (x_8171)
	 val x_8176: unit = 
	    let
	       val x_8177: unit -> unit = 
		  fn x_8178: unit => 
		  let
		     val x_8179: word8 vector = 
			"toplevel suffix not installed"
		     val x_8180: unit = 
			MLton_bug (x_8179)
		  in
		     x_8180
		  end
	       val x_8181: (unit -> unit) ref = 
		  Ref_ref[unit -> unit] (x_8177)
	       val x_8182: unit = 
		  ()
	       val x_8183: unit ref = 
		  Ref_ref[unit] (x_8182)
	       val x_8169: exn = 
		  Overflow x_8183
	       val rec 
		  not_0: bool -> bool = 
		     fn x_8184: bool => 
		     let
			val x_8185: bool = 
			   case x_8184 of
			   true => 
			      let
				 val x_8187: bool = 
				    false
			      in
				 x_8187
			      end
			   false => 
			      let
				 val x_8186: bool = 
				    true
			      in
				 x_8186
			      end
		     in
			x_8185
		     end
	       val bufSize_0: word32 = 
		  0x1000
	       val name_0: exn -> word8 vector = 
		  fn x_8188: exn => 
		  let
		     val x_8189: word8 vector = 
			case x_8188 of
			UNKNOWN_0 x_8278: unit ref => 
			   let
			      val x_8279: word8 vector = 
				 "UNKNOWN"
			   in
			      x_8279
			   end
			Poll_0 x_8276: unit ref => 
			   let
			      val x_8277: word8 vector = 
				 "Poll"
			   in
			      x_8277
			   end
			DoublyRedirected_0 x_8274: unit ref => 
			   let
			      val x_8275: word8 vector = 
				 "DoublyRedirected"
			   in
			      x_8275
			   end
			MisuseOfForget_0 x_8272: unit ref => 
			   let
			      val x_8273: word8 vector = 
				 "MisuseOfForget"
			   in
			      x_8273
			   end
			DieFailed_1 x_8270: unit ref => 
			   let
			      val x_8271: word8 vector = 
				 "DieFailed"
			   in
			      x_8271
			   end
			DieFailed_0 x_8268: unit ref => 
			   let
			      val x_8269: word8 vector = 
				 "DieFailed"
			   in
			      x_8269
			   end
			Interrupt_0 x_8266: unit ref => 
			   let
			      val x_8267: word8 vector = 
				 "Interrupt"
			   in
			      x_8267
			   end
			Io_1 x_8264: unit ref * word8 vector => 
			   let
			      val x_8265: word8 vector = 
				 "Io"
			   in
			      x_8265
			   end
			Ord_0 x_8262: unit ref => 
			   let
			      val x_8263: word8 vector = 
				 "Ord"
			   in
			      x_8263
			   end
			Ln_0 x_8260: unit ref => 
			   let
			      val x_8261: word8 vector = 
				 "Ln"
			   in
			      x_8261
			   end
			Sqrt_0 x_8258: unit ref => 
			   let
			      val x_8259: word8 vector = 
				 "Sqrt"
			   in
			      x_8259
			   end
			InvalidArc_0 x_8256: unit ref => 
			   let
			      val x_8257: word8 vector = 
				 "InvalidArc"
			   in
			      x_8257
			   end
			Path_0 x_8254: unit ref => 
			   let
			      val x_8255: word8 vector = 
				 "Path"
			   in
			      x_8255
			   end
			RandomAccessNotSupported_0 x_8252: unit ref => 
			   let
			      val x_8253: word8 vector = 
				 "RandomAccessNotSupported"
			   in
			      x_8253
			   end
			NonblockingNotSupported_0 x_8250: unit ref => 
			   let
			      val x_8251: word8 vector = 
				 "NonblockingNotSupported"
			   in
			      x_8251
			   end
			Io_0 x_8248: unit ref
				     * (exn * word8 vector * word8 vector) => 
			   let
			      val x_8249: word8 vector = 
				 "Io"
			   in
			      x_8249
			   end
			ClosedStream_0 x_8246: unit ref => 
			   let
			      val x_8247: word8 vector = 
				 "ClosedStream"
			   in
			      x_8247
			   end
			BlockingNotSupported_0 x_8244: unit ref => 
			   let
			      val x_8245: word8 vector = 
				 "BlockingNotSupported"
			   in
			      x_8245
			   end
			Date_0 x_8242: unit ref => 
			   let
			      val x_8243: word8 vector = 
				 "Date"
			   in
			      x_8243
			   end
			Time_0 x_8240: unit ref => 
			   let
			      val x_8241: word8 vector = 
				 "Time"
			   in
			      x_8241
			   end
			Bad_1 x_8238: unit ref => 
			   let
			      val x_8239: word8 vector = 
				 "Bad"
			   in
			      x_8239
			   end
			Bad_0 x_8236: unit ref => 
			   let
			      val x_8237: word8 vector = 
				 "Bad"
			   in
			      x_8237
			   end
			Unordered_0 x_8234: unit ref => 
			   let
			      val x_8235: word8 vector = 
				 "Unordered"
			   in
			      x_8235
			   end
			SysErr_0 x_8232: unit ref
					 * (word8 vector * Primitive.Option.t_0) => 
			   let
			      val x_8233: word8 vector = 
				 "SysErr"
			   in
			      x_8233
			   end
			UnequalLengths_0 x_8230: unit ref => 
			   let
			      val x_8231: word8 vector = 
				 "UnequalLengths"
			   in
			      x_8231
			   end
			Empty_0 x_8228: unit ref => 
			   let
			      val x_8229: word8 vector = 
				 "Empty"
			   in
			      x_8229
			   end
			Option_0 x_8226: unit ref => 
			   let
			      val x_8227: word8 vector = 
				 "Option"
			   in
			      x_8227
			   end
			Fail_0 x_8224: unit ref * word8 vector => 
			   let
			      val x_8225: word8 vector = 
				 "Fail"
			   in
			      x_8225
			   end
			Chr_0 x_8222: unit ref => 
			   let
			      val x_8223: word8 vector = 
				 "Chr"
			   in
			      x_8223
			   end
			GenerateVectorNotFull_1 x_8220: unit ref => 
			   let
			      val x_8221: word8 vector = 
				 "GenerateVectorNotFull"
			   in
			      x_8221
			   end
			GenerateAlreadyGotVector_1 x_8218: unit ref => 
			   let
			      val x_8219: word8 vector = 
				 "GenerateAlreadyGotVector"
			   in
			      x_8219
			   end
			GenerateVectorNotFull_0 x_8216: unit ref => 
			   let
			      val x_8217: word8 vector = 
				 "GenerateVectorNotFull"
			   in
			      x_8217
			   end
			GenerateAlreadyGotVector_0 x_8214: unit ref => 
			   let
			      val x_8215: word8 vector = 
				 "GenerateAlreadyGotVector"
			   in
			      x_8215
			   end
			Subscript_0 x_8212: unit ref => 
			   let
			      val x_8213: word8 vector = 
				 "Subscript"
			   in
			      x_8213
			   end
			Span_0 x_8210: unit ref => 
			   let
			      val x_8211: word8 vector = 
				 "Span"
			   in
			      x_8211
			   end
			Size_0 x_8208: unit ref => 
			   let
			      val x_8209: word8 vector = 
				 "Size"
			   in
			      x_8209
			   end
			Overflow_0 x_8206: unit ref => 
			   let
			      val x_8207: word8 vector = 
				 "Overflow"
			   in
			      x_8207
			   end
			Fail32_0 x_8204: unit ref * word32 vector => 
			   let
			      val x_8205: word8 vector = 
				 "Fail32"
			   in
			      x_8205
			   end
			Fail16_0 x_8202: unit ref * word16 vector => 
			   let
			      val x_8203: word8 vector = 
				 "Fail16"
			   in
			      x_8203
			   end
			Fail8_0 x_8200: unit ref * word8 vector => 
			   let
			      val x_8201: word8 vector = 
				 "Fail8"
			   in
			      x_8201
			   end
			Domain_0 x_8198: unit ref => 
			   let
			      val x_8199: word8 vector = 
				 "Domain"
			   in
			      x_8199
			   end
			Div_0 x_8196: unit ref => 
			   let
			      val x_8197: word8 vector = 
				 "Div"
			   in
			      x_8197
			   end
			Overflow x_8194: unit ref => 
			   let
			      val x_8195: word8 vector = 
				 "Overflow"
			   in
			      x_8195
			   end
			Match_0 x_8192: unit ref => 
			   let
			      val x_8193: word8 vector = 
				 "Match"
			   in
			      x_8193
			   end
			Bind_0 x_8190: unit ref => 
			   let
			      val x_8191: word8 vector = 
				 "Bind"
			   in
			      x_8191
			   end
		  in
		     x_8189
		  end
	       val x_8280: unit = 
		  ()
	       val x_8281: unit ref = 
		  Ref_ref[unit] (x_8280)
	       val x_8282: exn = 
		  Div_0 x_8281
	       val x_8283: unit = 
		  ()
	       val x_8284: unit ref = 
		  Ref_ref[unit] (x_8283)
	       val x_8285: exn = 
		  Domain_0 x_8284
	       val x_8286: unit = 
		  ()
	       val x_8287: unit ref = 
		  Ref_ref[unit] (x_8286)
	       val x_8288: unit = 
		  ()
	       val x_8289: unit ref = 
		  Ref_ref[unit] (x_8288)
	       val x_8290: exn = 
		  Overflow_0 x_8289
	       val x_8291: unit = 
		  ()
	       val x_8292: unit ref = 
		  Ref_ref[unit] (x_8291)
	       val x_8293: exn = 
		  Size_0 x_8292
	       val x_8294: unit = 
		  ()
	       val x_8295: unit ref = 
		  Ref_ref[unit] (x_8294)
	       val x_8296: exn = 
		  Subscript_0 x_8295
	       val x_8297: list_2 ref -> list_2 = 
		  fn x_8298: list_2 ref => 
		  let
		     val x_8299: list_2 = 
			Ref_deref[list_2] (x_8298)
		  in
		     x_8299
		  end
	       val x_8300: StreamIOExtra.state_0 ref -> StreamIOExtra.state_0 = 
		  fn x_8301: StreamIOExtra.state_0 ref => 
		  let
		     val x_8302: StreamIOExtra.state_0 = 
			Ref_deref[StreamIOExtra.state_0] (x_8301)
		  in
		     x_8302
		  end
	       val x_8303: list_5 ref -> list_5 = 
		  fn x_8304: list_5 ref => 
		  let
		     val x_8305: list_5 = 
			Ref_deref[list_5] (x_8304)
		  in
		     x_8305
		  end
	       val x_8306: word32 ref -> word32 = 
		  fn x_8307: word32 ref => 
		  let
		     val x_8308: word32 = 
			Ref_deref[word32] (x_8307)
		  in
		     x_8308
		  end
	       val x_8309: Primitive.Option.t_18 ref -> Primitive.Option.t_18 = 
		  fn x_8310: Primitive.Option.t_18 ref => 
		  let
		     val x_8311: Primitive.Option.t_18 = 
			Ref_deref[Primitive.Option.t_18] (x_8310)
		  in
		     x_8311
		  end
	       val x_8312: word64 ref -> word64 = 
		  fn x_8313: word64 ref => 
		  let
		     val x_8314: word64 = 
			Ref_deref[word64] (x_8313)
		  in
		     x_8314
		  end
	       val x_8315: StreamIOExtra.bufferMode_0 ref
			   -> StreamIOExtra.bufferMode_0 = 
		  fn x_8316: StreamIOExtra.bufferMode_0 ref => 
		  let
		     val x_8317: StreamIOExtra.bufferMode_0 = 
			Ref_deref[StreamIOExtra.bufferMode_0] (x_8316)
		  in
		     x_8317
		  end
	       val x_8318: list_0 ref -> list_0 = 
		  fn x_8319: list_0 ref => 
		  let
		     val x_8320: list_0 = 
			Ref_deref[list_0] (x_8319)
		  in
		     x_8320
		  end
	       val x_8321: bool ref -> bool = 
		  fn x_8322: bool ref => 
		  let
		     val x_8323: bool = 
			Ref_deref[bool] (x_8322)
		  in
		     x_8323
		  end
	       val x_8324: MLtonThread.thread_0 ref -> MLtonThread.thread_0 = 
		  fn x_8325: MLtonThread.thread_0 ref => 
		  let
		     val x_8326: MLtonThread.thread_0 = 
			Ref_deref[MLtonThread.thread_0] (x_8325)
		  in
		     x_8326
		  end
	       val x_8327: Primitive.Option.t_7 ref * Primitive.Option.t_7
			   -> unit = 
		  fn x_8328: Primitive.Option.t_7 ref * Primitive.Option.t_7 => 
		  let
		     val x_8329: Primitive.Option.t_7 = 
			#1 x_8328
		     val x_8330: Primitive.Option.t_7 ref = 
			#0 x_8328
		     val x_8331: unit = 
			Ref_assign[Primitive.Option.t_7] (x_8330, x_8329)
		  in
		     x_8331
		  end
	       val x_8332: MLtonThread.thread_1 ref * MLtonThread.thread_1
			   -> unit = 
		  fn x_8333: MLtonThread.thread_1 ref * MLtonThread.thread_1 => 
		  let
		     val x_8334: MLtonThread.thread_1 = 
			#1 x_8333
		     val x_8335: MLtonThread.thread_1 ref = 
			#0 x_8333
		     val x_8336: unit = 
			Ref_assign[MLtonThread.thread_1] (x_8335, x_8334)
		  in
		     x_8336
		  end
	       val x_8337: word32 ref * word32 -> unit = 
		  fn x_8338: word32 ref * word32 => 
		  let
		     val x_8339: word32 = 
			#1 x_8338
		     val x_8340: word32 ref = 
			#0 x_8338
		     val x_8341: unit = 
			Ref_assign[word32] (x_8340, x_8339)
		  in
		     x_8341
		  end
	       val x_8342: bool ref * bool -> unit = 
		  fn x_8343: bool ref * bool => 
		  let
		     val x_8344: bool = 
			#1 x_8343
		     val x_8345: bool ref = 
			#0 x_8343
		     val x_8346: unit = 
			Ref_assign[bool] (x_8345, x_8344)
		  in
		     x_8346
		  end
	       val x_8347: Primitive.Option.t_17 ref * Primitive.Option.t_17
			   -> unit = 
		  fn x_8348: Primitive.Option.t_17 ref * Primitive.Option.t_17 => 
		  let
		     val x_8349: Primitive.Option.t_17 = 
			#1 x_8348
		     val x_8350: Primitive.Option.t_17 ref = 
			#0 x_8348
		     val x_8351: unit = 
			Ref_assign[Primitive.Option.t_17] (x_8350, x_8349)
		  in
		     x_8351
		  end
	       val x_8352: Primitive.Option.t_18 ref * Primitive.Option.t_18
			   -> unit = 
		  fn x_8353: Primitive.Option.t_18 ref * Primitive.Option.t_18 => 
		  let
		     val x_8354: Primitive.Option.t_18 = 
			#1 x_8353
		     val x_8355: Primitive.Option.t_18 ref = 
			#0 x_8353
		     val x_8356: unit = 
			Ref_assign[Primitive.Option.t_18] (x_8355, x_8354)
		  in
		     x_8356
		  end
	       val x_8357: word64 ref * word64 -> unit = 
		  fn x_8358: word64 ref * word64 => 
		  let
		     val x_8359: word64 = 
			#1 x_8358
		     val x_8360: word64 ref = 
			#0 x_8358
		     val x_8361: unit = 
			Ref_assign[word64] (x_8360, x_8359)
		  in
		     x_8361
		  end
	       val x_8362: MLtonThread.thread_0 ref * MLtonThread.thread_0
			   -> unit = 
		  fn x_8363: MLtonThread.thread_0 ref * MLtonThread.thread_0 => 
		  let
		     val x_8364: MLtonThread.thread_0 = 
			#1 x_8363
		     val x_8365: MLtonThread.thread_0 ref = 
			#0 x_8363
		     val x_8366: unit = 
			Ref_assign[MLtonThread.thread_0] (x_8365, x_8364)
		  in
		     x_8366
		  end
	       val x_8367: word32 * word32 -> bool = 
		  fn x_8368: word32 * word32 => 
		  let
		     val x_8369: word32 = 
			#1 x_8368
		     val x_8370: word32 = 
			#0 x_8368
		     val x_8371: bool = 
			MLton_equal[word32] (x_8370, x_8369)
		  in
		     x_8371
		  end
	       val x_8372: word64 * word64 -> bool = 
		  fn x_8373: word64 * word64 => 
		  let
		     val x_8374: word64 = 
			#1 x_8373
		     val x_8375: word64 = 
			#0 x_8373
		     val x_8376: bool = 
			MLton_equal[word64] (x_8375, x_8374)
		  in
		     x_8376
		  end
	       val x_8377: word8 * word8 -> bool = 
		  fn x_8378: word8 * word8 => 
		  let
		     val x_8379: word8 = 
			#1 x_8378
		     val x_8380: word8 = 
			#0 x_8378
		     val x_8381: bool = 
			MLton_equal[word8] (x_8380, x_8379)
		  in
		     x_8381
		  end
	       val x_8382: word32 * word32 -> bool = 
		  fn x_8383: word32 * word32 => 
		  let
		     val y_0: word32 = 
			#1 x_8383
		     val x_8384: word32 = 
			#0 x_8383
		     val x_8385: word32 * word32 = 
			(x_8384, y_0)
		     val x_8386: bool = 
			x_8367 x_8385
		     val x_8387: bool = 
			not_0 x_8386
		  in
		     x_8387
		  end
	       val x_8388: word64 * word64 -> bool = 
		  fn x_8389: word64 * word64 => 
		  let
		     val y_1: word64 = 
			#1 x_8389
		     val x_8390: word64 = 
			#0 x_8389
		     val x_8391: word64 * word64 = 
			(x_8390, y_1)
		     val x_8392: bool = 
			x_8372 x_8391
		     val x_8393: bool = 
			not_0 x_8392
		  in
		     x_8393
		  end
	       val idFromInt8ToWord8_0: word8 -> word8 = 
		  fn x_8394: word8 => 
		  let
		  in
		     x_8394
		  end
	       val idFromInt16ToWord16_0: word16 -> word16 = 
		  fn x_8395: word16 => 
		  let
		  in
		     x_8395
		  end
	       val idFromInt32ToWord32_0: word32 -> word32 = 
		  fn x_8396: word32 => 
		  let
		  in
		     x_8396
		  end
	       val idFromInt64ToWord64_0: word64 -> word64 = 
		  fn x_8397: word64 => 
		  let
		  in
		     x_8397
		  end
	       val idFromWord8ToInt8_0: word8 -> word8 = 
		  fn x_8398: word8 => 
		  let
		  in
		     x_8398
		  end
	       val idFromWord16ToInt16_0: word16 -> word16 = 
		  fn x_8399: word16 => 
		  let
		  in
		     x_8399
		  end
	       val idFromWord32ToInt32_0: word32 -> word32 = 
		  fn x_8400: word32 => 
		  let
		  in
		     x_8400
		  end
	       val idFromWord64ToInt64_0: word64 -> word64 = 
		  fn x_8401: word64 => 
		  let
		  in
		     x_8401
		  end
	       val zextdFromInt32ToInt8_0: word32 -> word8 = 
		  fn x_8402: word32 => 
		  let
		     val x_8403: word8 = 
			WordU32_extdToWord8 (x_8402)
		  in
		     x_8403
		  end
	       val zextdFromInt32ToInt16_0: word32 -> word16 = 
		  fn x_8404: word32 => 
		  let
		     val x_8405: word16 = 
			WordU32_extdToWord16 (x_8404)
		  in
		     x_8405
		  end
	       val zextdFromInt32ToInt32_0: word32 -> word32 = 
		  fn x_8406: word32 => 
		  let
		  in
		     x_8406
		  end
	       val zextdFromInt32ToInt64_0: word32 -> word64 = 
		  fn x_8407: word32 => 
		  let
		     val x_8408: word64 = 
			WordU32_extdToWord64 (x_8407)
		  in
		     x_8408
		  end
	       val zextdFromInt32ToWord32_0: word32 -> word32 = 
		  fn x_8409: word32 => 
		  let
		  in
		     x_8409
		  end
	       val zextdFromInt32ToWord64_0: word32 -> word64 = 
		  fn x_8410: word32 => 
		  let
		     val x_8411: word64 = 
			WordU32_extdToWord64 (x_8410)
		  in
		     x_8411
		  end
	       val zextdFromInt64ToWord64_0: word64 -> word64 = 
		  fn x_8412: word64 => 
		  let
		  in
		     x_8412
		  end
	       val zextdFromWord32ToWord32_0: word32 -> word32 = 
		  fn x_8413: word32 => 
		  let
		  in
		     x_8413
		  end
	       val zextdFromWord32ToWord64_0: word32 -> word64 = 
		  fn x_8414: word32 => 
		  let
		     val x_8415: word64 = 
			WordU32_extdToWord64 (x_8414)
		  in
		     x_8415
		  end
	       val zextdFromWord64ToInt32_0: word64 -> word32 = 
		  fn x_8416: word64 => 
		  let
		     val x_8417: word32 = 
			WordU64_extdToWord32 (x_8416)
		  in
		     x_8417
		  end
	       val zextdFromWord64ToInt64_0: word64 -> word64 = 
		  fn x_8418: word64 => 
		  let
		  in
		     x_8418
		  end
	       val sextdFromInt8ToInt64_0: word8 -> word64 = 
		  fn x_8419: word8 => 
		  let
		     val x_8420: word64 = 
			WordS8_extdToWord64 (x_8419)
		  in
		     x_8420
		  end
	       val sextdFromInt16ToInt64_0: word16 -> word64 = 
		  fn x_8421: word16 => 
		  let
		     val x_8422: word64 = 
			WordS16_extdToWord64 (x_8421)
		  in
		     x_8422
		  end
	       val sextdFromInt32ToInt32_0: word32 -> word32 = 
		  fn x_8423: word32 => 
		  let
		  in
		     x_8423
		  end
	       val sextdFromInt32ToInt64_0: word32 -> word64 = 
		  fn x_8424: word32 => 
		  let
		     val x_8425: word64 = 
			WordS32_extdToWord64 (x_8424)
		  in
		     x_8425
		  end
	       val sextdFromInt32ToWord32_0: word32 -> word32 = 
		  fn x_8426: word32 => 
		  let
		  in
		     x_8426
		  end
	       val sextdFromInt32ToWord64_0: word32 -> word64 = 
		  fn x_8427: word32 => 
		  let
		     val x_8428: word64 = 
			WordS32_extdToWord64 (x_8427)
		  in
		     x_8428
		  end
	       val sextdFromInt64ToInt32_0: word64 -> word32 = 
		  fn x_8429: word64 => 
		  let
		     val x_8430: word32 = 
			WordS64_extdToWord32 (x_8429)
		  in
		     x_8430
		  end
	       val sextdFromInt64ToInt64_0: word64 -> word64 = 
		  fn x_8431: word64 => 
		  let
		  in
		     x_8431
		  end
	       val sizeInBits_0: word32 = 
		  0x1
	       val sizeInBits_1: word32 = 
		  0x2
	       val sizeInBits_2: word32 = 
		  0x3
	       val sizeInBits_3: word32 = 
		  0x4
	       val sizeInBits_4: word32 = 
		  0x5
	       val sizeInBits_5: word32 = 
		  0x6
	       val sizeInBits_6: word32 = 
		  0x7
	       val sizeInBits_7: word32 = 
		  0x8
	       val sizeInBitsWord_0: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_7
	       val <<?_0: word8 * word32 -> word8 = 
		  fn x_8432: word8 * word32 => 
		  let
		     val x_8433: word32 = 
			#1 x_8432
		     val x_8434: word8 = 
			#0 x_8432
		     val x_8435: word8 = 
			Word8_lshift (x_8434, x_8433)
		  in
		     x_8435
		  end
	       val notb_0: word8 -> word8 = 
		  fn x_8436: word8 => 
		  let
		     val x_8437: word8 = 
			Word8_notb (x_8436)
		  in
		     x_8437
		  end
	       val >>?_0: word8 * word32 -> word8 = 
		  fn x_8438: word8 * word32 => 
		  let
		     val x_8439: word32 = 
			#1 x_8438
		     val x_8440: word8 = 
			#0 x_8438
		     val x_8441: word8 = 
			WordU8_rshift (x_8440, x_8439)
		  in
		     x_8441
		  end
	       val sizeInBits_8: word32 = 
		  0x9
	       val sizeInBits_9: word32 = 
		  0xA
	       val sizeInBits_10: word32 = 
		  0xB
	       val sizeInBits_11: word32 = 
		  0xC
	       val sizeInBits_12: word32 = 
		  0xD
	       val sizeInBits_13: word32 = 
		  0xE
	       val sizeInBits_14: word32 = 
		  0xF
	       val sizeInBits_15: word32 = 
		  0x10
	       val sizeInBitsWord_1: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_15
	       val <<?_1: word16 * word32 -> word16 = 
		  fn x_8442: word16 * word32 => 
		  let
		     val x_8443: word32 = 
			#1 x_8442
		     val x_8444: word16 = 
			#0 x_8442
		     val x_8445: word16 = 
			Word16_lshift (x_8444, x_8443)
		  in
		     x_8445
		  end
	       val notb_1: word16 -> word16 = 
		  fn x_8446: word16 => 
		  let
		     val x_8447: word16 = 
			Word16_notb (x_8446)
		  in
		     x_8447
		  end
	       val >>?_1: word16 * word32 -> word16 = 
		  fn x_8448: word16 * word32 => 
		  let
		     val x_8449: word32 = 
			#1 x_8448
		     val x_8450: word16 = 
			#0 x_8448
		     val x_8451: word16 = 
			WordU16_rshift (x_8450, x_8449)
		  in
		     x_8451
		  end
	       val sizeInBits_16: word32 = 
		  0x11
	       val sizeInBits_17: word32 = 
		  0x12
	       val sizeInBits_18: word32 = 
		  0x13
	       val sizeInBits_19: word32 = 
		  0x14
	       val sizeInBits_20: word32 = 
		  0x15
	       val sizeInBits_21: word32 = 
		  0x16
	       val sizeInBits_22: word32 = 
		  0x17
	       val sizeInBits_23: word32 = 
		  0x18
	       val sizeInBits_24: word32 = 
		  0x19
	       val sizeInBits_25: word32 = 
		  0x1A
	       val sizeInBits_26: word32 = 
		  0x1B
	       val sizeInBits_27: word32 = 
		  0x1C
	       val sizeInBits_28: word32 = 
		  0x1D
	       val sizeInBits_29: word32 = 
		  0x1E
	       val sizeInBits_30: word32 = 
		  0x1F
	       val sizeInBits_31: word32 = 
		  0x20
	       val sizeInBitsWord_2: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_31
	       val andb_0: word32 * word32 -> word32 = 
		  fn x_8452: word32 * word32 => 
		  let
		     val x_8453: word32 = 
			#1 x_8452
		     val x_8454: word32 = 
			#0 x_8452
		     val x_8455: word32 = 
			Word32_andb (x_8454, x_8453)
		  in
		     x_8455
		  end
	       val <<?_2: word32 * word32 -> word32 = 
		  fn x_8456: word32 * word32 => 
		  let
		     val x_8457: word32 = 
			#1 x_8456
		     val x_8458: word32 = 
			#0 x_8456
		     val x_8459: word32 = 
			Word32_lshift (x_8458, x_8457)
		  in
		     x_8459
		  end
	       val notb_2: word32 -> word32 = 
		  fn x_8460: word32 => 
		  let
		     val x_8461: word32 = 
			Word32_notb (x_8460)
		  in
		     x_8461
		  end
	       val >>?_2: word32 * word32 -> word32 = 
		  fn x_8462: word32 * word32 => 
		  let
		     val x_8463: word32 = 
			#1 x_8462
		     val x_8464: word32 = 
			#0 x_8462
		     val x_8465: word32 = 
			WordU32_rshift (x_8464, x_8463)
		  in
		     x_8465
		  end
	       val -_0: word32 * word32 -> word32 = 
		  fn x_8466: word32 * word32 => 
		  let
		     val x_8467: word32 = 
			#1 x_8466
		     val x_8468: word32 = 
			#0 x_8466
		     val x_8469: word32 = 
			Word32_sub (x_8468, x_8467)
		  in
		     x_8469
		  end
	       val xorb_0: word32 * word32 -> word32 = 
		  fn x_8470: word32 * word32 => 
		  let
		     val x_8471: word32 = 
			#1 x_8470
		     val x_8472: word32 = 
			#0 x_8470
		     val x_8473: word32 = 
			Word32_xorb (x_8472, x_8471)
		  in
		     x_8473
		  end
	       val <_0: word32 * word32 -> bool = 
		  fn x_8474: word32 * word32 => 
		  let
		     val x_8475: word32 = 
			#1 x_8474
		     val x_8476: word32 = 
			#0 x_8474
		     val x_8477: bool = 
			WordU32_lt (x_8476, x_8475)
		  in
		     x_8477
		  end
	       val rec 
		  >=_0: word32 * word32 -> bool = 
		     fn x_8478: word32 * word32 => 
		     let
			val b_0: word32 = 
			   #1 x_8478
			val a_0: word32 = 
			   #0 x_8478
			val x_8479: word32 * word32 = 
			   (a_0, b_0)
			val x_8480: bool = 
			   <_0 x_8479
			val x_8481: bool = 
			   not_0 x_8480
		     in
			x_8481
		     end
	       val sizeInBits_32: word32 = 
		  0x40
	       val sizeInBitsWord_3: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_32
	       val +_0: word64 * word64 -> word64 = 
		  fn x_8482: word64 * word64 => 
		  let
		     val x_8483: word64 = 
			#1 x_8482
		     val x_8484: word64 = 
			#0 x_8482
		     val x_8485: word64 = 
			Word64_add (x_8484, x_8483)
		  in
		     x_8485
		  end
	       val andb_1: word64 * word64 -> word64 = 
		  fn x_8486: word64 * word64 => 
		  let
		     val x_8487: word64 = 
			#1 x_8486
		     val x_8488: word64 = 
			#0 x_8486
		     val x_8489: word64 = 
			Word64_andb (x_8488, x_8487)
		  in
		     x_8489
		  end
	       val <<?_3: word64 * word32 -> word64 = 
		  fn x_8490: word64 * word32 => 
		  let
		     val x_8491: word32 = 
			#1 x_8490
		     val x_8492: word64 = 
			#0 x_8490
		     val x_8493: word64 = 
			Word64_lshift (x_8492, x_8491)
		  in
		     x_8493
		  end
	       val *_0: word64 * word64 -> word64 = 
		  fn x_8494: word64 * word64 => 
		  let
		     val x_8495: word64 = 
			#1 x_8494
		     val x_8496: word64 = 
			#0 x_8494
		     val x_8497: word64 = 
			WordU64_mul (x_8496, x_8495)
		  in
		     x_8497
		  end
	       val notb_3: word64 -> word64 = 
		  fn x_8498: word64 => 
		  let
		     val x_8499: word64 = 
			Word64_notb (x_8498)
		  in
		     x_8499
		  end
	       val ~>>?_0: word64 * word32 -> word64 = 
		  fn x_8500: word64 * word32 => 
		  let
		     val x_8501: word32 = 
			#1 x_8500
		     val x_8502: word64 = 
			#0 x_8500
		     val x_8503: word64 = 
			WordS64_rshift (x_8502, x_8501)
		  in
		     x_8503
		  end
	       val >>?_3: word64 * word32 -> word64 = 
		  fn x_8504: word64 * word32 => 
		  let
		     val x_8505: word32 = 
			#1 x_8504
		     val x_8506: word64 = 
			#0 x_8504
		     val x_8507: word64 = 
			WordU64_rshift (x_8506, x_8505)
		  in
		     x_8507
		  end
	       val sizeInBits_33: word32 = 
		  0x1
	       val sizeInBits_34: word32 = 
		  0x2
	       val sizeInBits_35: word32 = 
		  0x3
	       val sizeInBits_36: word32 = 
		  0x4
	       val sizeInBits_37: word32 = 
		  0x5
	       val sizeInBits_38: word32 = 
		  0x6
	       val sizeInBits_39: word32 = 
		  0x7
	       val sizeInBits_40: word32 = 
		  0x8
	       val sizeInBitsWord_4: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_40
	       val precision_1: Primitive.Option.t_0 = 
		  SOME_0 sizeInBits_40
	       val sizeInBits_41: word32 = 
		  0x9
	       val sizeInBits_42: word32 = 
		  0xA
	       val sizeInBits_43: word32 = 
		  0xB
	       val sizeInBits_44: word32 = 
		  0xC
	       val sizeInBits_45: word32 = 
		  0xD
	       val sizeInBits_46: word32 = 
		  0xE
	       val sizeInBits_47: word32 = 
		  0xF
	       val sizeInBits_48: word32 = 
		  0x10
	       val sizeInBitsWord_5: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_48
	       val precision_2: Primitive.Option.t_0 = 
		  SOME_0 sizeInBits_48
	       val sizeInBits_49: word32 = 
		  0x11
	       val sizeInBits_50: word32 = 
		  0x12
	       val sizeInBits_51: word32 = 
		  0x13
	       val sizeInBits_52: word32 = 
		  0x14
	       val sizeInBits_53: word32 = 
		  0x15
	       val sizeInBits_54: word32 = 
		  0x16
	       val sizeInBits_55: word32 = 
		  0x17
	       val sizeInBits_56: word32 = 
		  0x18
	       val sizeInBits_57: word32 = 
		  0x19
	       val sizeInBits_58: word32 = 
		  0x1A
	       val sizeInBits_59: word32 = 
		  0x1B
	       val sizeInBits_60: word32 = 
		  0x1C
	       val sizeInBits_61: word32 = 
		  0x1D
	       val sizeInBits_62: word32 = 
		  0x1E
	       val sizeInBits_63: word32 = 
		  0x1F
	       val sizeInBits_64: word32 = 
		  0x20
	       val sizeInBitsWord_6: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_64
	       val precision_3: Primitive.Option.t_0 = 
		  SOME_0 sizeInBits_64
	       val x_8508: word32 * word32 -> word32 = 
		  fn x_8509: word32 * word32 => 
		  let
		     val x_8510: word32 = 
			let
			   val x_8511: word32 = 
			      #1 x_8509
			   val x_8512: word32 = 
			      #0 x_8509
			   val x_8513: word32 = 
			      WordS32_addCheck (x_8512, x_8511)
			in
			   x_8513
			end
			handle x_8514 => let
					    val x_8515: unit -> word32 = 
					       fn unit_0: unit => 
					       let
						  val x_8516: word32 = 
						     raise x_8514
					       in
						  x_8516
					       end
					    val x_8517: word32 = 
					       case x_8514 of
					       Overflow x_8518: unit ref => 
						  let
						     val x_8519: bool = 
							MLton_equal[unit ref] (x_8518,
									       x_8183)
						     val x_8520: word32 = 
							case x_8519 of
							true => 
							   let
							      val x_8523: word32 = 
								 raise x_8290
							   in
							      x_8523
							   end
							false => 
							   let
							      val x_8521: unit = 
								 ()
							      val x_8522: word32 = 
								 x_8515 x_8521
							   in
							      x_8522
							   end
						  in
						     x_8520
						  end
						 _ => let
							 val x_8524: unit = 
							    ()
							 val x_8525: word32 = 
							    x_8515 x_8524
						      in
							 x_8525
						      end
					 in
					    x_8517
					 end
		  in
		     x_8510
		  end
	       val +?_0: word32 * word32 -> word32 = 
		  fn x_8526: word32 * word32 => 
		  let
		     val x_8527: word32 = 
			#1 x_8526
		     val x_8528: word32 = 
			#0 x_8526
		     val x_8529: word32 = 
			Word32_add (x_8528, x_8527)
		  in
		     x_8529
		  end
	       val x_8530: word32 -> word32 = 
		  fn x_8531: word32 => 
		  let
		     val x_8532: word32 = 
			let
			   val x_8533: word32 = 
			      Word32_negCheck (x_8531)
			in
			   x_8533
			end
			handle x_8534 => let
					    val x_8535: unit -> word32 = 
					       fn unit_1: unit => 
					       let
						  val x_8536: word32 = 
						     raise x_8534
					       in
						  x_8536
					       end
					    val x_8537: word32 = 
					       case x_8534 of
					       Overflow x_8538: unit ref => 
						  let
						     val x_8539: bool = 
							MLton_equal[unit ref] (x_8538,
									       x_8183)
						     val x_8540: word32 = 
							case x_8539 of
							true => 
							   let
							      val x_8543: word32 = 
								 raise x_8290
							   in
							      x_8543
							   end
							false => 
							   let
							      val x_8541: unit = 
								 ()
							      val x_8542: word32 = 
								 x_8535 x_8541
							   in
							      x_8542
							   end
						  in
						     x_8540
						  end
						 _ => let
							 val x_8544: unit = 
							    ()
							 val x_8545: word32 = 
							    x_8535 x_8544
						      in
							 x_8545
						      end
					 in
					    x_8537
					 end
		  in
		     x_8532
		  end
	       val ~?_0: word32 -> word32 = 
		  fn x_8546: word32 => 
		  let
		     val x_8547: word32 = 
			Word32_neg (x_8546)
		  in
		     x_8547
		  end
	       val x_8548: word32 * word32 -> word32 = 
		  fn x_8549: word32 * word32 => 
		  let
		     val x_8550: word32 = 
			let
			   val x_8551: word32 = 
			      #1 x_8549
			   val x_8552: word32 = 
			      #0 x_8549
			   val x_8553: word32 = 
			      WordS32_subCheck (x_8552, x_8551)
			in
			   x_8553
			end
			handle x_8554 => let
					    val x_8555: unit -> word32 = 
					       fn unit_2: unit => 
					       let
						  val x_8556: word32 = 
						     raise x_8554
					       in
						  x_8556
					       end
					    val x_8557: word32 = 
					       case x_8554 of
					       Overflow x_8558: unit ref => 
						  let
						     val x_8559: bool = 
							MLton_equal[unit ref] (x_8558,
									       x_8183)
						     val x_8560: word32 = 
							case x_8559 of
							true => 
							   let
							      val x_8563: word32 = 
								 raise x_8290
							   in
							      x_8563
							   end
							false => 
							   let
							      val x_8561: unit = 
								 ()
							      val x_8562: word32 = 
								 x_8555 x_8561
							   in
							      x_8562
							   end
						  in
						     x_8560
						  end
						 _ => let
							 val x_8564: unit = 
							    ()
							 val x_8565: word32 = 
							    x_8555 x_8564
						      in
							 x_8565
						      end
					 in
					    x_8557
					 end
		  in
		     x_8550
		  end
	       val -?_0: word32 * word32 -> word32 = 
		  fn x_8566: word32 * word32 => 
		  let
		     val x_8567: word32 = 
			#1 x_8566
		     val x_8568: word32 = 
			#0 x_8566
		     val x_8569: word32 = 
			Word32_sub (x_8568, x_8567)
		  in
		     x_8569
		  end
	       val remUnsafe_0: word32 * word32 -> word32 = 
		  fn x_8570: word32 * word32 => 
		  let
		     val x_8571: word32 = 
			#1 x_8570
		     val x_8572: word32 = 
			#0 x_8570
		     val x_8573: word32 = 
			WordS32_rem (x_8572, x_8571)
		  in
		     x_8573
		  end
	       val <_1: word32 * word32 -> bool = 
		  fn x_8574: word32 * word32 => 
		  let
		     val x_8575: word32 = 
			#1 x_8574
		     val x_8576: word32 = 
			#0 x_8574
		     val x_8577: bool = 
			WordS32_lt (x_8576, x_8575)
		  in
		     x_8577
		  end
	       val rec 
		  <=_0: word32 * word32 -> bool = 
		     fn x_8578: word32 * word32 => 
		     let
			val b_1: word32 = 
			   #1 x_8578
			val a_1: word32 = 
			   #0 x_8578
			val x_8579: word32 * word32 = 
			   (b_1, a_1)
			val x_8580: bool = 
			   <_1 x_8579
			val x_8581: bool = 
			   not_0 x_8580
		     in
			x_8581
		     end
	       val rec 
		  >_0: word32 * word32 -> bool = 
		     fn x_8582: word32 * word32 => 
		     let
			val b_2: word32 = 
			   #1 x_8582
			val a_2: word32 = 
			   #0 x_8582
			val x_8583: word32 * word32 = 
			   (b_2, a_2)
			val x_8584: bool = 
			   <_1 x_8583
		     in
			x_8584
		     end
	       val rec 
		  >=_1: word32 * word32 -> bool = 
		     fn x_8585: word32 * word32 => 
		     let
			val b_3: word32 = 
			   #1 x_8585
			val a_3: word32 = 
			   #0 x_8585
			val x_8586: word32 * word32 = 
			   (b_3, a_3)
			val x_8587: bool = 
			   <=_0 x_8586
		     in
			x_8587
		     end
	       val sizeInBits_65: word32 = 
		  0x40
	       val sizeInBitsWord_7: word32 = 
		  zextdFromInt32ToWord32_0 sizeInBits_65
	       val precision_4: Primitive.Option.t_0 = 
		  SOME_0 sizeInBits_65
	       val x_8588: word64 * word64 -> word64 = 
		  fn x_8589: word64 * word64 => 
		  let
		     val x_8590: word64 = 
			let
			   val x_8591: word64 = 
			      #1 x_8589
			   val x_8592: word64 = 
			      #0 x_8589
			   val x_8593: word64 = 
			      WordS64_addCheck (x_8592, x_8591)
			in
			   x_8593
			end
			handle x_8594 => let
					    val x_8595: unit -> word64 = 
					       fn unit_3: unit => 
					       let
						  val x_8596: word64 = 
						     raise x_8594
					       in
						  x_8596
					       end
					    val x_8597: word64 = 
					       case x_8594 of
					       Overflow x_8598: unit ref => 
						  let
						     val x_8599: bool = 
							MLton_equal[unit ref] (x_8598,
									       x_8183)
						     val x_8600: word64 = 
							case x_8599 of
							true => 
							   let
							      val x_8603: word64 = 
								 raise x_8290
							   in
							      x_8603
							   end
							false => 
							   let
							      val x_8601: unit = 
								 ()
							      val x_8602: word64 = 
								 x_8595 x_8601
							   in
							      x_8602
							   end
						  in
						     x_8600
						  end
						 _ => let
							 val x_8604: unit = 
							    ()
							 val x_8605: word64 = 
							    x_8595 x_8604
						      in
							 x_8605
						      end
					 in
					    x_8597
					 end
		  in
		     x_8590
		  end
	       val +?_1: word64 * word64 -> word64 = 
		  fn x_8606: word64 * word64 => 
		  let
		     val x_8607: word64 = 
			#1 x_8606
		     val x_8608: word64 = 
			#0 x_8606
		     val x_8609: word64 = 
			Word64_add (x_8608, x_8607)
		  in
		     x_8609
		  end
	       val x_8610: word64 -> word64 = 
		  fn x_8611: word64 => 
		  let
		     val x_8612: word64 = 
			let
			   val x_8613: word64 = 
			      Word64_negCheck (x_8611)
			in
			   x_8613
			end
			handle x_8614 => let
					    val x_8615: unit -> word64 = 
					       fn unit_4: unit => 
					       let
						  val x_8616: word64 = 
						     raise x_8614
					       in
						  x_8616
					       end
					    val x_8617: word64 = 
					       case x_8614 of
					       Overflow x_8618: unit ref => 
						  let
						     val x_8619: bool = 
							MLton_equal[unit ref] (x_8618,
									       x_8183)
						     val x_8620: word64 = 
							case x_8619 of
							true => 
							   let
							      val x_8623: word64 = 
								 raise x_8290
							   in
							      x_8623
							   end
							false => 
							   let
							      val x_8621: unit = 
								 ()
							      val x_8622: word64 = 
								 x_8615 x_8621
							   in
							      x_8622
							   end
						  in
						     x_8620
						  end
						 _ => let
							 val x_8624: unit = 
							    ()
							 val x_8625: word64 = 
							    x_8615 x_8624
						      in
							 x_8625
						      end
					 in
					    x_8617
					 end
		  in
		     x_8612
		  end
	       val ~?_1: word64 -> word64 = 
		  fn x_8626: word64 => 
		  let
		     val x_8627: word64 = 
			Word64_neg (x_8626)
		  in
		     x_8627
		  end
	       val x_8628: word64 * word64 -> word64 = 
		  fn x_8629: word64 * word64 => 
		  let
		     val x_8630: word64 = 
			let
			   val x_8631: word64 = 
			      #1 x_8629
			   val x_8632: word64 = 
			      #0 x_8629
			   val x_8633: word64 = 
			      WordS64_subCheck (x_8632, x_8631)
			in
			   x_8633
			end
			handle x_8634 => let
					    val x_8635: unit -> word64 = 
					       fn unit_5: unit => 
					       let
						  val x_8636: word64 = 
						     raise x_8634
					       in
						  x_8636
					       end
					    val x_8637: word64 = 
					       case x_8634 of
					       Overflow x_8638: unit ref => 
						  let
						     val x_8639: bool = 
							MLton_equal[unit ref] (x_8638,
									       x_8183)
						     val x_8640: word64 = 
							case x_8639 of
							true => 
							   let
							      val x_8643: word64 = 
								 raise x_8290
							   in
							      x_8643
							   end
							false => 
							   let
							      val x_8641: unit = 
								 ()
							      val x_8642: word64 = 
								 x_8635 x_8641
							   in
							      x_8642
							   end
						  in
						     x_8640
						  end
						 _ => let
							 val x_8644: unit = 
							    ()
							 val x_8645: word64 = 
							    x_8635 x_8644
						      in
							 x_8645
						      end
					 in
					    x_8637
					 end
		  in
		     x_8630
		  end
	       val -?_1: word64 * word64 -> word64 = 
		  fn x_8646: word64 * word64 => 
		  let
		     val x_8647: word64 = 
			#1 x_8646
		     val x_8648: word64 = 
			#0 x_8646
		     val x_8649: word64 = 
			Word64_sub (x_8648, x_8647)
		  in
		     x_8649
		  end
	       val <_2: word64 * word64 -> bool = 
		  fn x_8650: word64 * word64 => 
		  let
		     val x_8651: word64 = 
			#1 x_8650
		     val x_8652: word64 = 
			#0 x_8650
		     val x_8653: bool = 
			WordS64_lt (x_8652, x_8651)
		  in
		     x_8653
		  end
	       val rec 
		  >_1: word64 * word64 -> bool = 
		     fn x_8654: word64 * word64 => 
		     let
			val b_4: word64 = 
			   #1 x_8654
			val a_4: word64 = 
			   #0 x_8654
			val x_8655: word64 * word64 = 
			   (b_4, a_4)
			val x_8656: bool = 
			   <_2 x_8655
		     in
			x_8656
		     end
	       val rec 
		  >=_2: word64 * word64 -> bool = 
		     fn x_8657: word64 * word64 => 
		     let
			val b_5: word64 = 
			   #1 x_8657
			val a_5: word64 = 
			   #0 x_8657
			val x_8658: word64 * word64 = 
			   (a_5, b_5)
			val x_8659: bool = 
			   <_2 x_8658
			val x_8660: bool = 
			   not_0 x_8659
		     in
			x_8660
		     end
	       val x_8661: word32 -> word32 = 
		  fn x_8662: word32 => 
		  let
		  in
		     x_8662
		  end
	       val x_8663: word64 -> word8 array = 
		  fn x_8664: word64 => 
		  let
		     val x_8665: word8 array = 
			Array_array[word8] (x_8664)
		  in
		     x_8665
		  end
	       val x_8666: unit -> word8 array = 
		  fn x_8667: unit => 
		  let
		     val x_8668: word8 array = 
			Array_array0Const[word8] ()
		  in
		     x_8668
		  end
	       val x_8669: word8 array -> word64 = 
		  fn x_8670: word8 array => 
		  let
		     val x_8671: word64 = 
			Array_length[word8] (x_8670)
		  in
		     x_8671
		  end
	       val x_8672: word8 array * word64 -> word8 = 
		  fn x_8673: word8 array * word64 => 
		  let
		     val x_8674: word64 = 
			#1 x_8673
		     val x_8675: word8 array = 
			#0 x_8673
		     val x_8676: word8 = 
			Array_sub[word8] (x_8675, x_8674)
		  in
		     x_8676
		  end
	       val x_8677: word8 array * word64 * word8 -> unit = 
		  fn x_8678: word8 array * word64 * word8 => 
		  let
		     val x_8679: word8 = 
			#2 x_8678
		     val x_8680: word64 = 
			#1 x_8678
		     val x_8681: word8 array = 
			#0 x_8678
		     val x_8682: unit = 
			Array_update[word8] (x_8681, x_8680, x_8679)
		  in
		     x_8682
		  end
	       val x_8683: word8 array -> word8 vector = 
		  fn x_8684: word8 array => 
		  let
		     val x_8685: word8 vector = 
			Array_toVector[word8] (x_8684)
		  in
		     x_8685
		  end
	       val x_8686: word8 vector -> word64 = 
		  fn x_8687: word8 vector => 
		  let
		     val x_8688: word64 = 
			Vector_length[word8] (x_8687)
		  in
		     x_8688
		  end
	       val x_8689: word8 vector * word64 -> word8 = 
		  fn x_8690: word8 vector * word64 => 
		  let
		     val x_8691: word64 = 
			#1 x_8690
		     val x_8692: word8 vector = 
			#0 x_8690
		     val x_8693: word8 = 
			Vector_sub[word8] (x_8692, x_8691)
		  in
		     x_8693
		  end
	       val fromWord_0: word64 -> intInf = 
		  fn x_8694: word64 => 
		  let
		     val x_8695: intInf = 
			Word_toIntInf (x_8694)
		  in
		     x_8695
		  end
	       val toWord_0: intInf -> word64 = 
		  fn x_8696: intInf => 
		  let
		     val x_8697: word64 = 
			IntInf_toWord (x_8696)
		  in
		     x_8697
		  end
	       val idFromWord8_0: word8 -> word8 = 
		  fn x_8698: word8 => 
		  let
		  in
		     x_8698
		  end
	       val rec 
		  <=_1: word8 * word8 -> bool = 
		     fn x_8699: word8 * word8 => 
		     let
			val b_6: word8 = 
			   #1 x_8699
			val a_6: word8 = 
			   #0 x_8699
			val x_8700: bool = 
			   WordU8_lt (b_6, a_6)
			val x_8701: bool = 
			   not_0 x_8700
		     in
			x_8701
		     end
	       val realSize_0: word32 = 
		  0x20
	       val exponentBias_0: word32 = 
		  0x7F
	       val precision_5: word32 = 
		  0x18
	       val +_1: real32 * real32 -> real32 = 
		  fn x_8702: real32 * real32 => 
		  let
		     val x_8703: real32 = 
			#1 x_8702
		     val x_8704: real32 = 
			#0 x_8702
		     val x_8705: real32 = 
			Real32_add (x_8704, x_8703)
		  in
		     x_8705
		  end
	       val -_1: real32 * real32 -> real32 = 
		  fn x_8706: real32 * real32 => 
		  let
		     val x_8707: real32 = 
			#1 x_8706
		     val x_8708: real32 = 
			#0 x_8706
		     val x_8709: real32 = 
			Real32_sub (x_8708, x_8707)
		  in
		     x_8709
		  end
	       val ~_0: real32 -> real32 = 
		  fn x_8710: real32 => 
		  let
		     val x_8711: real32 = 
			Real32_neg (x_8710)
		  in
		     x_8711
		  end
	       val <_3: real32 * real32 -> bool = 
		  fn x_8712: real32 * real32 => 
		  let
		     val x_8713: real32 = 
			#1 x_8712
		     val x_8714: real32 = 
			#0 x_8712
		     val x_8715: bool = 
			Real32_lt (x_8714, x_8713)
		  in
		     x_8715
		  end
	       val <=_2: real32 * real32 -> bool = 
		  fn x_8716: real32 * real32 => 
		  let
		     val x_8717: real32 = 
			#1 x_8716
		     val x_8718: real32 = 
			#0 x_8716
		     val x_8719: bool = 
			Real32_le (x_8718, x_8717)
		  in
		     x_8719
		  end
	       val round_0: real32 -> real32 = 
		  fn x_8720: real32 => 
		  let
		     val x_8721: real32 = 
			Real32_round (x_8720)
		  in
		     x_8721
		  end
	       val fromInt8Unsafe_0: word8 -> real32 = 
		  fn x_8722: word8 => 
		  let
		     val x_8723: real32 = 
			WordS8_rndToReal32 (x_8722)
		  in
		     x_8723
		  end
	       val fromInt16Unsafe_0: word16 -> real32 = 
		  fn x_8724: word16 => 
		  let
		     val x_8725: real32 = 
			WordS16_rndToReal32 (x_8724)
		  in
		     x_8725
		  end
	       val fromInt32Unsafe_0: word32 -> real32 = 
		  fn x_8726: word32 => 
		  let
		     val x_8727: real32 = 
			WordS32_rndToReal32 (x_8726)
		  in
		     x_8727
		  end
	       val fromInt64Unsafe_0: word64 -> real32 = 
		  fn x_8728: word64 => 
		  let
		     val x_8729: real32 = 
			WordS64_rndToReal32 (x_8728)
		  in
		     x_8729
		  end
	       val fromReal32Unsafe_0: real32 -> real32 = 
		  fn x_8730: real32 => 
		  let
		  in
		     x_8730
		  end
	       val fromWord8Unsafe_0: word8 -> real32 = 
		  fn x_8731: word8 => 
		  let
		     val x_8732: real32 = 
			WordU8_rndToReal32 (x_8731)
		  in
		     x_8732
		  end
	       val fromWord16Unsafe_0: word16 -> real32 = 
		  fn x_8733: word16 => 
		  let
		     val x_8734: real32 = 
			WordU16_rndToReal32 (x_8733)
		  in
		     x_8734
		  end
	       val fromWord32Unsafe_0: word32 -> real32 = 
		  fn x_8735: word32 => 
		  let
		     val x_8736: real32 = 
			WordU32_rndToReal32 (x_8735)
		  in
		     x_8736
		  end
	       val fromWord64Unsafe_0: word64 -> real32 = 
		  fn x_8737: word64 => 
		  let
		     val x_8738: real32 = 
			WordU64_rndToReal32 (x_8737)
		  in
		     x_8738
		  end
	       val toInt8Unsafe_0: real32 -> word8 = 
		  fn x_8739: real32 => 
		  let
		     val x_8740: word8 = 
			Real32_rndToWordS8 (x_8739)
		  in
		     x_8740
		  end
	       val toInt16Unsafe_0: real32 -> word16 = 
		  fn x_8741: real32 => 
		  let
		     val x_8742: word16 = 
			Real32_rndToWordS16 (x_8741)
		  in
		     x_8742
		  end
	       val toInt32Unsafe_0: real32 -> word32 = 
		  fn x_8743: real32 => 
		  let
		     val x_8744: word32 = 
			Real32_rndToWordS32 (x_8743)
		  in
		     x_8744
		  end
	       val toInt64Unsafe_0: real32 -> word64 = 
		  fn x_8745: real32 => 
		  let
		     val x_8746: word64 = 
			Real32_rndToWordS64 (x_8745)
		  in
		     x_8746
		  end
	       val toReal32Unsafe_0: real32 -> real32 = 
		  fn x_8747: real32 => 
		  let
		  in
		     x_8747
		  end
	       val toWord8Unsafe_0: real32 -> word8 = 
		  fn x_8748: real32 => 
		  let
		     val x_8749: word8 = 
			Real32_rndToWordU8 (x_8748)
		  in
		     x_8749
		  end
	       val toWord16Unsafe_0: real32 -> word16 = 
		  fn x_8750: real32 => 
		  let
		     val x_8751: word16 = 
			Real32_rndToWordU16 (x_8750)
		  in
		     x_8751
		  end
	       val toWord32Unsafe_0: real32 -> word32 = 
		  fn x_8752: real32 => 
		  let
		     val x_8753: word32 = 
			Real32_rndToWordU32 (x_8752)
		  in
		     x_8753
		  end
	       val toWord64Unsafe_0: real32 -> word64 = 
		  fn x_8754: real32 => 
		  let
		     val x_8755: word64 = 
			Real32_rndToWordU64 (x_8754)
		  in
		     x_8755
		  end
	       val rec 
		  >_2: real32 * real32 -> bool = 
		     fn x_8756: real32 * real32 => 
		     let
			val b_7: real32 = 
			   #1 x_8756
			val a_7: real32 = 
			   #0 x_8756
			val x_8757: real32 * real32 = 
			   (b_7, a_7)
			val x_8758: bool = 
			   <_3 x_8757
		     in
			x_8758
		     end
	       val rec 
		  >=_3: real32 * real32 -> bool = 
		     fn x_8759: real32 * real32 => 
		     let
			val b_8: real32 = 
			   #1 x_8759
			val a_8: real32 = 
			   #0 x_8759
			val x_8760: real32 * real32 = 
			   (b_8, a_8)
			val x_8761: bool = 
			   <=_2 x_8760
		     in
			x_8761
		     end
	       val realSize_1: word32 = 
		  0x40
	       val exponentBias_1: word32 = 
		  0x3FF
	       val precision_6: word32 = 
		  0x35
	       val +_2: real64 * real64 -> real64 = 
		  fn x_8762: real64 * real64 => 
		  let
		     val x_8763: real64 = 
			#1 x_8762
		     val x_8764: real64 = 
			#0 x_8762
		     val x_8765: real64 = 
			Real64_add (x_8764, x_8763)
		  in
		     x_8765
		  end
	       val -_2: real64 * real64 -> real64 = 
		  fn x_8766: real64 * real64 => 
		  let
		     val x_8767: real64 = 
			#1 x_8766
		     val x_8768: real64 = 
			#0 x_8766
		     val x_8769: real64 = 
			Real64_sub (x_8768, x_8767)
		  in
		     x_8769
		  end
	       val ~_1: real64 -> real64 = 
		  fn x_8770: real64 => 
		  let
		     val x_8771: real64 = 
			Real64_neg (x_8770)
		  in
		     x_8771
		  end
	       val <_4: real64 * real64 -> bool = 
		  fn x_8772: real64 * real64 => 
		  let
		     val x_8773: real64 = 
			#1 x_8772
		     val x_8774: real64 = 
			#0 x_8772
		     val x_8775: bool = 
			Real64_lt (x_8774, x_8773)
		  in
		     x_8775
		  end
	       val <=_3: real64 * real64 -> bool = 
		  fn x_8776: real64 * real64 => 
		  let
		     val x_8777: real64 = 
			#1 x_8776
		     val x_8778: real64 = 
			#0 x_8776
		     val x_8779: bool = 
			Real64_le (x_8778, x_8777)
		  in
		     x_8779
		  end
	       val round_1: real64 -> real64 = 
		  fn x_8780: real64 => 
		  let
		     val x_8781: real64 = 
			Real64_round (x_8780)
		  in
		     x_8781
		  end
	       val fromInt8Unsafe_1: word8 -> real64 = 
		  fn x_8782: word8 => 
		  let
		     val x_8783: real64 = 
			WordS8_rndToReal64 (x_8782)
		  in
		     x_8783
		  end
	       val fromInt16Unsafe_1: word16 -> real64 = 
		  fn x_8784: word16 => 
		  let
		     val x_8785: real64 = 
			WordS16_rndToReal64 (x_8784)
		  in
		     x_8785
		  end
	       val fromInt32Unsafe_1: word32 -> real64 = 
		  fn x_8786: word32 => 
		  let
		     val x_8787: real64 = 
			WordS32_rndToReal64 (x_8786)
		  in
		     x_8787
		  end
	       val fromInt64Unsafe_1: word64 -> real64 = 
		  fn x_8788: word64 => 
		  let
		     val x_8789: real64 = 
			WordS64_rndToReal64 (x_8788)
		  in
		     x_8789
		  end
	       val fromReal32Unsafe_1: real32 -> real64 = 
		  fn x_8790: real32 => 
		  let
		     val x_8791: real64 = 
			Real32_rndToReal64 (x_8790)
		  in
		     x_8791
		  end
	       val fromWord8Unsafe_1: word8 -> real64 = 
		  fn x_8792: word8 => 
		  let
		     val x_8793: real64 = 
			WordU8_rndToReal64 (x_8792)
		  in
		     x_8793
		  end
	       val fromWord16Unsafe_1: word16 -> real64 = 
		  fn x_8794: word16 => 
		  let
		     val x_8795: real64 = 
			WordU16_rndToReal64 (x_8794)
		  in
		     x_8795
		  end
	       val fromWord32Unsafe_1: word32 -> real64 = 
		  fn x_8796: word32 => 
		  let
		     val x_8797: real64 = 
			WordU32_rndToReal64 (x_8796)
		  in
		     x_8797
		  end
	       val fromWord64Unsafe_1: word64 -> real64 = 
		  fn x_8798: word64 => 
		  let
		     val x_8799: real64 = 
			WordU64_rndToReal64 (x_8798)
		  in
		     x_8799
		  end
	       val toInt8Unsafe_1: real64 -> word8 = 
		  fn x_8800: real64 => 
		  let
		     val x_8801: word8 = 
			Real64_rndToWordS8 (x_8800)
		  in
		     x_8801
		  end
	       val toInt16Unsafe_1: real64 -> word16 = 
		  fn x_8802: real64 => 
		  let
		     val x_8803: word16 = 
			Real64_rndToWordS16 (x_8802)
		  in
		     x_8803
		  end
	       val toInt32Unsafe_1: real64 -> word32 = 
		  fn x_8804: real64 => 
		  let
		     val x_8805: word32 = 
			Real64_rndToWordS32 (x_8804)
		  in
		     x_8805
		  end
	       val toInt64Unsafe_1: real64 -> word64 = 
		  fn x_8806: real64 => 
		  let
		     val x_8807: word64 = 
			Real64_rndToWordS64 (x_8806)
		  in
		     x_8807
		  end
	       val toReal32Unsafe_1: real64 -> real32 = 
		  fn x_8808: real64 => 
		  let
		     val x_8809: real32 = 
			Real64_rndToReal32 (x_8808)
		  in
		     x_8809
		  end
	       val toWord8Unsafe_1: real64 -> word8 = 
		  fn x_8810: real64 => 
		  let
		     val x_8811: word8 = 
			Real64_rndToWordU8 (x_8810)
		  in
		     x_8811
		  end
	       val toWord16Unsafe_1: real64 -> word16 = 
		  fn x_8812: real64 => 
		  let
		     val x_8813: word16 = 
			Real64_rndToWordU16 (x_8812)
		  in
		     x_8813
		  end
	       val toWord32Unsafe_1: real64 -> word32 = 
		  fn x_8814: real64 => 
		  let
		     val x_8815: word32 = 
			Real64_rndToWordU32 (x_8814)
		  in
		     x_8815
		  end
	       val toWord64Unsafe_1: real64 -> word64 = 
		  fn x_8816: real64 => 
		  let
		     val x_8817: word64 = 
			Real64_rndToWordU64 (x_8816)
		  in
		     x_8817
		  end
	       val rec 
		  >_3: real64 * real64 -> bool = 
		     fn x_8818: real64 * real64 => 
		     let
			val b_9: real64 = 
			   #1 x_8818
			val a_9: real64 = 
			   #0 x_8818
			val x_8819: real64 * real64 = 
			   (b_9, a_9)
			val x_8820: bool = 
			   <_4 x_8819
		     in
			x_8820
		     end
	       val rec 
		  >=_4: real64 * real64 -> bool = 
		     fn x_8821: real64 * real64 => 
		     let
			val b_10: real64 = 
			   #1 x_8821
			val a_10: real64 = 
			   #0 x_8821
			val x_8822: real64 * real64 = 
			   (b_10, a_10)
			val x_8823: bool = 
			   <=_3 x_8822
		     in
			x_8823
		     end
	       val castFromWord_0: word32 -> real32 = 
		  fn x_8824: word32 => 
		  let
		     val x_8825: real32 = 
			Word32_castToReal32 (x_8824)
		  in
		     x_8825
		  end
	       val castFromWord_1: word64 -> real64 = 
		  fn x_8826: word64 => 
		  let
		     val x_8827: real64 = 
			Word64_castToReal64 (x_8826)
		  in
		     x_8827
		  end
	       val halt_0: word32 -> unit = 
		  fn x_8828: word32 => 
		  let
		     val x_8829: unit = 
			MLton_halt (x_8828)
		  in
		     x_8829
		  end
	       val x_8830: cpointer = 
		  gcStateAddress ()
	       val x_8831: word64 = 
		  0x0
	       val x_8832: cpointer = 
		  CPointer_getCPointer (x_8830, x_8831)
	       val numExports_0: word32 = 
		  0x1
	       val fromWord_1: word64 -> cpointer = 
		  fn x_8833: word64 => 
		  let
		     val x_8834: cpointer = 
			CPointer_fromWord (x_8833)
		  in
		     x_8834
		  end
	       val x_8835: word64 = 
		  0x0
	       val null_0: cpointer = 
		  fromWord_1 x_8835
	       val isOn_0: bool = 
		  false
	       val atomicState_0: unit -> word32 = 
		  fn x_8836: unit => 
		  let
		     val x_8837: word32 = 
			Thread_atomicState ()
		  in
		     x_8837
		  end
	       val atomicBegin_0: unit -> unit = 
		  fn x_8838: unit => 
		  let
		     val x_8839: unit = 
			Thread_atomicBegin ()
		  in
		     x_8839
		  end
	       val rec 
		  atomicEnd_0: unit -> unit = 
		     fn x_8840: unit => 
		     let
			val x_8841: unit = 
			   ()
			val x_8842: word32 = 
			   atomicState_0 x_8841
			val x_8843: word32 = 
			   0x0
			val x_8844: word32 * word32 = 
			   (x_8842, x_8843)
			val x_8845: bool = 
			   x_8367 x_8844
			val x_8846: unit = 
			   case x_8845 of
			   true => 
			      let
				 val x_8848: word8 vector = 
				    "Thread.atomicEnd"
				 val x_8849: unit ref * word8 vector = 
				    (x_8287, x_8848)
				 val x_8850: exn = 
				    Fail8_0 x_8849
				 val x_8851: unit = 
				    raise x_8850
			      in
				 x_8851
			      end
			   false => 
			      let
				 val x_8847: unit = 
				    Thread_atomicEnd ()
			      in
				 x_8847
			      end
		     in
			x_8846
		     end
	       val switchTo_0: thread -> unit = 
		  fn x_8852: thread => 
		  let
		     val x_8853: unit = 
			Thread_switchTo (x_8852)
		  in
		     x_8853
		  end
	       val FE_DOWNWARD_0: word32 = 
		  0x400
	       val FE_NOSUPPORT_0: word32 = 
		  0xFFFFFFFF
	       val FE_TONEAREST_0: word32 = 
		  0x0
	       val FE_TOWARDZERO_0: word32 = 
		  0xC00
	       val FE_UPWARD_0: word32 = 
		  0x800
	       val bug_0: word8 vector -> unit = 
		  fn x_8854: word8 vector => 
		  let
		     val x_8855: unit = 
			MLton_bug (x_8854)
		  in
		     x_8855
		  end
	       val E2BIG_0: word32 = 
		  0x7
	       val EACCES_0: word32 = 
		  0xD
	       val EADDRINUSE_0: word32 = 
		  0x62
	       val EADDRNOTAVAIL_0: word32 = 
		  0x63
	       val EAFNOSUPPORT_0: word32 = 
		  0x61
	       val EAGAIN_0: word32 = 
		  0xB
	       val EALREADY_0: word32 = 
		  0x72
	       val EBADF_0: word32 = 
		  0x9
	       val EBADMSG_0: word32 = 
		  0x4A
	       val EBUSY_0: word32 = 
		  0x10
	       val ECANCELED_0: word32 = 
		  0x7D
	       val ECHILD_0: word32 = 
		  0xA
	       val ECONNABORTED_0: word32 = 
		  0x67
	       val ECONNREFUSED_0: word32 = 
		  0x6F
	       val ECONNRESET_0: word32 = 
		  0x68
	       val EDEADLK_0: word32 = 
		  0x23
	       val EDESTADDRREQ_0: word32 = 
		  0x59
	       val EDOM_0: word32 = 
		  0x21
	       val EDQUOT_0: word32 = 
		  0x7A
	       val EEXIST_0: word32 = 
		  0x11
	       val EFAULT_0: word32 = 
		  0xE
	       val EFBIG_0: word32 = 
		  0x1B
	       val EHOSTUNREACH_0: word32 = 
		  0x71
	       val EIDRM_0: word32 = 
		  0x2B
	       val EILSEQ_0: word32 = 
		  0x54
	       val EINPROGRESS_0: word32 = 
		  0x73
	       val EINTR_0: word32 = 
		  0x4
	       val EINVAL_0: word32 = 
		  0x16
	       val EIO_0: word32 = 
		  0x5
	       val EISCONN_0: word32 = 
		  0x6A
	       val EISDIR_0: word32 = 
		  0x15
	       val ELOOP_0: word32 = 
		  0x28
	       val EMFILE_0: word32 = 
		  0x18
	       val EMLINK_0: word32 = 
		  0x1F
	       val EMSGSIZE_0: word32 = 
		  0x5A
	       val EMULTIHOP_0: word32 = 
		  0x48
	       val ENAMETOOLONG_0: word32 = 
		  0x24
	       val ENETDOWN_0: word32 = 
		  0x64
	       val ENETRESET_0: word32 = 
		  0x66
	       val ENETUNREACH_0: word32 = 
		  0x65
	       val ENFILE_0: word32 = 
		  0x17
	       val ENOBUFS_0: word32 = 
		  0x69
	       val ENODATA_0: word32 = 
		  0x3D
	       val ENODEV_0: word32 = 
		  0x13
	       val ENOENT_0: word32 = 
		  0x2
	       val ENOEXEC_0: word32 = 
		  0x8
	       val ENOLCK_0: word32 = 
		  0x25
	       val ENOLINK_0: word32 = 
		  0x43
	       val ENOMEM_0: word32 = 
		  0xC
	       val ENOMSG_0: word32 = 
		  0x2A
	       val ENOPROTOOPT_0: word32 = 
		  0x5C
	       val ENOSPC_0: word32 = 
		  0x1C
	       val ENOSR_0: word32 = 
		  0x3F
	       val ENOSTR_0: word32 = 
		  0x3C
	       val ENOSYS_0: word32 = 
		  0x26
	       val ENOTCONN_0: word32 = 
		  0x6B
	       val ENOTDIR_0: word32 = 
		  0x14
	       val ENOTEMPTY_0: word32 = 
		  0x27
	       val ENOTSOCK_0: word32 = 
		  0x58
	       val ENOTSUP_0: word32 = 
		  0x5F
	       val ENOTTY_0: word32 = 
		  0x19
	       val ENXIO_0: word32 = 
		  0x6
	       val EOPNOTSUPP_0: word32 = 
		  0x5F
	       val EOVERFLOW_0: word32 = 
		  0x4B
	       val EPERM_0: word32 = 
		  0x1
	       val EPIPE_0: word32 = 
		  0x20
	       val EPROTO_0: word32 = 
		  0x47
	       val EPROTONOSUPPORT_0: word32 = 
		  0x5D
	       val EPROTOTYPE_0: word32 = 
		  0x5B
	       val ERANGE_0: word32 = 
		  0x22
	       val EROFS_0: word32 = 
		  0x1E
	       val ESPIPE_0: word32 = 
		  0x1D
	       val ESRCH_0: word32 = 
		  0x3
	       val ESTALE_0: word32 = 
		  0x74
	       val ETIME_0: word32 = 
		  0x3E
	       val ETIMEDOUT_0: word32 = 
		  0x6E
	       val ETXTBSY_0: word32 = 
		  0x1A
	       val EWOULDBLOCK_0: word32 = 
		  0xB
	       val EXDEV_0: word32 = 
		  0x12
	       val APPEND_0: word32 = 
		  0x400
	       val NONBLOCK_0: word32 = 
		  0x800
	       val F_SETFL_0: word32 = 
		  0x4
	       val SEEK_CUR_1: word32 = 
		  0x1
	       val SEEK_END_1: word32 = 
		  0x2
	       val SEEK_SET_1: word32 = 
		  0x0
	       val print_0: word8 vector -> unit = 
		  fn x_8856: word8 vector => 
		  let
		     val x_8857: unit = 
			Stdio_print (x_8856)
		  in
		     x_8857
		  end
	       val x_8858: exn -> unit = 
		  fn x_8859: exn => 
		  let
		     val x_8860: word8 vector = 
			"unhandled exception: "
		     val x_8861: unit = 
			print_0 x_8860
		     val x_8862: unit -> unit = 
			fn unit_6: unit => 
			let
			   val x_8863: word8 vector = 
			      name_0 x_8859
			   val x_8864: unit = 
			      print_0 x_8863
			in
			   x_8864
			end
		     val x_8865: unit = 
			case x_8859 of
			Fail8_0 x_8866: unit ref * word8 vector => 
			   let
			      val x_8867: word8 vector = 
				 #1 x_8866
			      val x_8868: unit ref = 
				 #0 x_8866
			      val x_8869: bool = 
				 MLton_equal[unit ref] (x_8868, x_8287)
			      val x_8870: unit = 
				 case x_8869 of
				 true => 
				    let
				       val x_8873: word8 vector = 
					  "Fail "
				       val x_8874: unit = 
					  print_0 x_8873
				       val x_8875: unit = 
					  print_0 x_8867
				    in
				       x_8875
				    end
				 false => 
				    let
				       val x_8871: unit = 
					  ()
				       val x_8872: unit = 
					  x_8862 x_8871
				    in
				       x_8872
				    end
			   in
			      x_8870
			   end
			  _ => let
				  val x_8876: unit = 
				     ()
				  val x_8877: unit = 
				     x_8862 x_8876
			       in
				  x_8877
			       end
		     val x_8878: word8 vector = 
			"\n"
		     val x_8879: unit = 
			print_0 x_8878
		     val x_8880: word8 vector = 
			"unhandled exception in Basis Library"
		     val x_8881: unit = 
			bug_0 x_8880
		  in
		     x_8881
		  end
	       val x_8882: unit = 
		  Ref_assign[exn -> unit] (x_8175, x_8858)
	       val x_8883: unit -> unit = 
		  fn x_8884: unit => 
		  let
		     val x_8885: word32 = 
			0x0
		     val x_8886: unit = 
			halt_0 x_8885
		     val x_8887: word8 vector = 
			"missing suffix in Basis Library"
		     val x_8888: unit = 
			bug_0 x_8887
		  in
		     x_8888
		  end
	       val x_8889: unit = 
		  Ref_assign[unit -> unit] (x_8181, x_8883)
	       val x_8890: word64 -> word32 = 
		  fn x_8891: word64 => 
		  let
		     val res_0: word32 = 
			sextdFromInt64ToInt32_0 x_8891
		     val x_8892: word64 = 
			sextdFromInt32ToInt64_0 res_0
		     val x_8893: word64 * word64 = 
			(x_8891, x_8892)
		     val x_8894: bool = 
			x_8372 x_8893
		     val x_8895: word32 = 
			case x_8894 of
			true => 
			   let
			   in
			      res_0
			   end
			false => 
			   let
			      val x_8896: word32 = 
				 raise x_8290
			   in
			      x_8896
			   end
		  in
		     x_8895
		  end
	       val x_8897: word32 * word32 = 
		  (sizeInBits_40, sizeInBits_7)
	       val x_8898: bool = 
		  x_8382 x_8897
	       val x_8899: bool = 
		  case x_8898 of
		  true => 
		     let
			val x_8902: bool = 
			   true
		     in
			x_8902
		     end
		  false => 
		     let
			val x_8900: word32 * word32 = 
			   (sizeInBitsWord_4, sizeInBitsWord_0)
			val x_8901: bool = 
			   x_8382 x_8900
		     in
			x_8901
		     end
	       val x_8903: unit = 
		  case x_8899 of
		  true => 
		     let
			val x_8905: word8 vector = 
			   "MkNum0: Int.sizeInBits <> Word.sizeInBits"
			val x_8906: unit ref * word8 vector = 
			   (x_8287, x_8905)
			val x_8907: exn = 
			   Fail8_0 x_8906
			val x_8908: unit = 
			   raise x_8907
		     in
			x_8908
		     end
		  false => 
		     let
			val x_8904: unit = 
			   ()
		     in
			x_8904
		     end
	       val x_8909: word8 = 
		  0x0
	       val maxWord'_0: word8 = 
		  notb_0 x_8909
	       val x_8910: word32 = 
		  0x0
	       val zero_0: word8 = 
		  zextdFromInt32ToInt8_0 x_8910
	       val x_8911: word32 = 
		  0x1
	       val one_0: word8 = 
		  zextdFromInt32ToInt8_0 x_8911
	       val x_8912: word8 * word32 -> word8 = 
		  fn x_8913: word8 * word32 => 
		  let
		     val w_0: word32 = 
			#1 x_8913
		     val x_8914: word8 = 
			#0 x_8913
		     val x_8915: word8 = 
			idFromInt8ToWord8_0 x_8914
		     val x_8916: word8 * word32 = 
			(x_8915, w_0)
		     val x_8917: word8 = 
			<<?_0 x_8916
		     val x_8918: word8 = 
			idFromWord8ToInt8_0 x_8917
		  in
		     x_8918
		  end
	       val x_8919: word8 * word32 -> word8 = 
		  fn x_8920: word8 * word32 => 
		  let
		     val w_1: word32 = 
			#1 x_8920
		     val x_8921: word8 = 
			#0 x_8920
		     val x_8922: word8 = 
			idFromInt8ToWord8_0 x_8921
		     val x_8923: word8 * word32 = 
			(x_8922, w_1)
		     val x_8924: word8 = 
			>>?_0 x_8923
		     val x_8925: word8 = 
			idFromWord8ToInt8_0 x_8924
		  in
		     x_8925
		  end
	       val x_8926: word32 = 
		  0x1
	       val x_8927: word32 * word32 = 
		  (sizeInBitsWord_4, x_8926)
	       val x_8928: word32 = 
		  -_0 x_8927
	       val x_8929: word8 * word32 = 
		  (one_0, x_8928)
	       val minInt'_0: word8 = 
		  x_8912 x_8929
	       val x_8930: word8 = 
		  idFromInt8ToWord8_0 zero_0
	       val x_8931: word8 = 
		  notb_0 x_8930
	       val x_8932: word8 = 
		  idFromWord8ToInt8_0 x_8931
	       val x_8933: word32 = 
		  0x1
	       val x_8934: word8 * word32 = 
		  (x_8932, x_8933)
	       val maxInt'_0: word8 = 
		  x_8919 x_8934
	       val x_8935: word32 * word32 = 
		  (sizeInBits_48, sizeInBits_15)
	       val x_8936: bool = 
		  x_8382 x_8935
	       val x_8937: bool = 
		  case x_8936 of
		  true => 
		     let
			val x_8940: bool = 
			   true
		     in
			x_8940
		     end
		  false => 
		     let
			val x_8938: word32 * word32 = 
			   (sizeInBitsWord_5, sizeInBitsWord_1)
			val x_8939: bool = 
			   x_8382 x_8938
		     in
			x_8939
		     end
	       val x_8941: unit = 
		  case x_8937 of
		  true => 
		     let
			val x_8943: word8 vector = 
			   "MkNum0: Int.sizeInBits <> Word.sizeInBits"
			val x_8944: unit ref * word8 vector = 
			   (x_8287, x_8943)
			val x_8945: exn = 
			   Fail8_0 x_8944
			val x_8946: unit = 
			   raise x_8945
		     in
			x_8946
		     end
		  false => 
		     let
			val x_8942: unit = 
			   ()
		     in
			x_8942
		     end
	       val x_8947: word16 = 
		  0x0
	       val maxWord'_1: word16 = 
		  notb_1 x_8947
	       val x_8948: word32 = 
		  0x0
	       val zero_1: word16 = 
		  zextdFromInt32ToInt16_0 x_8948
	       val x_8949: word32 = 
		  0x1
	       val one_1: word16 = 
		  zextdFromInt32ToInt16_0 x_8949
	       val x_8950: word16 * word32 -> word16 = 
		  fn x_8951: word16 * word32 => 
		  let
		     val w_2: word32 = 
			#1 x_8951
		     val x_8952: word16 = 
			#0 x_8951
		     val x_8953: word16 = 
			idFromInt16ToWord16_0 x_8952
		     val x_8954: word16 * word32 = 
			(x_8953, w_2)
		     val x_8955: word16 = 
			<<?_1 x_8954
		     val x_8956: word16 = 
			idFromWord16ToInt16_0 x_8955
		  in
		     x_8956
		  end
	       val x_8957: word16 * word32 -> word16 = 
		  fn x_8958: word16 * word32 => 
		  let
		     val w_3: word32 = 
			#1 x_8958
		     val x_8959: word16 = 
			#0 x_8958
		     val x_8960: word16 = 
			idFromInt16ToWord16_0 x_8959
		     val x_8961: word16 * word32 = 
			(x_8960, w_3)
		     val x_8962: word16 = 
			>>?_1 x_8961
		     val x_8963: word16 = 
			idFromWord16ToInt16_0 x_8962
		  in
		     x_8963
		  end
	       val x_8964: word32 = 
		  0x1
	       val x_8965: word32 * word32 = 
		  (sizeInBitsWord_5, x_8964)
	       val x_8966: word32 = 
		  -_0 x_8965
	       val x_8967: word16 * word32 = 
		  (one_1, x_8966)
	       val minInt'_1: word16 = 
		  x_8950 x_8967
	       val x_8968: word16 = 
		  idFromInt16ToWord16_0 zero_1
	       val x_8969: word16 = 
		  notb_1 x_8968
	       val x_8970: word16 = 
		  idFromWord16ToInt16_0 x_8969
	       val x_8971: word32 = 
		  0x1
	       val x_8972: word16 * word32 = 
		  (x_8970, x_8971)
	       val maxInt'_1: word16 = 
		  x_8957 x_8972
	       val x_8973: word32 * word32 = 
		  (sizeInBits_64, sizeInBits_31)
	       val x_8974: bool = 
		  x_8382 x_8973
	       val x_8975: bool = 
		  case x_8974 of
		  true => 
		     let
			val x_8978: bool = 
			   true
		     in
			x_8978
		     end
		  false => 
		     let
			val x_8976: word32 * word32 = 
			   (sizeInBitsWord_6, sizeInBitsWord_2)
			val x_8977: bool = 
			   x_8382 x_8976
		     in
			x_8977
		     end
	       val x_8979: unit = 
		  case x_8975 of
		  true => 
		     let
			val x_8981: word8 vector = 
			   "MkNum0: Int.sizeInBits <> Word.sizeInBits"
			val x_8982: unit ref * word8 vector = 
			   (x_8287, x_8981)
			val x_8983: exn = 
			   Fail8_0 x_8982
			val x_8984: unit = 
			   raise x_8983
		     in
			x_8984
		     end
		  false => 
		     let
			val x_8980: unit = 
			   ()
		     in
			x_8980
		     end
	       val x_8985: word32 = 
		  0x0
	       val zero_2: word32 = 
		  zextdFromWord32ToWord32_0 x_8985
	       val x_8986: word32 = 
		  0x1
	       val one_2: word32 = 
		  zextdFromWord32ToWord32_0 x_8986
	       val maxWord'_2: word32 = 
		  notb_2 zero_2
	       val x_8987: word32 = 
		  0x0
	       val zero_3: word32 = 
		  zextdFromInt32ToInt32_0 x_8987
	       val x_8988: word32 = 
		  0x1
	       val one_3: word32 = 
		  zextdFromInt32ToInt32_0 x_8988
	       val x_8989: word32 * word32 -> word32 = 
		  fn x_8990: word32 * word32 => 
		  let
		     val w_4: word32 = 
			#1 x_8990
		     val x_8991: word32 = 
			#0 x_8990
		     val x_8992: word32 = 
			idFromInt32ToWord32_0 x_8991
		     val x_8993: word32 * word32 = 
			(x_8992, w_4)
		     val x_8994: word32 = 
			<<?_2 x_8993
		     val x_8995: word32 = 
			idFromWord32ToInt32_0 x_8994
		  in
		     x_8995
		  end
	       val x_8996: word32 * word32 -> word32 = 
		  fn x_8997: word32 * word32 => 
		  let
		     val w_5: word32 = 
			#1 x_8997
		     val x_8998: word32 = 
			#0 x_8997
		     val x_8999: word32 = 
			idFromInt32ToWord32_0 x_8998
		     val x_9000: word32 * word32 = 
			(x_8999, w_5)
		     val x_9001: word32 = 
			>>?_2 x_9000
		     val x_9002: word32 = 
			idFromWord32ToInt32_0 x_9001
		  in
		     x_9002
		  end
	       val x_9003: word32 = 
		  0x1
	       val x_9004: word32 * word32 = 
		  (sizeInBitsWord_6, x_9003)
	       val x_9005: word32 = 
		  -_0 x_9004
	       val x_9006: word32 * word32 = 
		  (one_3, x_9005)
	       val minInt'_2: word32 = 
		  x_8989 x_9006
	       val x_9007: word32 = 
		  idFromInt32ToWord32_0 zero_3
	       val x_9008: word32 = 
		  notb_2 x_9007
	       val x_9009: word32 = 
		  idFromWord32ToInt32_0 x_9008
	       val x_9010: word32 = 
		  0x1
	       val x_9011: word32 * word32 = 
		  (x_9009, x_9010)
	       val maxInt'_2: word32 = 
		  x_8996 x_9011
	       val rec 
		  quot_0: word32 * word32 -> word32 = 
		     fn x_9012: word32 * word32 => 
		     let
			val y_2: word32 = 
			   #1 x_9012
			val x_9013: word32 = 
			   #0 x_9012
			val x_9014: word32 * word32 = 
			   (y_2, zero_3)
			val x_9015: bool = 
			   x_8367 x_9014
			val x_9016: word32 = 
			   case x_9015 of
			   true => 
			      let
				 val x_9027: word32 = 
				    raise x_8282
			      in
				 x_9027
			      end
			   false => 
			      let
				 val x_9017: word32 * word32 = 
				    (x_9013, minInt'_2)
				 val x_9018: bool = 
				    x_8367 x_9017
				 val x_9019: bool = 
				    case x_9018 of
				    true => 
				       let
					  val x_9021: word32 = 
					     x_8530 one_3
					  val x_9022: word32 * word32 = 
					     (y_2, x_9021)
					  val x_9023: bool = 
					     x_8367 x_9022
				       in
					  x_9023
				       end
				    false => 
				       let
					  val x_9020: bool = 
					     false
				       in
					  x_9020
				       end
				 val x_9024: word32 = 
				    case x_9019 of
				    true => 
				       let
					  val x_9026: word32 = 
					     raise x_8290
				       in
					  x_9026
				       end
				    false => 
				       let
					  val x_9025: word32 = 
					     WordS32_quot (x_9013, y_2)
				       in
					  x_9025
				       end
			      in
				 x_9024
			      end
		     in
			x_9016
		     end
	       val x_9028: word32 * word32 = 
		  (sizeInBits_65, sizeInBits_32)
	       val x_9029: bool = 
		  x_8382 x_9028
	       val x_9030: bool = 
		  case x_9029 of
		  true => 
		     let
			val x_9033: bool = 
			   true
		     in
			x_9033
		     end
		  false => 
		     let
			val x_9031: word32 * word32 = 
			   (sizeInBitsWord_7, sizeInBitsWord_3)
			val x_9032: bool = 
			   x_8382 x_9031
		     in
			x_9032
		     end
	       val x_9034: unit = 
		  case x_9030 of
		  true => 
		     let
			val x_9036: word8 vector = 
			   "MkNum0: Int.sizeInBits <> Word.sizeInBits"
			val x_9037: unit ref * word8 vector = 
			   (x_8287, x_9036)
			val x_9038: exn = 
			   Fail8_0 x_9037
			val x_9039: unit = 
			   raise x_9038
		     in
			x_9039
		     end
		  false => 
		     let
			val x_9035: unit = 
			   ()
		     in
			x_9035
		     end
	       val x_9040: word32 = 
		  0x0
	       val zero_4: word64 = 
		  zextdFromWord32ToWord64_0 x_9040
	       val x_9041: word32 = 
		  0x1
	       val one_4: word64 = 
		  zextdFromWord32ToWord64_0 x_9041
	       val maxWord'_3: word64 = 
		  notb_3 zero_4
	       val x_9042: word32 = 
		  0x0
	       val zero_5: word64 = 
		  zextdFromInt32ToInt64_0 x_9042
	       val x_9043: word32 = 
		  0x1
	       val one_5: word64 = 
		  zextdFromInt32ToInt64_0 x_9043
	       val x_9044: word64 * word32 -> word64 = 
		  fn x_9045: word64 * word32 => 
		  let
		     val w_6: word32 = 
			#1 x_9045
		     val x_9046: word64 = 
			#0 x_9045
		     val x_9047: word64 = 
			idFromInt64ToWord64_0 x_9046
		     val x_9048: word64 * word32 = 
			(x_9047, w_6)
		     val x_9049: word64 = 
			<<?_3 x_9048
		     val x_9050: word64 = 
			idFromWord64ToInt64_0 x_9049
		  in
		     x_9050
		  end
	       val x_9051: word64 * word32 -> word64 = 
		  fn x_9052: word64 * word32 => 
		  let
		     val w_7: word32 = 
			#1 x_9052
		     val x_9053: word64 = 
			#0 x_9052
		     val x_9054: word64 = 
			idFromInt64ToWord64_0 x_9053
		     val x_9055: word64 * word32 = 
			(x_9054, w_7)
		     val x_9056: word64 = 
			>>?_3 x_9055
		     val x_9057: word64 = 
			idFromWord64ToInt64_0 x_9056
		  in
		     x_9057
		  end
	       val x_9058: word32 = 
		  0x1
	       val x_9059: word32 * word32 = 
		  (sizeInBitsWord_7, x_9058)
	       val x_9060: word32 = 
		  -_0 x_9059
	       val x_9061: word64 * word32 = 
		  (one_5, x_9060)
	       val minInt'_3: word64 = 
		  x_9044 x_9061
	       val x_9062: word64 = 
		  idFromInt64ToWord64_0 zero_5
	       val x_9063: word64 = 
		  notb_3 x_9062
	       val x_9064: word64 = 
		  idFromWord64ToInt64_0 x_9063
	       val x_9065: word32 = 
		  0x1
	       val x_9066: word64 * word32 = 
		  (x_9064, x_9065)
	       val maxInt'_3: word64 = 
		  x_9051 x_9066
	       val rec 
		  quot_1: word64 * word64 -> word64 = 
		     fn x_9067: word64 * word64 => 
		     let
			val y_3: word64 = 
			   #1 x_9067
			val x_9068: word64 = 
			   #0 x_9067
			val x_9069: word64 * word64 = 
			   (y_3, zero_5)
			val x_9070: bool = 
			   x_8372 x_9069
			val x_9071: word64 = 
			   case x_9070 of
			   true => 
			      let
				 val x_9082: word64 = 
				    raise x_8282
			      in
				 x_9082
			      end
			   false => 
			      let
				 val x_9072: word64 * word64 = 
				    (x_9068, minInt'_3)
				 val x_9073: bool = 
				    x_8372 x_9072
				 val x_9074: bool = 
				    case x_9073 of
				    true => 
				       let
					  val x_9076: word64 = 
					     x_8610 one_5
					  val x_9077: word64 * word64 = 
					     (y_3, x_9076)
					  val x_9078: bool = 
					     x_8372 x_9077
				       in
					  x_9078
				       end
				    false => 
				       let
					  val x_9075: bool = 
					     false
				       in
					  x_9075
				       end
				 val x_9079: word64 = 
				    case x_9074 of
				    true => 
				       let
					  val x_9081: word64 = 
					     raise x_8290
				       in
					  x_9081
				       end
				    false => 
				       let
					  val x_9080: word64 = 
					     WordS64_quot (x_9068, y_3)
				       in
					  x_9080
				       end
			      in
				 x_9079
			      end
		     in
			x_9071
		     end
	       val rec 
		  ltu_0: word64 * word64 -> bool = 
		     fn x_9083: word64 * word64 => 
		     let
			val i'_0: word64 = 
			   #1 x_9083
			val i_0: word64 = 
			   #0 x_9083
			val x_9084: word64 = 
			   idFromInt64ToWord64_0 i_0
			val x_9085: word64 = 
			   idFromInt64ToWord64_0 i'_0
			val x_9086: bool = 
			   WordU64_lt (x_9084, x_9085)
		     in
			x_9086
		     end
	       val rec 
		  >_4: word64 * word64 -> bool = 
		     fn x_9087: word64 * word64 => 
		     let
			val b_11: word64 = 
			   #1 x_9087
			val a_11: word64 = 
			   #0 x_9087
			val x_9088: word64 * word64 = 
			   (b_11, a_11)
			val x_9089: bool = 
			   ltu_0 x_9088
		     in
			x_9089
		     end
	       val rec 
		  >=_5: word64 * word64 -> bool = 
		     fn x_9090: word64 * word64 => 
		     let
			val b_12: word64 = 
			   #1 x_9090
			val a_12: word64 = 
			   #0 x_9090
			val x_9091: word64 * word64 = 
			   (a_12, b_12)
			val x_9092: bool = 
			   ltu_0 x_9091
			val x_9093: bool = 
			   not_0 x_9092
		     in
			x_9093
		     end
	       val isMutable_0: bool = 
		  false
	       val rec 
		  valOf_2: Primitive.Option.t_0 -> word32 = 
		     fn x_9094: Primitive.Option.t_0 => 
		     let
			val x_9095: word32 = 
			   case x_9094 of
			   SOME_0 x_9097: word32 => 
			      let
			      in
				 x_9097
			      end
			   NONE_0 => 
			      let
				 val x_9096: word32 = 
				    0x0
			      in
				 x_9096
			      end
		     in
			x_9095
		     end
	       val x_9098: word32 = 
		  valOf_2 precision_1
	       val x_9099: word32 = 
		  valOf_2 precision_4
	       val x_9100: word32 * word32 = 
		  (x_9099, x_9098)
	       val x_9101: bool = 
		  >=_1 x_9100
	       val x_9102: word64 = 
		  case x_9101 of
		  true => 
		     let
			val x_9103: word64 = 
			   sextdFromInt8ToInt64_0 maxInt'_0
		     in
			x_9103
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val x_9104: word32 = 
		  valOf_2 precision_2
	       val x_9105: word32 = 
		  valOf_2 precision_4
	       val x_9106: word32 * word32 = 
		  (x_9105, x_9104)
	       val x_9107: bool = 
		  >=_1 x_9106
	       val x_9108: word64 = 
		  case x_9107 of
		  true => 
		     let
			val x_9109: word64 = 
			   sextdFromInt16ToInt64_0 maxInt'_1
		     in
			x_9109
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val x_9110: word32 = 
		  valOf_2 precision_3
	       val x_9111: word32 = 
		  valOf_2 precision_4
	       val x_9112: word32 * word32 = 
		  (x_9111, x_9110)
	       val x_9113: bool = 
		  >=_1 x_9112
	       val x_9114: word64 = 
		  case x_9113 of
		  true => 
		     let
			val x_9115: word64 = 
			   sextdFromInt32ToInt64_0 maxInt'_2
		     in
			x_9115
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val x_9116: word32 = 
		  valOf_2 precision_4
	       val x_9117: word32 = 
		  valOf_2 precision_4
	       val x_9118: word32 * word32 = 
		  (x_9117, x_9116)
	       val x_9119: bool = 
		  >=_1 x_9118
	       val x_9120: word64 = 
		  case x_9119 of
		  true => 
		     let
			val x_9121: word64 = 
			   sextdFromInt64ToInt64_0 maxInt'_3
		     in
			x_9121
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val rec 
		  arrayUninit_1: word64 -> word8 array = 
		     fn x_9122: word64 => 
		     let
			val x_9123: bool = 
			   not_0 isMutable_0
			val x_9124: bool = 
			   case x_9123 of
			   true => 
			      let
				 val x_9126: word64 = 
				    0x0
				 val x_9127: word64 * word64 = 
				    (x_9122, x_9126)
				 val x_9128: bool = 
				    x_8372 x_9127
			      in
				 x_9128
			      end
			   false => 
			      let
				 val x_9125: bool = 
				    false
			      in
				 x_9125
			      end
			val x_9129: word8 array = 
			   case x_9124 of
			   true => 
			      let
				 val x_9135: unit = 
				    ()
				 val x_9136: word8 array = 
				    x_8666 x_9135
			      in
				 x_9136
			      end
			   false => 
			      let
				 val x_9130: word64 * word64 = 
				    (x_9122, x_9114)
				 val x_9131: bool = 
				    >_4 x_9130
				 val x_9132: word8 array = 
				    case x_9131 of
				    true => 
				       let
					  val x_9134: word8 array = 
					     raise x_8293
				       in
					  x_9134
				       end
				    false => 
				       let
					  val x_9133: word8 array = 
					     x_8663 x_9122
				       in
					  x_9133
				       end
			      in
				 x_9132
			      end
		     in
			x_9129
		     end
	       val rec 
		  length_17: PrimSequence.Slice.t_1 -> word64 = 
		     fn x_9137: PrimSequence.Slice.t_1 => 
		     let
			val x_9138: word64 = 
			   case x_9137 of
			   T_5 x_9139: word64 * word8 vector * word64 => 
			      let
				 val x_9140: word64 = 
				    #0 x_9139
			      in
				 x_9140
			      end
		     in
			x_9138
		     end
	       val rec 
		  unsafeSub_6: PrimSequence.Slice.t_1 * word64 -> word8 = 
		     fn x_9141: PrimSequence.Slice.t_1 * word64 => 
		     let
			val x_9142: word64 = 
			   #1 x_9141
			val x_9143: PrimSequence.Slice.t_1 = 
			   #0 x_9141
			val x_9144: word8 = 
			   case x_9143 of
			   T_5 x_9145: word64 * word8 vector * word64 => 
			      let
				 val x_9146: word64 = 
				    #2 x_9145
				 val x_9147: word8 vector = 
				    #1 x_9145
				 val x_9148: word64 * word64 = 
				    (x_9146, x_9142)
				 val x_9149: word64 = 
				    +?_1 x_9148
				 val x_9150: word8 vector * word64 = 
				    (x_9147, x_9149)
				 val x_9151: word8 = 
				    x_8689 x_9150
			      in
				 x_9151
			      end
		     in
			x_9144
		     end
	       val rec 
		  full_10: word8 vector -> PrimSequence.Slice.t_1 = 
		     fn x_9152: word8 vector => 
		     let
			val x_9153: word64 = 
			   0x0
			val x_9154: word64 = 
			   x_8686 x_9152
			val x_9155: word64 * word8 vector * word64 = 
			   (x_9154, x_9152, x_9153)
			val x_9156: PrimSequence.Slice.t_1 = 
			   T_5 x_9155
		     in
			x_9156
		     end
	       val rec 
		  sequence_3: PrimSequence.Slice.t_1 -> word8 vector = 
		     fn x_9157: PrimSequence.Slice.t_1 => 
		     let
			val x_9158: word8 vector = 
			   case x_9157 of
			   T_5 x_9159: word64 * word8 vector * word64 => 
			      let
				 val x_9160: word64 = 
				    #2 x_9159
				 val x_9161: word8 vector = 
				    #1 x_9159
				 val x_9162: word64 = 
				    #0 x_9159
				 val x_9163: word64 = 
				    0x0
				 val x_9164: word64 * word64 = 
				    (x_9160, x_9163)
				 val x_9165: bool = 
				    x_8388 x_9164
				 val x_9166: bool = 
				    case x_9165 of
				    true => 
				       let
					  val x_9170: bool = 
					     true
				       in
					  x_9170
				       end
				    false => 
				       let
					  val x_9167: word64 = 
					     x_8686 x_9161
					  val x_9168: word64 * word64 = 
					     (x_9162, x_9167)
					  val x_9169: bool = 
					     x_8388 x_9168
				       in
					  x_9169
				       end
				 val x_9171: word8 vector = 
				    case x_9166 of
				    true => 
				       let
					  val x_9172: word8 vector = 
					     case x_9157 of
					     T_5 x_9173: word64
							 * word8 vector
							 * word64 => 
						let
						   val x_9174: word64 = 
						      #2 x_9173
						   val x_9175: word8 vector = 
						      #1 x_9173
						   val x_9176: word64 = 
						      #0 x_9173
						   val x_9177: unit = 
						      ()
						   val a_13: word8 array = 
						      arrayUninit_1 x_9176
						   val rec 
						      loop_0: word64 * unit
							      -> unit = 
							 fn x_9178: word64
								    * unit => 
							 let
							    val b_13: unit = 
							       #1 x_9178
							    val i_1: word64 = 
							       #0 x_9178
							    val x_9179: word64
									* word64 = 
							       (i_1, x_9176)
							    val x_9180: bool = 
							       >=_2 x_9179
							    val x_9181: unit = 
							       case x_9180 of
							       true => 
								  let
								  in
								     b_13
								  end
							       false => 
								  let
								     val x_9182: word64
										 * word64 = 
									(x_9174,
									 i_1)
								     val x_9183: word64 = 
									+?_1 x_9182
								     val x_9184: word8 vector
										 * word64 = 
									(x_9175,
									 x_9183)
								     val x_9185: word8 = 
									x_8689 x_9184
								     val x_9186: unit = 
									()
								     val x_9187: word8 array
										 * word64
										 * word8 = 
									(a_13,
									 i_1,
									 x_9185)
								     val x_9188: unit = 
									x_8677 x_9187
								     val x_9189: word64 = 
									0x1
								     val x_9190: word64
										 * word64 = 
									(i_1,
									 x_9189)
								     val x_9191: word64 = 
									+?_1 x_9190
								     val x_9192: word64
										 * unit = 
									(x_9191,
									 x_9186)
								     val x_9193: unit = 
									loop_0 x_9192
								  in
								     x_9193
								  end
							 in
							    x_9181
							 end
						   val x_9194: word64 = 
						      0x0
						   val x_9195: word64 * unit = 
						      (x_9194, x_9177)
						   val b_14: unit = 
						      loop_0 x_9195
						   val x_9196: word8 vector = 
						      x_8683 a_13
						in
						   x_9196
						end
				       in
					  x_9172
				       end
				    false => 
				       let
				       in
					  x_9161
				       end
			      in
				 x_9171
			      end
		     in
			x_9158
		     end
	       val isMutable_1: bool = 
		  true
	       val rec 
		  valOf_3: Primitive.Option.t_0 -> word32 = 
		     fn x_9197: Primitive.Option.t_0 => 
		     let
			val x_9198: word32 = 
			   case x_9197 of
			   SOME_0 x_9200: word32 => 
			      let
			      in
				 x_9200
			      end
			   NONE_0 => 
			      let
				 val x_9199: word32 = 
				    0x0
			      in
				 x_9199
			      end
		     in
			x_9198
		     end
	       val x_9201: word32 = 
		  valOf_3 precision_1
	       val x_9202: word32 = 
		  valOf_3 precision_4
	       val x_9203: word32 * word32 = 
		  (x_9202, x_9201)
	       val x_9204: bool = 
		  >=_1 x_9203
	       val x_9205: word64 = 
		  case x_9204 of
		  true => 
		     let
			val x_9206: word64 = 
			   sextdFromInt8ToInt64_0 maxInt'_0
		     in
			x_9206
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val x_9207: word32 = 
		  valOf_3 precision_2
	       val x_9208: word32 = 
		  valOf_3 precision_4
	       val x_9209: word32 * word32 = 
		  (x_9208, x_9207)
	       val x_9210: bool = 
		  >=_1 x_9209
	       val x_9211: word64 = 
		  case x_9210 of
		  true => 
		     let
			val x_9212: word64 = 
			   sextdFromInt16ToInt64_0 maxInt'_1
		     in
			x_9212
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val x_9213: word32 = 
		  valOf_3 precision_3
	       val x_9214: word32 = 
		  valOf_3 precision_4
	       val x_9215: word32 * word32 = 
		  (x_9214, x_9213)
	       val x_9216: bool = 
		  >=_1 x_9215
	       val x_9217: word64 = 
		  case x_9216 of
		  true => 
		     let
			val x_9218: word64 = 
			   sextdFromInt32ToInt64_0 maxInt'_2
		     in
			x_9218
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val x_9219: word32 = 
		  valOf_3 precision_4
	       val x_9220: word32 = 
		  valOf_3 precision_4
	       val x_9221: word32 * word32 = 
		  (x_9220, x_9219)
	       val x_9222: bool = 
		  >=_1 x_9221
	       val x_9223: word64 = 
		  case x_9222 of
		  true => 
		     let
			val x_9224: word64 = 
			   sextdFromInt64ToInt64_0 maxInt'_3
		     in
			x_9224
		     end
		  false => 
		     let
		     in
			maxInt'_3
		     end
	       val rec 
		  full_11: word8 array -> PrimSequence.Slice.t_0 = 
		     fn x_9225: word8 array => 
		     let
			val x_9226: word64 = 
			   0x0
			val x_9227: word64 = 
			   x_8669 x_9225
			val x_9228: word64 * word8 array * word64 = 
			   (x_9227, x_9225, x_9226)
			val x_9229: PrimSequence.Slice.t_0 = 
			   T_4 x_9228
		     in
			x_9229
		     end
	       val rec 
		  subslice_4: PrimSequence.Slice.t_0
			      * word64
			      * Primitive.Option.t_23
			      -> PrimSequence.Slice.t_0 = 
		     fn x_9230: PrimSequence.Slice.t_0
				* word64
				* Primitive.Option.t_23 => 
		     let
			val x_9231: Primitive.Option.t_23 = 
			   #2 x_9230
			val x_9232: word64 = 
			   #1 x_9230
			val x_9233: PrimSequence.Slice.t_0 = 
			   #0 x_9230
			val x_9234: PrimSequence.Slice.t_0 = 
			   case x_9233 of
			   T_4 x_9235: word64 * word8 array * word64 => 
			      let
				 val x_9236: word64 = 
				    #2 x_9235
				 val x_9237: word8 array = 
				    #1 x_9235
				 val x_9238: word64 = 
				    #0 x_9235
				 val x_9239: PrimSequence.Slice.t_0 = 
				    case x_9231 of
				    NONE_21 => 
				       let
					  val x_9255: word64 * word64 = 
					     (x_9232, x_9238)
					  val x_9256: bool = 
					     >_4 x_9255
					  val x_9257: PrimSequence.Slice.t_0 = 
					     case x_9256 of
					     true => 
						let
						   val x_9264: PrimSequence.Slice.t_0 = 
						      raise x_8296
						in
						   x_9264
						end
					     false => 
						let
						   val x_9258: word64 * word64 = 
						      (x_9236, x_9232)
						   val x_9259: word64 = 
						      +?_1 x_9258
						   val x_9260: word64 * word64 = 
						      (x_9238, x_9232)
						   val x_9261: word64 = 
						      -?_1 x_9260
						   val x_9262: word64
							       * word8 array
							       * word64 = 
						      (x_9261, x_9237, x_9259)
						   val x_9263: PrimSequence.Slice.t_0 = 
						      T_4 x_9262
						in
						   x_9263
						end
				       in
					  x_9257
				       end
				    SOME_23 x_9240: word64 => 
				       let
					  val x_9241: word64 * word64 = 
					     (x_9232, x_9238)
					  val x_9242: bool = 
					     >_4 x_9241
					  val x_9243: bool = 
					     case x_9242 of
					     true => 
						let
						   val x_9248: bool = 
						      true
						in
						   x_9248
						end
					     false => 
						let
						   val x_9244: word64 * word64 = 
						      (x_9238, x_9232)
						   val x_9245: word64 = 
						      -?_1 x_9244
						   val x_9246: word64 * word64 = 
						      (x_9240, x_9245)
						   val x_9247: bool = 
						      >_4 x_9246
						in
						   x_9247
						end
					  val x_9249: PrimSequence.Slice.t_0 = 
					     case x_9243 of
					     true => 
						let
						   val x_9254: PrimSequence.Slice.t_0 = 
						      raise x_8296
						in
						   x_9254
						end
					     false => 
						let
						   val x_9250: word64 * word64 = 
						      (x_9236, x_9232)
						   val x_9251: word64 = 
						      +?_1 x_9250
						   val x_9252: word64
							       * word8 array
							       * word64 = 
						      (x_9240, x_9237, x_9251)
						   val x_9253: PrimSequence.Slice.t_0 = 
						      T_4 x_9252
						in
						   x_9253
						end
				       in
					  x_9249
				       end
			      in
				 x_9239
			      end
		     in
			x_9234
		     end
	       val rec 
		  vector_7: PrimSequence.Slice.t_0 -> word8 vector = 
		     fn x_9265: PrimSequence.Slice.t_0 => 
		     let
			val x_9266: word64 = 
			   case x_9265 of
			   T_4 x_9267: word64 * word8 array * word64 => 
			      let
				 val x_9268: word64 = 
				    #0 x_9267
			      in
				 x_9268
			      end
			val x_9269: unit = 
			   ()
			val a_14: word8 array = 
			   arrayUninit_1 x_9266
			val rec 
			   loop_1: word64 * unit -> unit = 
			      fn x_9270: word64 * unit => 
			      let
				 val b_15: unit = 
				    #1 x_9270
				 val i_2: word64 = 
				    #0 x_9270
				 val x_9271: word64 * word64 = 
				    (i_2, x_9266)
				 val x_9272: bool = 
				    >=_2 x_9271
				 val x_9273: unit = 
				    case x_9272 of
				    true => 
				       let
				       in
					  b_15
				       end
				    false => 
				       let
					  val x_9274: word8 = 
					     case x_9265 of
					     T_4 x_9275: word64
							 * word8 array
							 * word64 => 
						let
						   val x_9276: word64 = 
						      #2 x_9275
						   val x_9277: word8 array = 
						      #1 x_9275
						   val x_9278: word64 * word64 = 
						      (x_9276, i_2)
						   val x_9279: word64 = 
						      +?_1 x_9278
						   val x_9280: word8 array
							       * word64 = 
						      (x_9277, x_9279)
						   val x_9281: word8 = 
						      x_8672 x_9280
						in
						   x_9281
						end
					  val x_9282: unit = 
					     ()
					  val x_9283: word8 array
						      * word64
						      * word8 = 
					     (a_14, i_2, x_9274)
					  val x_9284: unit = 
					     x_8677 x_9283
					  val x_9285: word64 = 
					     0x1
					  val x_9286: word64 * word64 = 
					     (i_2, x_9285)
					  val x_9287: word64 = 
					     +?_1 x_9286
					  val x_9288: word64 * unit = 
					     (x_9287, x_9282)
					  val x_9289: unit = 
					     loop_1 x_9288
				       in
					  x_9289
				       end
			      in
				 x_9273
			      end
			val x_9290: word64 = 
			   0x0
			val x_9291: word64 * unit = 
			   (x_9290, x_9269)
			val b_16: unit = 
			   loop_1 x_9291
			val x_9292: word8 vector = 
			   x_8683 a_14
		     in
			x_9292
		     end
	       val zero_6: intInf = 
		  0
	       val rec 
		  isSmall_0: intInf -> bool = 
		     fn x_9293: intInf => 
		     let
			val x_9294: word64 = 
			   0x0
			val x_9295: word64 = 
			   toWord_0 x_9293
			val x_9296: word64 = 
			   0x1
			val x_9297: word64 * word64 = 
			   (x_9295, x_9296)
			val x_9298: word64 = 
			   andb_1 x_9297
			val x_9299: word64 * word64 = 
			   (x_9294, x_9298)
			val x_9300: bool = 
			   x_8388 x_9299
		     in
			x_9300
		     end
	       val rec 
		  areSmall_0: intInf * intInf -> bool = 
		     fn x_9301: intInf * intInf => 
		     let
			val i'_1: intInf = 
			   #1 x_9301
			val i_3: intInf = 
			   #0 x_9301
			val x_9302: word64 = 
			   0x0
			val x_9303: word64 = 
			   toWord_0 i_3
			val x_9304: word64 = 
			   toWord_0 i'_1
			val x_9305: word64 * word64 = 
			   (x_9303, x_9304)
			val x_9306: word64 = 
			   andb_1 x_9305
			val x_9307: word64 = 
			   0x1
			val x_9308: word64 * word64 = 
			   (x_9306, x_9307)
			val x_9309: word64 = 
			   andb_1 x_9308
			val x_9310: word64 * word64 = 
			   (x_9302, x_9309)
			val x_9311: bool = 
			   x_8388 x_9310
		     in
			x_9311
		     end
	       val rec 
		  numLimbs_0: intInf -> word64 = 
		     fn x_9312: intInf => 
		     let
			val x_9313: bool = 
			   isSmall_0 x_9312
			val x_9314: word64 = 
			   case x_9313 of
			   true => 
			      let
				 val x_9320: word64 = 
				    0x1
			      in
				 x_9320
			      end
			   false => 
			      let
				 val x_9315: word64 vector = 
				    IntInf_toVector (x_9312)
				 val x_9316: word64 = 
				    Vector_length[word64] (x_9315)
				 val x_9317: word64 = 
				    0x1
				 val x_9318: word64 * word64 = 
				    (x_9316, x_9317)
				 val x_9319: word64 = 
				    x_8628 x_9318
			      in
				 x_9319
			      end
		     in
			x_9314
		     end
	       val rec 
		  dropTagCoerce_0: intInf -> word64 = 
		     fn x_9321: intInf => 
		     let
			val x_9322: word64 = 
			   toWord_0 x_9321
			val x_9323: word32 = 
			   0x1
			val x_9324: word64 * word32 = 
			   (x_9322, x_9323)
			val x_9325: word64 = 
			   ~>>?_0 x_9324
		     in
			x_9325
		     end
	       val rec 
		  addTag_0: word64 -> word64 = 
		     fn x_9326: word64 => 
		     let
			val x_9327: word32 = 
			   0x1
			val x_9328: word64 * word32 = 
			   (x_9326, x_9327)
			val x_9329: word64 = 
			   <<?_3 x_9328
			val x_9330: word64 = 
			   0x1
			val x_9331: word64 = 
			   Word64_orb (x_9329, x_9330)
		     in
			x_9331
		     end
	       val rec 
		  sextdFromInt64_0: word64 -> intInf = 
		     fn x_9332: word64 => 
		     let
			val x_9333: word64 = 
			   idFromInt64ToWord64_0 x_9332
			val x_9334: word32 * word32 = 
			   (sizeInBits_32, sizeInBits_32)
			val x_9335: bool = 
			   >_0 x_9334
			val x_9336: bool = 
			   case x_9335 of
			   true => 
			      let
				 val x_9346: bool = 
				    true
			      in
				 x_9346
			      end
			   false => 
			      let
				 val x_9337: word32 = 
				    0x2
				 val x_9338: word32 * word32 = 
				    (sizeInBitsWord_3, x_9337)
				 val shift_0: word32 = 
				    -_0 x_9338
				 val x_9339: word64 * word32 = 
				    (x_9333, shift_0)
				 val upperBits_0: word64 = 
				    ~>>?_0 x_9339
				 val oneBits_0: word64 = 
				    notb_3 zero_4
				 val x_9340: word64 * word64 = 
				    (upperBits_0, zero_4)
				 val x_9341: bool = 
				    x_8372 x_9340
				 val x_9342: bool = 
				    case x_9341 of
				    true => 
				       let
					  val x_9345: bool = 
					     true
				       in
					  x_9345
				       end
				    false => 
				       let
					  val x_9343: word64 * word64 = 
					     (upperBits_0, oneBits_0)
					  val x_9344: bool = 
					     x_8372 x_9343
				       in
					  x_9344
				       end
			      in
				 x_9342
			      end
			val x_9347: intInf = 
			   case x_9336 of
			   true => 
			      let
				 val x_9400: word64 = 
				    addTag_0 x_9333
				 val x_9401: intInf = 
				    fromWord_0 x_9400
			      in
				 x_9401
			      end
			   false => 
			      let
				 val rec 
				    loop_2: word64 * word64 * list_13
					    -> word64 * list_13 = 
				       fn x_9348: word64 * word64 * list_13 => 
				       let
					  val acc_0: list_13 = 
					     #2 x_9348
					  val i_4: word64 = 
					     #1 x_9348
					  val w_8: word64 = 
					     #0 x_9348
					  val x_9349: word64 * word64 = 
					     (w_8, zero_4)
					  val x_9350: bool = 
					     x_8372 x_9349
					  val x_9351: word64 * list_13 = 
					     case x_9350 of
					     true => 
						let
						   val x_9361: word64 * list_13 = 
						      (i_4, acc_0)
						in
						   x_9361
						end
					     false => 
						let
						   val x_9352: word64 * word32 = 
						      (w_8, sizeInBitsWord_3)
						   val w_9: word64 = 
						      >>?_3 x_9352
						   val x_9353: word64 = 
						      0x1
						   val x_9354: word64 * word64 = 
						      (i_4, x_9353)
						   val x_9355: word64 = 
						      x_8588 x_9354
						   val x_9356: word64 * word64 = 
						      (i_4, w_8)
						   val x_9357: (word64 * word64)
							       * list_13 = 
						      (x_9356, acc_0)
						   val x_9358: list_13 = 
						      ::_13 x_9357
						   val x_9359: word64
							       * word64
							       * list_13 = 
						      (w_9, x_9355, x_9358)
						   val x_9360: word64 * list_13 = 
						      loop_2 x_9359
						in
						   x_9360
						end
				       in
					  x_9351
				       end
				 val x_9362: word64 = 
				    idFromWord64ToInt64_0 x_9333
				 val x_9363: word64 = 
				    0x0
				 val x_9364: word64 * word64 = 
				    (x_9362, x_9363)
				 val x_9365: bool = 
				    <_2 x_9364
				 val x_9366: word64 * list_13 = 
				    case x_9365 of
				    true => 
				       let
					  val x_9376: word64 = 
					     Word64_neg (x_9333)
					  val x_9377: word64 = 
					     0x1
					  val x_9378: list_13 = 
					     nil_13
					  val x_9379: word64 = 
					     0x0
					  val x_9380: word64 = 
					     0x1
					  val x_9381: word64 * word64 = 
					     (x_9379, x_9380)
					  val x_9382: (word64 * word64)
						      * list_13 = 
					     (x_9381, x_9378)
					  val x_9383: list_13 = 
					     ::_13 x_9382
					  val x_9384: word64 * word64 * list_13 = 
					     (x_9376, x_9377, x_9383)
					  val x_9385: word64 * list_13 = 
					     loop_2 x_9384
				       in
					  x_9385
				       end
				    false => 
				       let
					  val x_9367: word64 = 
					     0x1
					  val x_9368: list_13 = 
					     nil_13
					  val x_9369: word64 = 
					     0x0
					  val x_9370: word64 = 
					     0x0
					  val x_9371: word64 * word64 = 
					     (x_9369, x_9370)
					  val x_9372: (word64 * word64)
						      * list_13 = 
					     (x_9371, x_9368)
					  val x_9373: list_13 = 
					     ::_13 x_9372
					  val x_9374: word64 * word64 * list_13 = 
					     (x_9333, x_9367, x_9373)
					  val x_9375: word64 * list_13 = 
					     loop_2 x_9374
				       in
					  x_9375
				       end
				 val acc_1: list_13 = 
				    #1 x_9366
				 val n_0: word64 = 
				    #0 x_9366
				 val x_9386: word64 array = 
				    Array_array[word64] (n_0)
				 val rec 
				    loop_3: list_13 -> unit = 
				       fn x_9387: list_13 => 
				       let
					  val x_9388: unit = 
					     case x_9387 of
					     nil_13 => 
						let
						   val x_9396: unit = 
						      ()
						in
						   x_9396
						end
					     ::_13 x_9389: (word64 * word64)
							   * list_13 => 
						let
						   val x_9390: list_13 = 
						      #1 x_9389
						   val x_9391: word64 * word64 = 
						      #0 x_9389
						   val x_9392: word64 = 
						      #1 x_9391
						   val x_9393: word64 = 
						      #0 x_9391
						   val x_9394: unit = 
						      Array_update[word64] (x_9386,
									    x_9393,
									    x_9392)
						   val x_9395: unit = 
						      loop_3 x_9390
						in
						   x_9395
						end
				       in
					  x_9388
				       end
				 val x_9397: unit = 
				    loop_3 acc_1
				 val x_9398: word64 vector = 
				    Array_toVector[word64] (x_9386)
				 val x_9399: intInf = 
				    WordVector_toIntInf (x_9398)
			      in
				 x_9399
			      end
		     in
			x_9347
		     end
	       val x_9402: word32 = 
		  0x8
	       val x_9403: word32 * word32 = 
		  (sizeInBits_32, x_9402)
	       val x_9404: word32 = 
		  quot_0 x_9403
	       val bytesPerMPLimb_0: word64 = 
		  zextdFromInt32ToWord64_0 x_9404
	       val x_9405: word32 = 
		  0x8
	       val x_9406: word32 * word32 = 
		  (sizeInBits_65, x_9405)
	       val x_9407: word32 = 
		  quot_0 x_9406
	       val bytesPerCounter_0: word64 = 
		  zextdFromInt32ToWord64_0 x_9407
	       val x_9408: word32 = 
		  0x8
	       val x_9409: word32 * word32 = 
		  (sizeInBits_65, x_9408)
	       val x_9410: word32 = 
		  quot_0 x_9409
	       val bytesPerLength_0: word64 = 
		  zextdFromInt32ToWord64_0 x_9410
	       val x_9411: word32 = 
		  0x8
	       val x_9412: word32 * word32 = 
		  (sizeInBits_32, x_9411)
	       val x_9413: word32 = 
		  quot_0 x_9412
	       val bytesPerHeader_0: word64 = 
		  zextdFromInt32ToWord64_0 x_9413
	       val x_9414: word64 * word64 = 
		  (bytesPerLength_0, bytesPerHeader_0)
	       val x_9415: word64 = 
		  +_0 x_9414
	       val x_9416: word64 * word64 = 
		  (bytesPerCounter_0, x_9415)
	       val bytesPerArrayHeader_0: word64 = 
		  +_0 x_9416
	       val rec 
		  reserve_0: word64 * word64 -> word64 = 
		     fn x_9417: word64 * word64 => 
		     let
			val extra_0: word64 = 
			   #1 x_9417
			val num_0: word64 = 
			   #0 x_9417
			val x_9418: word64 = 
			   zextdFromInt64ToWord64_0 num_0
			val x_9419: word64 * word64 = 
			   (bytesPerMPLimb_0, x_9418)
			val x_9420: word64 = 
			   *_0 x_9419
			val x_9421: word64 = 
			   zextdFromInt64ToWord64_0 extra_0
			val x_9422: word64 * word64 = 
			   (bytesPerMPLimb_0, x_9421)
			val x_9423: word64 = 
			   *_0 x_9422
			val x_9424: word64 = 
			   0x7
			val x_9425: word64 * word64 = 
			   (bytesPerArrayHeader_0, x_9424)
			val x_9426: word64 = 
			   +_0 x_9425
			val x_9427: word64 * word64 = 
			   (bytesPerMPLimb_0, x_9426)
			val x_9428: word64 = 
			   +_0 x_9427
			val x_9429: word64 * word64 = 
			   (x_9423, x_9428)
			val x_9430: word64 = 
			   +_0 x_9429
			val x_9431: word64 * word64 = 
			   (x_9420, x_9430)
			val x_9432: word64 = 
			   +_0 x_9431
		     in
			x_9432
		     end
	       val x_9433: word32 = 
		  0x1
	       val x_9434: word64 = 
		  idFromInt64ToWord64_0 minInt'_3
	       val x_9435: word64 * word32 = 
		  (x_9434, x_9433)
	       val x_9436: word64 = 
		  ~>>?_0 x_9435
	       val x_9437: word64 = 
		  idFromWord64ToInt64_0 x_9436
	       val badObjptrWord_0: word64 = 
		  zextdFromInt64ToWord64_0 x_9437
	       val badObjptrWordTagged_0: word64 = 
		  addTag_0 badObjptrWord_0
	       val x_9438: word64 = 
		  x_8610 x_9437
	       val negBadIntInf_0: intInf = 
		  sextdFromInt64_0 x_9438
	       val x_9439: word64 = 
		  0x0
	       val rec 
		  mkBigCvt_0: word32 * (word64 -> word8 vector)
			      -> intInf -> word8 vector = 
		     fn x_9440: word32 * (word64 -> word8 vector) => 
		     let
			val x_9441: intInf -> word8 vector = 
			   fn x_9442: intInf => 
			   let
			      val x_9443: word64 -> word8 vector = 
				 #1 x_9440
			      val x_9444: word32 = 
				 #0 x_9440
			      val x_9445: bool = 
				 isSmall_0 x_9442
			      val x_9446: word8 vector = 
				 case x_9445 of
				 true => 
				    let
				       val x_9547: word64 = 
					  dropTagCoerce_0 x_9442
				       val x_9548: word64 = 
					  zextdFromWord64ToInt64_0 x_9547
				       val x_9549: word8 vector = 
					  x_9443 x_9548
				    in
				       x_9549
				    end
				 false => 
				    let
				       val x_9447: word32 = 
					  idFromInt32ToWord32_0 x_9444
				       val rec 
					  loop_4: word32 * word32 * word32
						  -> word32 = 
					     fn x_9448: word32 * word32 * word32 => 
					     let
						val acc_2: word32 = 
						   #2 x_9448
						val s_0: word32 = 
						   #1 x_9448
						val n_1: word32 = 
						   #0 x_9448
						val x_9449: word32 * word32 = 
						   (n_1, one_2)
						val x_9450: bool = 
						   x_8367 x_9449
						val x_9451: word32 = 
						   case x_9450 of
						   true => 
						      let
						      in
							 acc_2
						      end
						   false => 
						      let
							 val x_9452: word32
								     * word32 = 
							    (one_2, s_0)
							 val x_9453: word32 = 
							    <<?_2 x_9452
							 val x_9454: word32
								     * word32 = 
							    (n_1, x_9453)
							 val x_9455: bool = 
							    >=_0 x_9454
							 val x_9456: word32
								     * word32 = 
							    case x_9455 of
							    true => 
							       let
								  val x_9458: word32
									      * word32 = 
								     (n_1, s_0)
								  val x_9459: word32 = 
								     >>?_2 x_9458
								  val x_9460: word32 = 
								     Word32_add (acc_2,
										 s_0)
								  val x_9461: word32
									      * word32 = 
								     (x_9459,
								      x_9460)
							       in
								  x_9461
							       end
							    false => 
							       let
								  val x_9457: word32
									      * word32 = 
								     (n_1, acc_2)
							       in
								  x_9457
							       end
							 val acc_3: word32 = 
							    #1 x_9456
							 val n_2: word32 = 
							    #0 x_9456
							 val x_9462: word32 = 
							    0x1
							 val x_9463: word32
								     * word32 = 
							    (s_0, x_9462)
							 val x_9464: word32 = 
							    >>?_2 x_9463
							 val x_9465: word32
								     * word32
								     * word32 = 
							    (n_2, x_9464, acc_3)
							 val x_9466: word32 = 
							    loop_4 x_9465
						      in
							 x_9466
						      end
					     in
						x_9451
					     end
				       val x_9467: word32 * word32 = 
					  (x_9447, zero_2)
				       val x_9468: bool = 
					  x_8367 x_9467
				       val x_9469: word32 = 
					  case x_9468 of
					  true => 
					     let
						val x_9476: word32 = 
						   raise x_8285
					     in
						x_9476
					     end
					  false => 
					     let
						val x_9470: word32 = 
						   0x1
						val x_9471: word32 * word32 = 
						   (sizeInBitsWord_2, x_9470)
						val x_9472: word32 = 
						   >>?_2 x_9471
						val x_9473: word32 = 
						   0x0
						val x_9474: word32
							    * word32
							    * word32 = 
						   (x_9447, x_9472, x_9473)
						val x_9475: word32 = 
						   loop_4 x_9474
					     in
						x_9475
					     end
				       val x_9477: word32 * word32 = 
					  (sizeInBits_32, x_9469)
				       val x_9478: word32 = 
					  quot_0 x_9477
				       val x_9479: word32 * word32 = 
					  (sizeInBits_32, zero_3)
				       val x_9480: bool = 
					  >=_1 x_9479
				       val x_9481: word32 = 
					  case x_9480 of
					  true => 
					     let
						val x_9507: word32 * word32 = 
						   (x_9469, zero_3)
						val x_9508: bool = 
						   >_0 x_9507
						val x_9509: word32 = 
						   case x_9508 of
						   true => 
						      let
							 val x_9525: word32
								     * word32 = 
							    (sizeInBits_32,
							     x_9469)
							 val x_9526: word32 = 
							    remUnsafe_0 x_9525
						      in
							 x_9526
						      end
						   false => 
						      let
							 val x_9510: word32
								     * word32 = 
							    (x_9469, zero_3)
							 val x_9511: bool = 
							    <_1 x_9510
							 val x_9512: word32 = 
							    case x_9511 of
							    true => 
							       let
								  val x_9514: word32
									      * word32 = 
								     (sizeInBits_32,
								      zero_3)
								  val x_9515: bool = 
								     x_8367 x_9514
								  val x_9516: word32 = 
								     case x_9515 of
								     true => 
									let
									in
									   zero_3
									end
								     false => 
									let
									   val x_9517: word32
										       * word32 = 
									      (sizeInBits_32,
									       one_3)
									   val x_9518: word32 = 
									      -?_0 x_9517
									   val x_9519: word32
										       * word32 = 
									      (x_9518,
									       x_9469)
									   val x_9520: word32 = 
									      remUnsafe_0 x_9519
									   val x_9521: word32
										       * word32 = 
									      (x_9469,
									       one_3)
									   val x_9522: word32 = 
									      x_8508 x_9521
									   val x_9523: word32
										       * word32 = 
									      (x_9520,
									       x_9522)
									   val x_9524: word32 = 
									      +?_0 x_9523
									in
									   x_9524
									end
							       in
								  x_9516
							       end
							    false => 
							       let
								  val x_9513: word32 = 
								     raise x_8282
							       in
								  x_9513
							       end
						      in
							 x_9512
						      end
					     in
						x_9509
					     end
					  false => 
					     let
						val x_9482: word32 * word32 = 
						   (x_9469, zero_3)
						val x_9483: bool = 
						   <_1 x_9482
						val x_9484: word32 = 
						   case x_9483 of
						   true => 
						      let
							 val x_9497: word32
								     * word32 = 
							    (sizeInBits_32,
							     minInt'_2)
							 val x_9498: bool = 
							    x_8367 x_9497
							 val x_9499: bool = 
							    case x_9498 of
							    true => 
							       let
								  val x_9501: word32 = 
								     x_8530 one_3
								  val x_9502: word32
									      * word32 = 
								     (x_9469,
								      x_9501)
								  val x_9503: bool = 
								     x_8367 x_9502
							       in
								  x_9503
							       end
							    false => 
							       let
								  val x_9500: bool = 
								     false
							       in
								  x_9500
							       end
							 val x_9504: word32 = 
							    case x_9499 of
							    true => 
							       let
							       in
								  zero_3
							       end
							    false => 
							       let
								  val x_9505: word32
									      * word32 = 
								     (sizeInBits_32,
								      x_9469)
								  val x_9506: word32 = 
								     remUnsafe_0 x_9505
							       in
								  x_9506
							       end
						      in
							 x_9504
						      end
						   false => 
						      let
							 val x_9485: word32
								     * word32 = 
							    (x_9469, zero_3)
							 val x_9486: bool = 
							    >_0 x_9485
							 val x_9487: word32 = 
							    case x_9486 of
							    true => 
							       let
								  val x_9489: word32
									      * word32 = 
								     (sizeInBits_32,
								      one_3)
								  val x_9490: word32 = 
								     +?_0 x_9489
								  val x_9491: word32
									      * word32 = 
								     (x_9490,
								      x_9469)
								  val x_9492: word32 = 
								     remUnsafe_0 x_9491
								  val x_9493: word32
									      * word32 = 
								     (x_9469,
								      one_3)
								  val x_9494: word32 = 
								     -?_0 x_9493
								  val x_9495: word32
									      * word32 = 
								     (x_9492,
								      x_9494)
								  val x_9496: word32 = 
								     +?_0 x_9495
							       in
								  x_9496
							       end
							    false => 
							       let
								  val x_9488: word32 = 
								     raise x_8282
							       in
								  x_9488
							       end
						      in
							 x_9487
						      end
					     in
						x_9484
					     end
				       val x_9527: word32 = 
					  0x0
				       val x_9528: word32 * word32 = 
					  (x_9481, x_9527)
				       val x_9529: bool = 
					  x_8367 x_9528
				       val x_9530: word32 = 
					  case x_9529 of
					  true => 
					     let
						val x_9532: word32 = 
						   0x0
					     in
						x_9532
					     end
					  false => 
					     let
						val x_9531: word32 = 
						   0x1
					     in
						x_9531
					     end
				       val x_9533: word32 * word32 = 
					  (x_9478, x_9530)
				       val dpl_0: word32 = 
					  x_8508 x_9533
				       val x_9534: word64 = 
					  0x1
				       val x_9535: word64 = 
					  0x7
				       val x_9536: word64 * word64 = 
					  (x_9534, x_9535)
				       val x_9537: word64 = 
					  +_0 x_9536
				       val x_9538: word64 * word64 = 
					  (bytesPerArrayHeader_0, x_9537)
				       val x_9539: word64 = 
					  +_0 x_9538
				       val x_9540: word64 = 
					  zextdFromInt32ToWord64_0 dpl_0
				       val x_9541: word64 = 
					  numLimbs_0 x_9442
				       val x_9542: word64 = 
					  zextdFromInt64ToWord64_0 x_9541
				       val x_9543: word64 * word64 = 
					  (x_9540, x_9542)
				       val x_9544: word64 = 
					  *_0 x_9543
				       val x_9545: word64 * word64 = 
					  (x_9539, x_9544)
				       val bytes_0: word64 = 
					  +_0 x_9545
				       val x_9546: word8 vector = 
					  IntInf_toString (x_9442,
							   x_9444,
							   bytes_0)
				    in
				       x_9546
				    end
			   in
			      x_9446
			   end
		     in
			x_9441
		     end
	       val x_9550: unit = 
		  ()
	       val x_9551: unit ref = 
		  Ref_ref[unit] (x_9550)
	       val x_9552: exn = 
		  Chr_0 x_9551
	       val x_9553: unit = 
		  ()
	       val x_9554: unit ref = 
		  Ref_ref[unit] (x_9553)
	       val rec 
		  before_2: MLtonThread.thread_0 * unit -> MLtonThread.thread_0 = 
		     fn x_9555: MLtonThread.thread_0 * unit => 
		     let
			val x_9556: MLtonThread.thread_0 = 
			   #0 x_9555
		     in
			x_9556
		     end
	       val x_9557: list_0 = 
		  nil_0
	       val messagers_0: list_0 ref = 
		  Ref_ref[list_0] (x_9557)
	       val rec 
		  exnMessage_0: exn -> word8 vector = 
		     fn x_9558: exn => 
		     let
			val rec 
			   find_1: list_0 -> word8 vector = 
			      fn x_9559: list_0 => 
			      let
				 val x_9560: word8 vector = 
				    case x_9559 of
				    nil_0 => 
				       let
					  val x_9568: word8 vector = 
					     name_0 x_9558
				       in
					  x_9568
				       end
				    ::_0 x_9561: (exn -> Primitive.Option.t_1)
						 * list_0 => 
				       let
					  val x_9562: list_0 = 
					     #1 x_9561
					  val x_9563: exn
						      -> Primitive.Option.t_1 = 
					     #0 x_9561
					  val x_9564: Primitive.Option.t_1 = 
					     x_9563 x_9558
					  val x_9565: word8 vector = 
					     case x_9564 of
					     NONE_1 => 
						let
						   val x_9567: word8 vector = 
						      find_1 x_9562
						in
						   x_9567
						end
					     SOME_1 x_9566: word8 vector => 
						let
						in
						   x_9566
						end
				       in
					  x_9565
				       end
			      in
				 x_9560
			      end
			val x_9569: list_0 = 
			   x_8318 messagers_0
			val x_9570: word8 vector = 
			   find_1 x_9569
		     in
			x_9570
		     end
	       val x_9571: unit = 
		  ()
	       val x_9572: unit ref = 
		  Ref_ref[unit] (x_9571)
	       val x_9573: exn = 
		  Option_0 x_9572
	       val rec 
		  base_12: PrimSequence.Slice.t_1
			   -> word8 vector * word32 * word32 = 
		     fn x_9574: PrimSequence.Slice.t_1 => 
		     let
			val x_9575: word8 vector * word64 * word64 = 
			   case x_9574 of
			   T_5 x_9576: word64 * word8 vector * word64 => 
			      let
				 val x_9577: word64 = 
				    #2 x_9576
				 val x_9578: word8 vector = 
				    #1 x_9576
				 val x_9579: word64 = 
				    #0 x_9576
				 val x_9580: word8 vector * word64 * word64 = 
				    (x_9578, x_9577, x_9579)
			      in
				 x_9580
			      end
			val len_0: word64 = 
			   #2 x_9575
			val start_0: word64 = 
			   #1 x_9575
			val seq_0: word8 vector = 
			   #0 x_9575
			val x_9581: word8 vector * word32 * word32 = 
			   let
			      val x_9582: word32 = 
				 x_8890 start_0
			      val x_9583: word32 = 
				 x_8890 len_0
			      val x_9584: word8 vector * word32 * word32 = 
				 (seq_0, x_9582, x_9583)
			   in
			      x_9584
			   end
			   handle x_9585 => let
					       val x_9586: unit
							   -> word8 vector
							      * word32
							      * word32 = 
						  fn unit_7: unit => 
						  let
						     val x_9587: word8 vector
								 * word32
								 * word32 = 
							raise x_9585
						  in
						     x_9587
						  end
					       val x_9588: word8 vector
							   * word32
							   * word32 = 
						  case x_9585 of
						  Overflow_0 x_9589: unit ref => 
						     let
							val x_9590: bool = 
							   MLton_equal[unit ref] (x_9589,
										  x_8289)
							val x_9591: word8 vector
								    * word32
								    * word32 = 
							   case x_9590 of
							   true => 
							      let
								 val x_9594: word8 vector = 
								    "Sequence.Slice.base"
								 val x_9595: unit ref
									     * word8 vector = 
								    (x_9554,
								     x_9594)
								 val x_9596: exn = 
								    Fail_0 x_9595
								 val x_9597: word8 vector
									     * word32
									     * word32 = 
								    raise x_9596
							      in
								 x_9597
							      end
							   false => 
							      let
								 val x_9592: unit = 
								    ()
								 val x_9593: word8 vector
									     * word32
									     * word32 = 
								    x_9586 x_9592
							      in
								 x_9593
							      end
						     in
							x_9591
						     end
						    _ => let
							    val x_9598: unit = 
							       ()
							    val x_9599: word8 vector
									* word32
									* word32 = 
							       x_9586 x_9598
							 in
							    x_9599
							 end
					    in
					       x_9588
					    end
		     in
			x_9581
		     end
	       val rec 
		  concat_3: list_7 -> word8 vector = 
		     fn x_9600: list_7 => 
		     let
			val x_9601: list_12 = 
			   nil_12
			val rec 
			   loop_5: list_7 * list_12 -> list_12 = 
			      fn x_9602: list_7 * list_12 => 
			      let
				 val b_17: list_12 = 
				    #1 x_9602
				 val l_0: list_7 = 
				    #0 x_9602
				 val x_9603: list_12 = 
				    case l_0 of
				    nil_7 => 
				       let
				       in
					  b_17
				       end
				    ::_7 x_9604: word8 vector * list_7 => 
				       let
					  val x_9605: list_7 = 
					     #1 x_9604
					  val x_9606: word8 vector = 
					     #0 x_9604
					  val x_9607: PrimSequence.Slice.t_1 = 
					     full_10 x_9606
					  val x_9608: PrimSequence.Slice.t_1
						      * list_12 = 
					     (x_9607, b_17)
					  val x_9609: list_12 = 
					     ::_12 x_9608
					  val x_9610: list_7 * list_12 = 
					     (x_9605, x_9609)
					  val x_9611: list_12 = 
					     loop_5 x_9610
				       in
					  x_9611
				       end
			      in
				 x_9603
			      end
			val x_9612: list_7 * list_12 = 
			   (x_9600, x_9601)
			val x_9613: list_12 = 
			   loop_5 x_9612
			val x_9614: list_12 = 
			   nil_12
			val rec 
			   loop_6: list_12 * list_12 -> list_12 = 
			      fn x_9615: list_12 * list_12 => 
			      let
				 val b_18: list_12 = 
				    #1 x_9615
				 val l_1: list_12 = 
				    #0 x_9615
				 val x_9616: list_12 = 
				    case l_1 of
				    nil_12 => 
				       let
				       in
					  b_18
				       end
				    ::_12 x_9617: PrimSequence.Slice.t_1
						  * list_12 => 
				       let
					  val x_9618: list_12 = 
					     #1 x_9617
					  val x_9619: PrimSequence.Slice.t_1 = 
					     #0 x_9617
					  val x_9620: PrimSequence.Slice.t_1
						      * list_12 = 
					     (x_9619, b_18)
					  val x_9621: list_12 = 
					     ::_12 x_9620
					  val x_9622: list_12 * list_12 = 
					     (x_9618, x_9621)
					  val x_9623: list_12 = 
					     loop_6 x_9622
				       in
					  x_9623
				       end
			      in
				 x_9616
			      end
			val x_9624: list_12 * list_12 = 
			   (x_9613, x_9614)
			val x_9625: list_12 = 
			   loop_6 x_9624
			val x_9626: word8 vector = 
			   case x_9625 of
			   nil_12 => 
			      let
				 val x_9699: word32 = 
				    0x0
				 val x_9700: unit = 
				    ()
				 val x_9701: word64 = 
				    let
				       val x_9702: word64 = 
					  sextdFromInt32ToInt64_0 x_9699
				    in
				       x_9702
				    end
				    handle x_9703 => let
							val x_9704: unit
								    -> word64 = 
							   fn unit_9: unit => 
							   let
							      val x_9705: word64 = 
								 raise x_9703
							   in
							      x_9705
							   end
							val x_9706: word64 = 
							   case x_9703 of
							   Overflow_0 x_9707: unit ref => 
							      let
								 val x_9708: bool = 
								    MLton_equal[unit ref] (x_9707,
											   x_8289)
								 val x_9709: word64 = 
								    case x_9708 of
								    true => 
								       let
									  val x_9712: word64 = 
									     raise x_8293
								       in
									  x_9712
								       end
								    false => 
								       let
									  val x_9710: unit = 
									     ()
									  val x_9711: word64 = 
									     x_9704 x_9710
								       in
									  x_9711
								       end
							      in
								 x_9709
							      end
							     _ => let
								     val x_9713: unit = 
									()
								     val x_9714: word64 = 
									x_9704 x_9713
								  in
								     x_9714
								  end
						     in
							x_9706
						     end
				 val a_16: word8 array = 
				    arrayUninit_1 x_9701
				 val rec 
				    loop_10: word64 * unit -> unit = 
				       fn x_9715: word64 * unit => 
				       let
					  val b_23: unit = 
					     #1 x_9715
					  val i_7: word64 = 
					     #0 x_9715
					  val x_9716: word64 * word64 = 
					     (i_7, x_9701)
					  val x_9717: bool = 
					     >=_2 x_9716
					  val x_9718: unit = 
					     case x_9717 of
					     true => 
						let
						in
						   b_23
						end
					     false => 
						let
						   val x_9719: word8 vector = 
						      "Sequence.seq0"
						   val x_9720: unit ref
							       * word8 vector = 
						      (x_9554, x_9719)
						   val x_9721: exn = 
						      Fail_0 x_9720
						   val x_9722: word8 * unit = 
						      raise x_9721
						   val b_24: unit = 
						      #1 x_9722
						   val x_9723: word8 = 
						      #0 x_9722
						   val x_9724: word8 array
							       * word64
							       * word8 = 
						      (a_16, i_7, x_9723)
						   val x_9725: unit = 
						      x_8677 x_9724
						   val x_9726: word64 = 
						      0x1
						   val x_9727: word64 * word64 = 
						      (i_7, x_9726)
						   val x_9728: word64 = 
						      +?_1 x_9727
						   val x_9729: word64 * unit = 
						      (x_9728, b_24)
						   val x_9730: unit = 
						      loop_10 x_9729
						in
						   x_9730
						end
				       in
					  x_9718
				       end
				 val x_9731: word64 = 
				    0x0
				 val x_9732: word64 * unit = 
				    (x_9731, x_9700)
				 val b_25: unit = 
				    loop_10 x_9732
				 val x_9733: word8 vector = 
				    x_8683 a_16
			      in
				 x_9733
			      end
			   ::_12 x_9627: PrimSequence.Slice.t_1 * list_12 => 
			      let
				 val x_9628: list_12 = 
				    #1 x_9627
				 val x_9629: PrimSequence.Slice.t_1 = 
				    #0 x_9627
				 val x_9630: word8 vector = 
				    case x_9628 of
				    nil_12 => 
				       let
					  val x_9631: word8 vector = 
					     sequence_3 x_9629
				       in
					  x_9631
				       end
				      _ => let
					      val x_9632: word64 = 
						 0x0
					      val rec 
						 loop_7: list_12 * word64
							 -> word64 = 
						    fn x_9633: list_12 * word64 => 
						    let
						       val b_19: word64 = 
							  #1 x_9633
						       val l_2: list_12 = 
							  #0 x_9633
						       val x_9634: word64 = 
							  case l_2 of
							  nil_12 => 
							     let
							     in
								b_19
							     end
							  ::_12 x_9635: PrimSequence.Slice.t_1
									* list_12 => 
							     let
								val x_9636: list_12 = 
								   #1 x_9635
								val x_9637: PrimSequence.Slice.t_1 = 
								   #0 x_9635
								val x_9638: word64 = 
								   let
								      val x_9639: word64 = 
									 length_17 x_9637
								      val x_9640: word64
										  * word64 = 
									 (b_19,
									  x_9639)
								      val x_9641: word64 = 
									 x_8588 x_9640
								   in
								      x_9641
								   end
								   handle x_9642 => let
										       val x_9643: unit
												   -> word64 = 
											  fn unit_8: unit => 
											  let
											     val x_9644: word64 = 
												raise x_9642
											  in
											     x_9644
											  end
										       val x_9645: word64 = 
											  case x_9642 of
											  Overflow_0 x_9646: unit ref => 
											     let
												val x_9647: bool = 
												   MLton_equal[unit ref] (x_9646,
															  x_8289)
												val x_9648: word64 = 
												   case x_9647 of
												   true => 
												      let
													 val x_9651: word64 = 
													    raise x_8293
												      in
													 x_9651
												      end
												   false => 
												      let
													 val x_9649: unit = 
													    ()
													 val x_9650: word64 = 
													    x_9643 x_9649
												      in
													 x_9650
												      end
											     in
												x_9648
											     end
											    _ => let
												    val x_9652: unit = 
												       ()
												    val x_9653: word64 = 
												       x_9643 x_9652
												 in
												    x_9653
												 end
										    in
										       x_9645
										    end
								val x_9654: list_12
									    * word64 = 
								   (x_9636,
								    x_9638)
								val x_9655: word64 = 
								   loop_7 x_9654
							     in
								x_9655
							     end
						    in
						       x_9634
						    end
					      val x_9656: list_12 * word64 = 
						 (x_9625, x_9632)
					      val x_9657: word64 = 
						 loop_7 x_9656
					      val rec 
						 loop_8: word64
							 * PrimSequence.Slice.t_1
							 * list_12
							 -> word8
							    * (word64
							       * PrimSequence.Slice.t_1
							       * list_12) = 
						    fn x_9658: word64
							       * PrimSequence.Slice.t_1
							       * list_12 => 
						    let
						       val sls_0: list_12 = 
							  #2 x_9658
						       val sl_0: PrimSequence.Slice.t_1 = 
							  #1 x_9658
						       val i_5: word64 = 
							  #0 x_9658
						       val x_9659: word64 = 
							  length_17 sl_0
						       val x_9660: word64
								   * word64 = 
							  (i_5, x_9659)
						       val x_9661: bool = 
							  <_2 x_9660
						       val x_9662: word8
								   * (word64
								      * PrimSequence.Slice.t_1
								      * list_12) = 
							  case x_9661 of
							  true => 
							     let
								val x_9674: PrimSequence.Slice.t_1
									    * word64 = 
								   (sl_0, i_5)
								val x_9675: word8 = 
								   unsafeSub_6 x_9674
								val x_9676: word64 = 
								   0x1
								val x_9677: word64
									    * word64 = 
								   (i_5, x_9676)
								val x_9678: word64 = 
								   +?_1 x_9677
								val x_9679: word64
									    * PrimSequence.Slice.t_1
									    * list_12 = 
								   (x_9678,
								    sl_0,
								    sls_0)
								val x_9680: word8
									    * (word64
									       * PrimSequence.Slice.t_1
									       * list_12) = 
								   (x_9675,
								    x_9679)
							     in
								x_9680
							     end
							  false => 
							     let
								val x_9663: word8
									    * (word64
									       * PrimSequence.Slice.t_1
									       * list_12) = 
								   case sls_0 of
								   nil_12 => 
								      let
									 val x_9670: word8 vector = 
									    "Sequence.Slice.concat"
									 val x_9671: unit ref
										     * word8 vector = 
									    (x_9554,
									     x_9670)
									 val x_9672: exn = 
									    Fail_0 x_9671
									 val x_9673: word8
										     * (word64
											* PrimSequence.Slice.t_1
											* list_12) = 
									    raise x_9672
								      in
									 x_9673
								      end
								   ::_12 x_9664: PrimSequence.Slice.t_1
										 * list_12 => 
								      let
									 val x_9665: list_12 = 
									    #1 x_9664
									 val x_9666: PrimSequence.Slice.t_1 = 
									    #0 x_9664
									 val x_9667: word64 = 
									    0x0
									 val x_9668: word64
										     * PrimSequence.Slice.t_1
										     * list_12 = 
									    (x_9667,
									     x_9666,
									     x_9665)
									 val x_9669: word8
										     * (word64
											* PrimSequence.Slice.t_1
											* list_12) = 
									    loop_8 x_9668
								      in
									 x_9669
								      end
							     in
								x_9663
							     end
						    in
						       x_9662
						    end
					      val x_9681: word64 = 
						 0x0
					      val x_9682: word64
							  * PrimSequence.Slice.t_1
							  * list_12 = 
						 (x_9681, x_9629, x_9628)
					      val a_15: word8 array = 
						 arrayUninit_1 x_9657
					      val rec 
						 loop_9: word64
							 * (word64
							    * PrimSequence.Slice.t_1
							    * list_12)
							 -> word64
							    * PrimSequence.Slice.t_1
							    * list_12 = 
						    fn x_9683: word64
							       * (word64
								  * PrimSequence.Slice.t_1
								  * list_12) => 
						    let
						       val b_20: word64
								 * PrimSequence.Slice.t_1
								 * list_12 = 
							  #1 x_9683
						       val i_6: word64 = 
							  #0 x_9683
						       val x_9684: word64
								   * word64 = 
							  (i_6, x_9657)
						       val x_9685: bool = 
							  >=_2 x_9684
						       val x_9686: word64
								   * PrimSequence.Slice.t_1
								   * list_12 = 
							  case x_9685 of
							  true => 
							     let
							     in
								b_20
							     end
							  false => 
							     let
								val x_9687: word8
									    * (word64
									       * PrimSequence.Slice.t_1
									       * list_12) = 
								   loop_8 b_20
								val b_21: word64
									  * PrimSequence.Slice.t_1
									  * list_12 = 
								   #1 x_9687
								val x_9688: word8 = 
								   #0 x_9687
								val x_9689: word8 array
									    * word64
									    * word8 = 
								   (a_15,
								    i_6,
								    x_9688)
								val x_9690: unit = 
								   x_8677 x_9689
								val x_9691: word64 = 
								   0x1
								val x_9692: word64
									    * word64 = 
								   (i_6, x_9691)
								val x_9693: word64 = 
								   +?_1 x_9692
								val x_9694: word64
									    * (word64
									       * PrimSequence.Slice.t_1
									       * list_12) = 
								   (x_9693, b_21)
								val x_9695: word64
									    * PrimSequence.Slice.t_1
									    * list_12 = 
								   loop_9 x_9694
							     in
								x_9695
							     end
						    in
						       x_9686
						    end
					      val x_9696: word64 = 
						 0x0
					      val x_9697: word64
							  * (word64
							     * PrimSequence.Slice.t_1
							     * list_12) = 
						 (x_9696, x_9682)
					      val b_22: word64
							* PrimSequence.Slice.t_1
							* list_12 = 
						 loop_9 x_9697
					      val x_9698: word8 vector = 
						 x_8683 a_15
					   in
					      x_9698
					   end
			      in
				 x_9630
			      end
		     in
			x_9626
		     end
	       val rec 
		  fromIntForLength_0: word32 -> word64 = 
		     fn x_9734: word32 => 
		     let
			val x_9735: word64 = 
			   let
			      val x_9736: word64 = 
				 sextdFromInt32ToInt64_0 x_9734
			   in
			      x_9736
			   end
			   handle x_9737 => let
					       val x_9738: unit -> word64 = 
						  fn unit_10: unit => 
						  let
						     val x_9739: word64 = 
							raise x_9737
						  in
						     x_9739
						  end
					       val x_9740: word64 = 
						  case x_9737 of
						  Overflow_0 x_9741: unit ref => 
						     let
							val x_9742: bool = 
							   MLton_equal[unit ref] (x_9741,
										  x_8289)
							val x_9743: word64 = 
							   case x_9742 of
							   true => 
							      let
								 val x_9746: word64 = 
								    raise x_8293
							      in
								 x_9746
							      end
							   false => 
							      let
								 val x_9744: unit = 
								    ()
								 val x_9745: word64 = 
								    x_9738 x_9744
							      in
								 x_9745
							      end
						     in
							x_9743
						     end
						    _ => let
							    val x_9747: unit = 
							       ()
							    val x_9748: word64 = 
							       x_9738 x_9747
							 in
							    x_9748
							 end
					    in
					       x_9740
					    end
		     in
			x_9735
		     end
	       val rec 
		  length_18: word8 array -> word32 = 
		     fn x_9749: word8 array => 
		     let
			val x_9750: word32 = 
			   let
			      val x_9751: word64 = 
				 x_8669 x_9749
			      val x_9752: word32 = 
				 x_8890 x_9751
			   in
			      x_9752
			   end
			   handle x_9753 => let
					       val x_9754: unit -> word32 = 
						  fn unit_11: unit => 
						  let
						     val x_9755: word32 = 
							raise x_9753
						  in
						     x_9755
						  end
					       val x_9756: word32 = 
						  case x_9753 of
						  Overflow_0 x_9757: unit ref => 
						     let
							val x_9758: bool = 
							   MLton_equal[unit ref] (x_9757,
										  x_8289)
							val x_9759: word32 = 
							   case x_9758 of
							   true => 
							      let
								 val x_9762: word8 vector = 
								    "Sequence.length"
								 val x_9763: unit ref
									     * word8 vector = 
								    (x_9554,
								     x_9762)
								 val x_9764: exn = 
								    Fail_0 x_9763
								 val x_9765: word32 = 
								    raise x_9764
							      in
								 x_9765
							      end
							   false => 
							      let
								 val x_9760: unit = 
								    ()
								 val x_9761: word32 = 
								    x_9754 x_9760
							      in
								 x_9761
							      end
						     in
							x_9759
						     end
						    _ => let
							    val x_9766: unit = 
							       ()
							    val x_9767: word32 = 
							       x_9754 x_9766
							 in
							    x_9767
							 end
					    in
					       x_9756
					    end
		     in
			x_9750
		     end
	       val rec 
		  new_2: word32 * word8 -> word8 array = 
		     fn x_9768: word32 * word8 => 
		     let
			val x_9769: word8 = 
			   #1 x_9768
			val n_3: word32 = 
			   #0 x_9768
			val x_9770: unit = 
			   ()
			val x_9771: word64 = 
			   fromIntForLength_0 n_3
			val x_9772: bool = 
			   not_0 isMutable_1
			val x_9773: bool = 
			   case x_9772 of
			   true => 
			      let
				 val x_9775: word64 = 
				    0x0
				 val x_9776: word64 * word64 = 
				    (x_9771, x_9775)
				 val x_9777: bool = 
				    x_8372 x_9776
			      in
				 x_9777
			      end
			   false => 
			      let
				 val x_9774: bool = 
				    false
			      in
				 x_9774
			      end
			val x_9778: word8 array = 
			   case x_9773 of
			   true => 
			      let
				 val x_9784: unit = 
				    ()
				 val x_9785: word8 array = 
				    x_8666 x_9784
			      in
				 x_9785
			      end
			   false => 
			      let
				 val x_9779: word64 * word64 = 
				    (x_9771, x_9217)
				 val x_9780: bool = 
				    >_4 x_9779
				 val x_9781: word8 array = 
				    case x_9780 of
				    true => 
				       let
					  val x_9783: word8 array = 
					     raise x_8293
				       in
					  x_9783
				       end
				    false => 
				       let
					  val x_9782: word8 array = 
					     x_8663 x_9771
				       in
					  x_9782
				       end
			      in
				 x_9781
			      end
			val rec 
			   loop_11: word64 * unit -> unit = 
			      fn x_9786: word64 * unit => 
			      let
				 val b_26: unit = 
				    #1 x_9786
				 val i_8: word64 = 
				    #0 x_9786
				 val x_9787: word64 * word64 = 
				    (i_8, x_9771)
				 val x_9788: bool = 
				    >=_2 x_9787
				 val x_9789: unit = 
				    case x_9788 of
				    true => 
				       let
				       in
					  b_26
				       end
				    false => 
				       let
					  val x_9790: unit = 
					     ()
					  val x_9791: word8 array
						      * word64
						      * word8 = 
					     (x_9778, i_8, x_9769)
					  val x_9792: unit = 
					     x_8677 x_9791
					  val x_9793: word64 = 
					     0x1
					  val x_9794: word64 * word64 = 
					     (i_8, x_9793)
					  val x_9795: word64 = 
					     +?_1 x_9794
					  val x_9796: word64 * unit = 
					     (x_9795, x_9790)
					  val x_9797: unit = 
					     loop_11 x_9796
				       in
					  x_9797
				       end
			      in
				 x_9789
			      end
			val x_9798: word64 = 
			   0x0
			val x_9799: word64 * unit = 
			   (x_9798, x_9770)
			val b_27: unit = 
			   loop_11 x_9799
		     in
			x_9778
		     end
	       val rec 
		  slice_8: word8 array * word32 * Primitive.Option.t_0
			   -> PrimSequence.Slice.t_0 = 
		     fn x_9800: word8 array * word32 * Primitive.Option.t_0 => 
		     let
			val len_1: Primitive.Option.t_0 = 
			   #2 x_9800
			val start_1: word32 = 
			   #1 x_9800
			val seq_1: word8 array = 
			   #0 x_9800
			val x_9801: PrimSequence.Slice.t_0 = 
			   full_11 seq_1
			val x_9802: PrimSequence.Slice.t_0 = 
			   let
			      val x_9803: word64 = 
				 sextdFromInt32ToInt64_0 start_1
			      val x_9804: Primitive.Option.t_23 = 
				 case len_1 of
				 NONE_0 => 
				    let
				       val x_9808: Primitive.Option.t_23 = 
					  NONE_21
				    in
				       x_9808
				    end
				 SOME_0 x_9805: word32 => 
				    let
				       val x_9806: word64 = 
					  sextdFromInt32ToInt64_0 x_9805
				       val x_9807: Primitive.Option.t_23 = 
					  SOME_23 x_9806
				    in
				       x_9807
				    end
			      val x_9809: PrimSequence.Slice.t_0
					  * word64
					  * Primitive.Option.t_23 = 
				 (x_9801, x_9803, x_9804)
			      val x_9810: PrimSequence.Slice.t_0 = 
				 subslice_4 x_9809
			   in
			      x_9810
			   end
			   handle x_9811 => let
					       val x_9812: unit
							   -> PrimSequence.Slice.t_0 = 
						  fn unit_12: unit => 
						  let
						     val x_9813: PrimSequence.Slice.t_0 = 
							raise x_9811
						  in
						     x_9813
						  end
					       val x_9814: PrimSequence.Slice.t_0 = 
						  case x_9811 of
						  Overflow_0 x_9815: unit ref => 
						     let
							val x_9816: bool = 
							   MLton_equal[unit ref] (x_9815,
										  x_8289)
							val x_9817: PrimSequence.Slice.t_0 = 
							   case x_9816 of
							   true => 
							      let
								 val x_9820: PrimSequence.Slice.t_0 = 
								    raise x_8296
							      in
								 x_9820
							      end
							   false => 
							      let
								 val x_9818: unit = 
								    ()
								 val x_9819: PrimSequence.Slice.t_0 = 
								    x_9812 x_9818
							      in
								 x_9819
							      end
						     in
							x_9817
						     end
						    _ => let
							    val x_9821: unit = 
							       ()
							    val x_9822: PrimSequence.Slice.t_0 = 
							       x_9812 x_9821
							 in
							    x_9822
							 end
					    in
					       x_9814
					    end
		     in
			x_9802
		     end
	       val rec 
		  base_13: PrimSequence.Slice.t_0
			   -> word8 array * word32 * word32 = 
		     fn x_9823: PrimSequence.Slice.t_0 => 
		     let
			val x_9824: word8 array * word64 * word64 = 
			   case x_9823 of
			   T_4 x_9825: word64 * word8 array * word64 => 
			      let
				 val x_9826: word64 = 
				    #2 x_9825
				 val x_9827: word8 array = 
				    #1 x_9825
				 val x_9828: word64 = 
				    #0 x_9825
				 val x_9829: word8 array * word64 * word64 = 
				    (x_9827, x_9826, x_9828)
			      in
				 x_9829
			      end
			val len_2: word64 = 
			   #2 x_9824
			val start_2: word64 = 
			   #1 x_9824
			val seq_2: word8 array = 
			   #0 x_9824
			val x_9830: word8 array * word32 * word32 = 
			   let
			      val x_9831: word32 = 
				 x_8890 start_2
			      val x_9832: word32 = 
				 x_8890 len_2
			      val x_9833: word8 array * word32 * word32 = 
				 (seq_2, x_9831, x_9832)
			   in
			      x_9833
			   end
			   handle x_9834 => let
					       val x_9835: unit
							   -> word8 array
							      * word32
							      * word32 = 
						  fn unit_13: unit => 
						  let
						     val x_9836: word8 array
								 * word32
								 * word32 = 
							raise x_9834
						  in
						     x_9836
						  end
					       val x_9837: word8 array
							   * word32
							   * word32 = 
						  case x_9834 of
						  Overflow_0 x_9838: unit ref => 
						     let
							val x_9839: bool = 
							   MLton_equal[unit ref] (x_9838,
										  x_8289)
							val x_9840: word8 array
								    * word32
								    * word32 = 
							   case x_9839 of
							   true => 
							      let
								 val x_9843: word8 vector = 
								    "Sequence.Slice.base"
								 val x_9844: unit ref
									     * word8 vector = 
								    (x_9554,
								     x_9843)
								 val x_9845: exn = 
								    Fail_0 x_9844
								 val x_9846: word8 array
									     * word32
									     * word32 = 
								    raise x_9845
							      in
								 x_9846
							      end
							   false => 
							      let
								 val x_9841: unit = 
								    ()
								 val x_9842: word8 array
									     * word32
									     * word32 = 
								    x_9835 x_9841
							      in
								 x_9842
							      end
						     in
							x_9840
						     end
						    _ => let
							    val x_9847: unit = 
							       ()
							    val x_9848: word8 array
									* word32
									* word32 = 
							       x_9835 x_9847
							 in
							    x_9848
							 end
					    in
					       x_9837
					    end
		     in
			x_9830
		     end
	       val rec 
		  update_2: word8 array * word32 * word8 -> unit = 
		     fn x_9849: word8 array * word32 * word8 => 
		     let
			val x_9850: word8 = 
			   #2 x_9849
			val x_9851: word32 = 
			   #1 x_9849
			val x_9852: word8 array = 
			   #0 x_9849
			val x_9853: PrimSequence.Slice.t_0 = 
			   full_11 x_9852
			val i_9: word64 = 
			   let
			      val x_9854: word64 = 
				 sextdFromInt32ToInt64_0 x_9851
			   in
			      x_9854
			   end
			   handle x_9855 => let
					       val x_9856: unit -> word64 = 
						  fn unit_14: unit => 
						  let
						     val x_9857: word64 = 
							raise x_9855
						  in
						     x_9857
						  end
					       val x_9858: word64 = 
						  case x_9855 of
						  Overflow_0 x_9859: unit ref => 
						     let
							val x_9860: bool = 
							   MLton_equal[unit ref] (x_9859,
										  x_8289)
							val x_9861: word64 = 
							   case x_9860 of
							   true => 
							      let
								 val x_9864: word64 = 
								    raise x_8296
							      in
								 x_9864
							      end
							   false => 
							      let
								 val x_9862: unit = 
								    ()
								 val x_9863: word64 = 
								    x_9856 x_9862
							      in
								 x_9863
							      end
						     in
							x_9861
						     end
						    _ => let
							    val x_9865: unit = 
							       ()
							    val x_9866: word64 = 
							       x_9856 x_9865
							 in
							    x_9866
							 end
					    in
					       x_9858
					    end
			val x_9867: unit = 
			   case x_9853 of
			   T_4 x_9868: word64 * word8 array * word64 => 
			      let
				 val x_9869: word64 = 
				    #0 x_9868
				 val x_9870: word64 * word64 = 
				    (i_9, x_9869)
				 val x_9871: bool = 
				    >=_5 x_9870
				 val x_9872: unit = 
				    case x_9871 of
				    true => 
				       let
					  val x_9881: unit = 
					     raise x_8296
				       in
					  x_9881
				       end
				    false => 
				       let
					  val x_9873: unit = 
					     case x_9853 of
					     T_4 x_9874: word64
							 * word8 array
							 * word64 => 
						let
						   val x_9875: word64 = 
						      #2 x_9874
						   val x_9876: word8 array = 
						      #1 x_9874
						   val x_9877: word64 * word64 = 
						      (x_9875, i_9)
						   val x_9878: word64 = 
						      +?_1 x_9877
						   val x_9879: word8 array
							       * word64
							       * word8 = 
						      (x_9876, x_9878, x_9850)
						   val x_9880: unit = 
						      x_8677 x_9879
						in
						   x_9880
						end
				       in
					  x_9873
				       end
			      in
				 x_9872
			      end
		     in
			x_9867
		     end
	       val x_9882: word32 -> word8 = 
		  fn x_9883: word32 => 
		  let
		     val x_9884: word8 = 
			WordS32_extdToWord8 (x_9883)
		     val x_9885: word8 = 
			idFromWord8_0 x_9884
		  in
		     x_9885
		  end
	       val x_9886: word8 -> word32 = 
		  fn x_9887: word8 => 
		  let
		     val x_9888: word32 = 
			WordU8_extdToWord32 (x_9887)
		  in
		     x_9888
		  end
	       val x_9889: word32 = 
		  0x100
	       val radixToInt_0: StringCvt.radix_0 -> word32 = 
		  fn x_9890: StringCvt.radix_0 => 
		  let
		     val x_9891: word32 = 
			case x_9890 of
			BIN_0 => 
			   let
			      val x_9895: word32 = 
				 0x2
			   in
			      x_9895
			   end
			DEC_0 => 
			   let
			      val x_9894: word32 = 
				 0xA
			   in
			      x_9894
			   end
			HEX_0 => 
			   let
			      val x_9893: word32 = 
				 0x10
			   in
			      x_9893
			   end
			OCT_0 => 
			   let
			      val x_9892: word32 = 
				 0x8
			   in
			      x_9892
			   end
		  in
		     x_9891
		  end
	       val rec 
		  range_0: word32 * word8 * word8
			   -> word8 -> Primitive.Option.t_0 = 
		     fn x_9896: word32 * word8 * word8 => 
		     let
			val cmax_0: word8 = 
			   #2 x_9896
			val cmin_0: word8 = 
			   #1 x_9896
			val add_0: word32 = 
			   #0 x_9896
			val min_0: word32 = 
			   x_9886 cmin_0
			val x_9897: word8 -> Primitive.Option.t_0 = 
			   fn x_9898: word8 => 
			   let
			      val x_9899: word8 * word8 = 
				 (cmin_0, x_9898)
			      val x_9900: bool = 
				 <=_1 x_9899
			      val x_9901: bool = 
				 case x_9900 of
				 true => 
				    let
				       val x_9903: word8 * word8 = 
					  (x_9898, cmax_0)
				       val x_9904: bool = 
					  <=_1 x_9903
				    in
				       x_9904
				    end
				 false => 
				    let
				       val x_9902: bool = 
					  false
				    in
				       x_9902
				    end
			      val x_9905: Primitive.Option.t_0 = 
				 case x_9901 of
				 true => 
				    let
				       val x_9907: word32 = 
					  x_9886 x_9898
				       val x_9908: word32 * word32 = 
					  (add_0, x_9907)
				       val x_9909: word32 = 
					  +?_0 x_9908
				       val x_9910: word32 * word32 = 
					  (x_9909, min_0)
				       val x_9911: word32 = 
					  -?_0 x_9910
				       val x_9912: Primitive.Option.t_0 = 
					  SOME_0 x_9911
				    in
				       x_9912
				    end
				 false => 
				    let
				       val x_9906: Primitive.Option.t_0 = 
					  NONE_0
				    in
				       x_9906
				    end
			   in
			      x_9905
			   end
		     in
			x_9897
		     end
	       val x_9913: word32 = 
		  0x0
	       val x_9914: word8 = 
		  0x30
	       val x_9915: word8 = 
		  0x31
	       val x_9916: word32 * word8 * word8 = 
		  (x_9913, x_9914, x_9915)
	       val x_9917: word8 -> Primitive.Option.t_0 = 
		  range_0 x_9916
	       val x_9918: unit = 
		  ()
	       val x_9919: word64 = 
		  fromIntForLength_0 x_9889
	       val x_9920: bool = 
		  not_0 isMutable_1
	       val x_9921: bool = 
		  case x_9920 of
		  true => 
		     let
			val x_9923: word64 = 
			   0x0
			val x_9924: word64 * word64 = 
			   (x_9919, x_9923)
			val x_9925: bool = 
			   x_8372 x_9924
		     in
			x_9925
		     end
		  false => 
		     let
			val x_9922: bool = 
			   false
		     in
			x_9922
		     end
	       val x_9926: Primitive.Option.t_0 array = 
		  case x_9921 of
		  true => 
		     let
			val x_9932: Primitive.Option.t_0 array = 
			   Array_array0Const[Primitive.Option.t_0] ()
		     in
			x_9932
		     end
		  false => 
		     let
			val x_9927: word64 * word64 = 
			   (x_9919, x_9217)
			val x_9928: bool = 
			   >_4 x_9927
			val x_9929: Primitive.Option.t_0 array = 
			   case x_9928 of
			   true => 
			      let
				 val x_9931: Primitive.Option.t_0 array = 
				    raise x_8293
			      in
				 x_9931
			      end
			   false => 
			      let
				 val x_9930: Primitive.Option.t_0 array = 
				    Array_array[Primitive.Option.t_0] (x_9919)
			      in
				 x_9930
			      end
		     in
			x_9929
		     end
	       val rec 
		  loop_12: word64 * unit -> unit = 
		     fn x_9933: word64 * unit => 
		     let
			val b_28: unit = 
			   #1 x_9933
			val i_10: word64 = 
			   #0 x_9933
			val x_9934: word64 * word64 = 
			   (i_10, x_9919)
			val x_9935: bool = 
			   >=_2 x_9934
			val x_9936: unit = 
			   case x_9935 of
			   true => 
			      let
			      in
				 b_28
			      end
			   false => 
			      let
				 val x_9937: word32 = 
				    sextdFromInt64ToInt32_0 i_10
				 val x_9938: word8 = 
				    x_9882 x_9937
				 val x_9939: Primitive.Option.t_0 = 
				    x_9917 x_9938
				 val x_9940: unit = 
				    ()
				 val x_9941: unit = 
				    Array_update[Primitive.Option.t_0] (x_9926,
									i_10,
									x_9939)
				 val x_9942: word64 = 
				    0x1
				 val x_9943: word64 * word64 = 
				    (i_10, x_9942)
				 val x_9944: word64 = 
				    +?_1 x_9943
				 val x_9945: word64 * unit = 
				    (x_9944, x_9940)
				 val x_9946: unit = 
				    loop_12 x_9945
			      in
				 x_9946
			      end
		     in
			x_9936
		     end
	       val x_9947: word64 = 
		  0x0
	       val x_9948: word64 * unit = 
		  (x_9947, x_9918)
	       val b_29: unit = 
		  loop_12 x_9948
	       val x_9949: word32 = 
		  0x0
	       val x_9950: word8 = 
		  0x30
	       val x_9951: word8 = 
		  0x37
	       val x_9952: word32 * word8 * word8 = 
		  (x_9949, x_9950, x_9951)
	       val x_9953: word8 -> Primitive.Option.t_0 = 
		  range_0 x_9952
	       val x_9954: unit = 
		  ()
	       val x_9955: word64 = 
		  fromIntForLength_0 x_9889
	       val x_9956: bool = 
		  not_0 isMutable_1
	       val x_9957: bool = 
		  case x_9956 of
		  true => 
		     let
			val x_9959: word64 = 
			   0x0
			val x_9960: word64 * word64 = 
			   (x_9955, x_9959)
			val x_9961: bool = 
			   x_8372 x_9960
		     in
			x_9961
		     end
		  false => 
		     let
			val x_9958: bool = 
			   false
		     in
			x_9958
		     end
	       val x_9962: Primitive.Option.t_0 array = 
		  case x_9957 of
		  true => 
		     let
			val x_9968: Primitive.Option.t_0 array = 
			   Array_array0Const[Primitive.Option.t_0] ()
		     in
			x_9968
		     end
		  false => 
		     let
			val x_9963: word64 * word64 = 
			   (x_9955, x_9217)
			val x_9964: bool = 
			   >_4 x_9963
			val x_9965: Primitive.Option.t_0 array = 
			   case x_9964 of
			   true => 
			      let
				 val x_9967: Primitive.Option.t_0 array = 
				    raise x_8293
			      in
				 x_9967
			      end
			   false => 
			      let
				 val x_9966: Primitive.Option.t_0 array = 
				    Array_array[Primitive.Option.t_0] (x_9955)
			      in
				 x_9966
			      end
		     in
			x_9965
		     end
	       val rec 
		  loop_13: word64 * unit -> unit = 
		     fn x_9969: word64 * unit => 
		     let
			val b_30: unit = 
			   #1 x_9969
			val i_11: word64 = 
			   #0 x_9969
			val x_9970: word64 * word64 = 
			   (i_11, x_9955)
			val x_9971: bool = 
			   >=_2 x_9970
			val x_9972: unit = 
			   case x_9971 of
			   true => 
			      let
			      in
				 b_30
			      end
			   false => 
			      let
				 val x_9973: word32 = 
				    sextdFromInt64ToInt32_0 i_11
				 val x_9974: word8 = 
				    x_9882 x_9973
				 val x_9975: Primitive.Option.t_0 = 
				    x_9953 x_9974
				 val x_9976: unit = 
				    ()
				 val x_9977: unit = 
				    Array_update[Primitive.Option.t_0] (x_9962,
									i_11,
									x_9975)
				 val x_9978: word64 = 
				    0x1
				 val x_9979: word64 * word64 = 
				    (i_11, x_9978)
				 val x_9980: word64 = 
				    +?_1 x_9979
				 val x_9981: word64 * unit = 
				    (x_9980, x_9976)
				 val x_9982: unit = 
				    loop_13 x_9981
			      in
				 x_9982
			      end
		     in
			x_9972
		     end
	       val x_9983: word64 = 
		  0x0
	       val x_9984: word64 * unit = 
		  (x_9983, x_9954)
	       val b_31: unit = 
		  loop_13 x_9984
	       val x_9985: word32 = 
		  0x0
	       val x_9986: word8 = 
		  0x30
	       val x_9987: word8 = 
		  0x39
	       val x_9988: word32 * word8 * word8 = 
		  (x_9985, x_9986, x_9987)
	       val x_9989: word8 -> Primitive.Option.t_0 = 
		  range_0 x_9988
	       val x_9990: unit = 
		  ()
	       val x_9991: word64 = 
		  fromIntForLength_0 x_9889
	       val x_9992: bool = 
		  not_0 isMutable_1
	       val x_9993: bool = 
		  case x_9992 of
		  true => 
		     let
			val x_9995: word64 = 
			   0x0
			val x_9996: word64 * word64 = 
			   (x_9991, x_9995)
			val x_9997: bool = 
			   x_8372 x_9996
		     in
			x_9997
		     end
		  false => 
		     let
			val x_9994: bool = 
			   false
		     in
			x_9994
		     end
	       val x_9998: Primitive.Option.t_0 array = 
		  case x_9993 of
		  true => 
		     let
			val x_10004: Primitive.Option.t_0 array = 
			   Array_array0Const[Primitive.Option.t_0] ()
		     in
			x_10004
		     end
		  false => 
		     let
			val x_9999: word64 * word64 = 
			   (x_9991, x_9217)
			val x_10000: bool = 
			   >_4 x_9999
			val x_10001: Primitive.Option.t_0 array = 
			   case x_10000 of
			   true => 
			      let
				 val x_10003: Primitive.Option.t_0 array = 
				    raise x_8293
			      in
				 x_10003
			      end
			   false => 
			      let
				 val x_10002: Primitive.Option.t_0 array = 
				    Array_array[Primitive.Option.t_0] (x_9991)
			      in
				 x_10002
			      end
		     in
			x_10001
		     end
	       val rec 
		  loop_14: word64 * unit -> unit = 
		     fn x_10005: word64 * unit => 
		     let
			val b_32: unit = 
			   #1 x_10005
			val i_12: word64 = 
			   #0 x_10005
			val x_10006: word64 * word64 = 
			   (i_12, x_9991)
			val x_10007: bool = 
			   >=_2 x_10006
			val x_10008: unit = 
			   case x_10007 of
			   true => 
			      let
			      in
				 b_32
			      end
			   false => 
			      let
				 val x_10009: word32 = 
				    sextdFromInt64ToInt32_0 i_12
				 val x_10010: word8 = 
				    x_9882 x_10009
				 val x_10011: Primitive.Option.t_0 = 
				    x_9989 x_10010
				 val x_10012: unit = 
				    ()
				 val x_10013: unit = 
				    Array_update[Primitive.Option.t_0] (x_9998,
									i_12,
									x_10011)
				 val x_10014: word64 = 
				    0x1
				 val x_10015: word64 * word64 = 
				    (i_12, x_10014)
				 val x_10016: word64 = 
				    +?_1 x_10015
				 val x_10017: word64 * unit = 
				    (x_10016, x_10012)
				 val x_10018: unit = 
				    loop_14 x_10017
			      in
				 x_10018
			      end
		     in
			x_10008
		     end
	       val x_10019: word64 = 
		  0x0
	       val x_10020: word64 * unit = 
		  (x_10019, x_9990)
	       val b_33: unit = 
		  loop_14 x_10020
	       val x_10021: word32 = 
		  0x0
	       val x_10022: word8 = 
		  0x30
	       val x_10023: word8 = 
		  0x39
	       val x_10024: word32 * word8 * word8 = 
		  (x_10021, x_10022, x_10023)
	       val x_10025: word8 -> Primitive.Option.t_0 = 
		  range_0 x_10024
	       val x_10026: word32 = 
		  0xA
	       val x_10027: word8 = 
		  0x61
	       val x_10028: word8 = 
		  0x66
	       val x_10029: word32 * word8 * word8 = 
		  (x_10026, x_10027, x_10028)
	       val x_10030: word8 -> Primitive.Option.t_0 = 
		  range_0 x_10029
	       val x_10031: word32 = 
		  0xA
	       val x_10032: word8 = 
		  0x41
	       val x_10033: word8 = 
		  0x46
	       val x_10034: word32 * word8 * word8 = 
		  (x_10031, x_10032, x_10033)
	       val x_10035: word8 -> Primitive.Option.t_0 = 
		  range_0 x_10034
	       val x_10036: list_1 = 
		  nil_1
	       val x_10037: (word8 -> Primitive.Option.t_0) * list_1 = 
		  (x_10035, x_10036)
	       val x_10038: list_1 = 
		  ::_1 x_10037
	       val x_10039: (word8 -> Primitive.Option.t_0) * list_1 = 
		  (x_10030, x_10038)
	       val x_10040: list_1 = 
		  ::_1 x_10039
	       val x_10041: (word8 -> Primitive.Option.t_0) * list_1 = 
		  (x_10025, x_10040)
	       val x_10042: list_1 = 
		  ::_1 x_10041
	       val x_10043: unit = 
		  ()
	       val x_10044: word64 = 
		  fromIntForLength_0 x_9889
	       val x_10045: bool = 
		  not_0 isMutable_1
	       val x_10046: bool = 
		  case x_10045 of
		  true => 
		     let
			val x_10048: word64 = 
			   0x0
			val x_10049: word64 * word64 = 
			   (x_10044, x_10048)
			val x_10050: bool = 
			   x_8372 x_10049
		     in
			x_10050
		     end
		  false => 
		     let
			val x_10047: bool = 
			   false
		     in
			x_10047
		     end
	       val x_10051: Primitive.Option.t_0 array = 
		  case x_10046 of
		  true => 
		     let
			val x_10057: Primitive.Option.t_0 array = 
			   Array_array0Const[Primitive.Option.t_0] ()
		     in
			x_10057
		     end
		  false => 
		     let
			val x_10052: word64 * word64 = 
			   (x_10044, x_9217)
			val x_10053: bool = 
			   >_4 x_10052
			val x_10054: Primitive.Option.t_0 array = 
			   case x_10053 of
			   true => 
			      let
				 val x_10056: Primitive.Option.t_0 array = 
				    raise x_8293
			      in
				 x_10056
			      end
			   false => 
			      let
				 val x_10055: Primitive.Option.t_0 array = 
				    Array_array[Primitive.Option.t_0] (x_10044)
			      in
				 x_10055
			      end
		     in
			x_10054
		     end
	       val rec 
		  loop_15: word64 * unit -> unit = 
		     fn x_10058: word64 * unit => 
		     let
			val b_34: unit = 
			   #1 x_10058
			val i_13: word64 = 
			   #0 x_10058
			val x_10059: word64 * word64 = 
			   (i_13, x_10044)
			val x_10060: bool = 
			   >=_2 x_10059
			val x_10061: unit = 
			   case x_10060 of
			   true => 
			      let
			      in
				 b_34
			      end
			   false => 
			      let
				 val x_10062: word32 = 
				    sextdFromInt64ToInt32_0 i_13
				 val x_10063: word8 = 
				    x_9882 x_10062
				 val rec 
				    loop_16: list_1 -> Primitive.Option.t_0 = 
				       fn x_10064: list_1 => 
				       let
					  val x_10065: Primitive.Option.t_0 = 
					     case x_10064 of
					     nil_1 => 
						let
						   val x_10072: Primitive.Option.t_0 = 
						      NONE_0
						in
						   x_10072
						end
					     ::_1 x_10066: (word8
							    -> Primitive.Option.t_0)
							   * list_1 => 
						let
						   val x_10067: list_1 = 
						      #1 x_10066
						   val x_10068: word8
								-> Primitive.Option.t_0 = 
						      #0 x_10066
						   val x_10069: Primitive.Option.t_0 = 
						      x_10068 x_10063
						   val x_10070: Primitive.Option.t_0 = 
						      case x_10069 of
						      NONE_0 => 
							 let
							    val x_10071: Primitive.Option.t_0 = 
							       loop_16 x_10067
							 in
							    x_10071
							 end
							_ => let
							     in
								x_10069
							     end
						in
						   x_10070
						end
				       in
					  x_10065
				       end
				 val x_10073: Primitive.Option.t_0 = 
				    loop_16 x_10042
				 val x_10074: unit = 
				    ()
				 val x_10075: unit = 
				    Array_update[Primitive.Option.t_0] (x_10051,
									i_13,
									x_10073)
				 val x_10076: word64 = 
				    0x1
				 val x_10077: word64 * word64 = 
				    (i_13, x_10076)
				 val x_10078: word64 = 
				    +?_1 x_10077
				 val x_10079: word64 * unit = 
				    (x_10078, x_10074)
				 val x_10080: unit = 
				    loop_15 x_10079
			      in
				 x_10080
			      end
		     in
			x_10061
		     end
	       val x_10081: word64 = 
		  0x0
	       val x_10082: word64 * unit = 
		  (x_10081, x_10043)
	       val b_35: unit = 
		  loop_15 x_10082
	       val x_10083: unit = 
		  ()
	       val x_10084: word64 = 
		  fromIntForLength_0 x_9889
	       val x_10085: bool = 
		  not_0 isMutable_1
	       val x_10086: bool = 
		  case x_10085 of
		  true => 
		     let
			val x_10088: word64 = 
			   0x0
			val x_10089: word64 * word64 = 
			   (x_10084, x_10088)
			val x_10090: bool = 
			   x_8372 x_10089
		     in
			x_10090
		     end
		  false => 
		     let
			val x_10087: bool = 
			   false
		     in
			x_10087
		     end
	       val x_10091: bool array = 
		  case x_10086 of
		  true => 
		     let
			val x_10097: bool array = 
			   Array_array0Const[bool] ()
		     in
			x_10097
		     end
		  false => 
		     let
			val x_10092: word64 * word64 = 
			   (x_10084, x_9217)
			val x_10093: bool = 
			   >_4 x_10092
			val x_10094: bool array = 
			   case x_10093 of
			   true => 
			      let
				 val x_10096: bool array = 
				    raise x_8293
			      in
				 x_10096
			      end
			   false => 
			      let
				 val x_10095: bool array = 
				    Array_array[bool] (x_10084)
			      in
				 x_10095
			      end
		     in
			x_10094
		     end
	       val rec 
		  loop_17: word64 * unit -> unit = 
		     fn x_10098: word64 * unit => 
		     let
			val b_36: unit = 
			   #1 x_10098
			val i_14: word64 = 
			   #0 x_10098
			val x_10099: word64 * word64 = 
			   (i_14, x_10084)
			val x_10100: bool = 
			   >=_2 x_10099
			val x_10101: unit = 
			   case x_10100 of
			   true => 
			      let
			      in
				 b_36
			      end
			   false => 
			      let
				 val x_10102: word32 = 
				    sextdFromInt64ToInt32_0 i_14
				 val x_10103: word8 = 
				    x_9882 x_10102
				 val x_10104: word8 = 
				    0x20
				 val x_10105: word8 * word8 = 
				    (x_10103, x_10104)
				 val x_10106: bool = 
				    x_8377 x_10105
				 val x_10107: bool = 
				    case x_10106 of
				    true => 
				       let
					  val x_10111: bool = 
					     true
				       in
					  x_10111
				       end
				    false => 
				       let
					  val x_10108: word8 = 
					     0x9
					  val x_10109: word8 * word8 = 
					     (x_10103, x_10108)
					  val x_10110: bool = 
					     x_8377 x_10109
				       in
					  x_10110
				       end
				 val x_10112: bool = 
				    case x_10107 of
				    true => 
				       let
					  val x_10116: bool = 
					     true
				       in
					  x_10116
				       end
				    false => 
				       let
					  val x_10113: word8 = 
					     0xD
					  val x_10114: word8 * word8 = 
					     (x_10103, x_10113)
					  val x_10115: bool = 
					     x_8377 x_10114
				       in
					  x_10115
				       end
				 val x_10117: bool = 
				    case x_10112 of
				    true => 
				       let
					  val x_10121: bool = 
					     true
				       in
					  x_10121
				       end
				    false => 
				       let
					  val x_10118: word8 = 
					     0xA
					  val x_10119: word8 * word8 = 
					     (x_10103, x_10118)
					  val x_10120: bool = 
					     x_8377 x_10119
				       in
					  x_10120
				       end
				 val x_10122: bool = 
				    case x_10117 of
				    true => 
				       let
					  val x_10126: bool = 
					     true
				       in
					  x_10126
				       end
				    false => 
				       let
					  val x_10123: word8 = 
					     0xB
					  val x_10124: word8 * word8 = 
					     (x_10103, x_10123)
					  val x_10125: bool = 
					     x_8377 x_10124
				       in
					  x_10125
				       end
				 val x_10127: bool = 
				    case x_10122 of
				    true => 
				       let
					  val x_10131: bool = 
					     true
				       in
					  x_10131
				       end
				    false => 
				       let
					  val x_10128: word8 = 
					     0xC
					  val x_10129: word8 * word8 = 
					     (x_10103, x_10128)
					  val x_10130: bool = 
					     x_8377 x_10129
				       in
					  x_10130
				       end
				 val x_10132: unit = 
				    ()
				 val x_10133: unit = 
				    Array_update[bool] (x_10091, i_14, x_10127)
				 val x_10134: word64 = 
				    0x1
				 val x_10135: word64 * word64 = 
				    (i_14, x_10134)
				 val x_10136: word64 = 
				    +?_1 x_10135
				 val x_10137: word64 * unit = 
				    (x_10136, x_10132)
				 val x_10138: unit = 
				    loop_17 x_10137
			      in
				 x_10138
			      end
		     in
			x_10101
		     end
	       val x_10139: word64 = 
		  0x0
	       val x_10140: word64 * unit = 
		  (x_10139, x_10083)
	       val b_37: unit = 
		  loop_17 x_10140
	       val rec 
		  digitToChar_0: word32 -> word8 = 
		     fn x_10141: word32 => 
		     let
			val x_10142: word8 vector = 
			   "0123456789ABCDEF"
			val x_10143: PrimSequence.Slice.t_1 = 
			   full_10 x_10142
			val i_15: word64 = 
			   let
			      val x_10144: word64 = 
				 sextdFromInt32ToInt64_0 x_10141
			   in
			      x_10144
			   end
			   handle x_10145 => let
						val x_10146: unit -> word64 = 
						   fn unit_15: unit => 
						   let
						      val x_10147: word64 = 
							 raise x_10145
						   in
						      x_10147
						   end
						val x_10148: word64 = 
						   case x_10145 of
						   Overflow_0 x_10149: unit ref => 
						      let
							 val x_10150: bool = 
							    MLton_equal[unit ref] (x_10149,
										   x_8289)
							 val x_10151: word64 = 
							    case x_10150 of
							    true => 
							       let
								  val x_10154: word64 = 
								     raise x_8296
							       in
								  x_10154
							       end
							    false => 
							       let
								  val x_10152: unit = 
								     ()
								  val x_10153: word64 = 
								     x_10146 x_10152
							       in
								  x_10153
							       end
						      in
							 x_10151
						      end
						     _ => let
							     val x_10155: unit = 
								()
							     val x_10156: word64 = 
								x_10146 x_10155
							  in
							     x_10156
							  end
					     in
						x_10148
					     end
			val x_10157: word8 = 
			   case x_10143 of
			   T_5 x_10158: word64 * word8 vector * word64 => 
			      let
				 val x_10159: word64 = 
				    #0 x_10158
				 val x_10160: word64 * word64 = 
				    (i_15, x_10159)
				 val x_10161: bool = 
				    >=_5 x_10160
				 val x_10162: word8 = 
				    case x_10161 of
				    true => 
				       let
					  val x_10165: word8 = 
					     raise x_8296
				       in
					  x_10165
				       end
				    false => 
				       let
					  val x_10163: PrimSequence.Slice.t_1
						       * word64 = 
					     (x_10143, i_15)
					  val x_10164: word8 = 
					     unsafeSub_6 x_10163
				       in
					  x_10164
				       end
			      in
				 x_10162
			      end
		     in
			x_10157
		     end
	       val precision'_0: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_40
	       val sizeInBitsWord_8: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_4
	       val rec 
		  <<_0: word8 * word32 -> word8 = 
		     fn x_10166: word8 * word32 => 
		     let
			val n_4: word32 = 
			   #1 x_10166
			val i_16: word8 = 
			   #0 x_10166
			val x_10167: word32 * word32 = 
			   (n_4, sizeInBitsWord_8)
			val x_10168: bool = 
			   >=_0 x_10167
			val x_10169: word8 = 
			   case x_10168 of
			   true => 
			      let
			      in
				 zero_0
			      end
			   false => 
			      let
				 val x_10170: word32 = 
				    zextdFromWord32ToWord32_0 n_4
				 val x_10171: word8 * word32 = 
				    (i_16, x_10170)
				 val x_10172: word8 = 
				    x_8912 x_10171
			      in
				 x_10172
			      end
		     in
			x_10169
		     end
	       val rec 
		  >>_0: word8 * word32 -> word8 = 
		     fn x_10173: word8 * word32 => 
		     let
			val n_5: word32 = 
			   #1 x_10173
			val i_17: word8 = 
			   #0 x_10173
			val x_10174: word32 * word32 = 
			   (n_5, sizeInBitsWord_8)
			val x_10175: bool = 
			   >=_0 x_10174
			val x_10176: word8 = 
			   case x_10175 of
			   true => 
			      let
			      in
				 zero_0
			      end
			   false => 
			      let
				 val x_10177: word32 = 
				    zextdFromWord32ToWord32_0 n_5
				 val x_10178: word8 * word32 = 
				    (i_17, x_10177)
				 val x_10179: word8 = 
				    x_8919 x_10178
			      in
				 x_10179
			      end
		     in
			x_10176
		     end
	       val precision'_1: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_48
	       val sizeInBitsWord_9: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_5
	       val rec 
		  <<_1: word16 * word32 -> word16 = 
		     fn x_10180: word16 * word32 => 
		     let
			val n_6: word32 = 
			   #1 x_10180
			val i_18: word16 = 
			   #0 x_10180
			val x_10181: word32 * word32 = 
			   (n_6, sizeInBitsWord_9)
			val x_10182: bool = 
			   >=_0 x_10181
			val x_10183: word16 = 
			   case x_10182 of
			   true => 
			      let
			      in
				 zero_1
			      end
			   false => 
			      let
				 val x_10184: word32 = 
				    zextdFromWord32ToWord32_0 n_6
				 val x_10185: word16 * word32 = 
				    (i_18, x_10184)
				 val x_10186: word16 = 
				    x_8950 x_10185
			      in
				 x_10186
			      end
		     in
			x_10183
		     end
	       val rec 
		  >>_1: word16 * word32 -> word16 = 
		     fn x_10187: word16 * word32 => 
		     let
			val n_7: word32 = 
			   #1 x_10187
			val i_19: word16 = 
			   #0 x_10187
			val x_10188: word32 * word32 = 
			   (n_7, sizeInBitsWord_9)
			val x_10189: bool = 
			   >=_0 x_10188
			val x_10190: word16 = 
			   case x_10189 of
			   true => 
			      let
			      in
				 zero_1
			      end
			   false => 
			      let
				 val x_10191: word32 = 
				    zextdFromWord32ToWord32_0 n_7
				 val x_10192: word16 * word32 = 
				    (i_19, x_10191)
				 val x_10193: word16 = 
				    x_8957 x_10192
			      in
				 x_10193
			      end
		     in
			x_10190
		     end
	       val precision'_2: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_64
	       val sizeInBitsWord_10: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_6
	       val rec 
		  <<_2: word32 * word32 -> word32 = 
		     fn x_10194: word32 * word32 => 
		     let
			val n_8: word32 = 
			   #1 x_10194
			val i_20: word32 = 
			   #0 x_10194
			val x_10195: word32 * word32 = 
			   (n_8, sizeInBitsWord_10)
			val x_10196: bool = 
			   >=_0 x_10195
			val x_10197: word32 = 
			   case x_10196 of
			   true => 
			      let
			      in
				 zero_3
			      end
			   false => 
			      let
				 val x_10198: word32 = 
				    zextdFromWord32ToWord32_0 n_8
				 val x_10199: word32 * word32 = 
				    (i_20, x_10198)
				 val x_10200: word32 = 
				    x_8989 x_10199
			      in
				 x_10200
			      end
		     in
			x_10197
		     end
	       val rec 
		  >>_2: word32 * word32 -> word32 = 
		     fn x_10201: word32 * word32 => 
		     let
			val n_9: word32 = 
			   #1 x_10201
			val i_21: word32 = 
			   #0 x_10201
			val x_10202: word32 * word32 = 
			   (n_9, sizeInBitsWord_10)
			val x_10203: bool = 
			   >=_0 x_10202
			val x_10204: word32 = 
			   case x_10203 of
			   true => 
			      let
			      in
				 zero_3
			      end
			   false => 
			      let
				 val x_10205: word32 = 
				    zextdFromWord32ToWord32_0 n_9
				 val x_10206: word32 * word32 = 
				    (i_21, x_10205)
				 val x_10207: word32 = 
				    x_8996 x_10206
			      in
				 x_10207
			      end
		     in
			x_10204
		     end
	       val x_10208: word32 = 
		  0x1
	       val x_10209: word32 * word32 = 
		  (precision'_2, x_10208)
	       val maxNumDigits_0: word32 = 
		  x_8508 x_10209
	       val x_10210: unit -> word8 array = 
		  fn x_10211: unit => 
		  let
		     val x_10212: word8 = 
			0x0
		     val x_10213: word32 * word8 = 
			(maxNumDigits_0, x_10212)
		     val x_10214: word8 array = 
			new_2 x_10213
		  in
		     x_10214
		  end
	       val x_10215: unit = 
		  ()
	       val x_10216: word8 array = 
		  x_10210 x_10215
	       val x_10217: bool = 
		  false
	       val x_10218: bool ref = 
		  Ref_ref[bool] (x_10217)
	       val x_10219: StringCvt.radix_0 = 
		  DEC_0
	       val precision'_3: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_65
	       val sizeInBitsWord_11: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_7
	       val rec 
		  <<_3: word64 * word32 -> word64 = 
		     fn x_10220: word64 * word32 => 
		     let
			val n_10: word32 = 
			   #1 x_10220
			val i_22: word64 = 
			   #0 x_10220
			val x_10221: word32 * word32 = 
			   (n_10, sizeInBitsWord_11)
			val x_10222: bool = 
			   >=_0 x_10221
			val x_10223: word64 = 
			   case x_10222 of
			   true => 
			      let
			      in
				 zero_5
			      end
			   false => 
			      let
				 val x_10224: word32 = 
				    zextdFromWord32ToWord32_0 n_10
				 val x_10225: word64 * word32 = 
				    (i_22, x_10224)
				 val x_10226: word64 = 
				    x_9044 x_10225
			      in
				 x_10226
			      end
		     in
			x_10223
		     end
	       val rec 
		  >>_3: word64 * word32 -> word64 = 
		     fn x_10227: word64 * word32 => 
		     let
			val n_11: word32 = 
			   #1 x_10227
			val i_23: word64 = 
			   #0 x_10227
			val x_10228: word32 * word32 = 
			   (n_11, sizeInBitsWord_11)
			val x_10229: bool = 
			   >=_0 x_10228
			val x_10230: word64 = 
			   case x_10229 of
			   true => 
			      let
			      in
				 zero_5
			      end
			   false => 
			      let
				 val x_10231: word32 = 
				    zextdFromWord32ToWord32_0 n_11
				 val x_10232: word64 * word32 = 
				    (i_23, x_10231)
				 val x_10233: word64 = 
				    x_9051 x_10232
			      in
				 x_10233
			      end
		     in
			x_10230
		     end
	       val x_10234: word32 = 
		  0x1
	       val x_10235: word32 * word32 = 
		  (precision'_3, x_10234)
	       val maxNumDigits_1: word32 = 
		  x_8508 x_10235
	       val x_10236: unit -> word8 array = 
		  fn x_10237: unit => 
		  let
		     val x_10238: word8 = 
			0x0
		     val x_10239: word32 * word8 = 
			(maxNumDigits_1, x_10238)
		     val x_10240: word8 array = 
			new_2 x_10239
		  in
		     x_10240
		  end
	       val x_10241: unit = 
		  ()
	       val x_10242: word8 array = 
		  x_10236 x_10241
	       val x_10243: bool = 
		  false
	       val x_10244: bool ref = 
		  Ref_ref[bool] (x_10243)
	       val rec 
		  fmt_0: StringCvt.radix_0 -> word64 -> word8 vector = 
		     fn x_10245: StringCvt.radix_0 => 
		     let
			val x_10246: word64 -> word8 vector = 
			   fn x_10247: word64 => 
			   let
			      val x_10248: unit = 
				 ()
			      val x_10249: unit = 
				 atomicBegin_0 x_10248
			      val b_38: bool = 
				 x_8321 x_10244
			      val x_10250: word8 array = 
				 case b_38 of
				 true => 
				    let
				       val x_10256: unit = 
					  ()
				       val x_10257: unit = 
					  atomicEnd_0 x_10256
				       val x_10258: unit = 
					  ()
				       val x_10259: word8 array = 
					  x_10236 x_10258
				    in
				       x_10259
				    end
				 false => 
				    let
				       val x_10251: bool = 
					  true
				       val x_10252: bool ref * bool = 
					  (x_10244, x_10251)
				       val x_10253: unit = 
					  x_8342 x_10252
				       val x_10254: unit = 
					  ()
				       val x_10255: unit = 
					  atomicEnd_0 x_10254
				    in
				       x_10242
				    end
			      val x_10260: unit -> unit = 
				 fn x_10261: unit => 
				 let
				    val x_10262: unit = 
				       case b_38 of
				       true => 
					  let
					     val x_10266: unit = 
						()
					  in
					     x_10266
					  end
				       false => 
					  let
					     val x_10263: bool = 
						false
					     val x_10264: bool ref * bool = 
						(x_10244, x_10263)
					     val x_10265: unit = 
						x_8342 x_10264
					  in
					     x_10265
					  end
				 in
				    x_10262
				 end
			      val x_10267: DynamicWind.try.t_0 = 
				 let
				    val x_10268: word32 = 
				       radixToInt_0 x_10245
				    val radix_0: word64 = 
				       sextdFromInt32ToInt64_0 x_10268
				    val rec 
				       loop_18: word64 * word32 -> word8 vector = 
					  fn x_10269: word64 * word32 => 
					  let
					     val i_24: word32 = 
						#1 x_10269
					     val q_0: word64 = 
						#0 x_10269
					     val x_10270: word64 * word64 = 
						(radix_0, zero_5)
					     val x_10271: bool = 
						x_8372 x_10270
					     val x_10272: word64 = 
						case x_10271 of
						true => 
						   let
						      val x_10282: word64 = 
							 raise x_8282
						   in
						      x_10282
						   end
						false => 
						   let
						      val x_10273: word64
								   * word64 = 
							 (q_0, minInt'_3)
						      val x_10274: bool = 
							 x_8372 x_10273
						      val x_10275: bool = 
							 case x_10274 of
							 true => 
							    let
							       val x_10277: word64 = 
								  x_8610 one_5
							       val x_10278: word64
									    * word64 = 
								  (radix_0,
								   x_10277)
							       val x_10279: bool = 
								  x_8372 x_10278
							    in
							       x_10279
							    end
							 false => 
							    let
							       val x_10276: bool = 
								  false
							    in
							       x_10276
							    end
						      val x_10280: word64 = 
							 case x_10275 of
							 true => 
							    let
							    in
							       zero_5
							    end
							 false => 
							    let
							       val x_10281: word64 = 
								  WordS64_rem (q_0,
									       radix_0)
							    in
							       x_10281
							    end
						   in
						      x_10280
						   end
					     val x_10283: word64 = 
						~?_1 x_10272
					     val x_10284: word32 = 
						x_8890 x_10283
					     val x_10285: word8 = 
						digitToChar_0 x_10284
					     val x_10286: word8 array
							  * word32
							  * word8 = 
						(x_10250, i_24, x_10285)
					     val x_10287: unit = 
						update_2 x_10286
					     val x_10288: word64 * word64 = 
						(q_0, radix_0)
					     val q_1: word64 = 
						quot_1 x_10288
					     val x_10289: word64 * word64 = 
						(q_1, zero_5)
					     val x_10290: bool = 
						x_8372 x_10289
					     val x_10291: word8 vector = 
						case x_10290 of
						true => 
						   let
						      val x_10297: word64
								   * word64 = 
							 (x_10247, zero_5)
						      val x_10298: bool = 
							 <_2 x_10297
						      val x_10299: word32 = 
							 case x_10298 of
							 true => 
							    let
							       val x_10300: word32 = 
								  0x1
							       val x_10301: word32
									    * word32 = 
								  (i_24, x_10300)
							       val i_25: word32 = 
								  x_8548 x_10301
							       val x_10302: word8 = 
								  0x7E
							       val x_10303: word8 array
									    * word32
									    * word8 = 
								  (x_10250,
								   i_25,
								   x_10302)
							       val x_10304: unit = 
								  update_2 x_10303
							    in
							       i_25
							    end
							 false => 
							    let
							    in
							       i_24
							    end
						      val x_10305: Primitive.Option.t_0 = 
							 NONE_0
						      val x_10306: word8 array
								   * word32
								   * Primitive.Option.t_0 = 
							 (x_10250,
							  x_10299,
							  x_10305)
						      val x_10307: PrimSequence.Slice.t_0 = 
							 slice_8 x_10306
						      val x_10308: word8 vector = 
							 vector_7 x_10307
						   in
						      x_10308
						   end
						false => 
						   let
						      val x_10292: word32 = 
							 0x1
						      val x_10293: word32
								   * word32 = 
							 (i_24, x_10292)
						      val x_10294: word32 = 
							 x_8548 x_10293
						      val x_10295: word64
								   * word32 = 
							 (q_1, x_10294)
						      val x_10296: word8 vector = 
							 loop_18 x_10295
						   in
						      x_10296
						   end
					  in
					     x_10291
					  end
				    val x_10309: word64 * word64 = 
				       (x_10247, zero_5)
				    val x_10310: bool = 
				       <_2 x_10309
				    val x_10311: word64 = 
				       case x_10310 of
				       true => 
					  let
					  in
					     x_10247
					  end
				       false => 
					  let
					     val x_10312: word64 = 
						~?_1 x_10247
					  in
					     x_10312
					  end
				    val x_10313: word32 = 
				       0x1
				    val x_10314: word32 * word32 = 
				       (maxNumDigits_1, x_10313)
				    val x_10315: word32 = 
				       x_8548 x_10314
				    val x_10316: word64 * word32 = 
				       (x_10311, x_10315)
				    val x_10317: word8 vector = 
				       loop_18 x_10316
				    val x_10318: DynamicWind.try.t_0 = 
				       A_0 x_10317
				 in
				    x_10318
				 end
				 handle x_10319 => let
						      val x_10320: DynamicWind.try.t_0 = 
							 E_0 x_10319
						   in
						      x_10320
						   end
			      val x_10321: word8 vector = 
				 case x_10267 of
				 A_0 x_10326: word8 vector => 
				    let
				       val x_10327: unit = 
					  ()
				       val x_10328: unit = 
					  x_10260 x_10327
				    in
				       x_10326
				    end
				 E_0 x_10322: exn => 
				    let
				       val x_10323: unit = 
					  ()
				       val x_10324: unit = 
					  x_10260 x_10323
				       val x_10325: word8 vector = 
					  raise x_10322
				    in
				       x_10325
				    end
			   in
			      x_10321
			   end
		     in
			x_10246
		     end
	       val wordSize_0: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_7
	       val sizeInBitsWord_12: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_0
	       val rec 
		  <<_4: word8 * word32 -> word8 = 
		     fn x_10329: word8 * word32 => 
		     let
			val n_12: word32 = 
			   #1 x_10329
			val i_26: word8 = 
			   #0 x_10329
			val x_10330: word32 * word32 = 
			   (n_12, sizeInBitsWord_12)
			val x_10331: bool = 
			   >=_0 x_10330
			val x_10332: word8 = 
			   case x_10331 of
			   true => 
			      let
			      in
				 x_8909
			      end
			   false => 
			      let
				 val x_10333: word32 = 
				    zextdFromWord32ToWord32_0 n_12
				 val x_10334: word8 * word32 = 
				    (i_26, x_10333)
				 val x_10335: word8 = 
				    <<?_0 x_10334
			      in
				 x_10335
			      end
		     in
			x_10332
		     end
	       val rec 
		  >>_4: word8 * word32 -> word8 = 
		     fn x_10336: word8 * word32 => 
		     let
			val n_13: word32 = 
			   #1 x_10336
			val i_27: word8 = 
			   #0 x_10336
			val x_10337: word32 * word32 = 
			   (n_13, sizeInBitsWord_12)
			val x_10338: bool = 
			   >=_0 x_10337
			val x_10339: word8 = 
			   case x_10338 of
			   true => 
			      let
			      in
				 x_8909
			      end
			   false => 
			      let
				 val x_10340: word32 = 
				    zextdFromWord32ToWord32_0 n_13
				 val x_10341: word8 * word32 = 
				    (i_27, x_10340)
				 val x_10342: word8 = 
				    >>?_0 x_10341
			      in
				 x_10342
			      end
		     in
			x_10339
		     end
	       val wordSize_1: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_15
	       val sizeInBitsWord_13: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_1
	       val rec 
		  <<_5: word16 * word32 -> word16 = 
		     fn x_10343: word16 * word32 => 
		     let
			val n_14: word32 = 
			   #1 x_10343
			val i_28: word16 = 
			   #0 x_10343
			val x_10344: word32 * word32 = 
			   (n_14, sizeInBitsWord_13)
			val x_10345: bool = 
			   >=_0 x_10344
			val x_10346: word16 = 
			   case x_10345 of
			   true => 
			      let
			      in
				 x_8947
			      end
			   false => 
			      let
				 val x_10347: word32 = 
				    zextdFromWord32ToWord32_0 n_14
				 val x_10348: word16 * word32 = 
				    (i_28, x_10347)
				 val x_10349: word16 = 
				    <<?_1 x_10348
			      in
				 x_10349
			      end
		     in
			x_10346
		     end
	       val rec 
		  >>_5: word16 * word32 -> word16 = 
		     fn x_10350: word16 * word32 => 
		     let
			val n_15: word32 = 
			   #1 x_10350
			val i_29: word16 = 
			   #0 x_10350
			val x_10351: word32 * word32 = 
			   (n_15, sizeInBitsWord_13)
			val x_10352: bool = 
			   >=_0 x_10351
			val x_10353: word16 = 
			   case x_10352 of
			   true => 
			      let
			      in
				 x_8947
			      end
			   false => 
			      let
				 val x_10354: word32 = 
				    zextdFromWord32ToWord32_0 n_15
				 val x_10355: word16 * word32 = 
				    (i_29, x_10354)
				 val x_10356: word16 = 
				    >>?_1 x_10355
			      in
				 x_10356
			      end
		     in
			x_10353
		     end
	       val wordSize_2: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_31
	       val sizeInBitsWord_14: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_2
	       val rec 
		  <<_6: word32 * word32 -> word32 = 
		     fn x_10357: word32 * word32 => 
		     let
			val n_16: word32 = 
			   #1 x_10357
			val i_30: word32 = 
			   #0 x_10357
			val x_10358: word32 * word32 = 
			   (n_16, sizeInBitsWord_14)
			val x_10359: bool = 
			   >=_0 x_10358
			val x_10360: word32 = 
			   case x_10359 of
			   true => 
			      let
			      in
				 zero_2
			      end
			   false => 
			      let
				 val x_10361: word32 = 
				    zextdFromWord32ToWord32_0 n_16
				 val x_10362: word32 * word32 = 
				    (i_30, x_10361)
				 val x_10363: word32 = 
				    <<?_2 x_10362
			      in
				 x_10363
			      end
		     in
			x_10360
		     end
	       val rec 
		  >>_6: word32 * word32 -> word32 = 
		     fn x_10364: word32 * word32 => 
		     let
			val n_17: word32 = 
			   #1 x_10364
			val i_31: word32 = 
			   #0 x_10364
			val x_10365: word32 * word32 = 
			   (n_17, sizeInBitsWord_14)
			val x_10366: bool = 
			   >=_0 x_10365
			val x_10367: word32 = 
			   case x_10366 of
			   true => 
			      let
			      in
				 zero_2
			      end
			   false => 
			      let
				 val x_10368: word32 = 
				    zextdFromWord32ToWord32_0 n_17
				 val x_10369: word32 * word32 = 
				    (i_31, x_10368)
				 val x_10370: word32 = 
				    >>?_2 x_10369
			      in
				 x_10370
			      end
		     in
			x_10367
		     end
	       val rec 
		  st_0: word32 * word32 * word32 -> word32 * word32 * word32 = 
		     fn x_10371: word32 * word32 * word32 => 
		     let
			val sft_0: word32 = 
			   #2 x_10371
			val msk_0: word32 = 
			   #1 x_10371
			val w_10: word32 = 
			   #0 x_10371
			val x_10372: word32 * word32 = 
			   (w_10, msk_0)
			val odd_0: word32 = 
			   andb_0 x_10372
			val x_10373: word32 * word32 = 
			   (w_10, odd_0)
			val evn_0: word32 = 
			   xorb_0 x_10373
			val x_10374: word32 * word32 = 
			   (odd_0, sft_0)
			val x_10375: word32 = 
			   <<?_2 x_10374
			val x_10376: word32 * word32 = 
			   (evn_0, sft_0)
			val x_10377: word32 = 
			   >>?_2 x_10376
			val x_10378: word32 * word32 = 
			   (x_10375, x_10377)
			val x_10379: word32 = 
			   xorb_0 x_10378
			val x_10380: word32 = 
			   0x1
			val x_10381: word32 * word32 = 
			   (sft_0, x_10380)
			val x_10382: word32 = 
			   >>?_2 x_10381
			val x_10383: word32 * word32 = 
			   (msk_0, x_10382)
			val x_10384: word32 = 
			   <<?_2 x_10383
			val x_10385: word32 * word32 = 
			   (msk_0, x_10384)
			val x_10386: word32 = 
			   xorb_0 x_10385
			val x_10387: word32 = 
			   0x1
			val x_10388: word32 * word32 = 
			   (sft_0, x_10387)
			val x_10389: word32 = 
			   >>?_2 x_10388
			val x_10390: word32 * word32 * word32 = 
			   (x_10379, x_10386, x_10389)
		     in
			x_10390
		     end
	       val x_10391: (word32 * word32 * word32
			     -> word32 * word32 * word32)
			    * word32 = 
		  case sizeInBitsWord_2 of
		  0x8 => 
		     let
			val x_10407: word32 * word32 * word32
				     -> word32 * word32 * word32 = 
			   fn x_10408: word32 * word32 * word32 => 
			   let
			   in
			      x_10408
			   end
			val x_10409: word32 = 
			   0x4
			val x_10410: (word32 * word32 * word32
				      -> word32 * word32 * word32)
				     * word32 = 
			   (x_10407, x_10409)
		     in
			x_10410
		     end
		  0x20 => 
		     let
			val x_10401: word32 * word32 * word32
				     -> word32 * word32 * word32 = 
			   fn x_10402: word32 * word32 * word32 => 
			   let
			      val x_10403: word32 * word32 * word32 = 
				 st_0 x_10402
			      val x_10404: word32 * word32 * word32 = 
				 st_0 x_10403
			   in
			      x_10404
			   end
			val x_10405: word32 = 
			   0x10
			val x_10406: (word32 * word32 * word32
				      -> word32 * word32 * word32)
				     * word32 = 
			   (x_10401, x_10405)
		     in
			x_10406
		     end
		  0x40 => 
		     let
			val x_10394: word32 * word32 * word32
				     -> word32 * word32 * word32 = 
			   fn x_10395: word32 * word32 * word32 => 
			   let
			      val x_10396: word32 * word32 * word32 = 
				 st_0 x_10395
			      val x_10397: word32 * word32 * word32 = 
				 st_0 x_10396
			      val x_10398: word32 * word32 * word32 = 
				 st_0 x_10397
			   in
			      x_10398
			   end
			val x_10399: word32 = 
			   0x20
			val x_10400: (word32 * word32 * word32
				      -> word32 * word32 * word32)
				     * word32 = 
			   (x_10394, x_10399)
		     in
			x_10400
		     end
		  0x10 => 
		     let
			val x_10392: word32 = 
			   0x8
			val x_10393: (word32 * word32 * word32
				      -> word32 * word32 * word32)
				     * word32 = 
			   (st_0, x_10392)
		     in
			x_10393
		     end
		    _ => let
			    val x_10411: word8 vector = 
			       "Word.bswap"
			    val x_10412: unit ref * word8 vector = 
			       (x_9554, x_10411)
			    val x_10413: exn = 
			       Fail_0 x_10412
			    val x_10414: (word32 * word32 * word32
					  -> word32 * word32 * word32)
					 * word32 = 
			       raise x_10413
			 in
			    x_10414
			 end
	       val wordSize_3: word32 = 
		  zextdFromInt32ToInt32_0 sizeInBits_32
	       val sizeInBitsWord_15: word32 = 
		  zextdFromWord32ToWord32_0 sizeInBitsWord_3
	       val rec 
		  <<_7: word64 * word32 -> word64 = 
		     fn x_10415: word64 * word32 => 
		     let
			val n_18: word32 = 
			   #1 x_10415
			val i_32: word64 = 
			   #0 x_10415
			val x_10416: word32 * word32 = 
			   (n_18, sizeInBitsWord_15)
			val x_10417: bool = 
			   >=_0 x_10416
			val x_10418: word64 = 
			   case x_10417 of
			   true => 
			      let
			      in
				 zero_4
			      end
			   false => 
			      let
				 val x_10419: word32 = 
				    zextdFromWord32ToWord32_0 n_18
				 val x_10420: word64 * word32 = 
				    (i_32, x_10419)
				 val x_10421: word64 = 
				    <<?_3 x_10420
			      in
				 x_10421
			      end
		     in
			x_10418
		     end
	       val rec 
		  >>_7: word64 * word32 -> word64 = 
		     fn x_10422: word64 * word32 => 
		     let
			val n_19: word32 = 
			   #1 x_10422
			val i_33: word64 = 
			   #0 x_10422
			val x_10423: word32 * word32 = 
			   (n_19, sizeInBitsWord_15)
			val x_10424: bool = 
			   >=_0 x_10423
			val x_10425: word64 = 
			   case x_10424 of
			   true => 
			      let
			      in
				 zero_4
			      end
			   false => 
			      let
				 val x_10426: word32 = 
				    zextdFromWord32ToWord32_0 n_19
				 val x_10427: word64 * word32 = 
				    (i_33, x_10426)
				 val x_10428: word64 = 
				    >>?_3 x_10427
			      in
				 x_10428
			      end
		     in
			x_10425
		     end
	       val x_10429: word32 = 
		  0x2
	       val x_10430: StringCvt.radix_0 = 
		  BIN_0
	       val x_10431: word64 -> word8 vector = 
		  fmt_0 x_10430
	       val x_10432: word32 * (word64 -> word8 vector) = 
		  (x_10429, x_10431)
	       val binCvt_0: intInf -> word8 vector = 
		  mkBigCvt_0 x_10432
	       val x_10433: word32 = 
		  0x8
	       val x_10434: StringCvt.radix_0 = 
		  OCT_0
	       val x_10435: word64 -> word8 vector = 
		  fmt_0 x_10434
	       val x_10436: word32 * (word64 -> word8 vector) = 
		  (x_10433, x_10435)
	       val octCvt_0: intInf -> word8 vector = 
		  mkBigCvt_0 x_10436
	       val x_10437: word32 = 
		  0xA
	       val x_10438: StringCvt.radix_0 = 
		  DEC_0
	       val x_10439: word64 -> word8 vector = 
		  fmt_0 x_10438
	       val x_10440: word32 * (word64 -> word8 vector) = 
		  (x_10437, x_10439)
	       val decCvt_0: intInf -> word8 vector = 
		  mkBigCvt_0 x_10440
	       val x_10441: word32 = 
		  0x10
	       val x_10442: StringCvt.radix_0 = 
		  HEX_0
	       val x_10443: word64 -> word8 vector = 
		  fmt_0 x_10442
	       val x_10444: word32 * (word64 -> word8 vector) = 
		  (x_10441, x_10443)
	       val hexCvt_0: intInf -> word8 vector = 
		  mkBigCvt_0 x_10444
	       val precision'_4: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_33
	       val x_10445: word32 * word32 = 
		  (precision'_4, precision'_0)
	       val x_10446: bool = 
		  <_1 x_10445
	       val x_10447: unit = 
		  case x_10446 of
		  true => 
		     let
			val x_10452: unit = 
			   ()
		     in
			x_10452
		     end
		  false => 
		     let
			val x_10448: word8 vector = 
			   "EmbedWord"
			val x_10449: unit ref * word8 vector = 
			   (x_9554, x_10448)
			val x_10450: exn = 
			   Fail_0 x_10449
			val x_10451: unit = 
			   raise x_10450
		     in
			x_10451
		     end
	       val precision'_5: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_34
	       val x_10453: word32 * word32 = 
		  (precision'_5, precision'_0)
	       val x_10454: bool = 
		  <_1 x_10453
	       val x_10455: unit = 
		  case x_10454 of
		  true => 
		     let
			val x_10460: unit = 
			   ()
		     in
			x_10460
		     end
		  false => 
		     let
			val x_10456: word8 vector = 
			   "EmbedWord"
			val x_10457: unit ref * word8 vector = 
			   (x_9554, x_10456)
			val x_10458: exn = 
			   Fail_0 x_10457
			val x_10459: unit = 
			   raise x_10458
		     in
			x_10459
		     end
	       val precision'_6: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_35
	       val x_10461: word32 * word32 = 
		  (precision'_6, precision'_0)
	       val x_10462: bool = 
		  <_1 x_10461
	       val x_10463: unit = 
		  case x_10462 of
		  true => 
		     let
			val x_10468: unit = 
			   ()
		     in
			x_10468
		     end
		  false => 
		     let
			val x_10464: word8 vector = 
			   "EmbedWord"
			val x_10465: unit ref * word8 vector = 
			   (x_9554, x_10464)
			val x_10466: exn = 
			   Fail_0 x_10465
			val x_10467: unit = 
			   raise x_10466
		     in
			x_10467
		     end
	       val precision'_7: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_36
	       val x_10469: word32 * word32 = 
		  (precision'_7, precision'_0)
	       val x_10470: bool = 
		  <_1 x_10469
	       val x_10471: unit = 
		  case x_10470 of
		  true => 
		     let
			val x_10476: unit = 
			   ()
		     in
			x_10476
		     end
		  false => 
		     let
			val x_10472: word8 vector = 
			   "EmbedWord"
			val x_10473: unit ref * word8 vector = 
			   (x_9554, x_10472)
			val x_10474: exn = 
			   Fail_0 x_10473
			val x_10475: unit = 
			   raise x_10474
		     in
			x_10475
		     end
	       val precision'_8: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_37
	       val x_10477: word32 * word32 = 
		  (precision'_8, precision'_0)
	       val x_10478: bool = 
		  <_1 x_10477
	       val x_10479: unit = 
		  case x_10478 of
		  true => 
		     let
			val x_10484: unit = 
			   ()
		     in
			x_10484
		     end
		  false => 
		     let
			val x_10480: word8 vector = 
			   "EmbedWord"
			val x_10481: unit ref * word8 vector = 
			   (x_9554, x_10480)
			val x_10482: exn = 
			   Fail_0 x_10481
			val x_10483: unit = 
			   raise x_10482
		     in
			x_10483
		     end
	       val precision'_9: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_38
	       val x_10485: word32 * word32 = 
		  (precision'_9, precision'_0)
	       val x_10486: bool = 
		  <_1 x_10485
	       val x_10487: unit = 
		  case x_10486 of
		  true => 
		     let
			val x_10492: unit = 
			   ()
		     in
			x_10492
		     end
		  false => 
		     let
			val x_10488: word8 vector = 
			   "EmbedWord"
			val x_10489: unit ref * word8 vector = 
			   (x_9554, x_10488)
			val x_10490: exn = 
			   Fail_0 x_10489
			val x_10491: unit = 
			   raise x_10490
		     in
			x_10491
		     end
	       val precision'_10: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_39
	       val x_10493: word32 * word32 = 
		  (precision'_10, precision'_0)
	       val x_10494: bool = 
		  <_1 x_10493
	       val x_10495: unit = 
		  case x_10494 of
		  true => 
		     let
			val x_10500: unit = 
			   ()
		     in
			x_10500
		     end
		  false => 
		     let
			val x_10496: word8 vector = 
			   "EmbedWord"
			val x_10497: unit ref * word8 vector = 
			   (x_9554, x_10496)
			val x_10498: exn = 
			   Fail_0 x_10497
			val x_10499: unit = 
			   raise x_10498
		     in
			x_10499
		     end
	       val precision'_11: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_41
	       val x_10501: word32 * word32 = 
		  (precision'_11, precision'_1)
	       val x_10502: bool = 
		  <_1 x_10501
	       val x_10503: unit = 
		  case x_10502 of
		  true => 
		     let
			val x_10508: unit = 
			   ()
		     in
			x_10508
		     end
		  false => 
		     let
			val x_10504: word8 vector = 
			   "EmbedWord"
			val x_10505: unit ref * word8 vector = 
			   (x_9554, x_10504)
			val x_10506: exn = 
			   Fail_0 x_10505
			val x_10507: unit = 
			   raise x_10506
		     in
			x_10507
		     end
	       val precision'_12: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_42
	       val x_10509: word32 * word32 = 
		  (precision'_12, precision'_1)
	       val x_10510: bool = 
		  <_1 x_10509
	       val x_10511: unit = 
		  case x_10510 of
		  true => 
		     let
			val x_10516: unit = 
			   ()
		     in
			x_10516
		     end
		  false => 
		     let
			val x_10512: word8 vector = 
			   "EmbedWord"
			val x_10513: unit ref * word8 vector = 
			   (x_9554, x_10512)
			val x_10514: exn = 
			   Fail_0 x_10513
			val x_10515: unit = 
			   raise x_10514
		     in
			x_10515
		     end
	       val precision'_13: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_43
	       val x_10517: word32 * word32 = 
		  (precision'_13, precision'_1)
	       val x_10518: bool = 
		  <_1 x_10517
	       val x_10519: unit = 
		  case x_10518 of
		  true => 
		     let
			val x_10524: unit = 
			   ()
		     in
			x_10524
		     end
		  false => 
		     let
			val x_10520: word8 vector = 
			   "EmbedWord"
			val x_10521: unit ref * word8 vector = 
			   (x_9554, x_10520)
			val x_10522: exn = 
			   Fail_0 x_10521
			val x_10523: unit = 
			   raise x_10522
		     in
			x_10523
		     end
	       val precision'_14: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_44
	       val x_10525: word32 * word32 = 
		  (precision'_14, precision'_1)
	       val x_10526: bool = 
		  <_1 x_10525
	       val x_10527: unit = 
		  case x_10526 of
		  true => 
		     let
			val x_10532: unit = 
			   ()
		     in
			x_10532
		     end
		  false => 
		     let
			val x_10528: word8 vector = 
			   "EmbedWord"
			val x_10529: unit ref * word8 vector = 
			   (x_9554, x_10528)
			val x_10530: exn = 
			   Fail_0 x_10529
			val x_10531: unit = 
			   raise x_10530
		     in
			x_10531
		     end
	       val precision'_15: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_45
	       val x_10533: word32 * word32 = 
		  (precision'_15, precision'_1)
	       val x_10534: bool = 
		  <_1 x_10533
	       val x_10535: unit = 
		  case x_10534 of
		  true => 
		     let
			val x_10540: unit = 
			   ()
		     in
			x_10540
		     end
		  false => 
		     let
			val x_10536: word8 vector = 
			   "EmbedWord"
			val x_10537: unit ref * word8 vector = 
			   (x_9554, x_10536)
			val x_10538: exn = 
			   Fail_0 x_10537
			val x_10539: unit = 
			   raise x_10538
		     in
			x_10539
		     end
	       val precision'_16: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_46
	       val x_10541: word32 * word32 = 
		  (precision'_16, precision'_1)
	       val x_10542: bool = 
		  <_1 x_10541
	       val x_10543: unit = 
		  case x_10542 of
		  true => 
		     let
			val x_10548: unit = 
			   ()
		     in
			x_10548
		     end
		  false => 
		     let
			val x_10544: word8 vector = 
			   "EmbedWord"
			val x_10545: unit ref * word8 vector = 
			   (x_9554, x_10544)
			val x_10546: exn = 
			   Fail_0 x_10545
			val x_10547: unit = 
			   raise x_10546
		     in
			x_10547
		     end
	       val precision'_17: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_47
	       val x_10549: word32 * word32 = 
		  (precision'_17, precision'_1)
	       val x_10550: bool = 
		  <_1 x_10549
	       val x_10551: unit = 
		  case x_10550 of
		  true => 
		     let
			val x_10556: unit = 
			   ()
		     in
			x_10556
		     end
		  false => 
		     let
			val x_10552: word8 vector = 
			   "EmbedWord"
			val x_10553: unit ref * word8 vector = 
			   (x_9554, x_10552)
			val x_10554: exn = 
			   Fail_0 x_10553
			val x_10555: unit = 
			   raise x_10554
		     in
			x_10555
		     end
	       val precision'_18: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_49
	       val x_10557: word32 * word32 = 
		  (precision'_18, precision'_2)
	       val x_10558: bool = 
		  <_1 x_10557
	       val x_10559: unit = 
		  case x_10558 of
		  true => 
		     let
			val x_10564: unit = 
			   ()
		     in
			x_10564
		     end
		  false => 
		     let
			val x_10560: word8 vector = 
			   "EmbedWord"
			val x_10561: unit ref * word8 vector = 
			   (x_9554, x_10560)
			val x_10562: exn = 
			   Fail_0 x_10561
			val x_10563: unit = 
			   raise x_10562
		     in
			x_10563
		     end
	       val precision'_19: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_50
	       val x_10565: word32 * word32 = 
		  (precision'_19, precision'_2)
	       val x_10566: bool = 
		  <_1 x_10565
	       val x_10567: unit = 
		  case x_10566 of
		  true => 
		     let
			val x_10572: unit = 
			   ()
		     in
			x_10572
		     end
		  false => 
		     let
			val x_10568: word8 vector = 
			   "EmbedWord"
			val x_10569: unit ref * word8 vector = 
			   (x_9554, x_10568)
			val x_10570: exn = 
			   Fail_0 x_10569
			val x_10571: unit = 
			   raise x_10570
		     in
			x_10571
		     end
	       val precision'_20: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_51
	       val x_10573: word32 * word32 = 
		  (precision'_20, precision'_2)
	       val x_10574: bool = 
		  <_1 x_10573
	       val x_10575: unit = 
		  case x_10574 of
		  true => 
		     let
			val x_10580: unit = 
			   ()
		     in
			x_10580
		     end
		  false => 
		     let
			val x_10576: word8 vector = 
			   "EmbedWord"
			val x_10577: unit ref * word8 vector = 
			   (x_9554, x_10576)
			val x_10578: exn = 
			   Fail_0 x_10577
			val x_10579: unit = 
			   raise x_10578
		     in
			x_10579
		     end
	       val precision'_21: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_52
	       val x_10581: word32 * word32 = 
		  (precision'_21, precision'_2)
	       val x_10582: bool = 
		  <_1 x_10581
	       val x_10583: unit = 
		  case x_10582 of
		  true => 
		     let
			val x_10588: unit = 
			   ()
		     in
			x_10588
		     end
		  false => 
		     let
			val x_10584: word8 vector = 
			   "EmbedWord"
			val x_10585: unit ref * word8 vector = 
			   (x_9554, x_10584)
			val x_10586: exn = 
			   Fail_0 x_10585
			val x_10587: unit = 
			   raise x_10586
		     in
			x_10587
		     end
	       val precision'_22: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_53
	       val x_10589: word32 * word32 = 
		  (precision'_22, precision'_2)
	       val x_10590: bool = 
		  <_1 x_10589
	       val x_10591: unit = 
		  case x_10590 of
		  true => 
		     let
			val x_10596: unit = 
			   ()
		     in
			x_10596
		     end
		  false => 
		     let
			val x_10592: word8 vector = 
			   "EmbedWord"
			val x_10593: unit ref * word8 vector = 
			   (x_9554, x_10592)
			val x_10594: exn = 
			   Fail_0 x_10593
			val x_10595: unit = 
			   raise x_10594
		     in
			x_10595
		     end
	       val precision'_23: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_54
	       val x_10597: word32 * word32 = 
		  (precision'_23, precision'_2)
	       val x_10598: bool = 
		  <_1 x_10597
	       val x_10599: unit = 
		  case x_10598 of
		  true => 
		     let
			val x_10604: unit = 
			   ()
		     in
			x_10604
		     end
		  false => 
		     let
			val x_10600: word8 vector = 
			   "EmbedWord"
			val x_10601: unit ref * word8 vector = 
			   (x_9554, x_10600)
			val x_10602: exn = 
			   Fail_0 x_10601
			val x_10603: unit = 
			   raise x_10602
		     in
			x_10603
		     end
	       val precision'_24: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_55
	       val x_10605: word32 * word32 = 
		  (precision'_24, precision'_2)
	       val x_10606: bool = 
		  <_1 x_10605
	       val x_10607: unit = 
		  case x_10606 of
		  true => 
		     let
			val x_10612: unit = 
			   ()
		     in
			x_10612
		     end
		  false => 
		     let
			val x_10608: word8 vector = 
			   "EmbedWord"
			val x_10609: unit ref * word8 vector = 
			   (x_9554, x_10608)
			val x_10610: exn = 
			   Fail_0 x_10609
			val x_10611: unit = 
			   raise x_10610
		     in
			x_10611
		     end
	       val precision'_25: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_56
	       val x_10613: word32 * word32 = 
		  (precision'_25, precision'_2)
	       val x_10614: bool = 
		  <_1 x_10613
	       val x_10615: unit = 
		  case x_10614 of
		  true => 
		     let
			val x_10620: unit = 
			   ()
		     in
			x_10620
		     end
		  false => 
		     let
			val x_10616: word8 vector = 
			   "EmbedWord"
			val x_10617: unit ref * word8 vector = 
			   (x_9554, x_10616)
			val x_10618: exn = 
			   Fail_0 x_10617
			val x_10619: unit = 
			   raise x_10618
		     in
			x_10619
		     end
	       val precision'_26: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_57
	       val x_10621: word32 * word32 = 
		  (precision'_26, precision'_2)
	       val x_10622: bool = 
		  <_1 x_10621
	       val x_10623: unit = 
		  case x_10622 of
		  true => 
		     let
			val x_10628: unit = 
			   ()
		     in
			x_10628
		     end
		  false => 
		     let
			val x_10624: word8 vector = 
			   "EmbedWord"
			val x_10625: unit ref * word8 vector = 
			   (x_9554, x_10624)
			val x_10626: exn = 
			   Fail_0 x_10625
			val x_10627: unit = 
			   raise x_10626
		     in
			x_10627
		     end
	       val precision'_27: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_58
	       val x_10629: word32 * word32 = 
		  (precision'_27, precision'_2)
	       val x_10630: bool = 
		  <_1 x_10629
	       val x_10631: unit = 
		  case x_10630 of
		  true => 
		     let
			val x_10636: unit = 
			   ()
		     in
			x_10636
		     end
		  false => 
		     let
			val x_10632: word8 vector = 
			   "EmbedWord"
			val x_10633: unit ref * word8 vector = 
			   (x_9554, x_10632)
			val x_10634: exn = 
			   Fail_0 x_10633
			val x_10635: unit = 
			   raise x_10634
		     in
			x_10635
		     end
	       val precision'_28: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_59
	       val x_10637: word32 * word32 = 
		  (precision'_28, precision'_2)
	       val x_10638: bool = 
		  <_1 x_10637
	       val x_10639: unit = 
		  case x_10638 of
		  true => 
		     let
			val x_10644: unit = 
			   ()
		     in
			x_10644
		     end
		  false => 
		     let
			val x_10640: word8 vector = 
			   "EmbedWord"
			val x_10641: unit ref * word8 vector = 
			   (x_9554, x_10640)
			val x_10642: exn = 
			   Fail_0 x_10641
			val x_10643: unit = 
			   raise x_10642
		     in
			x_10643
		     end
	       val precision'_29: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_60
	       val x_10645: word32 * word32 = 
		  (precision'_29, precision'_2)
	       val x_10646: bool = 
		  <_1 x_10645
	       val x_10647: unit = 
		  case x_10646 of
		  true => 
		     let
			val x_10652: unit = 
			   ()
		     in
			x_10652
		     end
		  false => 
		     let
			val x_10648: word8 vector = 
			   "EmbedWord"
			val x_10649: unit ref * word8 vector = 
			   (x_9554, x_10648)
			val x_10650: exn = 
			   Fail_0 x_10649
			val x_10651: unit = 
			   raise x_10650
		     in
			x_10651
		     end
	       val precision'_30: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_61
	       val x_10653: word32 * word32 = 
		  (precision'_30, precision'_2)
	       val x_10654: bool = 
		  <_1 x_10653
	       val x_10655: unit = 
		  case x_10654 of
		  true => 
		     let
			val x_10660: unit = 
			   ()
		     in
			x_10660
		     end
		  false => 
		     let
			val x_10656: word8 vector = 
			   "EmbedWord"
			val x_10657: unit ref * word8 vector = 
			   (x_9554, x_10656)
			val x_10658: exn = 
			   Fail_0 x_10657
			val x_10659: unit = 
			   raise x_10658
		     in
			x_10659
		     end
	       val precision'_31: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_62
	       val x_10661: word32 * word32 = 
		  (precision'_31, precision'_2)
	       val x_10662: bool = 
		  <_1 x_10661
	       val x_10663: unit = 
		  case x_10662 of
		  true => 
		     let
			val x_10668: unit = 
			   ()
		     in
			x_10668
		     end
		  false => 
		     let
			val x_10664: word8 vector = 
			   "EmbedWord"
			val x_10665: unit ref * word8 vector = 
			   (x_9554, x_10664)
			val x_10666: exn = 
			   Fail_0 x_10665
			val x_10667: unit = 
			   raise x_10666
		     in
			x_10667
		     end
	       val precision'_32: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_63
	       val x_10669: word32 * word32 = 
		  (precision'_32, precision'_2)
	       val x_10670: bool = 
		  <_1 x_10669
	       val x_10671: unit = 
		  case x_10670 of
		  true => 
		     let
			val x_10676: unit = 
			   ()
		     in
			x_10676
		     end
		  false => 
		     let
			val x_10672: word8 vector = 
			   "EmbedWord"
			val x_10673: unit ref * word8 vector = 
			   (x_9554, x_10672)
			val x_10674: exn = 
			   Fail_0 x_10673
			val x_10675: unit = 
			   raise x_10674
		     in
			x_10675
		     end
	       val wordSize_4: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_0
	       val x_10677: word32 * word32 = 
		  (wordSize_4, wordSize_0)
	       val x_10678: bool = 
		  <_1 x_10677
	       val x_10679: unit = 
		  case x_10678 of
		  true => 
		     let
			val x_10684: unit = 
			   ()
		     in
			x_10684
		     end
		  false => 
		     let
			val x_10680: word8 vector = 
			   "EmbedWord"
			val x_10681: unit ref * word8 vector = 
			   (x_9554, x_10680)
			val x_10682: exn = 
			   Fail_0 x_10681
			val x_10683: unit = 
			   raise x_10682
		     in
			x_10683
		     end
	       val wordSize_5: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_1
	       val x_10685: word32 * word32 = 
		  (wordSize_5, wordSize_0)
	       val x_10686: bool = 
		  <_1 x_10685
	       val x_10687: unit = 
		  case x_10686 of
		  true => 
		     let
			val x_10692: unit = 
			   ()
		     in
			x_10692
		     end
		  false => 
		     let
			val x_10688: word8 vector = 
			   "EmbedWord"
			val x_10689: unit ref * word8 vector = 
			   (x_9554, x_10688)
			val x_10690: exn = 
			   Fail_0 x_10689
			val x_10691: unit = 
			   raise x_10690
		     in
			x_10691
		     end
	       val wordSize_6: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_2
	       val x_10693: word32 * word32 = 
		  (wordSize_6, wordSize_0)
	       val x_10694: bool = 
		  <_1 x_10693
	       val x_10695: unit = 
		  case x_10694 of
		  true => 
		     let
			val x_10700: unit = 
			   ()
		     in
			x_10700
		     end
		  false => 
		     let
			val x_10696: word8 vector = 
			   "EmbedWord"
			val x_10697: unit ref * word8 vector = 
			   (x_9554, x_10696)
			val x_10698: exn = 
			   Fail_0 x_10697
			val x_10699: unit = 
			   raise x_10698
		     in
			x_10699
		     end
	       val wordSize_7: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_3
	       val x_10701: word32 * word32 = 
		  (wordSize_7, wordSize_0)
	       val x_10702: bool = 
		  <_1 x_10701
	       val x_10703: unit = 
		  case x_10702 of
		  true => 
		     let
			val x_10708: unit = 
			   ()
		     in
			x_10708
		     end
		  false => 
		     let
			val x_10704: word8 vector = 
			   "EmbedWord"
			val x_10705: unit ref * word8 vector = 
			   (x_9554, x_10704)
			val x_10706: exn = 
			   Fail_0 x_10705
			val x_10707: unit = 
			   raise x_10706
		     in
			x_10707
		     end
	       val wordSize_8: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_4
	       val x_10709: word32 * word32 = 
		  (wordSize_8, wordSize_0)
	       val x_10710: bool = 
		  <_1 x_10709
	       val x_10711: unit = 
		  case x_10710 of
		  true => 
		     let
			val x_10716: unit = 
			   ()
		     in
			x_10716
		     end
		  false => 
		     let
			val x_10712: word8 vector = 
			   "EmbedWord"
			val x_10713: unit ref * word8 vector = 
			   (x_9554, x_10712)
			val x_10714: exn = 
			   Fail_0 x_10713
			val x_10715: unit = 
			   raise x_10714
		     in
			x_10715
		     end
	       val wordSize_9: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_5
	       val x_10717: word32 * word32 = 
		  (wordSize_9, wordSize_0)
	       val x_10718: bool = 
		  <_1 x_10717
	       val x_10719: unit = 
		  case x_10718 of
		  true => 
		     let
			val x_10724: unit = 
			   ()
		     in
			x_10724
		     end
		  false => 
		     let
			val x_10720: word8 vector = 
			   "EmbedWord"
			val x_10721: unit ref * word8 vector = 
			   (x_9554, x_10720)
			val x_10722: exn = 
			   Fail_0 x_10721
			val x_10723: unit = 
			   raise x_10722
		     in
			x_10723
		     end
	       val wordSize_10: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_6
	       val x_10725: word32 * word32 = 
		  (wordSize_10, wordSize_0)
	       val x_10726: bool = 
		  <_1 x_10725
	       val x_10727: unit = 
		  case x_10726 of
		  true => 
		     let
			val x_10732: unit = 
			   ()
		     in
			x_10732
		     end
		  false => 
		     let
			val x_10728: word8 vector = 
			   "EmbedWord"
			val x_10729: unit ref * word8 vector = 
			   (x_9554, x_10728)
			val x_10730: exn = 
			   Fail_0 x_10729
			val x_10731: unit = 
			   raise x_10730
		     in
			x_10731
		     end
	       val wordSize_11: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_8
	       val x_10733: word32 * word32 = 
		  (wordSize_11, wordSize_1)
	       val x_10734: bool = 
		  <_1 x_10733
	       val x_10735: unit = 
		  case x_10734 of
		  true => 
		     let
			val x_10740: unit = 
			   ()
		     in
			x_10740
		     end
		  false => 
		     let
			val x_10736: word8 vector = 
			   "EmbedWord"
			val x_10737: unit ref * word8 vector = 
			   (x_9554, x_10736)
			val x_10738: exn = 
			   Fail_0 x_10737
			val x_10739: unit = 
			   raise x_10738
		     in
			x_10739
		     end
	       val wordSize_12: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_9
	       val x_10741: word32 * word32 = 
		  (wordSize_12, wordSize_1)
	       val x_10742: bool = 
		  <_1 x_10741
	       val x_10743: unit = 
		  case x_10742 of
		  true => 
		     let
			val x_10748: unit = 
			   ()
		     in
			x_10748
		     end
		  false => 
		     let
			val x_10744: word8 vector = 
			   "EmbedWord"
			val x_10745: unit ref * word8 vector = 
			   (x_9554, x_10744)
			val x_10746: exn = 
			   Fail_0 x_10745
			val x_10747: unit = 
			   raise x_10746
		     in
			x_10747
		     end
	       val wordSize_13: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_10
	       val x_10749: word32 * word32 = 
		  (wordSize_13, wordSize_1)
	       val x_10750: bool = 
		  <_1 x_10749
	       val x_10751: unit = 
		  case x_10750 of
		  true => 
		     let
			val x_10756: unit = 
			   ()
		     in
			x_10756
		     end
		  false => 
		     let
			val x_10752: word8 vector = 
			   "EmbedWord"
			val x_10753: unit ref * word8 vector = 
			   (x_9554, x_10752)
			val x_10754: exn = 
			   Fail_0 x_10753
			val x_10755: unit = 
			   raise x_10754
		     in
			x_10755
		     end
	       val wordSize_14: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_11
	       val x_10757: word32 * word32 = 
		  (wordSize_14, wordSize_1)
	       val x_10758: bool = 
		  <_1 x_10757
	       val x_10759: unit = 
		  case x_10758 of
		  true => 
		     let
			val x_10764: unit = 
			   ()
		     in
			x_10764
		     end
		  false => 
		     let
			val x_10760: word8 vector = 
			   "EmbedWord"
			val x_10761: unit ref * word8 vector = 
			   (x_9554, x_10760)
			val x_10762: exn = 
			   Fail_0 x_10761
			val x_10763: unit = 
			   raise x_10762
		     in
			x_10763
		     end
	       val wordSize_15: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_12
	       val x_10765: word32 * word32 = 
		  (wordSize_15, wordSize_1)
	       val x_10766: bool = 
		  <_1 x_10765
	       val x_10767: unit = 
		  case x_10766 of
		  true => 
		     let
			val x_10772: unit = 
			   ()
		     in
			x_10772
		     end
		  false => 
		     let
			val x_10768: word8 vector = 
			   "EmbedWord"
			val x_10769: unit ref * word8 vector = 
			   (x_9554, x_10768)
			val x_10770: exn = 
			   Fail_0 x_10769
			val x_10771: unit = 
			   raise x_10770
		     in
			x_10771
		     end
	       val wordSize_16: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_13
	       val x_10773: word32 * word32 = 
		  (wordSize_16, wordSize_1)
	       val x_10774: bool = 
		  <_1 x_10773
	       val x_10775: unit = 
		  case x_10774 of
		  true => 
		     let
			val x_10780: unit = 
			   ()
		     in
			x_10780
		     end
		  false => 
		     let
			val x_10776: word8 vector = 
			   "EmbedWord"
			val x_10777: unit ref * word8 vector = 
			   (x_9554, x_10776)
			val x_10778: exn = 
			   Fail_0 x_10777
			val x_10779: unit = 
			   raise x_10778
		     in
			x_10779
		     end
	       val wordSize_17: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_14
	       val x_10781: word32 * word32 = 
		  (wordSize_17, wordSize_1)
	       val x_10782: bool = 
		  <_1 x_10781
	       val x_10783: unit = 
		  case x_10782 of
		  true => 
		     let
			val x_10788: unit = 
			   ()
		     in
			x_10788
		     end
		  false => 
		     let
			val x_10784: word8 vector = 
			   "EmbedWord"
			val x_10785: unit ref * word8 vector = 
			   (x_9554, x_10784)
			val x_10786: exn = 
			   Fail_0 x_10785
			val x_10787: unit = 
			   raise x_10786
		     in
			x_10787
		     end
	       val wordSize_18: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_16
	       val x_10789: word32 * word32 = 
		  (wordSize_18, wordSize_2)
	       val x_10790: bool = 
		  <_1 x_10789
	       val x_10791: unit = 
		  case x_10790 of
		  true => 
		     let
			val x_10796: unit = 
			   ()
		     in
			x_10796
		     end
		  false => 
		     let
			val x_10792: word8 vector = 
			   "EmbedWord"
			val x_10793: unit ref * word8 vector = 
			   (x_9554, x_10792)
			val x_10794: exn = 
			   Fail_0 x_10793
			val x_10795: unit = 
			   raise x_10794
		     in
			x_10795
		     end
	       val wordSize_19: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_17
	       val x_10797: word32 * word32 = 
		  (wordSize_19, wordSize_2)
	       val x_10798: bool = 
		  <_1 x_10797
	       val x_10799: unit = 
		  case x_10798 of
		  true => 
		     let
			val x_10804: unit = 
			   ()
		     in
			x_10804
		     end
		  false => 
		     let
			val x_10800: word8 vector = 
			   "EmbedWord"
			val x_10801: unit ref * word8 vector = 
			   (x_9554, x_10800)
			val x_10802: exn = 
			   Fail_0 x_10801
			val x_10803: unit = 
			   raise x_10802
		     in
			x_10803
		     end
	       val wordSize_20: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_18
	       val x_10805: word32 * word32 = 
		  (wordSize_20, wordSize_2)
	       val x_10806: bool = 
		  <_1 x_10805
	       val x_10807: unit = 
		  case x_10806 of
		  true => 
		     let
			val x_10812: unit = 
			   ()
		     in
			x_10812
		     end
		  false => 
		     let
			val x_10808: word8 vector = 
			   "EmbedWord"
			val x_10809: unit ref * word8 vector = 
			   (x_9554, x_10808)
			val x_10810: exn = 
			   Fail_0 x_10809
			val x_10811: unit = 
			   raise x_10810
		     in
			x_10811
		     end
	       val wordSize_21: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_19
	       val x_10813: word32 * word32 = 
		  (wordSize_21, wordSize_2)
	       val x_10814: bool = 
		  <_1 x_10813
	       val x_10815: unit = 
		  case x_10814 of
		  true => 
		     let
			val x_10820: unit = 
			   ()
		     in
			x_10820
		     end
		  false => 
		     let
			val x_10816: word8 vector = 
			   "EmbedWord"
			val x_10817: unit ref * word8 vector = 
			   (x_9554, x_10816)
			val x_10818: exn = 
			   Fail_0 x_10817
			val x_10819: unit = 
			   raise x_10818
		     in
			x_10819
		     end
	       val wordSize_22: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_20
	       val x_10821: word32 * word32 = 
		  (wordSize_22, wordSize_2)
	       val x_10822: bool = 
		  <_1 x_10821
	       val x_10823: unit = 
		  case x_10822 of
		  true => 
		     let
			val x_10828: unit = 
			   ()
		     in
			x_10828
		     end
		  false => 
		     let
			val x_10824: word8 vector = 
			   "EmbedWord"
			val x_10825: unit ref * word8 vector = 
			   (x_9554, x_10824)
			val x_10826: exn = 
			   Fail_0 x_10825
			val x_10827: unit = 
			   raise x_10826
		     in
			x_10827
		     end
	       val wordSize_23: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_21
	       val x_10829: word32 * word32 = 
		  (wordSize_23, wordSize_2)
	       val x_10830: bool = 
		  <_1 x_10829
	       val x_10831: unit = 
		  case x_10830 of
		  true => 
		     let
			val x_10836: unit = 
			   ()
		     in
			x_10836
		     end
		  false => 
		     let
			val x_10832: word8 vector = 
			   "EmbedWord"
			val x_10833: unit ref * word8 vector = 
			   (x_9554, x_10832)
			val x_10834: exn = 
			   Fail_0 x_10833
			val x_10835: unit = 
			   raise x_10834
		     in
			x_10835
		     end
	       val wordSize_24: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_22
	       val x_10837: word32 * word32 = 
		  (wordSize_24, wordSize_2)
	       val x_10838: bool = 
		  <_1 x_10837
	       val x_10839: unit = 
		  case x_10838 of
		  true => 
		     let
			val x_10844: unit = 
			   ()
		     in
			x_10844
		     end
		  false => 
		     let
			val x_10840: word8 vector = 
			   "EmbedWord"
			val x_10841: unit ref * word8 vector = 
			   (x_9554, x_10840)
			val x_10842: exn = 
			   Fail_0 x_10841
			val x_10843: unit = 
			   raise x_10842
		     in
			x_10843
		     end
	       val wordSize_25: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_23
	       val x_10845: word32 * word32 = 
		  (wordSize_25, wordSize_2)
	       val x_10846: bool = 
		  <_1 x_10845
	       val x_10847: unit = 
		  case x_10846 of
		  true => 
		     let
			val x_10852: unit = 
			   ()
		     in
			x_10852
		     end
		  false => 
		     let
			val x_10848: word8 vector = 
			   "EmbedWord"
			val x_10849: unit ref * word8 vector = 
			   (x_9554, x_10848)
			val x_10850: exn = 
			   Fail_0 x_10849
			val x_10851: unit = 
			   raise x_10850
		     in
			x_10851
		     end
	       val wordSize_26: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_24
	       val x_10853: word32 * word32 = 
		  (wordSize_26, wordSize_2)
	       val x_10854: bool = 
		  <_1 x_10853
	       val x_10855: unit = 
		  case x_10854 of
		  true => 
		     let
			val x_10860: unit = 
			   ()
		     in
			x_10860
		     end
		  false => 
		     let
			val x_10856: word8 vector = 
			   "EmbedWord"
			val x_10857: unit ref * word8 vector = 
			   (x_9554, x_10856)
			val x_10858: exn = 
			   Fail_0 x_10857
			val x_10859: unit = 
			   raise x_10858
		     in
			x_10859
		     end
	       val wordSize_27: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_25
	       val x_10861: word32 * word32 = 
		  (wordSize_27, wordSize_2)
	       val x_10862: bool = 
		  <_1 x_10861
	       val x_10863: unit = 
		  case x_10862 of
		  true => 
		     let
			val x_10868: unit = 
			   ()
		     in
			x_10868
		     end
		  false => 
		     let
			val x_10864: word8 vector = 
			   "EmbedWord"
			val x_10865: unit ref * word8 vector = 
			   (x_9554, x_10864)
			val x_10866: exn = 
			   Fail_0 x_10865
			val x_10867: unit = 
			   raise x_10866
		     in
			x_10867
		     end
	       val wordSize_28: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_26
	       val x_10869: word32 * word32 = 
		  (wordSize_28, wordSize_2)
	       val x_10870: bool = 
		  <_1 x_10869
	       val x_10871: unit = 
		  case x_10870 of
		  true => 
		     let
			val x_10876: unit = 
			   ()
		     in
			x_10876
		     end
		  false => 
		     let
			val x_10872: word8 vector = 
			   "EmbedWord"
			val x_10873: unit ref * word8 vector = 
			   (x_9554, x_10872)
			val x_10874: exn = 
			   Fail_0 x_10873
			val x_10875: unit = 
			   raise x_10874
		     in
			x_10875
		     end
	       val wordSize_29: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_27
	       val x_10877: word32 * word32 = 
		  (wordSize_29, wordSize_2)
	       val x_10878: bool = 
		  <_1 x_10877
	       val x_10879: unit = 
		  case x_10878 of
		  true => 
		     let
			val x_10884: unit = 
			   ()
		     in
			x_10884
		     end
		  false => 
		     let
			val x_10880: word8 vector = 
			   "EmbedWord"
			val x_10881: unit ref * word8 vector = 
			   (x_9554, x_10880)
			val x_10882: exn = 
			   Fail_0 x_10881
			val x_10883: unit = 
			   raise x_10882
		     in
			x_10883
		     end
	       val wordSize_30: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_28
	       val x_10885: word32 * word32 = 
		  (wordSize_30, wordSize_2)
	       val x_10886: bool = 
		  <_1 x_10885
	       val x_10887: unit = 
		  case x_10886 of
		  true => 
		     let
			val x_10892: unit = 
			   ()
		     in
			x_10892
		     end
		  false => 
		     let
			val x_10888: word8 vector = 
			   "EmbedWord"
			val x_10889: unit ref * word8 vector = 
			   (x_9554, x_10888)
			val x_10890: exn = 
			   Fail_0 x_10889
			val x_10891: unit = 
			   raise x_10890
		     in
			x_10891
		     end
	       val wordSize_31: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_29
	       val x_10893: word32 * word32 = 
		  (wordSize_31, wordSize_2)
	       val x_10894: bool = 
		  <_1 x_10893
	       val x_10895: unit = 
		  case x_10894 of
		  true => 
		     let
			val x_10900: unit = 
			   ()
		     in
			x_10900
		     end
		  false => 
		     let
			val x_10896: word8 vector = 
			   "EmbedWord"
			val x_10897: unit ref * word8 vector = 
			   (x_9554, x_10896)
			val x_10898: exn = 
			   Fail_0 x_10897
			val x_10899: unit = 
			   raise x_10898
		     in
			x_10899
		     end
	       val wordSize_32: word32 = 
		  sextdFromInt32ToInt32_0 sizeInBits_30
	       val x_10901: word32 * word32 = 
		  (wordSize_32, wordSize_2)
	       val x_10902: bool = 
		  <_1 x_10901
	       val x_10903: unit = 
		  case x_10902 of
		  true => 
		     let
			val x_10908: unit = 
			   ()
		     in
			x_10908
		     end
		  false => 
		     let
			val x_10904: word8 vector = 
			   "EmbedWord"
			val x_10905: unit ref * word8 vector = 
			   (x_9554, x_10904)
			val x_10906: exn = 
			   Fail_0 x_10905
			val x_10907: unit = 
			   raise x_10906
		     in
			x_10907
		     end
	       val x_10909: word32 = 
		  0x1
	       val x_10910: word32 * word32 = 
		  (x_9889, x_10909)
	       val maxOrd_0: word32 = 
		  x_8548 x_10910
	       val x_10911: word32 = 
		  0x0
	       val x_10912: word32 = 
		  idFromInt32ToWord32_0 maxOrd_0
	       val x_10913: word32 = 
		  idFromInt32ToWord32_0 x_10911
	       val x_10914: word32 * word32 = 
		  (x_10912, x_10913)
	       val x_10915: bool = 
		  <_0 x_10914
	       val x_10916: Primitive.Option.t_6 = 
		  case x_10915 of
		  true => 
		     let
			val x_10919: Primitive.Option.t_6 = 
			   NONE_6
		     in
			x_10919
		     end
		  false => 
		     let
			val x_10917: word8 = 
			   x_9882 x_10911
			val x_10918: Primitive.Option.t_6 = 
			   SOME_6 x_10917
		     in
			x_10918
		     end
	       val x_10920: word8 = 
		  case x_10916 of
		  NONE_6 => 
		     let
			val x_10922: word8 = 
			   raise x_9552
		     in
			x_10922
		     end
		  SOME_6 x_10921: word8 => 
		     let
		     in
			x_10921
		     end
	       val x_10923: word32 = 
		  0x1
	       val x_10924: unit = 
		  ()
	       val x_10925: word64 = 
		  let
		     val x_10926: word64 = 
			sextdFromInt32ToInt64_0 x_10923
		  in
		     x_10926
		  end
		  handle x_10927 => let
				       val x_10928: unit -> word64 = 
					  fn unit_16: unit => 
					  let
					     val x_10929: word64 = 
						raise x_10927
					  in
					     x_10929
					  end
				       val x_10930: word64 = 
					  case x_10927 of
					  Overflow_0 x_10931: unit ref => 
					     let
						val x_10932: bool = 
						   MLton_equal[unit ref] (x_10931,
									  x_8289)
						val x_10933: word64 = 
						   case x_10932 of
						   true => 
						      let
							 val x_10936: word64 = 
							    raise x_8293
						      in
							 x_10936
						      end
						   false => 
						      let
							 val x_10934: unit = 
							    ()
							 val x_10935: word64 = 
							    x_10928 x_10934
						      in
							 x_10935
						      end
					     in
						x_10933
					     end
					    _ => let
						    val x_10937: unit = 
						       ()
						    val x_10938: word64 = 
						       x_10928 x_10937
						 in
						    x_10938
						 end
				    in
				       x_10930
				    end
	       val a_17: word8 array = 
		  arrayUninit_1 x_10925
	       val rec 
		  loop_19: word64 * unit -> unit = 
		     fn x_10939: word64 * unit => 
		     let
			val b_39: unit = 
			   #1 x_10939
			val i_34: word64 = 
			   #0 x_10939
			val x_10940: word64 * word64 = 
			   (i_34, x_10925)
			val x_10941: bool = 
			   >=_2 x_10940
			val x_10942: unit = 
			   case x_10941 of
			   true => 
			      let
			      in
				 b_39
			      end
			   false => 
			      let
				 val x_10943: unit = 
				    ()
				 val x_10944: word8 array * word64 * word8 = 
				    (a_17, i_34, x_10920)
				 val x_10945: unit = 
				    x_8677 x_10944
				 val x_10946: word64 = 
				    0x1
				 val x_10947: word64 * word64 = 
				    (i_34, x_10946)
				 val x_10948: word64 = 
				    +?_1 x_10947
				 val x_10949: word64 * unit = 
				    (x_10948, x_10943)
				 val x_10950: unit = 
				    loop_19 x_10949
			      in
				 x_10950
			      end
		     in
			x_10942
		     end
	       val x_10951: word64 = 
		  0x0
	       val x_10952: word64 * unit = 
		  (x_10951, x_10924)
	       val b_40: unit = 
		  loop_19 x_10952
	       val x_10953: word8 vector = 
		  x_8683 a_17
	       val x_10954: exn -> Primitive.Option.t_1 = 
		  fn x_10955: exn => 
		  let
		     val x_10956: unit -> Primitive.Option.t_1 = 
			fn unit_17: unit => 
			let
			   val x_10957: Primitive.Option.t_1 = 
			      NONE_1
			in
			   x_10957
			end
		     val x_10958: Primitive.Option.t_1 = 
			case x_10955 of
			Fail_0 x_10959: unit ref * word8 vector => 
			   let
			      val x_10960: word8 vector = 
				 #1 x_10959
			      val x_10961: unit ref = 
				 #0 x_10959
			      val x_10962: bool = 
				 MLton_equal[unit ref] (x_10961, x_9554)
			      val x_10963: Primitive.Option.t_1 = 
				 case x_10962 of
				 true => 
				    let
				       val x_10966: list_7 = 
					  nil_7
				       val x_10967: word8 vector * list_7 = 
					  (x_10960, x_10966)
				       val x_10968: list_7 = 
					  ::_7 x_10967
				       val x_10969: word8 vector = 
					  "Fail: "
				       val x_10970: word8 vector * list_7 = 
					  (x_10969, x_10968)
				       val x_10971: list_7 = 
					  ::_7 x_10970
				       val x_10972: word8 vector = 
					  concat_3 x_10971
				       val x_10973: Primitive.Option.t_1 = 
					  SOME_1 x_10972
				    in
				       x_10973
				    end
				 false => 
				    let
				       val x_10964: unit = 
					  ()
				       val x_10965: Primitive.Option.t_1 = 
					  x_10956 x_10964
				    in
				       x_10965
				    end
			   in
			      x_10963
			   end
			  _ => let
				  val x_10974: unit = 
				     ()
				  val x_10975: Primitive.Option.t_1 = 
				     x_10956 x_10974
			       in
				  x_10975
			       end
		  in
		     x_10958
		  end
	       val x_10976: list_0 = 
		  x_8318 messagers_0
	       val x_10977: (exn -> Primitive.Option.t_1) * list_0 = 
		  (x_10954, x_10976)
	       val x_10978: list_0 = 
		  ::_0 x_10977
	       val x_10979: unit = 
		  Ref_assign[list_0] (messagers_0, x_10978)
	       val rec 
		  sub_12: word64 * word32 -> word8 = 
		     fn x_10980: word64 * word32 => 
		     let
			val i_35: word32 = 
			   #1 x_10980
			val cs_0: word64 = 
			   #0 x_10980
			val x_10981: cpointer = 
			   fromWord_1 cs_0
			val x_10982: word64 = 
			   sextdFromInt32ToInt64_0 i_35
			val x_10983: word8 = 
			   CPointer_getWord8 (x_10981, x_10982)
			val x_10984: word8 = 
			   idFromWord8_0 x_10983
		     in
			x_10984
		     end
	       val rec 
		  new_3: unit -> list_2 ref = 
		     fn x_10985: unit => 
		     let
			val x_10986: list_2 = 
			   nil_2
			val x_10987: list_2 ref = 
			   Ref_ref[list_2] (x_10986)
		     in
			x_10987
		     end
	       val x_10988: unit = 
		  ()
	       val atExit_0: list_2 ref = 
		  new_3 x_10988
	       val x_10989: unit = 
		  ()
	       val atLoadWorld_0: list_2 ref = 
		  new_3 x_10989
	       val toRep_0: word32 -> word32 = 
		  fn x_10990: word32 => 
		  let
		  in
		     x_10990
		  end
	       val fromRep_0: word32 -> word32 = 
		  fn x_10991: word32 => 
		  let
		  in
		     x_10991
		  end
	       val toRep_1: word32 -> word32 = 
		  fn x_10992: word32 => 
		  let
		  in
		     x_10992
		  end
	       val fromRep_1: word32 -> word32 = 
		  fn x_10993: word32 => 
		  let
		  in
		     x_10993
		  end
	       val acces_0: word32 = 
		  fromRep_1 EACCES_0
	       val addrinuse_0: word32 = 
		  fromRep_1 EADDRINUSE_0
	       val addrnotavail_0: word32 = 
		  fromRep_1 EADDRNOTAVAIL_0
	       val afnosupport_0: word32 = 
		  fromRep_1 EAFNOSUPPORT_0
	       val again_0: word32 = 
		  fromRep_1 EAGAIN_0
	       val already_0: word32 = 
		  fromRep_1 EALREADY_0
	       val badf_0: word32 = 
		  fromRep_1 EBADF_0
	       val badmsg_0: word32 = 
		  fromRep_1 EBADMSG_0
	       val busy_0: word32 = 
		  fromRep_1 EBUSY_0
	       val canceled_0: word32 = 
		  fromRep_1 ECANCELED_0
	       val child_0: word32 = 
		  fromRep_1 ECHILD_0
	       val connaborted_0: word32 = 
		  fromRep_1 ECONNABORTED_0
	       val connrefused_0: word32 = 
		  fromRep_1 ECONNREFUSED_0
	       val connreset_0: word32 = 
		  fromRep_1 ECONNRESET_0
	       val deadlk_0: word32 = 
		  fromRep_1 EDEADLK_0
	       val destaddrreq_0: word32 = 
		  fromRep_1 EDESTADDRREQ_0
	       val dom_0: word32 = 
		  fromRep_1 EDOM_0
	       val dquot_0: word32 = 
		  fromRep_1 EDQUOT_0
	       val exist_0: word32 = 
		  fromRep_1 EEXIST_0
	       val fault_0: word32 = 
		  fromRep_1 EFAULT_0
	       val fbig_0: word32 = 
		  fromRep_1 EFBIG_0
	       val hostunreach_0: word32 = 
		  fromRep_1 EHOSTUNREACH_0
	       val idrm_0: word32 = 
		  fromRep_1 EIDRM_0
	       val ilseq_0: word32 = 
		  fromRep_1 EILSEQ_0
	       val inprogress_0: word32 = 
		  fromRep_1 EINPROGRESS_0
	       val intr_0: word32 = 
		  fromRep_1 EINTR_0
	       val inval_0: word32 = 
		  fromRep_1 EINVAL_0
	       val io_0: word32 = 
		  fromRep_1 EIO_0
	       val isconn_0: word32 = 
		  fromRep_1 EISCONN_0
	       val isdir_0: word32 = 
		  fromRep_1 EISDIR_0
	       val loop_20: word32 = 
		  fromRep_1 ELOOP_0
	       val mfile_0: word32 = 
		  fromRep_1 EMFILE_0
	       val mlink_0: word32 = 
		  fromRep_1 EMLINK_0
	       val msgsize_0: word32 = 
		  fromRep_1 EMSGSIZE_0
	       val multihop_0: word32 = 
		  fromRep_1 EMULTIHOP_0
	       val nametoolong_0: word32 = 
		  fromRep_1 ENAMETOOLONG_0
	       val netdown_0: word32 = 
		  fromRep_1 ENETDOWN_0
	       val netreset_0: word32 = 
		  fromRep_1 ENETRESET_0
	       val netunreach_0: word32 = 
		  fromRep_1 ENETUNREACH_0
	       val nfile_0: word32 = 
		  fromRep_1 ENFILE_0
	       val nobufs_0: word32 = 
		  fromRep_1 ENOBUFS_0
	       val nodata_0: word32 = 
		  fromRep_1 ENODATA_0
	       val nodev_0: word32 = 
		  fromRep_1 ENODEV_0
	       val noent_0: word32 = 
		  fromRep_1 ENOENT_0
	       val noexec_0: word32 = 
		  fromRep_1 ENOEXEC_0
	       val nolck_0: word32 = 
		  fromRep_1 ENOLCK_0
	       val nolink_0: word32 = 
		  fromRep_1 ENOLINK_0
	       val nomem_0: word32 = 
		  fromRep_1 ENOMEM_0
	       val nomsg_0: word32 = 
		  fromRep_1 ENOMSG_0
	       val noprotoopt_0: word32 = 
		  fromRep_1 ENOPROTOOPT_0
	       val nospc_0: word32 = 
		  fromRep_1 ENOSPC_0
	       val nosr_0: word32 = 
		  fromRep_1 ENOSR_0
	       val nostr_0: word32 = 
		  fromRep_1 ENOSTR_0
	       val nosys_0: word32 = 
		  fromRep_1 ENOSYS_0
	       val notconn_0: word32 = 
		  fromRep_1 ENOTCONN_0
	       val notdir_0: word32 = 
		  fromRep_1 ENOTDIR_0
	       val notempty_0: word32 = 
		  fromRep_1 ENOTEMPTY_0
	       val notsock_0: word32 = 
		  fromRep_1 ENOTSOCK_0
	       val notsup_0: word32 = 
		  fromRep_1 ENOTSUP_0
	       val notty_0: word32 = 
		  fromRep_1 ENOTTY_0
	       val nxio_0: word32 = 
		  fromRep_1 ENXIO_0
	       val opnotsupp_0: word32 = 
		  fromRep_1 EOPNOTSUPP_0
	       val overflow_0: word32 = 
		  fromRep_1 EOVERFLOW_0
	       val perm_0: word32 = 
		  fromRep_1 EPERM_0
	       val pipe_0: word32 = 
		  fromRep_1 EPIPE_0
	       val proto_0: word32 = 
		  fromRep_1 EPROTO_0
	       val protonosupport_0: word32 = 
		  fromRep_1 EPROTONOSUPPORT_0
	       val prototype_0: word32 = 
		  fromRep_1 EPROTOTYPE_0
	       val range_1: word32 = 
		  fromRep_1 ERANGE_0
	       val rofs_0: word32 = 
		  fromRep_1 EROFS_0
	       val spipe_0: word32 = 
		  fromRep_1 ESPIPE_0
	       val srch_0: word32 = 
		  fromRep_1 ESRCH_0
	       val stale_0: word32 = 
		  fromRep_1 ESTALE_0
	       val time_0: word32 = 
		  fromRep_1 ETIME_0
	       val timedout_0: word32 = 
		  fromRep_1 ETIMEDOUT_0
	       val toobig_0: word32 = 
		  fromRep_1 E2BIG_0
	       val txtbsy_0: word32 = 
		  fromRep_1 ETXTBSY_0
	       val wouldblock_0: word32 = 
		  fromRep_1 EWOULDBLOCK_0
	       val xdev_0: word32 = 
		  fromRep_1 EXDEV_0
	       val rec 
		  ::?_0: (word32 * word8 vector) * list_3 -> list_3 = 
		     fn x_10994: (word32 * word8 vector) * list_3 => 
		     let
			val x_10995: list_3 = 
			   #1 x_10994
			val x_10996: word32 * word8 vector = 
			   #0 x_10994
			val x_10997: word8 vector = 
			   #1 x_10996
			val x_10998: word32 = 
			   #0 x_10996
			val x_10999: word32 = 
			   0xFFFFFFFF
			val x_11000: word32 = 
			   fromRep_1 x_10999
			val x_11001: word32 * word32 = 
			   (x_10998, x_11000)
			val x_11002: bool = 
			   x_8367 x_11001
			val x_11003: list_3 = 
			   case x_11002 of
			   true => 
			      let
			      in
				 x_10995
			      end
			   false => 
			      let
				 val x_11004: word32 * word8 vector = 
				    (x_10998, x_10997)
				 val x_11005: (word32 * word8 vector) * list_3 = 
				    (x_11004, x_10995)
				 val x_11006: list_3 = 
				    ::_3 x_11005
			      in
				 x_11006
			      end
		     in
			x_11003
		     end
	       val x_11007: word8 vector = 
		  "acces"
	       val x_11008: word32 * word8 vector = 
		  (acces_0, x_11007)
	       val x_11009: word8 vector = 
		  "addrinuse"
	       val x_11010: word32 * word8 vector = 
		  (addrinuse_0, x_11009)
	       val x_11011: word8 vector = 
		  "addrnotavail"
	       val x_11012: word32 * word8 vector = 
		  (addrnotavail_0, x_11011)
	       val x_11013: word8 vector = 
		  "afnosupport"
	       val x_11014: word32 * word8 vector = 
		  (afnosupport_0, x_11013)
	       val x_11015: word8 vector = 
		  "again"
	       val x_11016: word32 * word8 vector = 
		  (again_0, x_11015)
	       val x_11017: word8 vector = 
		  "already"
	       val x_11018: word32 * word8 vector = 
		  (already_0, x_11017)
	       val x_11019: word8 vector = 
		  "badf"
	       val x_11020: word32 * word8 vector = 
		  (badf_0, x_11019)
	       val x_11021: word8 vector = 
		  "badmsg"
	       val x_11022: word32 * word8 vector = 
		  (badmsg_0, x_11021)
	       val x_11023: word8 vector = 
		  "busy"
	       val x_11024: word32 * word8 vector = 
		  (busy_0, x_11023)
	       val x_11025: word8 vector = 
		  "canceled"
	       val x_11026: word32 * word8 vector = 
		  (canceled_0, x_11025)
	       val x_11027: word8 vector = 
		  "child"
	       val x_11028: word32 * word8 vector = 
		  (child_0, x_11027)
	       val x_11029: word8 vector = 
		  "connaborted"
	       val x_11030: word32 * word8 vector = 
		  (connaborted_0, x_11029)
	       val x_11031: word8 vector = 
		  "connrefused"
	       val x_11032: word32 * word8 vector = 
		  (connrefused_0, x_11031)
	       val x_11033: word8 vector = 
		  "connreset"
	       val x_11034: word32 * word8 vector = 
		  (connreset_0, x_11033)
	       val x_11035: word8 vector = 
		  "deadlk"
	       val x_11036: word32 * word8 vector = 
		  (deadlk_0, x_11035)
	       val x_11037: word8 vector = 
		  "destaddrreq"
	       val x_11038: word32 * word8 vector = 
		  (destaddrreq_0, x_11037)
	       val x_11039: word8 vector = 
		  "dom"
	       val x_11040: word32 * word8 vector = 
		  (dom_0, x_11039)
	       val x_11041: word8 vector = 
		  "dquot"
	       val x_11042: word32 * word8 vector = 
		  (dquot_0, x_11041)
	       val x_11043: word8 vector = 
		  "exist"
	       val x_11044: word32 * word8 vector = 
		  (exist_0, x_11043)
	       val x_11045: word8 vector = 
		  "fault"
	       val x_11046: word32 * word8 vector = 
		  (fault_0, x_11045)
	       val x_11047: word8 vector = 
		  "fbig"
	       val x_11048: word32 * word8 vector = 
		  (fbig_0, x_11047)
	       val x_11049: word8 vector = 
		  "hostunreach"
	       val x_11050: word32 * word8 vector = 
		  (hostunreach_0, x_11049)
	       val x_11051: word8 vector = 
		  "idrm"
	       val x_11052: word32 * word8 vector = 
		  (idrm_0, x_11051)
	       val x_11053: word8 vector = 
		  "ilseq"
	       val x_11054: word32 * word8 vector = 
		  (ilseq_0, x_11053)
	       val x_11055: word8 vector = 
		  "inprogress"
	       val x_11056: word32 * word8 vector = 
		  (inprogress_0, x_11055)
	       val x_11057: word8 vector = 
		  "intr"
	       val x_11058: word32 * word8 vector = 
		  (intr_0, x_11057)
	       val x_11059: word8 vector = 
		  "inval"
	       val x_11060: word32 * word8 vector = 
		  (inval_0, x_11059)
	       val x_11061: word8 vector = 
		  "io"
	       val x_11062: word32 * word8 vector = 
		  (io_0, x_11061)
	       val x_11063: word8 vector = 
		  "isconn"
	       val x_11064: word32 * word8 vector = 
		  (isconn_0, x_11063)
	       val x_11065: word8 vector = 
		  "isdir"
	       val x_11066: word32 * word8 vector = 
		  (isdir_0, x_11065)
	       val x_11067: word8 vector = 
		  "loop"
	       val x_11068: word32 * word8 vector = 
		  (loop_20, x_11067)
	       val x_11069: word8 vector = 
		  "mfile"
	       val x_11070: word32 * word8 vector = 
		  (mfile_0, x_11069)
	       val x_11071: word8 vector = 
		  "mlink"
	       val x_11072: word32 * word8 vector = 
		  (mlink_0, x_11071)
	       val x_11073: word8 vector = 
		  "msgsize"
	       val x_11074: word32 * word8 vector = 
		  (msgsize_0, x_11073)
	       val x_11075: word8 vector = 
		  "multihop"
	       val x_11076: word32 * word8 vector = 
		  (multihop_0, x_11075)
	       val x_11077: word8 vector = 
		  "nametoolong"
	       val x_11078: word32 * word8 vector = 
		  (nametoolong_0, x_11077)
	       val x_11079: word8 vector = 
		  "netdown"
	       val x_11080: word32 * word8 vector = 
		  (netdown_0, x_11079)
	       val x_11081: word8 vector = 
		  "netreset"
	       val x_11082: word32 * word8 vector = 
		  (netreset_0, x_11081)
	       val x_11083: word8 vector = 
		  "netunreach"
	       val x_11084: word32 * word8 vector = 
		  (netunreach_0, x_11083)
	       val x_11085: word8 vector = 
		  "nfile"
	       val x_11086: word32 * word8 vector = 
		  (nfile_0, x_11085)
	       val x_11087: word8 vector = 
		  "nobufs"
	       val x_11088: word32 * word8 vector = 
		  (nobufs_0, x_11087)
	       val x_11089: word8 vector = 
		  "nodata"
	       val x_11090: word32 * word8 vector = 
		  (nodata_0, x_11089)
	       val x_11091: word8 vector = 
		  "nodev"
	       val x_11092: word32 * word8 vector = 
		  (nodev_0, x_11091)
	       val x_11093: word8 vector = 
		  "noent"
	       val x_11094: word32 * word8 vector = 
		  (noent_0, x_11093)
	       val x_11095: word8 vector = 
		  "noexec"
	       val x_11096: word32 * word8 vector = 
		  (noexec_0, x_11095)
	       val x_11097: word8 vector = 
		  "nolck"
	       val x_11098: word32 * word8 vector = 
		  (nolck_0, x_11097)
	       val x_11099: word8 vector = 
		  "nolink"
	       val x_11100: word32 * word8 vector = 
		  (nolink_0, x_11099)
	       val x_11101: word8 vector = 
		  "nomem"
	       val x_11102: word32 * word8 vector = 
		  (nomem_0, x_11101)
	       val x_11103: word8 vector = 
		  "nomsg"
	       val x_11104: word32 * word8 vector = 
		  (nomsg_0, x_11103)
	       val x_11105: word8 vector = 
		  "noprotoopt"
	       val x_11106: word32 * word8 vector = 
		  (noprotoopt_0, x_11105)
	       val x_11107: word8 vector = 
		  "nospc"
	       val x_11108: word32 * word8 vector = 
		  (nospc_0, x_11107)
	       val x_11109: word8 vector = 
		  "nosr"
	       val x_11110: word32 * word8 vector = 
		  (nosr_0, x_11109)
	       val x_11111: word8 vector = 
		  "nostr"
	       val x_11112: word32 * word8 vector = 
		  (nostr_0, x_11111)
	       val x_11113: word8 vector = 
		  "nosys"
	       val x_11114: word32 * word8 vector = 
		  (nosys_0, x_11113)
	       val x_11115: word8 vector = 
		  "notconn"
	       val x_11116: word32 * word8 vector = 
		  (notconn_0, x_11115)
	       val x_11117: word8 vector = 
		  "notdir"
	       val x_11118: word32 * word8 vector = 
		  (notdir_0, x_11117)
	       val x_11119: word8 vector = 
		  "notempty"
	       val x_11120: word32 * word8 vector = 
		  (notempty_0, x_11119)
	       val x_11121: word8 vector = 
		  "notsock"
	       val x_11122: word32 * word8 vector = 
		  (notsock_0, x_11121)
	       val x_11123: word8 vector = 
		  "notsup"
	       val x_11124: word32 * word8 vector = 
		  (notsup_0, x_11123)
	       val x_11125: word8 vector = 
		  "notty"
	       val x_11126: word32 * word8 vector = 
		  (notty_0, x_11125)
	       val x_11127: word8 vector = 
		  "nxio"
	       val x_11128: word32 * word8 vector = 
		  (nxio_0, x_11127)
	       val x_11129: word8 vector = 
		  "opnotsupp"
	       val x_11130: word32 * word8 vector = 
		  (opnotsupp_0, x_11129)
	       val x_11131: word8 vector = 
		  "overflow"
	       val x_11132: word32 * word8 vector = 
		  (overflow_0, x_11131)
	       val x_11133: word8 vector = 
		  "perm"
	       val x_11134: word32 * word8 vector = 
		  (perm_0, x_11133)
	       val x_11135: word8 vector = 
		  "pipe"
	       val x_11136: word32 * word8 vector = 
		  (pipe_0, x_11135)
	       val x_11137: word8 vector = 
		  "proto"
	       val x_11138: word32 * word8 vector = 
		  (proto_0, x_11137)
	       val x_11139: word8 vector = 
		  "protonosupport"
	       val x_11140: word32 * word8 vector = 
		  (protonosupport_0, x_11139)
	       val x_11141: word8 vector = 
		  "prototype"
	       val x_11142: word32 * word8 vector = 
		  (prototype_0, x_11141)
	       val x_11143: word8 vector = 
		  "range"
	       val x_11144: word32 * word8 vector = 
		  (range_1, x_11143)
	       val x_11145: word8 vector = 
		  "rofs"
	       val x_11146: word32 * word8 vector = 
		  (rofs_0, x_11145)
	       val x_11147: word8 vector = 
		  "spipe"
	       val x_11148: word32 * word8 vector = 
		  (spipe_0, x_11147)
	       val x_11149: word8 vector = 
		  "srch"
	       val x_11150: word32 * word8 vector = 
		  (srch_0, x_11149)
	       val x_11151: word8 vector = 
		  "stale"
	       val x_11152: word32 * word8 vector = 
		  (stale_0, x_11151)
	       val x_11153: word8 vector = 
		  "time"
	       val x_11154: word32 * word8 vector = 
		  (time_0, x_11153)
	       val x_11155: word8 vector = 
		  "timedout"
	       val x_11156: word32 * word8 vector = 
		  (timedout_0, x_11155)
	       val x_11157: word8 vector = 
		  "toobig"
	       val x_11158: word32 * word8 vector = 
		  (toobig_0, x_11157)
	       val x_11159: word8 vector = 
		  "txtbsy"
	       val x_11160: word32 * word8 vector = 
		  (txtbsy_0, x_11159)
	       val x_11161: word8 vector = 
		  "wouldblock"
	       val x_11162: word32 * word8 vector = 
		  (wouldblock_0, x_11161)
	       val x_11163: word8 vector = 
		  "xdev"
	       val x_11164: word32 * word8 vector = 
		  (xdev_0, x_11163)
	       val x_11165: list_3 = 
		  nil_3
	       val x_11166: (word32 * word8 vector) * list_3 = 
		  (x_11164, x_11165)
	       val x_11167: list_3 = 
		  ::?_0 x_11166
	       val x_11168: (word32 * word8 vector) * list_3 = 
		  (x_11162, x_11167)
	       val x_11169: list_3 = 
		  ::?_0 x_11168
	       val x_11170: (word32 * word8 vector) * list_3 = 
		  (x_11160, x_11169)
	       val x_11171: list_3 = 
		  ::?_0 x_11170
	       val x_11172: (word32 * word8 vector) * list_3 = 
		  (x_11158, x_11171)
	       val x_11173: list_3 = 
		  ::?_0 x_11172
	       val x_11174: (word32 * word8 vector) * list_3 = 
		  (x_11156, x_11173)
	       val x_11175: list_3 = 
		  ::?_0 x_11174
	       val x_11176: (word32 * word8 vector) * list_3 = 
		  (x_11154, x_11175)
	       val x_11177: list_3 = 
		  ::?_0 x_11176
	       val x_11178: (word32 * word8 vector) * list_3 = 
		  (x_11152, x_11177)
	       val x_11179: list_3 = 
		  ::?_0 x_11178
	       val x_11180: (word32 * word8 vector) * list_3 = 
		  (x_11150, x_11179)
	       val x_11181: list_3 = 
		  ::?_0 x_11180
	       val x_11182: (word32 * word8 vector) * list_3 = 
		  (x_11148, x_11181)
	       val x_11183: list_3 = 
		  ::?_0 x_11182
	       val x_11184: (word32 * word8 vector) * list_3 = 
		  (x_11146, x_11183)
	       val x_11185: list_3 = 
		  ::?_0 x_11184
	       val x_11186: (word32 * word8 vector) * list_3 = 
		  (x_11144, x_11185)
	       val x_11187: list_3 = 
		  ::?_0 x_11186
	       val x_11188: (word32 * word8 vector) * list_3 = 
		  (x_11142, x_11187)
	       val x_11189: list_3 = 
		  ::?_0 x_11188
	       val x_11190: (word32 * word8 vector) * list_3 = 
		  (x_11140, x_11189)
	       val x_11191: list_3 = 
		  ::?_0 x_11190
	       val x_11192: (word32 * word8 vector) * list_3 = 
		  (x_11138, x_11191)
	       val x_11193: list_3 = 
		  ::?_0 x_11192
	       val x_11194: (word32 * word8 vector) * list_3 = 
		  (x_11136, x_11193)
	       val x_11195: list_3 = 
		  ::?_0 x_11194
	       val x_11196: (word32 * word8 vector) * list_3 = 
		  (x_11134, x_11195)
	       val x_11197: list_3 = 
		  ::?_0 x_11196
	       val x_11198: (word32 * word8 vector) * list_3 = 
		  (x_11132, x_11197)
	       val x_11199: list_3 = 
		  ::?_0 x_11198
	       val x_11200: (word32 * word8 vector) * list_3 = 
		  (x_11130, x_11199)
	       val x_11201: list_3 = 
		  ::?_0 x_11200
	       val x_11202: (word32 * word8 vector) * list_3 = 
		  (x_11128, x_11201)
	       val x_11203: list_3 = 
		  ::?_0 x_11202
	       val x_11204: (word32 * word8 vector) * list_3 = 
		  (x_11126, x_11203)
	       val x_11205: list_3 = 
		  ::?_0 x_11204
	       val x_11206: (word32 * word8 vector) * list_3 = 
		  (x_11124, x_11205)
	       val x_11207: list_3 = 
		  ::?_0 x_11206
	       val x_11208: (word32 * word8 vector) * list_3 = 
		  (x_11122, x_11207)
	       val x_11209: list_3 = 
		  ::?_0 x_11208
	       val x_11210: (word32 * word8 vector) * list_3 = 
		  (x_11120, x_11209)
	       val x_11211: list_3 = 
		  ::?_0 x_11210
	       val x_11212: (word32 * word8 vector) * list_3 = 
		  (x_11118, x_11211)
	       val x_11213: list_3 = 
		  ::?_0 x_11212
	       val x_11214: (word32 * word8 vector) * list_3 = 
		  (x_11116, x_11213)
	       val x_11215: list_3 = 
		  ::?_0 x_11214
	       val x_11216: (word32 * word8 vector) * list_3 = 
		  (x_11114, x_11215)
	       val x_11217: list_3 = 
		  ::?_0 x_11216
	       val x_11218: (word32 * word8 vector) * list_3 = 
		  (x_11112, x_11217)
	       val x_11219: list_3 = 
		  ::?_0 x_11218
	       val x_11220: (word32 * word8 vector) * list_3 = 
		  (x_11110, x_11219)
	       val x_11221: list_3 = 
		  ::?_0 x_11220
	       val x_11222: (word32 * word8 vector) * list_3 = 
		  (x_11108, x_11221)
	       val x_11223: list_3 = 
		  ::?_0 x_11222
	       val x_11224: (word32 * word8 vector) * list_3 = 
		  (x_11106, x_11223)
	       val x_11225: list_3 = 
		  ::?_0 x_11224
	       val x_11226: (word32 * word8 vector) * list_3 = 
		  (x_11104, x_11225)
	       val x_11227: list_3 = 
		  ::?_0 x_11226
	       val x_11228: (word32 * word8 vector) * list_3 = 
		  (x_11102, x_11227)
	       val x_11229: list_3 = 
		  ::?_0 x_11228
	       val x_11230: (word32 * word8 vector) * list_3 = 
		  (x_11100, x_11229)
	       val x_11231: list_3 = 
		  ::?_0 x_11230
	       val x_11232: (word32 * word8 vector) * list_3 = 
		  (x_11098, x_11231)
	       val x_11233: list_3 = 
		  ::?_0 x_11232
	       val x_11234: (word32 * word8 vector) * list_3 = 
		  (x_11096, x_11233)
	       val x_11235: list_3 = 
		  ::?_0 x_11234
	       val x_11236: (word32 * word8 vector) * list_3 = 
		  (x_11094, x_11235)
	       val x_11237: list_3 = 
		  ::?_0 x_11236
	       val x_11238: (word32 * word8 vector) * list_3 = 
		  (x_11092, x_11237)
	       val x_11239: list_3 = 
		  ::?_0 x_11238
	       val x_11240: (word32 * word8 vector) * list_3 = 
		  (x_11090, x_11239)
	       val x_11241: list_3 = 
		  ::?_0 x_11240
	       val x_11242: (word32 * word8 vector) * list_3 = 
		  (x_11088, x_11241)
	       val x_11243: list_3 = 
		  ::?_0 x_11242
	       val x_11244: (word32 * word8 vector) * list_3 = 
		  (x_11086, x_11243)
	       val x_11245: list_3 = 
		  ::?_0 x_11244
	       val x_11246: (word32 * word8 vector) * list_3 = 
		  (x_11084, x_11245)
	       val x_11247: list_3 = 
		  ::?_0 x_11246
	       val x_11248: (word32 * word8 vector) * list_3 = 
		  (x_11082, x_11247)
	       val x_11249: list_3 = 
		  ::?_0 x_11248
	       val x_11250: (word32 * word8 vector) * list_3 = 
		  (x_11080, x_11249)
	       val x_11251: list_3 = 
		  ::?_0 x_11250
	       val x_11252: (word32 * word8 vector) * list_3 = 
		  (x_11078, x_11251)
	       val x_11253: list_3 = 
		  ::?_0 x_11252
	       val x_11254: (word32 * word8 vector) * list_3 = 
		  (x_11076, x_11253)
	       val x_11255: list_3 = 
		  ::?_0 x_11254
	       val x_11256: (word32 * word8 vector) * list_3 = 
		  (x_11074, x_11255)
	       val x_11257: list_3 = 
		  ::?_0 x_11256
	       val x_11258: (word32 * word8 vector) * list_3 = 
		  (x_11072, x_11257)
	       val x_11259: list_3 = 
		  ::?_0 x_11258
	       val x_11260: (word32 * word8 vector) * list_3 = 
		  (x_11070, x_11259)
	       val x_11261: list_3 = 
		  ::?_0 x_11260
	       val x_11262: (word32 * word8 vector) * list_3 = 
		  (x_11068, x_11261)
	       val x_11263: list_3 = 
		  ::?_0 x_11262
	       val x_11264: (word32 * word8 vector) * list_3 = 
		  (x_11066, x_11263)
	       val x_11265: list_3 = 
		  ::?_0 x_11264
	       val x_11266: (word32 * word8 vector) * list_3 = 
		  (x_11064, x_11265)
	       val x_11267: list_3 = 
		  ::?_0 x_11266
	       val x_11268: (word32 * word8 vector) * list_3 = 
		  (x_11062, x_11267)
	       val x_11269: list_3 = 
		  ::?_0 x_11268
	       val x_11270: (word32 * word8 vector) * list_3 = 
		  (x_11060, x_11269)
	       val x_11271: list_3 = 
		  ::?_0 x_11270
	       val x_11272: (word32 * word8 vector) * list_3 = 
		  (x_11058, x_11271)
	       val x_11273: list_3 = 
		  ::?_0 x_11272
	       val x_11274: (word32 * word8 vector) * list_3 = 
		  (x_11056, x_11273)
	       val x_11275: list_3 = 
		  ::?_0 x_11274
	       val x_11276: (word32 * word8 vector) * list_3 = 
		  (x_11054, x_11275)
	       val x_11277: list_3 = 
		  ::?_0 x_11276
	       val x_11278: (word32 * word8 vector) * list_3 = 
		  (x_11052, x_11277)
	       val x_11279: list_3 = 
		  ::?_0 x_11278
	       val x_11280: (word32 * word8 vector) * list_3 = 
		  (x_11050, x_11279)
	       val x_11281: list_3 = 
		  ::?_0 x_11280
	       val x_11282: (word32 * word8 vector) * list_3 = 
		  (x_11048, x_11281)
	       val x_11283: list_3 = 
		  ::?_0 x_11282
	       val x_11284: (word32 * word8 vector) * list_3 = 
		  (x_11046, x_11283)
	       val x_11285: list_3 = 
		  ::?_0 x_11284
	       val x_11286: (word32 * word8 vector) * list_3 = 
		  (x_11044, x_11285)
	       val x_11287: list_3 = 
		  ::?_0 x_11286
	       val x_11288: (word32 * word8 vector) * list_3 = 
		  (x_11042, x_11287)
	       val x_11289: list_3 = 
		  ::?_0 x_11288
	       val x_11290: (word32 * word8 vector) * list_3 = 
		  (x_11040, x_11289)
	       val x_11291: list_3 = 
		  ::?_0 x_11290
	       val x_11292: (word32 * word8 vector) * list_3 = 
		  (x_11038, x_11291)
	       val x_11293: list_3 = 
		  ::?_0 x_11292
	       val x_11294: (word32 * word8 vector) * list_3 = 
		  (x_11036, x_11293)
	       val x_11295: list_3 = 
		  ::?_0 x_11294
	       val x_11296: (word32 * word8 vector) * list_3 = 
		  (x_11034, x_11295)
	       val x_11297: list_3 = 
		  ::?_0 x_11296
	       val x_11298: (word32 * word8 vector) * list_3 = 
		  (x_11032, x_11297)
	       val x_11299: list_3 = 
		  ::?_0 x_11298
	       val x_11300: (word32 * word8 vector) * list_3 = 
		  (x_11030, x_11299)
	       val x_11301: list_3 = 
		  ::?_0 x_11300
	       val x_11302: (word32 * word8 vector) * list_3 = 
		  (x_11028, x_11301)
	       val x_11303: list_3 = 
		  ::?_0 x_11302
	       val x_11304: (word32 * word8 vector) * list_3 = 
		  (x_11026, x_11303)
	       val x_11305: list_3 = 
		  ::?_0 x_11304
	       val x_11306: (word32 * word8 vector) * list_3 = 
		  (x_11024, x_11305)
	       val x_11307: list_3 = 
		  ::?_0 x_11306
	       val x_11308: (word32 * word8 vector) * list_3 = 
		  (x_11022, x_11307)
	       val x_11309: list_3 = 
		  ::?_0 x_11308
	       val x_11310: (word32 * word8 vector) * list_3 = 
		  (x_11020, x_11309)
	       val x_11311: list_3 = 
		  ::?_0 x_11310
	       val x_11312: (word32 * word8 vector) * list_3 = 
		  (x_11018, x_11311)
	       val x_11313: list_3 = 
		  ::?_0 x_11312
	       val x_11314: (word32 * word8 vector) * list_3 = 
		  (x_11016, x_11313)
	       val x_11315: list_3 = 
		  ::?_0 x_11314
	       val x_11316: (word32 * word8 vector) * list_3 = 
		  (x_11014, x_11315)
	       val x_11317: list_3 = 
		  ::?_0 x_11316
	       val x_11318: (word32 * word8 vector) * list_3 = 
		  (x_11012, x_11317)
	       val x_11319: list_3 = 
		  ::?_0 x_11318
	       val x_11320: (word32 * word8 vector) * list_3 = 
		  (x_11010, x_11319)
	       val x_11321: list_3 = 
		  ::?_0 x_11320
	       val x_11322: (word32 * word8 vector) * list_3 = 
		  (x_11008, x_11321)
	       val errorNames_0: list_3 = 
		  ::?_0 x_11322
	       val x_11323: unit = 
		  ()
	       val x_11324: unit ref = 
		  Ref_ref[unit] (x_11323)
	       val x_11325: exn -> Primitive.Option.t_1 = 
		  fn x_11326: exn => 
		  let
		     val x_11327: unit -> Primitive.Option.t_1 = 
			fn unit_18: unit => 
			let
			   val x_11328: Primitive.Option.t_1 = 
			      NONE_1
			in
			   x_11328
			end
		     val x_11329: Primitive.Option.t_1 = 
			case x_11326 of
			SysErr_0 x_11330: unit ref
					  * (word8 vector * Primitive.Option.t_0) => 
			   let
			      val x_11331: word8 vector * Primitive.Option.t_0 = 
				 #1 x_11330
			      val x_11332: unit ref = 
				 #0 x_11330
			      val x_11333: bool = 
				 MLton_equal[unit ref] (x_11332, x_11324)
			      val x_11334: Primitive.Option.t_1 = 
				 case x_11333 of
				 true => 
				    let
				       val x_11337: Primitive.Option.t_0 = 
					  #1 x_11331
				       val x_11338: word8 vector = 
					  #0 x_11331
				       val x_11339: list_7 = 
					  nil_7
				       val x_11340: word8 vector = 
					  case x_11337 of
					  NONE_0 => 
					     let
						val x_11369: word8 vector = 
						   ""
					     in
						x_11369
					     end
					  SOME_0 x_11341: word32 => 
					     let
						val x_11342: list_7 = 
						   nil_7
						val x_11343: word8 vector = 
						   "]"
						val x_11344: word8 vector
							     * list_7 = 
						   (x_11343, x_11342)
						val x_11345: list_7 = 
						   ::_7 x_11344
						val rec 
						   loop_21: list_3
							    -> Primitive.Option.t_22 = 
						      fn x_11346: list_3 => 
						      let
							 val x_11347: Primitive.Option.t_22 = 
							    case x_11346 of
							    nil_3 => 
							       let
								  val x_11357: Primitive.Option.t_22 = 
								     NONE_20
							       in
								  x_11357
							       end
							    ::_3 x_11348: (word32
									   * word8 vector)
									  * list_3 => 
							       let
								  val x_11349: list_3 = 
								     #1 x_11348
								  val x_11350: word32
									       * word8 vector = 
								     #0 x_11348
								  val x_11351: word32 = 
								     #0 x_11350
								  val x_11352: word32
									       * word32 = 
								     (x_11341,
								      x_11351)
								  val x_11353: bool = 
								     x_8367 x_11352
								  val x_11354: Primitive.Option.t_22 = 
								     case x_11353 of
								     true => 
									let
									   val x_11356: Primitive.Option.t_22 = 
									      SOME_22 x_11350
									in
									   x_11356
									end
								     false => 
									let
									   val x_11355: Primitive.Option.t_22 = 
									      loop_21 x_11349
									in
									   x_11355
									end
							       in
								  x_11354
							       end
						      in
							 x_11347
						      end
						val x_11358: Primitive.Option.t_22 = 
						   loop_21 errorNames_0
						val x_11359: word8 vector = 
						   case x_11358 of
						   NONE_20 => 
						      let
							 val x_11362: word8 vector = 
							    "<UNKNOWN>"
						      in
							 x_11362
						      end
						   SOME_22 x_11360: word32
								    * word8 vector => 
						      let
							 val x_11361: word8 vector = 
							    #1 x_11360
						      in
							 x_11361
						      end
						val x_11363: word8 vector
							     * list_7 = 
						   (x_11359, x_11345)
						val x_11364: list_7 = 
						   ::_7 x_11363
						val x_11365: word8 vector = 
						   " ["
						val x_11366: word8 vector
							     * list_7 = 
						   (x_11365, x_11364)
						val x_11367: list_7 = 
						   ::_7 x_11366
						val x_11368: word8 vector = 
						   concat_3 x_11367
					     in
						x_11368
					     end
				       val x_11370: word8 vector * list_7 = 
					  (x_11340, x_11339)
				       val x_11371: list_7 = 
					  ::_7 x_11370
				       val x_11372: word8 vector * list_7 = 
					  (x_11338, x_11371)
				       val x_11373: list_7 = 
					  ::_7 x_11372
				       val x_11374: word8 vector = 
					  "SysErr: "
				       val x_11375: word8 vector * list_7 = 
					  (x_11374, x_11373)
				       val x_11376: list_7 = 
					  ::_7 x_11375
				       val x_11377: word8 vector = 
					  concat_3 x_11376
				       val x_11378: Primitive.Option.t_1 = 
					  SOME_1 x_11377
				    in
				       x_11378
				    end
				 false => 
				    let
				       val x_11335: unit = 
					  ()
				       val x_11336: Primitive.Option.t_1 = 
					  x_11327 x_11335
				    in
				       x_11336
				    end
			   in
			      x_11334
			   end
			  _ => let
				  val x_11379: unit = 
				     ()
				  val x_11380: Primitive.Option.t_1 = 
				     x_11327 x_11379
			       in
				  x_11380
			       end
		  in
		     x_11329
		  end
	       val x_11381: list_0 = 
		  x_8318 messagers_0
	       val x_11382: (exn -> Primitive.Option.t_1) * list_0 = 
		  (x_11325, x_11381)
	       val x_11383: list_0 = 
		  ::_0 x_11382
	       val x_11384: unit = 
		  Ref_assign[list_0] (messagers_0, x_11383)
	       val rec 
		  errorMsg_0: word32 -> word8 vector = 
		     fn x_11385: word32 => 
		     let
			val x_11386: word64 = 
			   Posix_Error_strError (x_11385)
			val x_11387: cpointer = 
			   fromWord_1 x_11386
			val x_11388: bool = 
			   MLton_equal[cpointer] (x_11387, null_0)
			val x_11389: word8 vector = 
			   case x_11388 of
			   true => 
			      let
				 val x_11437: word8 vector = 
				    "Unknown error"
			      in
				 x_11437
			      end
			   false => 
			      let
				 val rec 
				    loop_22: word32 -> word32 = 
				       fn x_11390: word32 => 
				       let
					  val x_11391: word64 * word32 = 
					     (x_11386, x_11390)
					  val x_11392: word8 = 
					     sub_12 x_11391
					  val x_11393: bool = 
					     case x_11392 of
					     0x0 => 
						let
						   val x_11394: bool = 
						      true
						in
						   x_11394
						end
					       _ => let
						       val x_11395: bool = 
							  false
						    in
						       x_11395
						    end
					  val x_11396: word32 = 
					     case x_11393 of
					     true => 
						let
						in
						   x_11390
						end
					     false => 
						let
						   val x_11397: word32 = 
						      0x1
						   val x_11398: word32 * word32 = 
						      (x_11390, x_11397)
						   val x_11399: word32 = 
						      +?_0 x_11398
						   val x_11400: word32 = 
						      loop_22 x_11399
						in
						   x_11400
						end
				       in
					  x_11396
				       end
				 val x_11401: word32 = 
				    0x0
				 val x_11402: word32 = 
				    loop_22 x_11401
				 val x_11403: unit = 
				    ()
				 val x_11404: word64 = 
				    fromIntForLength_0 x_11402
				 val x_11405: bool = 
				    not_0 isMutable_1
				 val x_11406: bool = 
				    case x_11405 of
				    true => 
				       let
					  val x_11408: word64 = 
					     0x0
					  val x_11409: word64 * word64 = 
					     (x_11404, x_11408)
					  val x_11410: bool = 
					     x_8372 x_11409
				       in
					  x_11410
				       end
				    false => 
				       let
					  val x_11407: bool = 
					     false
				       in
					  x_11407
				       end
				 val x_11411: word8 array = 
				    case x_11406 of
				    true => 
				       let
					  val x_11417: unit = 
					     ()
					  val x_11418: word8 array = 
					     x_8666 x_11417
				       in
					  x_11418
				       end
				    false => 
				       let
					  val x_11412: word64 * word64 = 
					     (x_11404, x_9217)
					  val x_11413: bool = 
					     >_4 x_11412
					  val x_11414: word8 array = 
					     case x_11413 of
					     true => 
						let
						   val x_11416: word8 array = 
						      raise x_8293
						in
						   x_11416
						end
					     false => 
						let
						   val x_11415: word8 array = 
						      x_8663 x_11404
						in
						   x_11415
						end
				       in
					  x_11414
				       end
				 val rec 
				    loop_23: word64 * unit -> unit = 
				       fn x_11419: word64 * unit => 
				       let
					  val b_41: unit = 
					     #1 x_11419
					  val i_36: word64 = 
					     #0 x_11419
					  val x_11420: word64 * word64 = 
					     (i_36, x_11404)
					  val x_11421: bool = 
					     >=_2 x_11420
					  val x_11422: unit = 
					     case x_11421 of
					     true => 
						let
						in
						   b_41
						end
					     false => 
						let
						   val x_11423: word32 = 
						      sextdFromInt64ToInt32_0 i_36
						   val x_11424: word64 * word32 = 
						      (x_11386, x_11423)
						   val x_11425: word8 = 
						      sub_12 x_11424
						   val x_11426: unit = 
						      ()
						   val x_11427: word8 array
								* word64
								* word8 = 
						      (x_11411, i_36, x_11425)
						   val x_11428: unit = 
						      x_8677 x_11427
						   val x_11429: word64 = 
						      0x1
						   val x_11430: word64 * word64 = 
						      (i_36, x_11429)
						   val x_11431: word64 = 
						      +?_1 x_11430
						   val x_11432: word64 * unit = 
						      (x_11431, x_11426)
						   val x_11433: unit = 
						      loop_23 x_11432
						in
						   x_11433
						end
				       in
					  x_11422
				       end
				 val x_11434: word64 = 
				    0x0
				 val x_11435: word64 * unit = 
				    (x_11434, x_11403)
				 val b_42: unit = 
				    loop_23 x_11435
				 val x_11436: word8 vector = 
				    x_8683 x_11411
			      in
				 x_11436
			      end
		     in
			x_11389
		     end
	       val rec 
		  raiseSys_1: word32 -> word32 = 
		     fn x_11438: word32 => 
		     let
			val x_11439: word8 vector = 
			   errorMsg_0 x_11438
			val x_11440: Primitive.Option.t_0 = 
			   SOME_0 x_11438
			val x_11441: word8 vector * Primitive.Option.t_0 = 
			   (x_11439, x_11440)
			val x_11442: unit ref
				     * (word8 vector * Primitive.Option.t_0) = 
			   (x_11324, x_11441)
			val x_11443: exn = 
			   SysErr_0 x_11442
			val x_11444: word32 = 
			   raise x_11443
		     in
			x_11444
		     end
	       val rec 
		  raiseSys_2: word32 -> word64 = 
		     fn x_11445: word32 => 
		     let
			val x_11446: word8 vector = 
			   errorMsg_0 x_11445
			val x_11447: Primitive.Option.t_0 = 
			   SOME_0 x_11445
			val x_11448: word8 vector * Primitive.Option.t_0 = 
			   (x_11446, x_11447)
			val x_11449: unit ref
				     * (word8 vector * Primitive.Option.t_0) = 
			   (x_11324, x_11448)
			val x_11450: exn = 
			   SysErr_0 x_11449
			val x_11451: word64 = 
			   raise x_11450
		     in
			x_11451
		     end
	       val x_11452: unit -> unit -> unit = 
		  fn x_11453: unit => 
		  let
		     val x_11454: unit -> unit = 
			fn x_11455: unit => 
			let
			   val x_11456: unit = 
			      ()
			in
			   x_11456
			end
		  in
		     x_11454
		  end
	       val blocker_0: (unit -> unit -> unit) ref = 
		  Ref_ref[unit -> unit -> unit] (x_11452)
	       val x_11457: bool = 
		  true
	       val restartFlag_0: bool ref = 
		  Ref_ref[bool] (x_11457)
	       val rec 
		  setRoundingMode_0: IEEEReal.RoundingMode.t_0 -> unit = 
		     fn x_11458: IEEEReal.RoundingMode.t_0 => 
		     let
			val x_11459: word32 = 
			   case x_11458 of
			   TO_NEAREST_0 => 
			      let
			      in
				 FE_TONEAREST_0
			      end
			   TO_POSINF_0 => 
			      let
			      in
				 FE_UPWARD_0
			      end
			   TO_ZERO_0 => 
			      let
			      in
				 FE_TOWARDZERO_0
			      end
			   TO_NEGINF_0 => 
			      let
			      in
				 FE_DOWNWARD_0
			      end
			val x_11460: word32 * word32 = 
			   (x_11459, FE_NOSUPPORT_0)
			val x_11461: bool = 
			   x_8367 x_11460
			val x_11462: word32 = 
			   case x_11461 of
			   true => 
			      let
				 val x_11463: word8 vector = 
				    "IEEEReal rounding mode not supported"
				 val x_11464: unit ref * word8 vector = 
				    (x_9554, x_11463)
				 val x_11465: exn = 
				    Fail_0 x_11464
				 val x_11466: word32 = 
				    raise x_11465
			      in
				 x_11466
			      end
			   false => 
			      let
			      in
				 x_11459
			      end
			val x_11467: word32 = 
			   IEEEReal_setRoundingMode (x_11462)
			val x_11468: word32 = 
			   0x0
			val x_11469: word32 * word32 = 
			   (x_11467, x_11468)
			val x_11470: bool = 
			   x_8367 x_11469
			val x_11471: unit = 
			   case x_11470 of
			   true => 
			      let
				 val x_11479: unit = 
				    ()
			      in
				 x_11479
			      end
			   false => 
			      let
				 val x_11472: word8 vector = 
				    errorMsg_0 inval_0
				 val x_11473: Primitive.Option.t_0 = 
				    SOME_0 inval_0
				 val x_11474: word8 vector
					      * Primitive.Option.t_0 = 
				    (x_11472, x_11473)
				 val x_11475: unit ref
					      * (word8 vector
						 * Primitive.Option.t_0) = 
				    (x_11324, x_11474)
				 val x_11476: exn = 
				    SysErr_0 x_11475
				 val x_11477: exn = 
				    raise x_11476
				 val x_11478: unit = 
				    raise x_11477
			      in
				 x_11478
			      end
		     in
			x_11471
		     end
	       val x_11480: unit -> IEEEReal.RoundingMode.t_0 = 
		  fn x_11481: unit => 
		  let
		     val x_11482: word32 = 
			IEEEReal_getRoundingMode ()
		     val x_11483: word32 * word32 = 
			(x_11482, FE_TONEAREST_0)
		     val x_11484: bool = 
			x_8367 x_11483
		     val x_11485: IEEEReal.RoundingMode.t_0 = 
			case x_11484 of
			true => 
			   let
			      val x_11502: IEEEReal.RoundingMode.t_0 = 
				 TO_NEAREST_0
			   in
			      x_11502
			   end
			false => 
			   let
			      val x_11486: word32 * word32 = 
				 (x_11482, FE_DOWNWARD_0)
			      val x_11487: bool = 
				 x_8367 x_11486
			      val x_11488: IEEEReal.RoundingMode.t_0 = 
				 case x_11487 of
				 true => 
				    let
				       val x_11501: IEEEReal.RoundingMode.t_0 = 
					  TO_NEGINF_0
				    in
				       x_11501
				    end
				 false => 
				    let
				       val x_11489: word32 * word32 = 
					  (x_11482, FE_UPWARD_0)
				       val x_11490: bool = 
					  x_8367 x_11489
				       val x_11491: IEEEReal.RoundingMode.t_0 = 
					  case x_11490 of
					  true => 
					     let
						val x_11500: IEEEReal.RoundingMode.t_0 = 
						   TO_POSINF_0
					     in
						x_11500
					     end
					  false => 
					     let
						val x_11492: word32 * word32 = 
						   (x_11482, FE_TOWARDZERO_0)
						val x_11493: bool = 
						   x_8367 x_11492
						val x_11494: IEEEReal.RoundingMode.t_0 = 
						   case x_11493 of
						   true => 
						      let
							 val x_11499: IEEEReal.RoundingMode.t_0 = 
							    TO_ZERO_0
						      in
							 x_11499
						      end
						   false => 
						      let
							 val x_11495: word8 vector = 
							    "IEEEReal.RoundingMode.fromInt"
							 val x_11496: unit ref
								      * word8 vector = 
							    (x_9554, x_11495)
							 val x_11497: exn = 
							    Fail_0 x_11496
							 val x_11498: IEEEReal.RoundingMode.t_0 = 
							    raise x_11497
						      in
							 x_11498
						      end
					     in
						x_11494
					     end
				    in
				       x_11491
				    end
			   in
			      x_11488
			   end
		  in
		     x_11485
		  end
	       val realSize_2: word32 = 
		  sextdFromInt32ToInt32_0 realSize_0
	       val exponentBias_2: word32 = 
		  sextdFromInt32ToInt32_0 exponentBias_0
	       val precision_7: word32 = 
		  sextdFromInt32ToInt32_0 precision_5
	       val x_11503: word32 = 
		  sextdFromInt32ToWord32_0 realSize_2
	       val x_11504: word32 * word32 = 
		  (x_11503, one_2)
	       val exponentSignificandBits_0: word32 = 
		  -_0 x_11504
	       val x_11505: word32 = 
		  sextdFromInt32ToWord32_0 precision_7
	       val x_11506: word32 * word32 = 
		  (x_11505, one_2)
	       val significandBits_0: word32 = 
		  -_0 x_11506
	       val x_11507: word32 * word32 = 
		  (exponentSignificandBits_0, significandBits_0)
	       val exponentBits_0: word32 = 
		  -_0 x_11507
	       val mkMask_0: word32 -> word32 = 
		  fn x_11508: word32 => 
		  let
		     val x_11509: word32 = 
			notb_2 zero_2
		     val x_11510: word32 * word32 = 
			(x_11509, x_11508)
		     val x_11511: word32 = 
			<<_6 x_11510
		     val x_11512: word32 = 
			notb_2 x_11511
		  in
		     x_11512
		  end
	       val x_11513: word32 = 
		  mkMask_0 one_2
	       val x_11514: word32 * word32 = 
		  (x_11513, exponentSignificandBits_0)
	       val signMask_0: word32 = 
		  <<_6 x_11514
	       val x_11515: word32 = 
		  mkMask_0 exponentBits_0
	       val x_11516: word32 * word32 = 
		  (x_11515, significandBits_0)
	       val exponentMask_0: word32 = 
		  <<_6 x_11516
	       val significandMask_0: word32 = 
		  mkMask_0 significandBits_0
	       val class_0: real32 -> IEEEReal.float_class_0 = 
		  fn x_11517: real32 => 
		  let
		     val x_11518: word32 = 
			Real32_castToWord32 (x_11517)
		     val x_11519: word32 * word32 = 
			(x_11518, exponentMask_0)
		     val x_11520: word32 = 
			andb_0 x_11519
		     val x_11521: word32 * word32 = 
			(x_11520, exponentMask_0)
		     val x_11522: bool = 
			x_8367 x_11521
		     val x_11523: IEEEReal.float_class_0 = 
			case x_11522 of
			true => 
			   let
			      val x_11537: word32 * word32 = 
				 (x_11518, significandMask_0)
			      val x_11538: word32 = 
				 andb_0 x_11537
			      val x_11539: word32 * word32 = 
				 (x_11538, zero_2)
			      val x_11540: bool = 
				 x_8367 x_11539
			      val x_11541: IEEEReal.float_class_0 = 
				 case x_11540 of
				 true => 
				    let
				       val x_11543: IEEEReal.float_class_0 = 
					  INF_0
				    in
				       x_11543
				    end
				 false => 
				    let
				       val x_11542: IEEEReal.float_class_0 = 
					  NAN_0
				    in
				       x_11542
				    end
			   in
			      x_11541
			   end
			false => 
			   let
			      val x_11524: word32 * word32 = 
				 (x_11518, exponentMask_0)
			      val x_11525: word32 = 
				 andb_0 x_11524
			      val x_11526: word32 * word32 = 
				 (x_11525, zero_2)
			      val x_11527: bool = 
				 x_8367 x_11526
			      val x_11528: IEEEReal.float_class_0 = 
				 case x_11527 of
				 true => 
				    let
				       val x_11530: word32 * word32 = 
					  (x_11518, significandMask_0)
				       val x_11531: word32 = 
					  andb_0 x_11530
				       val x_11532: word32 * word32 = 
					  (x_11531, zero_2)
				       val x_11533: bool = 
					  x_8367 x_11532
				       val x_11534: IEEEReal.float_class_0 = 
					  case x_11533 of
					  true => 
					     let
						val x_11536: IEEEReal.float_class_0 = 
						   ZERO_0
					     in
						x_11536
					     end
					  false => 
					     let
						val x_11535: IEEEReal.float_class_0 = 
						   SUBNORMAL_0
					     in
						x_11535
					     end
				    in
				       x_11534
				    end
				 false => 
				    let
				       val x_11529: IEEEReal.float_class_0 = 
					  NORMAL_0
				    in
				       x_11529
				    end
			   in
			      x_11528
			   end
		  in
		     x_11523
		  end
	       val x_11544: word32 * word32 = 
		  (precision_5, precision_5)
	       val x_11545: bool = 
		  x_8367 x_11544
	       val x_11546: (IEEEReal.RoundingMode.t_0 -> real32 -> real32)
			    * (real32 -> real32) = 
		  case x_11545 of
		  true => 
		     let
			val x_11556: IEEEReal.RoundingMode.t_0
				     -> real32 -> real32 = 
			   fn x_11557: IEEEReal.RoundingMode.t_0 => 
			   let
			   in
			      fromReal32Unsafe_0
			   end
			val x_11558: (IEEEReal.RoundingMode.t_0
				      -> real32 -> real32)
				     * (real32 -> real32) = 
			   (x_11556, toReal32Unsafe_0)
		     in
			x_11558
		     end
		  false => 
		     let
			val x_11547: IEEEReal.RoundingMode.t_0
				     -> real32 -> real32 = 
			   fn x_11548: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11549: real32 -> real32 = 
				 fn x_11550: real32 => 
				 let
				    val x_11551: unit = 
				       ()
				    val m'_0: IEEEReal.RoundingMode.t_0 = 
				       x_11480 x_11551
				    val x_11552: unit = 
				       setRoundingMode_0 x_11548
				    val x_11553: real32 = 
				       fromReal32Unsafe_0 x_11550
				    val x_11554: unit = 
				       setRoundingMode_0 m'_0
				 in
				    x_11553
				 end
			   in
			      x_11549
			   end
			val x_11555: (IEEEReal.RoundingMode.t_0
				      -> real32 -> real32)
				     * (real32 -> real32) = 
			   (x_11547, toReal32Unsafe_0)
		     in
			x_11555
		     end
	       val zero_7: real32 = 
		  castFromWord_0 zero_2
	       val x_11559: word32 = 
		  sextdFromInt32ToWord32_0 exponentBias_2
	       val x_11560: word32 * word32 = 
		  (x_11559, one_2)
	       val x_11561: word32 = 
		  -_0 x_11560
	       val x_11562: word32 * word32 = 
		  (x_11561, significandBits_0)
	       val x_11563: word32 = 
		  <<_6 x_11562
	       val half_0: real32 = 
		  castFromWord_0 x_11563
	       val x_11564: word32 = 
		  sextdFromInt32ToWord32_0 exponentBias_2
	       val x_11565: word32 * word32 = 
		  (x_11564, significandBits_0)
	       val x_11566: word32 = 
		  <<_6 x_11565
	       val one_6: real32 = 
		  castFromWord_0 x_11566
	       val x_11567: word32 -> word8 = 
		  fn x_11568: word32 => 
		  let
		     val x_11569: word8 * word32 = 
			(maxInt'_0, x_11568)
		     val x_11570: word8 = 
			>>_0 x_11569
		     val x_11571: word8 * word32 = 
			(x_11570, x_11568)
		     val x_11572: word8 = 
			<<_0 x_11571
		  in
		     x_11572
		  end
	       val x_11573: word32 * word32 = 
		  (precision_7, precision'_0)
	       val x_11574: bool = 
		  <_1 x_11573
	       val x_11575: IEEEReal.RoundingMode.t_0 -> real32 -> word8 = 
		  case x_11574 of
		  true => 
		     let
			val x_11633: word32 * word32 = 
			   (precision'_0, precision_7)
			val x_11634: word32 = 
			   x_8548 x_11633
			val x_11635: word32 = 
			   0x1
			val x_11636: word32 * word32 = 
			   (x_11634, x_11635)
			val trim_0: word32 = 
			   x_8548 x_11636
			val x_11637: word32 = 
			   sextdFromInt32ToWord32_0 trim_0
			val maxInt'_5: word8 = 
			   x_11567 x_11637
			val maxInt_1: real32 = 
			   fromInt8Unsafe_0 maxInt'_5
			val minInt_1: real32 = 
			   fromInt8Unsafe_0 minInt'_0
			val x_11638: IEEEReal.RoundingMode.t_0
				     -> real32 -> word8 = 
			   fn x_11639: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11640: real32 -> word8 = 
				 fn x_11641: real32 => 
				 let
				    val x_11642: real32 * real32 = 
				       (minInt_1, x_11641)
				    val x_11643: bool = 
				       <=_2 x_11642
				    val x_11644: word8 = 
				       case x_11643 of
				       true => 
					  let
					     val x_11650: real32 * real32 = 
						(x_11641, maxInt_1)
					     val x_11651: bool = 
						<=_2 x_11650
					     val x_11652: word8 = 
						case x_11651 of
						true => 
						   let
						      val x_11654: word8 = 
							 case x_11639 of
							 TO_POSINF_0 => 
							    let
							       val x_11665: real32 = 
								  Real32_realCeil (x_11641)
							       val x_11666: word8 = 
								  toInt8Unsafe_0 x_11665
							    in
							       x_11666
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11659: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11660: unit = 
								  ()
							       val m'_2: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11660
							       val x_11661: unit = 
								  setRoundingMode_0 x_11659
							       val x_11662: real32 = 
								  round_0 x_11641
							       val x_11663: unit = 
								  setRoundingMode_0 m'_2
							       val x_11664: word8 = 
								  toInt8Unsafe_0 x_11662
							    in
							       x_11664
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11657: real32 = 
								  Real32_realTrunc (x_11641)
							       val x_11658: word8 = 
								  toInt8Unsafe_0 x_11657
							    in
							       x_11658
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11655: real32 = 
								  Real32_realFloor (x_11641)
							       val x_11656: word8 = 
								  toInt8Unsafe_0 x_11655
							    in
							       x_11656
							    end
						   in
						      x_11654
						   end
						false => 
						   let
						      val x_11653: word8 = 
							 raise x_8290
						   in
						      x_11653
						   end
					  in
					     x_11652
					  end
				       false => 
					  let
					     val x_11645: real32 * real32 = 
						(x_11641, minInt_1)
					     val x_11646: bool = 
						<_3 x_11645
					     val x_11647: word8 = 
						case x_11646 of
						true => 
						   let
						      val x_11649: word8 = 
							 raise x_8290
						   in
						      x_11649
						   end
						false => 
						   let
						      val x_11648: word8 = 
							 raise x_8285
						   in
						      x_11648
						   end
					  in
					     x_11647
					  end
				 in
				    x_11644
				 end
			   in
			      x_11640
			   end
		     in
			x_11638
		     end
		  false => 
		     let
			val x_11576: word32 = 
			   0x0
			val maxInt'_4: word8 = 
			   x_11567 x_11576
			val maxInt_0: real32 = 
			   fromInt8Unsafe_0 maxInt'_4
			val minInt_0: real32 = 
			   fromInt8Unsafe_0 minInt'_0
			val x_11577: IEEEReal.RoundingMode.t_0
				     -> real32 -> word8 = 
			   fn x_11578: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11579: real32 -> word8 = 
				 fn x_11580: real32 => 
				 let
				    val x_11581: real32 * real32 = 
				       (minInt_0, x_11580)
				    val x_11582: bool = 
				       <=_2 x_11581
				    val x_11583: word8 = 
				       case x_11582 of
				       true => 
					  let
					     val x_11603: real32 * real32 = 
						(x_11580, maxInt_0)
					     val x_11604: bool = 
						<=_2 x_11603
					     val x_11605: word8 = 
						case x_11604 of
						true => 
						   let
						      val x_11620: word8 = 
							 case x_11578 of
							 TO_POSINF_0 => 
							    let
							       val x_11631: real32 = 
								  Real32_realCeil (x_11580)
							       val x_11632: word8 = 
								  toInt8Unsafe_0 x_11631
							    in
							       x_11632
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11625: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11626: unit = 
								  ()
							       val m'_1: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11626
							       val x_11627: unit = 
								  setRoundingMode_0 x_11625
							       val x_11628: real32 = 
								  round_0 x_11580
							       val x_11629: unit = 
								  setRoundingMode_0 m'_1
							       val x_11630: word8 = 
								  toInt8Unsafe_0 x_11628
							    in
							       x_11630
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11623: real32 = 
								  Real32_realTrunc (x_11580)
							       val x_11624: word8 = 
								  toInt8Unsafe_0 x_11623
							    in
							       x_11624
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11621: real32 = 
								  Real32_realFloor (x_11580)
							       val x_11622: word8 = 
								  toInt8Unsafe_0 x_11621
							    in
							       x_11622
							    end
						   in
						      x_11620
						   end
						false => 
						   let
						      val x_11606: real32
								   * real32 = 
							 (maxInt_0, one_6)
						      val x_11607: real32 = 
							 +_1 x_11606
						      val x_11608: real32
								   * real32 = 
							 (x_11580, x_11607)
						      val x_11609: bool = 
							 <_3 x_11608
						      val x_11610: word8 = 
							 case x_11609 of
							 true => 
							    let
							       val x_11612: word8 = 
								  case x_11578 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_4
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_4
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11614: real32
										     * real32 = 
									   (x_11580,
									    maxInt_0)
									val x_11615: real32 = 
									   -_1 x_11614
									val x_11616: real32
										     * real32 = 
									   (x_11615,
									    half_0)
									val x_11617: bool = 
									   >=_3 x_11616
									val x_11618: word8 = 
									   case x_11617 of
									   true => 
									      let
										 val x_11619: word8 = 
										    raise x_8290
									      in
										 x_11619
									      end
									   false => 
									      let
									      in
										 maxInt'_4
									      end
								     in
									x_11618
								     end
								  TO_POSINF_0 => 
								     let
									val x_11613: word8 = 
									   raise x_8290
								     in
									x_11613
								     end
							    in
							       x_11612
							    end
							 false => 
							    let
							       val x_11611: word8 = 
								  raise x_8290
							    in
							       x_11611
							    end
						   in
						      x_11610
						   end
					  in
					     x_11605
					  end
				       false => 
					  let
					     val x_11584: real32 * real32 = 
						(x_11580, minInt_0)
					     val x_11585: bool = 
						<_3 x_11584
					     val x_11586: word8 = 
						case x_11585 of
						true => 
						   let
						      val x_11588: real32
								   * real32 = 
							 (minInt_0, one_6)
						      val x_11589: real32 = 
							 -_1 x_11588
						      val x_11590: real32
								   * real32 = 
							 (x_11589, x_11580)
						      val x_11591: bool = 
							 <_3 x_11590
						      val x_11592: word8 = 
							 case x_11591 of
							 true => 
							    let
							       val x_11594: word8 = 
								  case x_11578 of
								  TO_NEGINF_0 => 
								     let
									val x_11602: word8 = 
									   raise x_8290
								     in
									x_11602
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_0
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11595: real32
										     * real32 = 
									   (x_11580,
									    minInt_0)
									val x_11596: real32 = 
									   -_1 x_11595
									val x_11597: real32 = 
									   ~_0 half_0
									val x_11598: real32
										     * real32 = 
									   (x_11596,
									    x_11597)
									val x_11599: bool = 
									   <_3 x_11598
									val x_11600: word8 = 
									   case x_11599 of
									   true => 
									      let
										 val x_11601: word8 = 
										    raise x_8290
									      in
										 x_11601
									      end
									   false => 
									      let
									      in
										 minInt'_0
									      end
								     in
									x_11600
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_0
								     end
							    in
							       x_11594
							    end
							 false => 
							    let
							       val x_11593: word8 = 
								  raise x_8290
							    in
							       x_11593
							    end
						   in
						      x_11592
						   end
						false => 
						   let
						      val x_11587: word8 = 
							 raise x_8285
						   in
						      x_11587
						   end
					  in
					     x_11586
					  end
				 in
				    x_11583
				 end
			   in
			      x_11579
			   end
		     in
			x_11577
		     end
	       val x_11667: word32 -> word16 = 
		  fn x_11668: word32 => 
		  let
		     val x_11669: word16 * word32 = 
			(maxInt'_1, x_11668)
		     val x_11670: word16 = 
			>>_1 x_11669
		     val x_11671: word16 * word32 = 
			(x_11670, x_11668)
		     val x_11672: word16 = 
			<<_1 x_11671
		  in
		     x_11672
		  end
	       val x_11673: word32 * word32 = 
		  (precision_7, precision'_1)
	       val x_11674: bool = 
		  <_1 x_11673
	       val x_11675: IEEEReal.RoundingMode.t_0 -> real32 -> word16 = 
		  case x_11674 of
		  true => 
		     let
			val x_11733: word32 * word32 = 
			   (precision'_1, precision_7)
			val x_11734: word32 = 
			   x_8548 x_11733
			val x_11735: word32 = 
			   0x1
			val x_11736: word32 * word32 = 
			   (x_11734, x_11735)
			val trim_1: word32 = 
			   x_8548 x_11736
			val x_11737: word32 = 
			   sextdFromInt32ToWord32_0 trim_1
			val maxInt'_7: word16 = 
			   x_11667 x_11737
			val maxInt_3: real32 = 
			   fromInt16Unsafe_0 maxInt'_7
			val minInt_3: real32 = 
			   fromInt16Unsafe_0 minInt'_1
			val x_11738: IEEEReal.RoundingMode.t_0
				     -> real32 -> word16 = 
			   fn x_11739: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11740: real32 -> word16 = 
				 fn x_11741: real32 => 
				 let
				    val x_11742: real32 * real32 = 
				       (minInt_3, x_11741)
				    val x_11743: bool = 
				       <=_2 x_11742
				    val x_11744: word16 = 
				       case x_11743 of
				       true => 
					  let
					     val x_11750: real32 * real32 = 
						(x_11741, maxInt_3)
					     val x_11751: bool = 
						<=_2 x_11750
					     val x_11752: word16 = 
						case x_11751 of
						true => 
						   let
						      val x_11754: word16 = 
							 case x_11739 of
							 TO_POSINF_0 => 
							    let
							       val x_11765: real32 = 
								  Real32_realCeil (x_11741)
							       val x_11766: word16 = 
								  toInt16Unsafe_0 x_11765
							    in
							       x_11766
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11759: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11760: unit = 
								  ()
							       val m'_4: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11760
							       val x_11761: unit = 
								  setRoundingMode_0 x_11759
							       val x_11762: real32 = 
								  round_0 x_11741
							       val x_11763: unit = 
								  setRoundingMode_0 m'_4
							       val x_11764: word16 = 
								  toInt16Unsafe_0 x_11762
							    in
							       x_11764
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11757: real32 = 
								  Real32_realTrunc (x_11741)
							       val x_11758: word16 = 
								  toInt16Unsafe_0 x_11757
							    in
							       x_11758
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11755: real32 = 
								  Real32_realFloor (x_11741)
							       val x_11756: word16 = 
								  toInt16Unsafe_0 x_11755
							    in
							       x_11756
							    end
						   in
						      x_11754
						   end
						false => 
						   let
						      val x_11753: word16 = 
							 raise x_8290
						   in
						      x_11753
						   end
					  in
					     x_11752
					  end
				       false => 
					  let
					     val x_11745: real32 * real32 = 
						(x_11741, minInt_3)
					     val x_11746: bool = 
						<_3 x_11745
					     val x_11747: word16 = 
						case x_11746 of
						true => 
						   let
						      val x_11749: word16 = 
							 raise x_8290
						   in
						      x_11749
						   end
						false => 
						   let
						      val x_11748: word16 = 
							 raise x_8285
						   in
						      x_11748
						   end
					  in
					     x_11747
					  end
				 in
				    x_11744
				 end
			   in
			      x_11740
			   end
		     in
			x_11738
		     end
		  false => 
		     let
			val x_11676: word32 = 
			   0x0
			val maxInt'_6: word16 = 
			   x_11667 x_11676
			val maxInt_2: real32 = 
			   fromInt16Unsafe_0 maxInt'_6
			val minInt_2: real32 = 
			   fromInt16Unsafe_0 minInt'_1
			val x_11677: IEEEReal.RoundingMode.t_0
				     -> real32 -> word16 = 
			   fn x_11678: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11679: real32 -> word16 = 
				 fn x_11680: real32 => 
				 let
				    val x_11681: real32 * real32 = 
				       (minInt_2, x_11680)
				    val x_11682: bool = 
				       <=_2 x_11681
				    val x_11683: word16 = 
				       case x_11682 of
				       true => 
					  let
					     val x_11703: real32 * real32 = 
						(x_11680, maxInt_2)
					     val x_11704: bool = 
						<=_2 x_11703
					     val x_11705: word16 = 
						case x_11704 of
						true => 
						   let
						      val x_11720: word16 = 
							 case x_11678 of
							 TO_POSINF_0 => 
							    let
							       val x_11731: real32 = 
								  Real32_realCeil (x_11680)
							       val x_11732: word16 = 
								  toInt16Unsafe_0 x_11731
							    in
							       x_11732
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11725: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11726: unit = 
								  ()
							       val m'_3: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11726
							       val x_11727: unit = 
								  setRoundingMode_0 x_11725
							       val x_11728: real32 = 
								  round_0 x_11680
							       val x_11729: unit = 
								  setRoundingMode_0 m'_3
							       val x_11730: word16 = 
								  toInt16Unsafe_0 x_11728
							    in
							       x_11730
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11723: real32 = 
								  Real32_realTrunc (x_11680)
							       val x_11724: word16 = 
								  toInt16Unsafe_0 x_11723
							    in
							       x_11724
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11721: real32 = 
								  Real32_realFloor (x_11680)
							       val x_11722: word16 = 
								  toInt16Unsafe_0 x_11721
							    in
							       x_11722
							    end
						   in
						      x_11720
						   end
						false => 
						   let
						      val x_11706: real32
								   * real32 = 
							 (maxInt_2, one_6)
						      val x_11707: real32 = 
							 +_1 x_11706
						      val x_11708: real32
								   * real32 = 
							 (x_11680, x_11707)
						      val x_11709: bool = 
							 <_3 x_11708
						      val x_11710: word16 = 
							 case x_11709 of
							 true => 
							    let
							       val x_11712: word16 = 
								  case x_11678 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_6
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_6
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11714: real32
										     * real32 = 
									   (x_11680,
									    maxInt_2)
									val x_11715: real32 = 
									   -_1 x_11714
									val x_11716: real32
										     * real32 = 
									   (x_11715,
									    half_0)
									val x_11717: bool = 
									   >=_3 x_11716
									val x_11718: word16 = 
									   case x_11717 of
									   true => 
									      let
										 val x_11719: word16 = 
										    raise x_8290
									      in
										 x_11719
									      end
									   false => 
									      let
									      in
										 maxInt'_6
									      end
								     in
									x_11718
								     end
								  TO_POSINF_0 => 
								     let
									val x_11713: word16 = 
									   raise x_8290
								     in
									x_11713
								     end
							    in
							       x_11712
							    end
							 false => 
							    let
							       val x_11711: word16 = 
								  raise x_8290
							    in
							       x_11711
							    end
						   in
						      x_11710
						   end
					  in
					     x_11705
					  end
				       false => 
					  let
					     val x_11684: real32 * real32 = 
						(x_11680, minInt_2)
					     val x_11685: bool = 
						<_3 x_11684
					     val x_11686: word16 = 
						case x_11685 of
						true => 
						   let
						      val x_11688: real32
								   * real32 = 
							 (minInt_2, one_6)
						      val x_11689: real32 = 
							 -_1 x_11688
						      val x_11690: real32
								   * real32 = 
							 (x_11689, x_11680)
						      val x_11691: bool = 
							 <_3 x_11690
						      val x_11692: word16 = 
							 case x_11691 of
							 true => 
							    let
							       val x_11694: word16 = 
								  case x_11678 of
								  TO_NEGINF_0 => 
								     let
									val x_11702: word16 = 
									   raise x_8290
								     in
									x_11702
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_1
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11695: real32
										     * real32 = 
									   (x_11680,
									    minInt_2)
									val x_11696: real32 = 
									   -_1 x_11695
									val x_11697: real32 = 
									   ~_0 half_0
									val x_11698: real32
										     * real32 = 
									   (x_11696,
									    x_11697)
									val x_11699: bool = 
									   <_3 x_11698
									val x_11700: word16 = 
									   case x_11699 of
									   true => 
									      let
										 val x_11701: word16 = 
										    raise x_8290
									      in
										 x_11701
									      end
									   false => 
									      let
									      in
										 minInt'_1
									      end
								     in
									x_11700
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_1
								     end
							    in
							       x_11694
							    end
							 false => 
							    let
							       val x_11693: word16 = 
								  raise x_8290
							    in
							       x_11693
							    end
						   in
						      x_11692
						   end
						false => 
						   let
						      val x_11687: word16 = 
							 raise x_8285
						   in
						      x_11687
						   end
					  in
					     x_11686
					  end
				 in
				    x_11683
				 end
			   in
			      x_11679
			   end
		     in
			x_11677
		     end
	       val x_11767: word32 -> word32 = 
		  fn x_11768: word32 => 
		  let
		     val x_11769: word32 * word32 = 
			(maxInt'_2, x_11768)
		     val x_11770: word32 = 
			>>_2 x_11769
		     val x_11771: word32 * word32 = 
			(x_11770, x_11768)
		     val x_11772: word32 = 
			<<_2 x_11771
		  in
		     x_11772
		  end
	       val x_11773: word32 * word32 = 
		  (precision_7, precision'_2)
	       val x_11774: bool = 
		  <_1 x_11773
	       val x_11775: IEEEReal.RoundingMode.t_0 -> real32 -> word32 = 
		  case x_11774 of
		  true => 
		     let
			val x_11833: word32 * word32 = 
			   (precision'_2, precision_7)
			val x_11834: word32 = 
			   x_8548 x_11833
			val x_11835: word32 = 
			   0x1
			val x_11836: word32 * word32 = 
			   (x_11834, x_11835)
			val trim_2: word32 = 
			   x_8548 x_11836
			val x_11837: word32 = 
			   sextdFromInt32ToWord32_0 trim_2
			val maxInt'_9: word32 = 
			   x_11767 x_11837
			val maxInt_5: real32 = 
			   fromInt32Unsafe_0 maxInt'_9
			val minInt_5: real32 = 
			   fromInt32Unsafe_0 minInt'_2
			val x_11838: IEEEReal.RoundingMode.t_0
				     -> real32 -> word32 = 
			   fn x_11839: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11840: real32 -> word32 = 
				 fn x_11841: real32 => 
				 let
				    val x_11842: real32 * real32 = 
				       (minInt_5, x_11841)
				    val x_11843: bool = 
				       <=_2 x_11842
				    val x_11844: word32 = 
				       case x_11843 of
				       true => 
					  let
					     val x_11850: real32 * real32 = 
						(x_11841, maxInt_5)
					     val x_11851: bool = 
						<=_2 x_11850
					     val x_11852: word32 = 
						case x_11851 of
						true => 
						   let
						      val x_11854: word32 = 
							 case x_11839 of
							 TO_POSINF_0 => 
							    let
							       val x_11865: real32 = 
								  Real32_realCeil (x_11841)
							       val x_11866: word32 = 
								  toInt32Unsafe_0 x_11865
							    in
							       x_11866
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11859: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11860: unit = 
								  ()
							       val m'_6: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11860
							       val x_11861: unit = 
								  setRoundingMode_0 x_11859
							       val x_11862: real32 = 
								  round_0 x_11841
							       val x_11863: unit = 
								  setRoundingMode_0 m'_6
							       val x_11864: word32 = 
								  toInt32Unsafe_0 x_11862
							    in
							       x_11864
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11857: real32 = 
								  Real32_realTrunc (x_11841)
							       val x_11858: word32 = 
								  toInt32Unsafe_0 x_11857
							    in
							       x_11858
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11855: real32 = 
								  Real32_realFloor (x_11841)
							       val x_11856: word32 = 
								  toInt32Unsafe_0 x_11855
							    in
							       x_11856
							    end
						   in
						      x_11854
						   end
						false => 
						   let
						      val x_11853: word32 = 
							 raise x_8290
						   in
						      x_11853
						   end
					  in
					     x_11852
					  end
				       false => 
					  let
					     val x_11845: real32 * real32 = 
						(x_11841, minInt_5)
					     val x_11846: bool = 
						<_3 x_11845
					     val x_11847: word32 = 
						case x_11846 of
						true => 
						   let
						      val x_11849: word32 = 
							 raise x_8290
						   in
						      x_11849
						   end
						false => 
						   let
						      val x_11848: word32 = 
							 raise x_8285
						   in
						      x_11848
						   end
					  in
					     x_11847
					  end
				 in
				    x_11844
				 end
			   in
			      x_11840
			   end
		     in
			x_11838
		     end
		  false => 
		     let
			val x_11776: word32 = 
			   0x0
			val maxInt'_8: word32 = 
			   x_11767 x_11776
			val maxInt_4: real32 = 
			   fromInt32Unsafe_0 maxInt'_8
			val minInt_4: real32 = 
			   fromInt32Unsafe_0 minInt'_2
			val x_11777: IEEEReal.RoundingMode.t_0
				     -> real32 -> word32 = 
			   fn x_11778: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11779: real32 -> word32 = 
				 fn x_11780: real32 => 
				 let
				    val x_11781: real32 * real32 = 
				       (minInt_4, x_11780)
				    val x_11782: bool = 
				       <=_2 x_11781
				    val x_11783: word32 = 
				       case x_11782 of
				       true => 
					  let
					     val x_11803: real32 * real32 = 
						(x_11780, maxInt_4)
					     val x_11804: bool = 
						<=_2 x_11803
					     val x_11805: word32 = 
						case x_11804 of
						true => 
						   let
						      val x_11820: word32 = 
							 case x_11778 of
							 TO_POSINF_0 => 
							    let
							       val x_11831: real32 = 
								  Real32_realCeil (x_11780)
							       val x_11832: word32 = 
								  toInt32Unsafe_0 x_11831
							    in
							       x_11832
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11825: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11826: unit = 
								  ()
							       val m'_5: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11826
							       val x_11827: unit = 
								  setRoundingMode_0 x_11825
							       val x_11828: real32 = 
								  round_0 x_11780
							       val x_11829: unit = 
								  setRoundingMode_0 m'_5
							       val x_11830: word32 = 
								  toInt32Unsafe_0 x_11828
							    in
							       x_11830
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11823: real32 = 
								  Real32_realTrunc (x_11780)
							       val x_11824: word32 = 
								  toInt32Unsafe_0 x_11823
							    in
							       x_11824
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11821: real32 = 
								  Real32_realFloor (x_11780)
							       val x_11822: word32 = 
								  toInt32Unsafe_0 x_11821
							    in
							       x_11822
							    end
						   in
						      x_11820
						   end
						false => 
						   let
						      val x_11806: real32
								   * real32 = 
							 (maxInt_4, one_6)
						      val x_11807: real32 = 
							 +_1 x_11806
						      val x_11808: real32
								   * real32 = 
							 (x_11780, x_11807)
						      val x_11809: bool = 
							 <_3 x_11808
						      val x_11810: word32 = 
							 case x_11809 of
							 true => 
							    let
							       val x_11812: word32 = 
								  case x_11778 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_8
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_8
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11814: real32
										     * real32 = 
									   (x_11780,
									    maxInt_4)
									val x_11815: real32 = 
									   -_1 x_11814
									val x_11816: real32
										     * real32 = 
									   (x_11815,
									    half_0)
									val x_11817: bool = 
									   >=_3 x_11816
									val x_11818: word32 = 
									   case x_11817 of
									   true => 
									      let
										 val x_11819: word32 = 
										    raise x_8290
									      in
										 x_11819
									      end
									   false => 
									      let
									      in
										 maxInt'_8
									      end
								     in
									x_11818
								     end
								  TO_POSINF_0 => 
								     let
									val x_11813: word32 = 
									   raise x_8290
								     in
									x_11813
								     end
							    in
							       x_11812
							    end
							 false => 
							    let
							       val x_11811: word32 = 
								  raise x_8290
							    in
							       x_11811
							    end
						   in
						      x_11810
						   end
					  in
					     x_11805
					  end
				       false => 
					  let
					     val x_11784: real32 * real32 = 
						(x_11780, minInt_4)
					     val x_11785: bool = 
						<_3 x_11784
					     val x_11786: word32 = 
						case x_11785 of
						true => 
						   let
						      val x_11788: real32
								   * real32 = 
							 (minInt_4, one_6)
						      val x_11789: real32 = 
							 -_1 x_11788
						      val x_11790: real32
								   * real32 = 
							 (x_11789, x_11780)
						      val x_11791: bool = 
							 <_3 x_11790
						      val x_11792: word32 = 
							 case x_11791 of
							 true => 
							    let
							       val x_11794: word32 = 
								  case x_11778 of
								  TO_NEGINF_0 => 
								     let
									val x_11802: word32 = 
									   raise x_8290
								     in
									x_11802
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_2
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11795: real32
										     * real32 = 
									   (x_11780,
									    minInt_4)
									val x_11796: real32 = 
									   -_1 x_11795
									val x_11797: real32 = 
									   ~_0 half_0
									val x_11798: real32
										     * real32 = 
									   (x_11796,
									    x_11797)
									val x_11799: bool = 
									   <_3 x_11798
									val x_11800: word32 = 
									   case x_11799 of
									   true => 
									      let
										 val x_11801: word32 = 
										    raise x_8290
									      in
										 x_11801
									      end
									   false => 
									      let
									      in
										 minInt'_2
									      end
								     in
									x_11800
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_2
								     end
							    in
							       x_11794
							    end
							 false => 
							    let
							       val x_11793: word32 = 
								  raise x_8290
							    in
							       x_11793
							    end
						   in
						      x_11792
						   end
						false => 
						   let
						      val x_11787: word32 = 
							 raise x_8285
						   in
						      x_11787
						   end
					  in
					     x_11786
					  end
				 in
				    x_11783
				 end
			   in
			      x_11779
			   end
		     in
			x_11777
		     end
	       val x_11867: word32 -> word64 = 
		  fn x_11868: word32 => 
		  let
		     val x_11869: word64 * word32 = 
			(maxInt'_3, x_11868)
		     val x_11870: word64 = 
			>>_3 x_11869
		     val x_11871: word64 * word32 = 
			(x_11870, x_11868)
		     val x_11872: word64 = 
			<<_3 x_11871
		  in
		     x_11872
		  end
	       val x_11873: word32 * word32 = 
		  (precision_7, precision'_3)
	       val x_11874: bool = 
		  <_1 x_11873
	       val x_11875: IEEEReal.RoundingMode.t_0 -> real32 -> word64 = 
		  case x_11874 of
		  true => 
		     let
			val x_11933: word32 * word32 = 
			   (precision'_3, precision_7)
			val x_11934: word32 = 
			   x_8548 x_11933
			val x_11935: word32 = 
			   0x1
			val x_11936: word32 * word32 = 
			   (x_11934, x_11935)
			val trim_3: word32 = 
			   x_8548 x_11936
			val x_11937: word32 = 
			   sextdFromInt32ToWord32_0 trim_3
			val maxInt'_11: word64 = 
			   x_11867 x_11937
			val maxInt_7: real32 = 
			   fromInt64Unsafe_0 maxInt'_11
			val minInt_7: real32 = 
			   fromInt64Unsafe_0 minInt'_3
			val x_11938: IEEEReal.RoundingMode.t_0
				     -> real32 -> word64 = 
			   fn x_11939: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11940: real32 -> word64 = 
				 fn x_11941: real32 => 
				 let
				    val x_11942: real32 * real32 = 
				       (minInt_7, x_11941)
				    val x_11943: bool = 
				       <=_2 x_11942
				    val x_11944: word64 = 
				       case x_11943 of
				       true => 
					  let
					     val x_11950: real32 * real32 = 
						(x_11941, maxInt_7)
					     val x_11951: bool = 
						<=_2 x_11950
					     val x_11952: word64 = 
						case x_11951 of
						true => 
						   let
						      val x_11954: word64 = 
							 case x_11939 of
							 TO_POSINF_0 => 
							    let
							       val x_11965: real32 = 
								  Real32_realCeil (x_11941)
							       val x_11966: word64 = 
								  toInt64Unsafe_0 x_11965
							    in
							       x_11966
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11959: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11960: unit = 
								  ()
							       val m'_8: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11960
							       val x_11961: unit = 
								  setRoundingMode_0 x_11959
							       val x_11962: real32 = 
								  round_0 x_11941
							       val x_11963: unit = 
								  setRoundingMode_0 m'_8
							       val x_11964: word64 = 
								  toInt64Unsafe_0 x_11962
							    in
							       x_11964
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11957: real32 = 
								  Real32_realTrunc (x_11941)
							       val x_11958: word64 = 
								  toInt64Unsafe_0 x_11957
							    in
							       x_11958
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11955: real32 = 
								  Real32_realFloor (x_11941)
							       val x_11956: word64 = 
								  toInt64Unsafe_0 x_11955
							    in
							       x_11956
							    end
						   in
						      x_11954
						   end
						false => 
						   let
						      val x_11953: word64 = 
							 raise x_8290
						   in
						      x_11953
						   end
					  in
					     x_11952
					  end
				       false => 
					  let
					     val x_11945: real32 * real32 = 
						(x_11941, minInt_7)
					     val x_11946: bool = 
						<_3 x_11945
					     val x_11947: word64 = 
						case x_11946 of
						true => 
						   let
						      val x_11949: word64 = 
							 raise x_8290
						   in
						      x_11949
						   end
						false => 
						   let
						      val x_11948: word64 = 
							 raise x_8285
						   in
						      x_11948
						   end
					  in
					     x_11947
					  end
				 in
				    x_11944
				 end
			   in
			      x_11940
			   end
		     in
			x_11938
		     end
		  false => 
		     let
			val x_11876: word32 = 
			   0x0
			val maxInt'_10: word64 = 
			   x_11867 x_11876
			val maxInt_6: real32 = 
			   fromInt64Unsafe_0 maxInt'_10
			val minInt_6: real32 = 
			   fromInt64Unsafe_0 minInt'_3
			val x_11877: IEEEReal.RoundingMode.t_0
				     -> real32 -> word64 = 
			   fn x_11878: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11879: real32 -> word64 = 
				 fn x_11880: real32 => 
				 let
				    val x_11881: real32 * real32 = 
				       (minInt_6, x_11880)
				    val x_11882: bool = 
				       <=_2 x_11881
				    val x_11883: word64 = 
				       case x_11882 of
				       true => 
					  let
					     val x_11903: real32 * real32 = 
						(x_11880, maxInt_6)
					     val x_11904: bool = 
						<=_2 x_11903
					     val x_11905: word64 = 
						case x_11904 of
						true => 
						   let
						      val x_11920: word64 = 
							 case x_11878 of
							 TO_POSINF_0 => 
							    let
							       val x_11931: real32 = 
								  Real32_realCeil (x_11880)
							       val x_11932: word64 = 
								  toInt64Unsafe_0 x_11931
							    in
							       x_11932
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_11925: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_11926: unit = 
								  ()
							       val m'_7: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_11926
							       val x_11927: unit = 
								  setRoundingMode_0 x_11925
							       val x_11928: real32 = 
								  round_0 x_11880
							       val x_11929: unit = 
								  setRoundingMode_0 m'_7
							       val x_11930: word64 = 
								  toInt64Unsafe_0 x_11928
							    in
							       x_11930
							    end
							 TO_ZERO_0 => 
							    let
							       val x_11923: real32 = 
								  Real32_realTrunc (x_11880)
							       val x_11924: word64 = 
								  toInt64Unsafe_0 x_11923
							    in
							       x_11924
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_11921: real32 = 
								  Real32_realFloor (x_11880)
							       val x_11922: word64 = 
								  toInt64Unsafe_0 x_11921
							    in
							       x_11922
							    end
						   in
						      x_11920
						   end
						false => 
						   let
						      val x_11906: real32
								   * real32 = 
							 (maxInt_6, one_6)
						      val x_11907: real32 = 
							 +_1 x_11906
						      val x_11908: real32
								   * real32 = 
							 (x_11880, x_11907)
						      val x_11909: bool = 
							 <_3 x_11908
						      val x_11910: word64 = 
							 case x_11909 of
							 true => 
							    let
							       val x_11912: word64 = 
								  case x_11878 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_10
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_10
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11914: real32
										     * real32 = 
									   (x_11880,
									    maxInt_6)
									val x_11915: real32 = 
									   -_1 x_11914
									val x_11916: real32
										     * real32 = 
									   (x_11915,
									    half_0)
									val x_11917: bool = 
									   >=_3 x_11916
									val x_11918: word64 = 
									   case x_11917 of
									   true => 
									      let
										 val x_11919: word64 = 
										    raise x_8290
									      in
										 x_11919
									      end
									   false => 
									      let
									      in
										 maxInt'_10
									      end
								     in
									x_11918
								     end
								  TO_POSINF_0 => 
								     let
									val x_11913: word64 = 
									   raise x_8290
								     in
									x_11913
								     end
							    in
							       x_11912
							    end
							 false => 
							    let
							       val x_11911: word64 = 
								  raise x_8290
							    in
							       x_11911
							    end
						   in
						      x_11910
						   end
					  in
					     x_11905
					  end
				       false => 
					  let
					     val x_11884: real32 * real32 = 
						(x_11880, minInt_6)
					     val x_11885: bool = 
						<_3 x_11884
					     val x_11886: word64 = 
						case x_11885 of
						true => 
						   let
						      val x_11888: real32
								   * real32 = 
							 (minInt_6, one_6)
						      val x_11889: real32 = 
							 -_1 x_11888
						      val x_11890: real32
								   * real32 = 
							 (x_11889, x_11880)
						      val x_11891: bool = 
							 <_3 x_11890
						      val x_11892: word64 = 
							 case x_11891 of
							 true => 
							    let
							       val x_11894: word64 = 
								  case x_11878 of
								  TO_NEGINF_0 => 
								     let
									val x_11902: word64 = 
									   raise x_8290
								     in
									x_11902
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_3
								     end
								  TO_NEAREST_0 => 
								     let
									val x_11895: real32
										     * real32 = 
									   (x_11880,
									    minInt_6)
									val x_11896: real32 = 
									   -_1 x_11895
									val x_11897: real32 = 
									   ~_0 half_0
									val x_11898: real32
										     * real32 = 
									   (x_11896,
									    x_11897)
									val x_11899: bool = 
									   <_3 x_11898
									val x_11900: word64 = 
									   case x_11899 of
									   true => 
									      let
										 val x_11901: word64 = 
										    raise x_8290
									      in
										 x_11901
									      end
									   false => 
									      let
									      in
										 minInt'_3
									      end
								     in
									x_11900
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_3
								     end
							    in
							       x_11894
							    end
							 false => 
							    let
							       val x_11893: word64 = 
								  raise x_8290
							    in
							       x_11893
							    end
						   in
						      x_11892
						   end
						false => 
						   let
						      val x_11887: word64 = 
							 raise x_8285
						   in
						      x_11887
						   end
					  in
					     x_11886
					  end
				 in
				    x_11883
				 end
			   in
			      x_11879
			   end
		     in
			x_11877
		     end
	       val x_11967: word32 -> word8 = 
		  fn x_11968: word32 => 
		  let
		     val x_11969: word8 * word32 = 
			(maxWord'_0, x_11968)
		     val x_11970: word8 = 
			>>_4 x_11969
		     val x_11971: word8 * word32 = 
			(x_11970, x_11968)
		     val x_11972: word8 = 
			<<_4 x_11971
		  in
		     x_11972
		  end
	       val x_11973: word32 * word32 = 
		  (precision_7, wordSize_0)
	       val x_11974: bool = 
		  <=_0 x_11973
	       val x_11975: IEEEReal.RoundingMode.t_0 -> real32 -> word8 = 
		  case x_11974 of
		  true => 
		     let
			val x_12030: word32 * word32 = 
			   (wordSize_0, precision_7)
			val trim_4: word32 = 
			   x_8548 x_12030
			val x_12031: word32 = 
			   sextdFromInt32ToWord32_0 trim_4
			val maxWord'_5: word8 = 
			   x_11967 x_12031
			val maxWord_1: real32 = 
			   fromWord8Unsafe_0 maxWord'_5
			val x_12032: IEEEReal.RoundingMode.t_0
				     -> real32 -> word8 = 
			   fn x_12033: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12034: real32 -> word8 = 
				 fn x_12035: real32 => 
				 let
				    val x_12036: IEEEReal.float_class_0 = 
				       class_0 x_12035
				    val x_12037: word8 = 
				       case x_12036 of
				       INF_0 => 
					  let
					     val x_12039: word8 = 
						raise x_8290
					  in
					     x_12039
					  end
				       NAN_0 => 
					  let
					     val x_12038: word8 = 
						raise x_8285
					  in
					     x_12038
					  end
					 _ => let
						 val x_12040: real32 * real32 = 
						    (zero_7, x_12035)
						 val x_12041: bool = 
						    <=_2 x_12040
						 val x_12042: word8 = 
						    case x_12041 of
						    true => 
						       let
							  val x_12055: real32
								       * real32 = 
							     (x_12035, maxWord_1)
							  val x_12056: bool = 
							     <=_2 x_12055
							  val x_12057: word8 = 
							     case x_12056 of
							     true => 
								let
								   val x_12059: word8 = 
								      case x_12033 of
								      TO_POSINF_0 => 
									 let
									    val x_12070: real32 = 
									       Real32_realCeil (x_12035)
									    val x_12071: word8 = 
									       toWord8Unsafe_0 x_12070
									 in
									    x_12071
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12064: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12065: unit = 
									       ()
									    val m'_10: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12065
									    val x_12066: unit = 
									       setRoundingMode_0 x_12064
									    val x_12067: real32 = 
									       round_0 x_12035
									    val x_12068: unit = 
									       setRoundingMode_0 m'_10
									    val x_12069: word8 = 
									       toWord8Unsafe_0 x_12067
									 in
									    x_12069
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12062: real32 = 
									       Real32_realTrunc (x_12035)
									    val x_12063: word8 = 
									       toWord8Unsafe_0 x_12062
									 in
									    x_12063
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12060: real32 = 
									       Real32_realFloor (x_12035)
									    val x_12061: word8 = 
									       toWord8Unsafe_0 x_12060
									 in
									    x_12061
									 end
								in
								   x_12059
								end
							     false => 
								let
								   val x_12058: word8 = 
								      raise x_8290
								in
								   x_12058
								end
						       in
							  x_12057
						       end
						    false => 
						       let
							  val x_12043: real32 = 
							     ~_0 one_6
							  val x_12044: real32
								       * real32 = 
							     (x_12035, x_12043)
							  val x_12045: bool = 
							     >_2 x_12044
							  val x_12046: word8 = 
							     case x_12045 of
							     true => 
								let
								   val x_12048: word8 = 
								      case x_12033 of
								      TO_NEGINF_0 => 
									 let
									    val x_12054: word8 = 
									       raise x_8290
									 in
									    x_12054
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8909
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12049: real32 = 
									       ~_0 half_0
									    val x_12050: real32
											 * real32 = 
									       (x_12035,
										x_12049)
									    val x_12051: bool = 
									       <_3 x_12050
									    val x_12052: word8 = 
									       case x_12051 of
									       true => 
										  let
										     val x_12053: word8 = 
											raise x_8290
										  in
										     x_12053
										  end
									       false => 
										  let
										  in
										     x_8909
										  end
									 in
									    x_12052
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8909
									 end
								in
								   x_12048
								end
							     false => 
								let
								   val x_12047: word8 = 
								      raise x_8290
								in
								   x_12047
								end
						       in
							  x_12046
						       end
					      in
						 x_12042
					      end
				 in
				    x_12037
				 end
			   in
			      x_12034
			   end
		     in
			x_12032
		     end
		  false => 
		     let
			val x_11976: word32 = 
			   0x0
			val maxWord'_4: word8 = 
			   x_11967 x_11976
			val maxWord_0: real32 = 
			   fromWord8Unsafe_0 maxWord'_4
			val x_11977: IEEEReal.RoundingMode.t_0
				     -> real32 -> word8 = 
			   fn x_11978: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_11979: real32 -> word8 = 
				 fn x_11980: real32 => 
				 let
				    val x_11981: IEEEReal.float_class_0 = 
				       class_0 x_11980
				    val x_11982: word8 = 
				       case x_11981 of
				       INF_0 => 
					  let
					     val x_11984: word8 = 
						raise x_8290
					  in
					     x_11984
					  end
				       NAN_0 => 
					  let
					     val x_11983: word8 = 
						raise x_8285
					  in
					     x_11983
					  end
					 _ => let
						 val x_11985: real32 * real32 = 
						    (zero_7, x_11980)
						 val x_11986: bool = 
						    <=_2 x_11985
						 val x_11987: word8 = 
						    case x_11986 of
						    true => 
						       let
							  val x_12000: real32
								       * real32 = 
							     (x_11980, maxWord_0)
							  val x_12001: bool = 
							     <=_2 x_12000
							  val x_12002: word8 = 
							     case x_12001 of
							     true => 
								let
								   val x_12017: word8 = 
								      case x_11978 of
								      TO_POSINF_0 => 
									 let
									    val x_12028: real32 = 
									       Real32_realCeil (x_11980)
									    val x_12029: word8 = 
									       toWord8Unsafe_0 x_12028
									 in
									    x_12029
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12022: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12023: unit = 
									       ()
									    val m'_9: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12023
									    val x_12024: unit = 
									       setRoundingMode_0 x_12022
									    val x_12025: real32 = 
									       round_0 x_11980
									    val x_12026: unit = 
									       setRoundingMode_0 m'_9
									    val x_12027: word8 = 
									       toWord8Unsafe_0 x_12025
									 in
									    x_12027
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12020: real32 = 
									       Real32_realTrunc (x_11980)
									    val x_12021: word8 = 
									       toWord8Unsafe_0 x_12020
									 in
									    x_12021
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12018: real32 = 
									       Real32_realFloor (x_11980)
									    val x_12019: word8 = 
									       toWord8Unsafe_0 x_12018
									 in
									    x_12019
									 end
								in
								   x_12017
								end
							     false => 
								let
								   val x_12003: real32
										* real32 = 
								      (maxWord_0,
								       one_6)
								   val x_12004: real32 = 
								      +_1 x_12003
								   val x_12005: real32
										* real32 = 
								      (x_11980,
								       x_12004)
								   val x_12006: bool = 
								      <_3 x_12005
								   val x_12007: word8 = 
								      case x_12006 of
								      true => 
									 let
									    val x_12009: word8 = 
									       case x_11978 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_4
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_4
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_12011: real32
												  * real32 = 
											(x_11980,
											 maxWord_0)
										     val x_12012: real32 = 
											-_1 x_12011
										     val x_12013: real32
												  * real32 = 
											(x_12012,
											 half_0)
										     val x_12014: bool = 
											>=_3 x_12013
										     val x_12015: word8 = 
											case x_12014 of
											true => 
											   let
											      val x_12016: word8 = 
												 raise x_8290
											   in
											      x_12016
											   end
											false => 
											   let
											   in
											      maxWord'_4
											   end
										  in
										     x_12015
										  end
									       TO_POSINF_0 => 
										  let
										     val x_12010: word8 = 
											raise x_8290
										  in
										     x_12010
										  end
									 in
									    x_12009
									 end
								      false => 
									 let
									    val x_12008: word8 = 
									       raise x_8290
									 in
									    x_12008
									 end
								in
								   x_12007
								end
						       in
							  x_12002
						       end
						    false => 
						       let
							  val x_11988: real32 = 
							     ~_0 one_6
							  val x_11989: real32
								       * real32 = 
							     (x_11980, x_11988)
							  val x_11990: bool = 
							     >_2 x_11989
							  val x_11991: word8 = 
							     case x_11990 of
							     true => 
								let
								   val x_11993: word8 = 
								      case x_11978 of
								      TO_NEGINF_0 => 
									 let
									    val x_11999: word8 = 
									       raise x_8290
									 in
									    x_11999
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8909
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_11994: real32 = 
									       ~_0 half_0
									    val x_11995: real32
											 * real32 = 
									       (x_11980,
										x_11994)
									    val x_11996: bool = 
									       <_3 x_11995
									    val x_11997: word8 = 
									       case x_11996 of
									       true => 
										  let
										     val x_11998: word8 = 
											raise x_8290
										  in
										     x_11998
										  end
									       false => 
										  let
										  in
										     x_8909
										  end
									 in
									    x_11997
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8909
									 end
								in
								   x_11993
								end
							     false => 
								let
								   val x_11992: word8 = 
								      raise x_8290
								in
								   x_11992
								end
						       in
							  x_11991
						       end
					      in
						 x_11987
					      end
				 in
				    x_11982
				 end
			   in
			      x_11979
			   end
		     in
			x_11977
		     end
	       val x_12072: word32 -> word16 = 
		  fn x_12073: word32 => 
		  let
		     val x_12074: word16 * word32 = 
			(maxWord'_1, x_12073)
		     val x_12075: word16 = 
			>>_5 x_12074
		     val x_12076: word16 * word32 = 
			(x_12075, x_12073)
		     val x_12077: word16 = 
			<<_5 x_12076
		  in
		     x_12077
		  end
	       val x_12078: word32 * word32 = 
		  (precision_7, wordSize_1)
	       val x_12079: bool = 
		  <=_0 x_12078
	       val x_12080: IEEEReal.RoundingMode.t_0 -> real32 -> word16 = 
		  case x_12079 of
		  true => 
		     let
			val x_12135: word32 * word32 = 
			   (wordSize_1, precision_7)
			val trim_5: word32 = 
			   x_8548 x_12135
			val x_12136: word32 = 
			   sextdFromInt32ToWord32_0 trim_5
			val maxWord'_7: word16 = 
			   x_12072 x_12136
			val maxWord_3: real32 = 
			   fromWord16Unsafe_0 maxWord'_7
			val x_12137: IEEEReal.RoundingMode.t_0
				     -> real32 -> word16 = 
			   fn x_12138: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12139: real32 -> word16 = 
				 fn x_12140: real32 => 
				 let
				    val x_12141: IEEEReal.float_class_0 = 
				       class_0 x_12140
				    val x_12142: word16 = 
				       case x_12141 of
				       INF_0 => 
					  let
					     val x_12144: word16 = 
						raise x_8290
					  in
					     x_12144
					  end
				       NAN_0 => 
					  let
					     val x_12143: word16 = 
						raise x_8285
					  in
					     x_12143
					  end
					 _ => let
						 val x_12145: real32 * real32 = 
						    (zero_7, x_12140)
						 val x_12146: bool = 
						    <=_2 x_12145
						 val x_12147: word16 = 
						    case x_12146 of
						    true => 
						       let
							  val x_12160: real32
								       * real32 = 
							     (x_12140, maxWord_3)
							  val x_12161: bool = 
							     <=_2 x_12160
							  val x_12162: word16 = 
							     case x_12161 of
							     true => 
								let
								   val x_12164: word16 = 
								      case x_12138 of
								      TO_POSINF_0 => 
									 let
									    val x_12175: real32 = 
									       Real32_realCeil (x_12140)
									    val x_12176: word16 = 
									       toWord16Unsafe_0 x_12175
									 in
									    x_12176
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12169: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12170: unit = 
									       ()
									    val m'_12: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12170
									    val x_12171: unit = 
									       setRoundingMode_0 x_12169
									    val x_12172: real32 = 
									       round_0 x_12140
									    val x_12173: unit = 
									       setRoundingMode_0 m'_12
									    val x_12174: word16 = 
									       toWord16Unsafe_0 x_12172
									 in
									    x_12174
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12167: real32 = 
									       Real32_realTrunc (x_12140)
									    val x_12168: word16 = 
									       toWord16Unsafe_0 x_12167
									 in
									    x_12168
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12165: real32 = 
									       Real32_realFloor (x_12140)
									    val x_12166: word16 = 
									       toWord16Unsafe_0 x_12165
									 in
									    x_12166
									 end
								in
								   x_12164
								end
							     false => 
								let
								   val x_12163: word16 = 
								      raise x_8290
								in
								   x_12163
								end
						       in
							  x_12162
						       end
						    false => 
						       let
							  val x_12148: real32 = 
							     ~_0 one_6
							  val x_12149: real32
								       * real32 = 
							     (x_12140, x_12148)
							  val x_12150: bool = 
							     >_2 x_12149
							  val x_12151: word16 = 
							     case x_12150 of
							     true => 
								let
								   val x_12153: word16 = 
								      case x_12138 of
								      TO_NEGINF_0 => 
									 let
									    val x_12159: word16 = 
									       raise x_8290
									 in
									    x_12159
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8947
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12154: real32 = 
									       ~_0 half_0
									    val x_12155: real32
											 * real32 = 
									       (x_12140,
										x_12154)
									    val x_12156: bool = 
									       <_3 x_12155
									    val x_12157: word16 = 
									       case x_12156 of
									       true => 
										  let
										     val x_12158: word16 = 
											raise x_8290
										  in
										     x_12158
										  end
									       false => 
										  let
										  in
										     x_8947
										  end
									 in
									    x_12157
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8947
									 end
								in
								   x_12153
								end
							     false => 
								let
								   val x_12152: word16 = 
								      raise x_8290
								in
								   x_12152
								end
						       in
							  x_12151
						       end
					      in
						 x_12147
					      end
				 in
				    x_12142
				 end
			   in
			      x_12139
			   end
		     in
			x_12137
		     end
		  false => 
		     let
			val x_12081: word32 = 
			   0x0
			val maxWord'_6: word16 = 
			   x_12072 x_12081
			val maxWord_2: real32 = 
			   fromWord16Unsafe_0 maxWord'_6
			val x_12082: IEEEReal.RoundingMode.t_0
				     -> real32 -> word16 = 
			   fn x_12083: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12084: real32 -> word16 = 
				 fn x_12085: real32 => 
				 let
				    val x_12086: IEEEReal.float_class_0 = 
				       class_0 x_12085
				    val x_12087: word16 = 
				       case x_12086 of
				       INF_0 => 
					  let
					     val x_12089: word16 = 
						raise x_8290
					  in
					     x_12089
					  end
				       NAN_0 => 
					  let
					     val x_12088: word16 = 
						raise x_8285
					  in
					     x_12088
					  end
					 _ => let
						 val x_12090: real32 * real32 = 
						    (zero_7, x_12085)
						 val x_12091: bool = 
						    <=_2 x_12090
						 val x_12092: word16 = 
						    case x_12091 of
						    true => 
						       let
							  val x_12105: real32
								       * real32 = 
							     (x_12085, maxWord_2)
							  val x_12106: bool = 
							     <=_2 x_12105
							  val x_12107: word16 = 
							     case x_12106 of
							     true => 
								let
								   val x_12122: word16 = 
								      case x_12083 of
								      TO_POSINF_0 => 
									 let
									    val x_12133: real32 = 
									       Real32_realCeil (x_12085)
									    val x_12134: word16 = 
									       toWord16Unsafe_0 x_12133
									 in
									    x_12134
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12127: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12128: unit = 
									       ()
									    val m'_11: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12128
									    val x_12129: unit = 
									       setRoundingMode_0 x_12127
									    val x_12130: real32 = 
									       round_0 x_12085
									    val x_12131: unit = 
									       setRoundingMode_0 m'_11
									    val x_12132: word16 = 
									       toWord16Unsafe_0 x_12130
									 in
									    x_12132
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12125: real32 = 
									       Real32_realTrunc (x_12085)
									    val x_12126: word16 = 
									       toWord16Unsafe_0 x_12125
									 in
									    x_12126
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12123: real32 = 
									       Real32_realFloor (x_12085)
									    val x_12124: word16 = 
									       toWord16Unsafe_0 x_12123
									 in
									    x_12124
									 end
								in
								   x_12122
								end
							     false => 
								let
								   val x_12108: real32
										* real32 = 
								      (maxWord_2,
								       one_6)
								   val x_12109: real32 = 
								      +_1 x_12108
								   val x_12110: real32
										* real32 = 
								      (x_12085,
								       x_12109)
								   val x_12111: bool = 
								      <_3 x_12110
								   val x_12112: word16 = 
								      case x_12111 of
								      true => 
									 let
									    val x_12114: word16 = 
									       case x_12083 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_6
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_6
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_12116: real32
												  * real32 = 
											(x_12085,
											 maxWord_2)
										     val x_12117: real32 = 
											-_1 x_12116
										     val x_12118: real32
												  * real32 = 
											(x_12117,
											 half_0)
										     val x_12119: bool = 
											>=_3 x_12118
										     val x_12120: word16 = 
											case x_12119 of
											true => 
											   let
											      val x_12121: word16 = 
												 raise x_8290
											   in
											      x_12121
											   end
											false => 
											   let
											   in
											      maxWord'_6
											   end
										  in
										     x_12120
										  end
									       TO_POSINF_0 => 
										  let
										     val x_12115: word16 = 
											raise x_8290
										  in
										     x_12115
										  end
									 in
									    x_12114
									 end
								      false => 
									 let
									    val x_12113: word16 = 
									       raise x_8290
									 in
									    x_12113
									 end
								in
								   x_12112
								end
						       in
							  x_12107
						       end
						    false => 
						       let
							  val x_12093: real32 = 
							     ~_0 one_6
							  val x_12094: real32
								       * real32 = 
							     (x_12085, x_12093)
							  val x_12095: bool = 
							     >_2 x_12094
							  val x_12096: word16 = 
							     case x_12095 of
							     true => 
								let
								   val x_12098: word16 = 
								      case x_12083 of
								      TO_NEGINF_0 => 
									 let
									    val x_12104: word16 = 
									       raise x_8290
									 in
									    x_12104
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8947
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12099: real32 = 
									       ~_0 half_0
									    val x_12100: real32
											 * real32 = 
									       (x_12085,
										x_12099)
									    val x_12101: bool = 
									       <_3 x_12100
									    val x_12102: word16 = 
									       case x_12101 of
									       true => 
										  let
										     val x_12103: word16 = 
											raise x_8290
										  in
										     x_12103
										  end
									       false => 
										  let
										  in
										     x_8947
										  end
									 in
									    x_12102
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8947
									 end
								in
								   x_12098
								end
							     false => 
								let
								   val x_12097: word16 = 
								      raise x_8290
								in
								   x_12097
								end
						       in
							  x_12096
						       end
					      in
						 x_12092
					      end
				 in
				    x_12087
				 end
			   in
			      x_12084
			   end
		     in
			x_12082
		     end
	       val x_12177: word32 -> word32 = 
		  fn x_12178: word32 => 
		  let
		     val x_12179: word32 * word32 = 
			(maxWord'_2, x_12178)
		     val x_12180: word32 = 
			>>_6 x_12179
		     val x_12181: word32 * word32 = 
			(x_12180, x_12178)
		     val x_12182: word32 = 
			<<_6 x_12181
		  in
		     x_12182
		  end
	       val x_12183: word32 * word32 = 
		  (precision_7, wordSize_2)
	       val x_12184: bool = 
		  <=_0 x_12183
	       val x_12185: IEEEReal.RoundingMode.t_0 -> real32 -> word32 = 
		  case x_12184 of
		  true => 
		     let
			val x_12240: word32 * word32 = 
			   (wordSize_2, precision_7)
			val trim_6: word32 = 
			   x_8548 x_12240
			val x_12241: word32 = 
			   sextdFromInt32ToWord32_0 trim_6
			val maxWord'_9: word32 = 
			   x_12177 x_12241
			val maxWord_5: real32 = 
			   fromWord32Unsafe_0 maxWord'_9
			val x_12242: IEEEReal.RoundingMode.t_0
				     -> real32 -> word32 = 
			   fn x_12243: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12244: real32 -> word32 = 
				 fn x_12245: real32 => 
				 let
				    val x_12246: IEEEReal.float_class_0 = 
				       class_0 x_12245
				    val x_12247: word32 = 
				       case x_12246 of
				       INF_0 => 
					  let
					     val x_12249: word32 = 
						raise x_8290
					  in
					     x_12249
					  end
				       NAN_0 => 
					  let
					     val x_12248: word32 = 
						raise x_8285
					  in
					     x_12248
					  end
					 _ => let
						 val x_12250: real32 * real32 = 
						    (zero_7, x_12245)
						 val x_12251: bool = 
						    <=_2 x_12250
						 val x_12252: word32 = 
						    case x_12251 of
						    true => 
						       let
							  val x_12265: real32
								       * real32 = 
							     (x_12245, maxWord_5)
							  val x_12266: bool = 
							     <=_2 x_12265
							  val x_12267: word32 = 
							     case x_12266 of
							     true => 
								let
								   val x_12269: word32 = 
								      case x_12243 of
								      TO_POSINF_0 => 
									 let
									    val x_12280: real32 = 
									       Real32_realCeil (x_12245)
									    val x_12281: word32 = 
									       toWord32Unsafe_0 x_12280
									 in
									    x_12281
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12274: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12275: unit = 
									       ()
									    val m'_14: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12275
									    val x_12276: unit = 
									       setRoundingMode_0 x_12274
									    val x_12277: real32 = 
									       round_0 x_12245
									    val x_12278: unit = 
									       setRoundingMode_0 m'_14
									    val x_12279: word32 = 
									       toWord32Unsafe_0 x_12277
									 in
									    x_12279
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12272: real32 = 
									       Real32_realTrunc (x_12245)
									    val x_12273: word32 = 
									       toWord32Unsafe_0 x_12272
									 in
									    x_12273
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12270: real32 = 
									       Real32_realFloor (x_12245)
									    val x_12271: word32 = 
									       toWord32Unsafe_0 x_12270
									 in
									    x_12271
									 end
								in
								   x_12269
								end
							     false => 
								let
								   val x_12268: word32 = 
								      raise x_8290
								in
								   x_12268
								end
						       in
							  x_12267
						       end
						    false => 
						       let
							  val x_12253: real32 = 
							     ~_0 one_6
							  val x_12254: real32
								       * real32 = 
							     (x_12245, x_12253)
							  val x_12255: bool = 
							     >_2 x_12254
							  val x_12256: word32 = 
							     case x_12255 of
							     true => 
								let
								   val x_12258: word32 = 
								      case x_12243 of
								      TO_NEGINF_0 => 
									 let
									    val x_12264: word32 = 
									       raise x_8290
									 in
									    x_12264
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_2
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12259: real32 = 
									       ~_0 half_0
									    val x_12260: real32
											 * real32 = 
									       (x_12245,
										x_12259)
									    val x_12261: bool = 
									       <_3 x_12260
									    val x_12262: word32 = 
									       case x_12261 of
									       true => 
										  let
										     val x_12263: word32 = 
											raise x_8290
										  in
										     x_12263
										  end
									       false => 
										  let
										  in
										     zero_2
										  end
									 in
									    x_12262
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_2
									 end
								in
								   x_12258
								end
							     false => 
								let
								   val x_12257: word32 = 
								      raise x_8290
								in
								   x_12257
								end
						       in
							  x_12256
						       end
					      in
						 x_12252
					      end
				 in
				    x_12247
				 end
			   in
			      x_12244
			   end
		     in
			x_12242
		     end
		  false => 
		     let
			val x_12186: word32 = 
			   0x0
			val maxWord'_8: word32 = 
			   x_12177 x_12186
			val maxWord_4: real32 = 
			   fromWord32Unsafe_0 maxWord'_8
			val x_12187: IEEEReal.RoundingMode.t_0
				     -> real32 -> word32 = 
			   fn x_12188: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12189: real32 -> word32 = 
				 fn x_12190: real32 => 
				 let
				    val x_12191: IEEEReal.float_class_0 = 
				       class_0 x_12190
				    val x_12192: word32 = 
				       case x_12191 of
				       INF_0 => 
					  let
					     val x_12194: word32 = 
						raise x_8290
					  in
					     x_12194
					  end
				       NAN_0 => 
					  let
					     val x_12193: word32 = 
						raise x_8285
					  in
					     x_12193
					  end
					 _ => let
						 val x_12195: real32 * real32 = 
						    (zero_7, x_12190)
						 val x_12196: bool = 
						    <=_2 x_12195
						 val x_12197: word32 = 
						    case x_12196 of
						    true => 
						       let
							  val x_12210: real32
								       * real32 = 
							     (x_12190, maxWord_4)
							  val x_12211: bool = 
							     <=_2 x_12210
							  val x_12212: word32 = 
							     case x_12211 of
							     true => 
								let
								   val x_12227: word32 = 
								      case x_12188 of
								      TO_POSINF_0 => 
									 let
									    val x_12238: real32 = 
									       Real32_realCeil (x_12190)
									    val x_12239: word32 = 
									       toWord32Unsafe_0 x_12238
									 in
									    x_12239
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12232: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12233: unit = 
									       ()
									    val m'_13: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12233
									    val x_12234: unit = 
									       setRoundingMode_0 x_12232
									    val x_12235: real32 = 
									       round_0 x_12190
									    val x_12236: unit = 
									       setRoundingMode_0 m'_13
									    val x_12237: word32 = 
									       toWord32Unsafe_0 x_12235
									 in
									    x_12237
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12230: real32 = 
									       Real32_realTrunc (x_12190)
									    val x_12231: word32 = 
									       toWord32Unsafe_0 x_12230
									 in
									    x_12231
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12228: real32 = 
									       Real32_realFloor (x_12190)
									    val x_12229: word32 = 
									       toWord32Unsafe_0 x_12228
									 in
									    x_12229
									 end
								in
								   x_12227
								end
							     false => 
								let
								   val x_12213: real32
										* real32 = 
								      (maxWord_4,
								       one_6)
								   val x_12214: real32 = 
								      +_1 x_12213
								   val x_12215: real32
										* real32 = 
								      (x_12190,
								       x_12214)
								   val x_12216: bool = 
								      <_3 x_12215
								   val x_12217: word32 = 
								      case x_12216 of
								      true => 
									 let
									    val x_12219: word32 = 
									       case x_12188 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_8
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_8
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_12221: real32
												  * real32 = 
											(x_12190,
											 maxWord_4)
										     val x_12222: real32 = 
											-_1 x_12221
										     val x_12223: real32
												  * real32 = 
											(x_12222,
											 half_0)
										     val x_12224: bool = 
											>=_3 x_12223
										     val x_12225: word32 = 
											case x_12224 of
											true => 
											   let
											      val x_12226: word32 = 
												 raise x_8290
											   in
											      x_12226
											   end
											false => 
											   let
											   in
											      maxWord'_8
											   end
										  in
										     x_12225
										  end
									       TO_POSINF_0 => 
										  let
										     val x_12220: word32 = 
											raise x_8290
										  in
										     x_12220
										  end
									 in
									    x_12219
									 end
								      false => 
									 let
									    val x_12218: word32 = 
									       raise x_8290
									 in
									    x_12218
									 end
								in
								   x_12217
								end
						       in
							  x_12212
						       end
						    false => 
						       let
							  val x_12198: real32 = 
							     ~_0 one_6
							  val x_12199: real32
								       * real32 = 
							     (x_12190, x_12198)
							  val x_12200: bool = 
							     >_2 x_12199
							  val x_12201: word32 = 
							     case x_12200 of
							     true => 
								let
								   val x_12203: word32 = 
								      case x_12188 of
								      TO_NEGINF_0 => 
									 let
									    val x_12209: word32 = 
									       raise x_8290
									 in
									    x_12209
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_2
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12204: real32 = 
									       ~_0 half_0
									    val x_12205: real32
											 * real32 = 
									       (x_12190,
										x_12204)
									    val x_12206: bool = 
									       <_3 x_12205
									    val x_12207: word32 = 
									       case x_12206 of
									       true => 
										  let
										     val x_12208: word32 = 
											raise x_8290
										  in
										     x_12208
										  end
									       false => 
										  let
										  in
										     zero_2
										  end
									 in
									    x_12207
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_2
									 end
								in
								   x_12203
								end
							     false => 
								let
								   val x_12202: word32 = 
								      raise x_8290
								in
								   x_12202
								end
						       in
							  x_12201
						       end
					      in
						 x_12197
					      end
				 in
				    x_12192
				 end
			   in
			      x_12189
			   end
		     in
			x_12187
		     end
	       val x_12282: word32 -> word64 = 
		  fn x_12283: word32 => 
		  let
		     val x_12284: word64 * word32 = 
			(maxWord'_3, x_12283)
		     val x_12285: word64 = 
			>>_7 x_12284
		     val x_12286: word64 * word32 = 
			(x_12285, x_12283)
		     val x_12287: word64 = 
			<<_7 x_12286
		  in
		     x_12287
		  end
	       val x_12288: word32 * word32 = 
		  (precision_7, wordSize_3)
	       val x_12289: bool = 
		  <=_0 x_12288
	       val x_12290: IEEEReal.RoundingMode.t_0 -> real32 -> word64 = 
		  case x_12289 of
		  true => 
		     let
			val x_12345: word32 * word32 = 
			   (wordSize_3, precision_7)
			val trim_7: word32 = 
			   x_8548 x_12345
			val x_12346: word32 = 
			   sextdFromInt32ToWord32_0 trim_7
			val maxWord'_11: word64 = 
			   x_12282 x_12346
			val maxWord_7: real32 = 
			   fromWord64Unsafe_0 maxWord'_11
			val x_12347: IEEEReal.RoundingMode.t_0
				     -> real32 -> word64 = 
			   fn x_12348: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12349: real32 -> word64 = 
				 fn x_12350: real32 => 
				 let
				    val x_12351: IEEEReal.float_class_0 = 
				       class_0 x_12350
				    val x_12352: word64 = 
				       case x_12351 of
				       INF_0 => 
					  let
					     val x_12354: word64 = 
						raise x_8290
					  in
					     x_12354
					  end
				       NAN_0 => 
					  let
					     val x_12353: word64 = 
						raise x_8285
					  in
					     x_12353
					  end
					 _ => let
						 val x_12355: real32 * real32 = 
						    (zero_7, x_12350)
						 val x_12356: bool = 
						    <=_2 x_12355
						 val x_12357: word64 = 
						    case x_12356 of
						    true => 
						       let
							  val x_12370: real32
								       * real32 = 
							     (x_12350, maxWord_7)
							  val x_12371: bool = 
							     <=_2 x_12370
							  val x_12372: word64 = 
							     case x_12371 of
							     true => 
								let
								   val x_12374: word64 = 
								      case x_12348 of
								      TO_POSINF_0 => 
									 let
									    val x_12385: real32 = 
									       Real32_realCeil (x_12350)
									    val x_12386: word64 = 
									       toWord64Unsafe_0 x_12385
									 in
									    x_12386
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12379: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12380: unit = 
									       ()
									    val m'_16: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12380
									    val x_12381: unit = 
									       setRoundingMode_0 x_12379
									    val x_12382: real32 = 
									       round_0 x_12350
									    val x_12383: unit = 
									       setRoundingMode_0 m'_16
									    val x_12384: word64 = 
									       toWord64Unsafe_0 x_12382
									 in
									    x_12384
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12377: real32 = 
									       Real32_realTrunc (x_12350)
									    val x_12378: word64 = 
									       toWord64Unsafe_0 x_12377
									 in
									    x_12378
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12375: real32 = 
									       Real32_realFloor (x_12350)
									    val x_12376: word64 = 
									       toWord64Unsafe_0 x_12375
									 in
									    x_12376
									 end
								in
								   x_12374
								end
							     false => 
								let
								   val x_12373: word64 = 
								      raise x_8290
								in
								   x_12373
								end
						       in
							  x_12372
						       end
						    false => 
						       let
							  val x_12358: real32 = 
							     ~_0 one_6
							  val x_12359: real32
								       * real32 = 
							     (x_12350, x_12358)
							  val x_12360: bool = 
							     >_2 x_12359
							  val x_12361: word64 = 
							     case x_12360 of
							     true => 
								let
								   val x_12363: word64 = 
								      case x_12348 of
								      TO_NEGINF_0 => 
									 let
									    val x_12369: word64 = 
									       raise x_8290
									 in
									    x_12369
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_4
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12364: real32 = 
									       ~_0 half_0
									    val x_12365: real32
											 * real32 = 
									       (x_12350,
										x_12364)
									    val x_12366: bool = 
									       <_3 x_12365
									    val x_12367: word64 = 
									       case x_12366 of
									       true => 
										  let
										     val x_12368: word64 = 
											raise x_8290
										  in
										     x_12368
										  end
									       false => 
										  let
										  in
										     zero_4
										  end
									 in
									    x_12367
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_4
									 end
								in
								   x_12363
								end
							     false => 
								let
								   val x_12362: word64 = 
								      raise x_8290
								in
								   x_12362
								end
						       in
							  x_12361
						       end
					      in
						 x_12357
					      end
				 in
				    x_12352
				 end
			   in
			      x_12349
			   end
		     in
			x_12347
		     end
		  false => 
		     let
			val x_12291: word32 = 
			   0x0
			val maxWord'_10: word64 = 
			   x_12282 x_12291
			val maxWord_6: real32 = 
			   fromWord64Unsafe_0 maxWord'_10
			val x_12292: IEEEReal.RoundingMode.t_0
				     -> real32 -> word64 = 
			   fn x_12293: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12294: real32 -> word64 = 
				 fn x_12295: real32 => 
				 let
				    val x_12296: IEEEReal.float_class_0 = 
				       class_0 x_12295
				    val x_12297: word64 = 
				       case x_12296 of
				       INF_0 => 
					  let
					     val x_12299: word64 = 
						raise x_8290
					  in
					     x_12299
					  end
				       NAN_0 => 
					  let
					     val x_12298: word64 = 
						raise x_8285
					  in
					     x_12298
					  end
					 _ => let
						 val x_12300: real32 * real32 = 
						    (zero_7, x_12295)
						 val x_12301: bool = 
						    <=_2 x_12300
						 val x_12302: word64 = 
						    case x_12301 of
						    true => 
						       let
							  val x_12315: real32
								       * real32 = 
							     (x_12295, maxWord_6)
							  val x_12316: bool = 
							     <=_2 x_12315
							  val x_12317: word64 = 
							     case x_12316 of
							     true => 
								let
								   val x_12332: word64 = 
								      case x_12293 of
								      TO_POSINF_0 => 
									 let
									    val x_12343: real32 = 
									       Real32_realCeil (x_12295)
									    val x_12344: word64 = 
									       toWord64Unsafe_0 x_12343
									 in
									    x_12344
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12337: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12338: unit = 
									       ()
									    val m'_15: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12338
									    val x_12339: unit = 
									       setRoundingMode_0 x_12337
									    val x_12340: real32 = 
									       round_0 x_12295
									    val x_12341: unit = 
									       setRoundingMode_0 m'_15
									    val x_12342: word64 = 
									       toWord64Unsafe_0 x_12340
									 in
									    x_12342
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12335: real32 = 
									       Real32_realTrunc (x_12295)
									    val x_12336: word64 = 
									       toWord64Unsafe_0 x_12335
									 in
									    x_12336
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12333: real32 = 
									       Real32_realFloor (x_12295)
									    val x_12334: word64 = 
									       toWord64Unsafe_0 x_12333
									 in
									    x_12334
									 end
								in
								   x_12332
								end
							     false => 
								let
								   val x_12318: real32
										* real32 = 
								      (maxWord_6,
								       one_6)
								   val x_12319: real32 = 
								      +_1 x_12318
								   val x_12320: real32
										* real32 = 
								      (x_12295,
								       x_12319)
								   val x_12321: bool = 
								      <_3 x_12320
								   val x_12322: word64 = 
								      case x_12321 of
								      true => 
									 let
									    val x_12324: word64 = 
									       case x_12293 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_10
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_10
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_12326: real32
												  * real32 = 
											(x_12295,
											 maxWord_6)
										     val x_12327: real32 = 
											-_1 x_12326
										     val x_12328: real32
												  * real32 = 
											(x_12327,
											 half_0)
										     val x_12329: bool = 
											>=_3 x_12328
										     val x_12330: word64 = 
											case x_12329 of
											true => 
											   let
											      val x_12331: word64 = 
												 raise x_8290
											   in
											      x_12331
											   end
											false => 
											   let
											   in
											      maxWord'_10
											   end
										  in
										     x_12330
										  end
									       TO_POSINF_0 => 
										  let
										     val x_12325: word64 = 
											raise x_8290
										  in
										     x_12325
										  end
									 in
									    x_12324
									 end
								      false => 
									 let
									    val x_12323: word64 = 
									       raise x_8290
									 in
									    x_12323
									 end
								in
								   x_12322
								end
						       in
							  x_12317
						       end
						    false => 
						       let
							  val x_12303: real32 = 
							     ~_0 one_6
							  val x_12304: real32
								       * real32 = 
							     (x_12295, x_12303)
							  val x_12305: bool = 
							     >_2 x_12304
							  val x_12306: word64 = 
							     case x_12305 of
							     true => 
								let
								   val x_12308: word64 = 
								      case x_12293 of
								      TO_NEGINF_0 => 
									 let
									    val x_12314: word64 = 
									       raise x_8290
									 in
									    x_12314
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_4
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12309: real32 = 
									       ~_0 half_0
									    val x_12310: real32
											 * real32 = 
									       (x_12295,
										x_12309)
									    val x_12311: bool = 
									       <_3 x_12310
									    val x_12312: word64 = 
									       case x_12311 of
									       true => 
										  let
										     val x_12313: word64 = 
											raise x_8290
										  in
										     x_12313
										  end
									       false => 
										  let
										  in
										     zero_4
										  end
									 in
									    x_12312
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_4
									 end
								in
								   x_12308
								end
							     false => 
								let
								   val x_12307: word64 = 
								      raise x_8290
								in
								   x_12307
								end
						       in
							  x_12306
						       end
					      in
						 x_12302
					      end
				 in
				    x_12297
				 end
			   in
			      x_12294
			   end
		     in
			x_12292
		     end
	       val realSize_3: word32 = 
		  sextdFromInt32ToInt32_0 realSize_1
	       val exponentBias_3: word32 = 
		  sextdFromInt32ToInt32_0 exponentBias_1
	       val precision_8: word32 = 
		  sextdFromInt32ToInt32_0 precision_6
	       val x_12387: word32 = 
		  sextdFromInt32ToWord32_0 realSize_3
	       val x_12388: word32 * word32 = 
		  (x_12387, one_2)
	       val exponentSignificandBits_1: word32 = 
		  -_0 x_12388
	       val x_12389: word32 = 
		  sextdFromInt32ToWord32_0 precision_8
	       val x_12390: word32 * word32 = 
		  (x_12389, one_2)
	       val significandBits_1: word32 = 
		  -_0 x_12390
	       val x_12391: word32 * word32 = 
		  (exponentSignificandBits_1, significandBits_1)
	       val exponentBits_1: word32 = 
		  -_0 x_12391
	       val mkMask_1: word32 -> word64 = 
		  fn x_12392: word32 => 
		  let
		     val x_12393: word64 = 
			notb_3 zero_4
		     val x_12394: word64 * word32 = 
			(x_12393, x_12392)
		     val x_12395: word64 = 
			<<_7 x_12394
		     val x_12396: word64 = 
			notb_3 x_12395
		  in
		     x_12396
		  end
	       val x_12397: word64 = 
		  mkMask_1 one_2
	       val x_12398: word64 * word32 = 
		  (x_12397, exponentSignificandBits_1)
	       val signMask_1: word64 = 
		  <<_7 x_12398
	       val x_12399: word64 = 
		  mkMask_1 exponentBits_1
	       val x_12400: word64 * word32 = 
		  (x_12399, significandBits_1)
	       val exponentMask_1: word64 = 
		  <<_7 x_12400
	       val significandMask_1: word64 = 
		  mkMask_1 significandBits_1
	       val class_1: real64 -> IEEEReal.float_class_0 = 
		  fn x_12401: real64 => 
		  let
		     val x_12402: word64 = 
			Real64_castToWord64 (x_12401)
		     val x_12403: word64 * word64 = 
			(x_12402, exponentMask_1)
		     val x_12404: word64 = 
			andb_1 x_12403
		     val x_12405: word64 * word64 = 
			(x_12404, exponentMask_1)
		     val x_12406: bool = 
			x_8372 x_12405
		     val x_12407: IEEEReal.float_class_0 = 
			case x_12406 of
			true => 
			   let
			      val x_12421: word64 * word64 = 
				 (x_12402, significandMask_1)
			      val x_12422: word64 = 
				 andb_1 x_12421
			      val x_12423: word64 * word64 = 
				 (x_12422, zero_4)
			      val x_12424: bool = 
				 x_8372 x_12423
			      val x_12425: IEEEReal.float_class_0 = 
				 case x_12424 of
				 true => 
				    let
				       val x_12427: IEEEReal.float_class_0 = 
					  INF_0
				    in
				       x_12427
				    end
				 false => 
				    let
				       val x_12426: IEEEReal.float_class_0 = 
					  NAN_0
				    in
				       x_12426
				    end
			   in
			      x_12425
			   end
			false => 
			   let
			      val x_12408: word64 * word64 = 
				 (x_12402, exponentMask_1)
			      val x_12409: word64 = 
				 andb_1 x_12408
			      val x_12410: word64 * word64 = 
				 (x_12409, zero_4)
			      val x_12411: bool = 
				 x_8372 x_12410
			      val x_12412: IEEEReal.float_class_0 = 
				 case x_12411 of
				 true => 
				    let
				       val x_12414: word64 * word64 = 
					  (x_12402, significandMask_1)
				       val x_12415: word64 = 
					  andb_1 x_12414
				       val x_12416: word64 * word64 = 
					  (x_12415, zero_4)
				       val x_12417: bool = 
					  x_8372 x_12416
				       val x_12418: IEEEReal.float_class_0 = 
					  case x_12417 of
					  true => 
					     let
						val x_12420: IEEEReal.float_class_0 = 
						   ZERO_0
					     in
						x_12420
					     end
					  false => 
					     let
						val x_12419: IEEEReal.float_class_0 = 
						   SUBNORMAL_0
					     in
						x_12419
					     end
				    in
				       x_12418
				    end
				 false => 
				    let
				       val x_12413: IEEEReal.float_class_0 = 
					  NORMAL_0
				    in
				       x_12413
				    end
			   in
			      x_12412
			   end
		  in
		     x_12407
		  end
	       val x_12428: word32 * word32 = 
		  (precision_6, precision_5)
	       val x_12429: bool = 
		  x_8367 x_12428
	       val x_12430: (IEEEReal.RoundingMode.t_0 -> real32 -> real64)
			    * (real64 -> real32) = 
		  case x_12429 of
		  true => 
		     let
			val x_12440: IEEEReal.RoundingMode.t_0
				     -> real32 -> real64 = 
			   fn x_12441: IEEEReal.RoundingMode.t_0 => 
			   let
			   in
			      fromReal32Unsafe_1
			   end
			val x_12442: (IEEEReal.RoundingMode.t_0
				      -> real32 -> real64)
				     * (real64 -> real32) = 
			   (x_12440, toReal32Unsafe_1)
		     in
			x_12442
		     end
		  false => 
		     let
			val x_12431: IEEEReal.RoundingMode.t_0
				     -> real32 -> real64 = 
			   fn x_12432: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12433: real32 -> real64 = 
				 fn x_12434: real32 => 
				 let
				    val x_12435: unit = 
				       ()
				    val m'_17: IEEEReal.RoundingMode.t_0 = 
				       x_11480 x_12435
				    val x_12436: unit = 
				       setRoundingMode_0 x_12432
				    val x_12437: real64 = 
				       fromReal32Unsafe_1 x_12434
				    val x_12438: unit = 
				       setRoundingMode_0 m'_17
				 in
				    x_12437
				 end
			   in
			      x_12433
			   end
			val x_12439: (IEEEReal.RoundingMode.t_0
				      -> real32 -> real64)
				     * (real64 -> real32) = 
			   (x_12431, toReal32Unsafe_1)
		     in
			x_12439
		     end
	       val zero_8: real64 = 
		  castFromWord_1 zero_4
	       val x_12443: word64 = 
		  sextdFromInt32ToWord64_0 exponentBias_3
	       val x_12444: word64 = 
		  Word64_sub (x_12443, one_4)
	       val x_12445: word64 * word32 = 
		  (x_12444, significandBits_1)
	       val x_12446: word64 = 
		  <<_7 x_12445
	       val half_1: real64 = 
		  castFromWord_1 x_12446
	       val x_12447: word64 = 
		  sextdFromInt32ToWord64_0 exponentBias_3
	       val x_12448: word64 * word32 = 
		  (x_12447, significandBits_1)
	       val x_12449: word64 = 
		  <<_7 x_12448
	       val one_7: real64 = 
		  castFromWord_1 x_12449
	       val x_12450: word32 -> word8 = 
		  fn x_12451: word32 => 
		  let
		     val x_12452: word8 * word32 = 
			(maxInt'_0, x_12451)
		     val x_12453: word8 = 
			>>_0 x_12452
		     val x_12454: word8 * word32 = 
			(x_12453, x_12451)
		     val x_12455: word8 = 
			<<_0 x_12454
		  in
		     x_12455
		  end
	       val x_12456: word32 * word32 = 
		  (precision_8, precision'_0)
	       val x_12457: bool = 
		  <_1 x_12456
	       val x_12458: IEEEReal.RoundingMode.t_0 -> real64 -> word8 = 
		  case x_12457 of
		  true => 
		     let
			val x_12516: word32 * word32 = 
			   (precision'_0, precision_8)
			val x_12517: word32 = 
			   x_8548 x_12516
			val x_12518: word32 = 
			   0x1
			val x_12519: word32 * word32 = 
			   (x_12517, x_12518)
			val trim_8: word32 = 
			   x_8548 x_12519
			val x_12520: word32 = 
			   sextdFromInt32ToWord32_0 trim_8
			val maxInt'_13: word8 = 
			   x_12450 x_12520
			val maxInt_9: real64 = 
			   fromInt8Unsafe_1 maxInt'_13
			val minInt_9: real64 = 
			   fromInt8Unsafe_1 minInt'_0
			val x_12521: IEEEReal.RoundingMode.t_0
				     -> real64 -> word8 = 
			   fn x_12522: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12523: real64 -> word8 = 
				 fn x_12524: real64 => 
				 let
				    val x_12525: real64 * real64 = 
				       (minInt_9, x_12524)
				    val x_12526: bool = 
				       <=_3 x_12525
				    val x_12527: word8 = 
				       case x_12526 of
				       true => 
					  let
					     val x_12533: real64 * real64 = 
						(x_12524, maxInt_9)
					     val x_12534: bool = 
						<=_3 x_12533
					     val x_12535: word8 = 
						case x_12534 of
						true => 
						   let
						      val x_12537: word8 = 
							 case x_12522 of
							 TO_POSINF_0 => 
							    let
							       val x_12548: real64 = 
								  Real64_realCeil (x_12524)
							       val x_12549: word8 = 
								  toInt8Unsafe_1 x_12548
							    in
							       x_12549
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12542: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12543: unit = 
								  ()
							       val m'_19: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12543
							       val x_12544: unit = 
								  setRoundingMode_0 x_12542
							       val x_12545: real64 = 
								  round_1 x_12524
							       val x_12546: unit = 
								  setRoundingMode_0 m'_19
							       val x_12547: word8 = 
								  toInt8Unsafe_1 x_12545
							    in
							       x_12547
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12540: real64 = 
								  Real64_realTrunc (x_12524)
							       val x_12541: word8 = 
								  toInt8Unsafe_1 x_12540
							    in
							       x_12541
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12538: real64 = 
								  Real64_realFloor (x_12524)
							       val x_12539: word8 = 
								  toInt8Unsafe_1 x_12538
							    in
							       x_12539
							    end
						   in
						      x_12537
						   end
						false => 
						   let
						      val x_12536: word8 = 
							 raise x_8290
						   in
						      x_12536
						   end
					  in
					     x_12535
					  end
				       false => 
					  let
					     val x_12528: real64 * real64 = 
						(x_12524, minInt_9)
					     val x_12529: bool = 
						<_4 x_12528
					     val x_12530: word8 = 
						case x_12529 of
						true => 
						   let
						      val x_12532: word8 = 
							 raise x_8290
						   in
						      x_12532
						   end
						false => 
						   let
						      val x_12531: word8 = 
							 raise x_8285
						   in
						      x_12531
						   end
					  in
					     x_12530
					  end
				 in
				    x_12527
				 end
			   in
			      x_12523
			   end
		     in
			x_12521
		     end
		  false => 
		     let
			val x_12459: word32 = 
			   0x0
			val maxInt'_12: word8 = 
			   x_12450 x_12459
			val maxInt_8: real64 = 
			   fromInt8Unsafe_1 maxInt'_12
			val minInt_8: real64 = 
			   fromInt8Unsafe_1 minInt'_0
			val x_12460: IEEEReal.RoundingMode.t_0
				     -> real64 -> word8 = 
			   fn x_12461: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12462: real64 -> word8 = 
				 fn x_12463: real64 => 
				 let
				    val x_12464: real64 * real64 = 
				       (minInt_8, x_12463)
				    val x_12465: bool = 
				       <=_3 x_12464
				    val x_12466: word8 = 
				       case x_12465 of
				       true => 
					  let
					     val x_12486: real64 * real64 = 
						(x_12463, maxInt_8)
					     val x_12487: bool = 
						<=_3 x_12486
					     val x_12488: word8 = 
						case x_12487 of
						true => 
						   let
						      val x_12503: word8 = 
							 case x_12461 of
							 TO_POSINF_0 => 
							    let
							       val x_12514: real64 = 
								  Real64_realCeil (x_12463)
							       val x_12515: word8 = 
								  toInt8Unsafe_1 x_12514
							    in
							       x_12515
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12508: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12509: unit = 
								  ()
							       val m'_18: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12509
							       val x_12510: unit = 
								  setRoundingMode_0 x_12508
							       val x_12511: real64 = 
								  round_1 x_12463
							       val x_12512: unit = 
								  setRoundingMode_0 m'_18
							       val x_12513: word8 = 
								  toInt8Unsafe_1 x_12511
							    in
							       x_12513
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12506: real64 = 
								  Real64_realTrunc (x_12463)
							       val x_12507: word8 = 
								  toInt8Unsafe_1 x_12506
							    in
							       x_12507
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12504: real64 = 
								  Real64_realFloor (x_12463)
							       val x_12505: word8 = 
								  toInt8Unsafe_1 x_12504
							    in
							       x_12505
							    end
						   in
						      x_12503
						   end
						false => 
						   let
						      val x_12489: real64
								   * real64 = 
							 (maxInt_8, one_7)
						      val x_12490: real64 = 
							 +_2 x_12489
						      val x_12491: real64
								   * real64 = 
							 (x_12463, x_12490)
						      val x_12492: bool = 
							 <_4 x_12491
						      val x_12493: word8 = 
							 case x_12492 of
							 true => 
							    let
							       val x_12495: word8 = 
								  case x_12461 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_12
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_12
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12497: real64
										     * real64 = 
									   (x_12463,
									    maxInt_8)
									val x_12498: real64 = 
									   -_2 x_12497
									val x_12499: real64
										     * real64 = 
									   (x_12498,
									    half_1)
									val x_12500: bool = 
									   >=_4 x_12499
									val x_12501: word8 = 
									   case x_12500 of
									   true => 
									      let
										 val x_12502: word8 = 
										    raise x_8290
									      in
										 x_12502
									      end
									   false => 
									      let
									      in
										 maxInt'_12
									      end
								     in
									x_12501
								     end
								  TO_POSINF_0 => 
								     let
									val x_12496: word8 = 
									   raise x_8290
								     in
									x_12496
								     end
							    in
							       x_12495
							    end
							 false => 
							    let
							       val x_12494: word8 = 
								  raise x_8290
							    in
							       x_12494
							    end
						   in
						      x_12493
						   end
					  in
					     x_12488
					  end
				       false => 
					  let
					     val x_12467: real64 * real64 = 
						(x_12463, minInt_8)
					     val x_12468: bool = 
						<_4 x_12467
					     val x_12469: word8 = 
						case x_12468 of
						true => 
						   let
						      val x_12471: real64
								   * real64 = 
							 (minInt_8, one_7)
						      val x_12472: real64 = 
							 -_2 x_12471
						      val x_12473: real64
								   * real64 = 
							 (x_12472, x_12463)
						      val x_12474: bool = 
							 <_4 x_12473
						      val x_12475: word8 = 
							 case x_12474 of
							 true => 
							    let
							       val x_12477: word8 = 
								  case x_12461 of
								  TO_NEGINF_0 => 
								     let
									val x_12485: word8 = 
									   raise x_8290
								     in
									x_12485
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_0
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12478: real64
										     * real64 = 
									   (x_12463,
									    minInt_8)
									val x_12479: real64 = 
									   -_2 x_12478
									val x_12480: real64 = 
									   ~_1 half_1
									val x_12481: real64
										     * real64 = 
									   (x_12479,
									    x_12480)
									val x_12482: bool = 
									   <_4 x_12481
									val x_12483: word8 = 
									   case x_12482 of
									   true => 
									      let
										 val x_12484: word8 = 
										    raise x_8290
									      in
										 x_12484
									      end
									   false => 
									      let
									      in
										 minInt'_0
									      end
								     in
									x_12483
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_0
								     end
							    in
							       x_12477
							    end
							 false => 
							    let
							       val x_12476: word8 = 
								  raise x_8290
							    in
							       x_12476
							    end
						   in
						      x_12475
						   end
						false => 
						   let
						      val x_12470: word8 = 
							 raise x_8285
						   in
						      x_12470
						   end
					  in
					     x_12469
					  end
				 in
				    x_12466
				 end
			   in
			      x_12462
			   end
		     in
			x_12460
		     end
	       val x_12550: word32 -> word16 = 
		  fn x_12551: word32 => 
		  let
		     val x_12552: word16 * word32 = 
			(maxInt'_1, x_12551)
		     val x_12553: word16 = 
			>>_1 x_12552
		     val x_12554: word16 * word32 = 
			(x_12553, x_12551)
		     val x_12555: word16 = 
			<<_1 x_12554
		  in
		     x_12555
		  end
	       val x_12556: word32 * word32 = 
		  (precision_8, precision'_1)
	       val x_12557: bool = 
		  <_1 x_12556
	       val x_12558: IEEEReal.RoundingMode.t_0 -> real64 -> word16 = 
		  case x_12557 of
		  true => 
		     let
			val x_12616: word32 * word32 = 
			   (precision'_1, precision_8)
			val x_12617: word32 = 
			   x_8548 x_12616
			val x_12618: word32 = 
			   0x1
			val x_12619: word32 * word32 = 
			   (x_12617, x_12618)
			val trim_9: word32 = 
			   x_8548 x_12619
			val x_12620: word32 = 
			   sextdFromInt32ToWord32_0 trim_9
			val maxInt'_15: word16 = 
			   x_12550 x_12620
			val maxInt_11: real64 = 
			   fromInt16Unsafe_1 maxInt'_15
			val minInt_11: real64 = 
			   fromInt16Unsafe_1 minInt'_1
			val x_12621: IEEEReal.RoundingMode.t_0
				     -> real64 -> word16 = 
			   fn x_12622: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12623: real64 -> word16 = 
				 fn x_12624: real64 => 
				 let
				    val x_12625: real64 * real64 = 
				       (minInt_11, x_12624)
				    val x_12626: bool = 
				       <=_3 x_12625
				    val x_12627: word16 = 
				       case x_12626 of
				       true => 
					  let
					     val x_12633: real64 * real64 = 
						(x_12624, maxInt_11)
					     val x_12634: bool = 
						<=_3 x_12633
					     val x_12635: word16 = 
						case x_12634 of
						true => 
						   let
						      val x_12637: word16 = 
							 case x_12622 of
							 TO_POSINF_0 => 
							    let
							       val x_12648: real64 = 
								  Real64_realCeil (x_12624)
							       val x_12649: word16 = 
								  toInt16Unsafe_1 x_12648
							    in
							       x_12649
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12642: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12643: unit = 
								  ()
							       val m'_21: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12643
							       val x_12644: unit = 
								  setRoundingMode_0 x_12642
							       val x_12645: real64 = 
								  round_1 x_12624
							       val x_12646: unit = 
								  setRoundingMode_0 m'_21
							       val x_12647: word16 = 
								  toInt16Unsafe_1 x_12645
							    in
							       x_12647
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12640: real64 = 
								  Real64_realTrunc (x_12624)
							       val x_12641: word16 = 
								  toInt16Unsafe_1 x_12640
							    in
							       x_12641
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12638: real64 = 
								  Real64_realFloor (x_12624)
							       val x_12639: word16 = 
								  toInt16Unsafe_1 x_12638
							    in
							       x_12639
							    end
						   in
						      x_12637
						   end
						false => 
						   let
						      val x_12636: word16 = 
							 raise x_8290
						   in
						      x_12636
						   end
					  in
					     x_12635
					  end
				       false => 
					  let
					     val x_12628: real64 * real64 = 
						(x_12624, minInt_11)
					     val x_12629: bool = 
						<_4 x_12628
					     val x_12630: word16 = 
						case x_12629 of
						true => 
						   let
						      val x_12632: word16 = 
							 raise x_8290
						   in
						      x_12632
						   end
						false => 
						   let
						      val x_12631: word16 = 
							 raise x_8285
						   in
						      x_12631
						   end
					  in
					     x_12630
					  end
				 in
				    x_12627
				 end
			   in
			      x_12623
			   end
		     in
			x_12621
		     end
		  false => 
		     let
			val x_12559: word32 = 
			   0x0
			val maxInt'_14: word16 = 
			   x_12550 x_12559
			val maxInt_10: real64 = 
			   fromInt16Unsafe_1 maxInt'_14
			val minInt_10: real64 = 
			   fromInt16Unsafe_1 minInt'_1
			val x_12560: IEEEReal.RoundingMode.t_0
				     -> real64 -> word16 = 
			   fn x_12561: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12562: real64 -> word16 = 
				 fn x_12563: real64 => 
				 let
				    val x_12564: real64 * real64 = 
				       (minInt_10, x_12563)
				    val x_12565: bool = 
				       <=_3 x_12564
				    val x_12566: word16 = 
				       case x_12565 of
				       true => 
					  let
					     val x_12586: real64 * real64 = 
						(x_12563, maxInt_10)
					     val x_12587: bool = 
						<=_3 x_12586
					     val x_12588: word16 = 
						case x_12587 of
						true => 
						   let
						      val x_12603: word16 = 
							 case x_12561 of
							 TO_POSINF_0 => 
							    let
							       val x_12614: real64 = 
								  Real64_realCeil (x_12563)
							       val x_12615: word16 = 
								  toInt16Unsafe_1 x_12614
							    in
							       x_12615
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12608: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12609: unit = 
								  ()
							       val m'_20: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12609
							       val x_12610: unit = 
								  setRoundingMode_0 x_12608
							       val x_12611: real64 = 
								  round_1 x_12563
							       val x_12612: unit = 
								  setRoundingMode_0 m'_20
							       val x_12613: word16 = 
								  toInt16Unsafe_1 x_12611
							    in
							       x_12613
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12606: real64 = 
								  Real64_realTrunc (x_12563)
							       val x_12607: word16 = 
								  toInt16Unsafe_1 x_12606
							    in
							       x_12607
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12604: real64 = 
								  Real64_realFloor (x_12563)
							       val x_12605: word16 = 
								  toInt16Unsafe_1 x_12604
							    in
							       x_12605
							    end
						   in
						      x_12603
						   end
						false => 
						   let
						      val x_12589: real64
								   * real64 = 
							 (maxInt_10, one_7)
						      val x_12590: real64 = 
							 +_2 x_12589
						      val x_12591: real64
								   * real64 = 
							 (x_12563, x_12590)
						      val x_12592: bool = 
							 <_4 x_12591
						      val x_12593: word16 = 
							 case x_12592 of
							 true => 
							    let
							       val x_12595: word16 = 
								  case x_12561 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_14
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_14
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12597: real64
										     * real64 = 
									   (x_12563,
									    maxInt_10)
									val x_12598: real64 = 
									   -_2 x_12597
									val x_12599: real64
										     * real64 = 
									   (x_12598,
									    half_1)
									val x_12600: bool = 
									   >=_4 x_12599
									val x_12601: word16 = 
									   case x_12600 of
									   true => 
									      let
										 val x_12602: word16 = 
										    raise x_8290
									      in
										 x_12602
									      end
									   false => 
									      let
									      in
										 maxInt'_14
									      end
								     in
									x_12601
								     end
								  TO_POSINF_0 => 
								     let
									val x_12596: word16 = 
									   raise x_8290
								     in
									x_12596
								     end
							    in
							       x_12595
							    end
							 false => 
							    let
							       val x_12594: word16 = 
								  raise x_8290
							    in
							       x_12594
							    end
						   in
						      x_12593
						   end
					  in
					     x_12588
					  end
				       false => 
					  let
					     val x_12567: real64 * real64 = 
						(x_12563, minInt_10)
					     val x_12568: bool = 
						<_4 x_12567
					     val x_12569: word16 = 
						case x_12568 of
						true => 
						   let
						      val x_12571: real64
								   * real64 = 
							 (minInt_10, one_7)
						      val x_12572: real64 = 
							 -_2 x_12571
						      val x_12573: real64
								   * real64 = 
							 (x_12572, x_12563)
						      val x_12574: bool = 
							 <_4 x_12573
						      val x_12575: word16 = 
							 case x_12574 of
							 true => 
							    let
							       val x_12577: word16 = 
								  case x_12561 of
								  TO_NEGINF_0 => 
								     let
									val x_12585: word16 = 
									   raise x_8290
								     in
									x_12585
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_1
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12578: real64
										     * real64 = 
									   (x_12563,
									    minInt_10)
									val x_12579: real64 = 
									   -_2 x_12578
									val x_12580: real64 = 
									   ~_1 half_1
									val x_12581: real64
										     * real64 = 
									   (x_12579,
									    x_12580)
									val x_12582: bool = 
									   <_4 x_12581
									val x_12583: word16 = 
									   case x_12582 of
									   true => 
									      let
										 val x_12584: word16 = 
										    raise x_8290
									      in
										 x_12584
									      end
									   false => 
									      let
									      in
										 minInt'_1
									      end
								     in
									x_12583
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_1
								     end
							    in
							       x_12577
							    end
							 false => 
							    let
							       val x_12576: word16 = 
								  raise x_8290
							    in
							       x_12576
							    end
						   in
						      x_12575
						   end
						false => 
						   let
						      val x_12570: word16 = 
							 raise x_8285
						   in
						      x_12570
						   end
					  in
					     x_12569
					  end
				 in
				    x_12566
				 end
			   in
			      x_12562
			   end
		     in
			x_12560
		     end
	       val x_12650: word32 -> word32 = 
		  fn x_12651: word32 => 
		  let
		     val x_12652: word32 * word32 = 
			(maxInt'_2, x_12651)
		     val x_12653: word32 = 
			>>_2 x_12652
		     val x_12654: word32 * word32 = 
			(x_12653, x_12651)
		     val x_12655: word32 = 
			<<_2 x_12654
		  in
		     x_12655
		  end
	       val x_12656: word32 * word32 = 
		  (precision_8, precision'_2)
	       val x_12657: bool = 
		  <_1 x_12656
	       val x_12658: IEEEReal.RoundingMode.t_0 -> real64 -> word32 = 
		  case x_12657 of
		  true => 
		     let
			val x_12716: word32 * word32 = 
			   (precision'_2, precision_8)
			val x_12717: word32 = 
			   x_8548 x_12716
			val x_12718: word32 = 
			   0x1
			val x_12719: word32 * word32 = 
			   (x_12717, x_12718)
			val trim_10: word32 = 
			   x_8548 x_12719
			val x_12720: word32 = 
			   sextdFromInt32ToWord32_0 trim_10
			val maxInt'_17: word32 = 
			   x_12650 x_12720
			val maxInt_13: real64 = 
			   fromInt32Unsafe_1 maxInt'_17
			val minInt_13: real64 = 
			   fromInt32Unsafe_1 minInt'_2
			val x_12721: IEEEReal.RoundingMode.t_0
				     -> real64 -> word32 = 
			   fn x_12722: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12723: real64 -> word32 = 
				 fn x_12724: real64 => 
				 let
				    val x_12725: real64 * real64 = 
				       (minInt_13, x_12724)
				    val x_12726: bool = 
				       <=_3 x_12725
				    val x_12727: word32 = 
				       case x_12726 of
				       true => 
					  let
					     val x_12733: real64 * real64 = 
						(x_12724, maxInt_13)
					     val x_12734: bool = 
						<=_3 x_12733
					     val x_12735: word32 = 
						case x_12734 of
						true => 
						   let
						      val x_12737: word32 = 
							 case x_12722 of
							 TO_POSINF_0 => 
							    let
							       val x_12748: real64 = 
								  Real64_realCeil (x_12724)
							       val x_12749: word32 = 
								  toInt32Unsafe_1 x_12748
							    in
							       x_12749
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12742: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12743: unit = 
								  ()
							       val m'_23: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12743
							       val x_12744: unit = 
								  setRoundingMode_0 x_12742
							       val x_12745: real64 = 
								  round_1 x_12724
							       val x_12746: unit = 
								  setRoundingMode_0 m'_23
							       val x_12747: word32 = 
								  toInt32Unsafe_1 x_12745
							    in
							       x_12747
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12740: real64 = 
								  Real64_realTrunc (x_12724)
							       val x_12741: word32 = 
								  toInt32Unsafe_1 x_12740
							    in
							       x_12741
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12738: real64 = 
								  Real64_realFloor (x_12724)
							       val x_12739: word32 = 
								  toInt32Unsafe_1 x_12738
							    in
							       x_12739
							    end
						   in
						      x_12737
						   end
						false => 
						   let
						      val x_12736: word32 = 
							 raise x_8290
						   in
						      x_12736
						   end
					  in
					     x_12735
					  end
				       false => 
					  let
					     val x_12728: real64 * real64 = 
						(x_12724, minInt_13)
					     val x_12729: bool = 
						<_4 x_12728
					     val x_12730: word32 = 
						case x_12729 of
						true => 
						   let
						      val x_12732: word32 = 
							 raise x_8290
						   in
						      x_12732
						   end
						false => 
						   let
						      val x_12731: word32 = 
							 raise x_8285
						   in
						      x_12731
						   end
					  in
					     x_12730
					  end
				 in
				    x_12727
				 end
			   in
			      x_12723
			   end
		     in
			x_12721
		     end
		  false => 
		     let
			val x_12659: word32 = 
			   0x0
			val maxInt'_16: word32 = 
			   x_12650 x_12659
			val maxInt_12: real64 = 
			   fromInt32Unsafe_1 maxInt'_16
			val minInt_12: real64 = 
			   fromInt32Unsafe_1 minInt'_2
			val x_12660: IEEEReal.RoundingMode.t_0
				     -> real64 -> word32 = 
			   fn x_12661: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12662: real64 -> word32 = 
				 fn x_12663: real64 => 
				 let
				    val x_12664: real64 * real64 = 
				       (minInt_12, x_12663)
				    val x_12665: bool = 
				       <=_3 x_12664
				    val x_12666: word32 = 
				       case x_12665 of
				       true => 
					  let
					     val x_12686: real64 * real64 = 
						(x_12663, maxInt_12)
					     val x_12687: bool = 
						<=_3 x_12686
					     val x_12688: word32 = 
						case x_12687 of
						true => 
						   let
						      val x_12703: word32 = 
							 case x_12661 of
							 TO_POSINF_0 => 
							    let
							       val x_12714: real64 = 
								  Real64_realCeil (x_12663)
							       val x_12715: word32 = 
								  toInt32Unsafe_1 x_12714
							    in
							       x_12715
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12708: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12709: unit = 
								  ()
							       val m'_22: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12709
							       val x_12710: unit = 
								  setRoundingMode_0 x_12708
							       val x_12711: real64 = 
								  round_1 x_12663
							       val x_12712: unit = 
								  setRoundingMode_0 m'_22
							       val x_12713: word32 = 
								  toInt32Unsafe_1 x_12711
							    in
							       x_12713
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12706: real64 = 
								  Real64_realTrunc (x_12663)
							       val x_12707: word32 = 
								  toInt32Unsafe_1 x_12706
							    in
							       x_12707
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12704: real64 = 
								  Real64_realFloor (x_12663)
							       val x_12705: word32 = 
								  toInt32Unsafe_1 x_12704
							    in
							       x_12705
							    end
						   in
						      x_12703
						   end
						false => 
						   let
						      val x_12689: real64
								   * real64 = 
							 (maxInt_12, one_7)
						      val x_12690: real64 = 
							 +_2 x_12689
						      val x_12691: real64
								   * real64 = 
							 (x_12663, x_12690)
						      val x_12692: bool = 
							 <_4 x_12691
						      val x_12693: word32 = 
							 case x_12692 of
							 true => 
							    let
							       val x_12695: word32 = 
								  case x_12661 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_16
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_16
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12697: real64
										     * real64 = 
									   (x_12663,
									    maxInt_12)
									val x_12698: real64 = 
									   -_2 x_12697
									val x_12699: real64
										     * real64 = 
									   (x_12698,
									    half_1)
									val x_12700: bool = 
									   >=_4 x_12699
									val x_12701: word32 = 
									   case x_12700 of
									   true => 
									      let
										 val x_12702: word32 = 
										    raise x_8290
									      in
										 x_12702
									      end
									   false => 
									      let
									      in
										 maxInt'_16
									      end
								     in
									x_12701
								     end
								  TO_POSINF_0 => 
								     let
									val x_12696: word32 = 
									   raise x_8290
								     in
									x_12696
								     end
							    in
							       x_12695
							    end
							 false => 
							    let
							       val x_12694: word32 = 
								  raise x_8290
							    in
							       x_12694
							    end
						   in
						      x_12693
						   end
					  in
					     x_12688
					  end
				       false => 
					  let
					     val x_12667: real64 * real64 = 
						(x_12663, minInt_12)
					     val x_12668: bool = 
						<_4 x_12667
					     val x_12669: word32 = 
						case x_12668 of
						true => 
						   let
						      val x_12671: real64
								   * real64 = 
							 (minInt_12, one_7)
						      val x_12672: real64 = 
							 -_2 x_12671
						      val x_12673: real64
								   * real64 = 
							 (x_12672, x_12663)
						      val x_12674: bool = 
							 <_4 x_12673
						      val x_12675: word32 = 
							 case x_12674 of
							 true => 
							    let
							       val x_12677: word32 = 
								  case x_12661 of
								  TO_NEGINF_0 => 
								     let
									val x_12685: word32 = 
									   raise x_8290
								     in
									x_12685
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_2
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12678: real64
										     * real64 = 
									   (x_12663,
									    minInt_12)
									val x_12679: real64 = 
									   -_2 x_12678
									val x_12680: real64 = 
									   ~_1 half_1
									val x_12681: real64
										     * real64 = 
									   (x_12679,
									    x_12680)
									val x_12682: bool = 
									   <_4 x_12681
									val x_12683: word32 = 
									   case x_12682 of
									   true => 
									      let
										 val x_12684: word32 = 
										    raise x_8290
									      in
										 x_12684
									      end
									   false => 
									      let
									      in
										 minInt'_2
									      end
								     in
									x_12683
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_2
								     end
							    in
							       x_12677
							    end
							 false => 
							    let
							       val x_12676: word32 = 
								  raise x_8290
							    in
							       x_12676
							    end
						   in
						      x_12675
						   end
						false => 
						   let
						      val x_12670: word32 = 
							 raise x_8285
						   in
						      x_12670
						   end
					  in
					     x_12669
					  end
				 in
				    x_12666
				 end
			   in
			      x_12662
			   end
		     in
			x_12660
		     end
	       val x_12750: word32 -> word64 = 
		  fn x_12751: word32 => 
		  let
		     val x_12752: word64 * word32 = 
			(maxInt'_3, x_12751)
		     val x_12753: word64 = 
			>>_3 x_12752
		     val x_12754: word64 * word32 = 
			(x_12753, x_12751)
		     val x_12755: word64 = 
			<<_3 x_12754
		  in
		     x_12755
		  end
	       val x_12756: word32 * word32 = 
		  (precision_8, precision'_3)
	       val x_12757: bool = 
		  <_1 x_12756
	       val x_12758: IEEEReal.RoundingMode.t_0 -> real64 -> word64 = 
		  case x_12757 of
		  true => 
		     let
			val x_12816: word32 * word32 = 
			   (precision'_3, precision_8)
			val x_12817: word32 = 
			   x_8548 x_12816
			val x_12818: word32 = 
			   0x1
			val x_12819: word32 * word32 = 
			   (x_12817, x_12818)
			val trim_11: word32 = 
			   x_8548 x_12819
			val x_12820: word32 = 
			   sextdFromInt32ToWord32_0 trim_11
			val maxInt'_19: word64 = 
			   x_12750 x_12820
			val maxInt_15: real64 = 
			   fromInt64Unsafe_1 maxInt'_19
			val minInt_15: real64 = 
			   fromInt64Unsafe_1 minInt'_3
			val x_12821: IEEEReal.RoundingMode.t_0
				     -> real64 -> word64 = 
			   fn x_12822: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12823: real64 -> word64 = 
				 fn x_12824: real64 => 
				 let
				    val x_12825: real64 * real64 = 
				       (minInt_15, x_12824)
				    val x_12826: bool = 
				       <=_3 x_12825
				    val x_12827: word64 = 
				       case x_12826 of
				       true => 
					  let
					     val x_12833: real64 * real64 = 
						(x_12824, maxInt_15)
					     val x_12834: bool = 
						<=_3 x_12833
					     val x_12835: word64 = 
						case x_12834 of
						true => 
						   let
						      val x_12837: word64 = 
							 case x_12822 of
							 TO_POSINF_0 => 
							    let
							       val x_12848: real64 = 
								  Real64_realCeil (x_12824)
							       val x_12849: word64 = 
								  toInt64Unsafe_1 x_12848
							    in
							       x_12849
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12842: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12843: unit = 
								  ()
							       val m'_25: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12843
							       val x_12844: unit = 
								  setRoundingMode_0 x_12842
							       val x_12845: real64 = 
								  round_1 x_12824
							       val x_12846: unit = 
								  setRoundingMode_0 m'_25
							       val x_12847: word64 = 
								  toInt64Unsafe_1 x_12845
							    in
							       x_12847
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12840: real64 = 
								  Real64_realTrunc (x_12824)
							       val x_12841: word64 = 
								  toInt64Unsafe_1 x_12840
							    in
							       x_12841
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12838: real64 = 
								  Real64_realFloor (x_12824)
							       val x_12839: word64 = 
								  toInt64Unsafe_1 x_12838
							    in
							       x_12839
							    end
						   in
						      x_12837
						   end
						false => 
						   let
						      val x_12836: word64 = 
							 raise x_8290
						   in
						      x_12836
						   end
					  in
					     x_12835
					  end
				       false => 
					  let
					     val x_12828: real64 * real64 = 
						(x_12824, minInt_15)
					     val x_12829: bool = 
						<_4 x_12828
					     val x_12830: word64 = 
						case x_12829 of
						true => 
						   let
						      val x_12832: word64 = 
							 raise x_8290
						   in
						      x_12832
						   end
						false => 
						   let
						      val x_12831: word64 = 
							 raise x_8285
						   in
						      x_12831
						   end
					  in
					     x_12830
					  end
				 in
				    x_12827
				 end
			   in
			      x_12823
			   end
		     in
			x_12821
		     end
		  false => 
		     let
			val x_12759: word32 = 
			   0x0
			val maxInt'_18: word64 = 
			   x_12750 x_12759
			val maxInt_14: real64 = 
			   fromInt64Unsafe_1 maxInt'_18
			val minInt_14: real64 = 
			   fromInt64Unsafe_1 minInt'_3
			val x_12760: IEEEReal.RoundingMode.t_0
				     -> real64 -> word64 = 
			   fn x_12761: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12762: real64 -> word64 = 
				 fn x_12763: real64 => 
				 let
				    val x_12764: real64 * real64 = 
				       (minInt_14, x_12763)
				    val x_12765: bool = 
				       <=_3 x_12764
				    val x_12766: word64 = 
				       case x_12765 of
				       true => 
					  let
					     val x_12786: real64 * real64 = 
						(x_12763, maxInt_14)
					     val x_12787: bool = 
						<=_3 x_12786
					     val x_12788: word64 = 
						case x_12787 of
						true => 
						   let
						      val x_12803: word64 = 
							 case x_12761 of
							 TO_POSINF_0 => 
							    let
							       val x_12814: real64 = 
								  Real64_realCeil (x_12763)
							       val x_12815: word64 = 
								  toInt64Unsafe_1 x_12814
							    in
							       x_12815
							    end
							 TO_NEAREST_0 => 
							    let
							       val x_12808: IEEEReal.RoundingMode.t_0 = 
								  TO_NEAREST_0
							       val x_12809: unit = 
								  ()
							       val m'_24: IEEEReal.RoundingMode.t_0 = 
								  x_11480 x_12809
							       val x_12810: unit = 
								  setRoundingMode_0 x_12808
							       val x_12811: real64 = 
								  round_1 x_12763
							       val x_12812: unit = 
								  setRoundingMode_0 m'_24
							       val x_12813: word64 = 
								  toInt64Unsafe_1 x_12811
							    in
							       x_12813
							    end
							 TO_ZERO_0 => 
							    let
							       val x_12806: real64 = 
								  Real64_realTrunc (x_12763)
							       val x_12807: word64 = 
								  toInt64Unsafe_1 x_12806
							    in
							       x_12807
							    end
							 TO_NEGINF_0 => 
							    let
							       val x_12804: real64 = 
								  Real64_realFloor (x_12763)
							       val x_12805: word64 = 
								  toInt64Unsafe_1 x_12804
							    in
							       x_12805
							    end
						   in
						      x_12803
						   end
						false => 
						   let
						      val x_12789: real64
								   * real64 = 
							 (maxInt_14, one_7)
						      val x_12790: real64 = 
							 +_2 x_12789
						      val x_12791: real64
								   * real64 = 
							 (x_12763, x_12790)
						      val x_12792: bool = 
							 <_4 x_12791
						      val x_12793: word64 = 
							 case x_12792 of
							 true => 
							    let
							       val x_12795: word64 = 
								  case x_12761 of
								  TO_NEGINF_0 => 
								     let
								     in
									maxInt'_18
								     end
								  TO_ZERO_0 => 
								     let
								     in
									maxInt'_18
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12797: real64
										     * real64 = 
									   (x_12763,
									    maxInt_14)
									val x_12798: real64 = 
									   -_2 x_12797
									val x_12799: real64
										     * real64 = 
									   (x_12798,
									    half_1)
									val x_12800: bool = 
									   >=_4 x_12799
									val x_12801: word64 = 
									   case x_12800 of
									   true => 
									      let
										 val x_12802: word64 = 
										    raise x_8290
									      in
										 x_12802
									      end
									   false => 
									      let
									      in
										 maxInt'_18
									      end
								     in
									x_12801
								     end
								  TO_POSINF_0 => 
								     let
									val x_12796: word64 = 
									   raise x_8290
								     in
									x_12796
								     end
							    in
							       x_12795
							    end
							 false => 
							    let
							       val x_12794: word64 = 
								  raise x_8290
							    in
							       x_12794
							    end
						   in
						      x_12793
						   end
					  in
					     x_12788
					  end
				       false => 
					  let
					     val x_12767: real64 * real64 = 
						(x_12763, minInt_14)
					     val x_12768: bool = 
						<_4 x_12767
					     val x_12769: word64 = 
						case x_12768 of
						true => 
						   let
						      val x_12771: real64
								   * real64 = 
							 (minInt_14, one_7)
						      val x_12772: real64 = 
							 -_2 x_12771
						      val x_12773: real64
								   * real64 = 
							 (x_12772, x_12763)
						      val x_12774: bool = 
							 <_4 x_12773
						      val x_12775: word64 = 
							 case x_12774 of
							 true => 
							    let
							       val x_12777: word64 = 
								  case x_12761 of
								  TO_NEGINF_0 => 
								     let
									val x_12785: word64 = 
									   raise x_8290
								     in
									x_12785
								     end
								  TO_ZERO_0 => 
								     let
								     in
									minInt'_3
								     end
								  TO_NEAREST_0 => 
								     let
									val x_12778: real64
										     * real64 = 
									   (x_12763,
									    minInt_14)
									val x_12779: real64 = 
									   -_2 x_12778
									val x_12780: real64 = 
									   ~_1 half_1
									val x_12781: real64
										     * real64 = 
									   (x_12779,
									    x_12780)
									val x_12782: bool = 
									   <_4 x_12781
									val x_12783: word64 = 
									   case x_12782 of
									   true => 
									      let
										 val x_12784: word64 = 
										    raise x_8290
									      in
										 x_12784
									      end
									   false => 
									      let
									      in
										 minInt'_3
									      end
								     in
									x_12783
								     end
								  TO_POSINF_0 => 
								     let
								     in
									minInt'_3
								     end
							    in
							       x_12777
							    end
							 false => 
							    let
							       val x_12776: word64 = 
								  raise x_8290
							    in
							       x_12776
							    end
						   in
						      x_12775
						   end
						false => 
						   let
						      val x_12770: word64 = 
							 raise x_8285
						   in
						      x_12770
						   end
					  in
					     x_12769
					  end
				 in
				    x_12766
				 end
			   in
			      x_12762
			   end
		     in
			x_12760
		     end
	       val x_12850: word32 -> word8 = 
		  fn x_12851: word32 => 
		  let
		     val x_12852: word8 * word32 = 
			(maxWord'_0, x_12851)
		     val x_12853: word8 = 
			>>_4 x_12852
		     val x_12854: word8 * word32 = 
			(x_12853, x_12851)
		     val x_12855: word8 = 
			<<_4 x_12854
		  in
		     x_12855
		  end
	       val x_12856: word32 * word32 = 
		  (precision_8, wordSize_0)
	       val x_12857: bool = 
		  <=_0 x_12856
	       val x_12858: IEEEReal.RoundingMode.t_0 -> real64 -> word8 = 
		  case x_12857 of
		  true => 
		     let
			val x_12913: word32 * word32 = 
			   (wordSize_0, precision_8)
			val trim_12: word32 = 
			   x_8548 x_12913
			val x_12914: word32 = 
			   sextdFromInt32ToWord32_0 trim_12
			val maxWord'_13: word8 = 
			   x_12850 x_12914
			val maxWord_9: real64 = 
			   fromWord8Unsafe_1 maxWord'_13
			val x_12915: IEEEReal.RoundingMode.t_0
				     -> real64 -> word8 = 
			   fn x_12916: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12917: real64 -> word8 = 
				 fn x_12918: real64 => 
				 let
				    val x_12919: IEEEReal.float_class_0 = 
				       class_1 x_12918
				    val x_12920: word8 = 
				       case x_12919 of
				       INF_0 => 
					  let
					     val x_12922: word8 = 
						raise x_8290
					  in
					     x_12922
					  end
				       NAN_0 => 
					  let
					     val x_12921: word8 = 
						raise x_8285
					  in
					     x_12921
					  end
					 _ => let
						 val x_12923: real64 * real64 = 
						    (zero_8, x_12918)
						 val x_12924: bool = 
						    <=_3 x_12923
						 val x_12925: word8 = 
						    case x_12924 of
						    true => 
						       let
							  val x_12938: real64
								       * real64 = 
							     (x_12918, maxWord_9)
							  val x_12939: bool = 
							     <=_3 x_12938
							  val x_12940: word8 = 
							     case x_12939 of
							     true => 
								let
								   val x_12942: word8 = 
								      case x_12916 of
								      TO_POSINF_0 => 
									 let
									    val x_12953: real64 = 
									       Real64_realCeil (x_12918)
									    val x_12954: word8 = 
									       toWord8Unsafe_1 x_12953
									 in
									    x_12954
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12947: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12948: unit = 
									       ()
									    val m'_27: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12948
									    val x_12949: unit = 
									       setRoundingMode_0 x_12947
									    val x_12950: real64 = 
									       round_1 x_12918
									    val x_12951: unit = 
									       setRoundingMode_0 m'_27
									    val x_12952: word8 = 
									       toWord8Unsafe_1 x_12950
									 in
									    x_12952
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12945: real64 = 
									       Real64_realTrunc (x_12918)
									    val x_12946: word8 = 
									       toWord8Unsafe_1 x_12945
									 in
									    x_12946
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12943: real64 = 
									       Real64_realFloor (x_12918)
									    val x_12944: word8 = 
									       toWord8Unsafe_1 x_12943
									 in
									    x_12944
									 end
								in
								   x_12942
								end
							     false => 
								let
								   val x_12941: word8 = 
								      raise x_8290
								in
								   x_12941
								end
						       in
							  x_12940
						       end
						    false => 
						       let
							  val x_12926: real64 = 
							     ~_1 one_7
							  val x_12927: real64
								       * real64 = 
							     (x_12918, x_12926)
							  val x_12928: bool = 
							     >_3 x_12927
							  val x_12929: word8 = 
							     case x_12928 of
							     true => 
								let
								   val x_12931: word8 = 
								      case x_12916 of
								      TO_NEGINF_0 => 
									 let
									    val x_12937: word8 = 
									       raise x_8290
									 in
									    x_12937
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8909
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12932: real64 = 
									       ~_1 half_1
									    val x_12933: real64
											 * real64 = 
									       (x_12918,
										x_12932)
									    val x_12934: bool = 
									       <_4 x_12933
									    val x_12935: word8 = 
									       case x_12934 of
									       true => 
										  let
										     val x_12936: word8 = 
											raise x_8290
										  in
										     x_12936
										  end
									       false => 
										  let
										  in
										     x_8909
										  end
									 in
									    x_12935
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8909
									 end
								in
								   x_12931
								end
							     false => 
								let
								   val x_12930: word8 = 
								      raise x_8290
								in
								   x_12930
								end
						       in
							  x_12929
						       end
					      in
						 x_12925
					      end
				 in
				    x_12920
				 end
			   in
			      x_12917
			   end
		     in
			x_12915
		     end
		  false => 
		     let
			val x_12859: word32 = 
			   0x0
			val maxWord'_12: word8 = 
			   x_12850 x_12859
			val maxWord_8: real64 = 
			   fromWord8Unsafe_1 maxWord'_12
			val x_12860: IEEEReal.RoundingMode.t_0
				     -> real64 -> word8 = 
			   fn x_12861: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12862: real64 -> word8 = 
				 fn x_12863: real64 => 
				 let
				    val x_12864: IEEEReal.float_class_0 = 
				       class_1 x_12863
				    val x_12865: word8 = 
				       case x_12864 of
				       INF_0 => 
					  let
					     val x_12867: word8 = 
						raise x_8290
					  in
					     x_12867
					  end
				       NAN_0 => 
					  let
					     val x_12866: word8 = 
						raise x_8285
					  in
					     x_12866
					  end
					 _ => let
						 val x_12868: real64 * real64 = 
						    (zero_8, x_12863)
						 val x_12869: bool = 
						    <=_3 x_12868
						 val x_12870: word8 = 
						    case x_12869 of
						    true => 
						       let
							  val x_12883: real64
								       * real64 = 
							     (x_12863, maxWord_8)
							  val x_12884: bool = 
							     <=_3 x_12883
							  val x_12885: word8 = 
							     case x_12884 of
							     true => 
								let
								   val x_12900: word8 = 
								      case x_12861 of
								      TO_POSINF_0 => 
									 let
									    val x_12911: real64 = 
									       Real64_realCeil (x_12863)
									    val x_12912: word8 = 
									       toWord8Unsafe_1 x_12911
									 in
									    x_12912
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12905: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_12906: unit = 
									       ()
									    val m'_26: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_12906
									    val x_12907: unit = 
									       setRoundingMode_0 x_12905
									    val x_12908: real64 = 
									       round_1 x_12863
									    val x_12909: unit = 
									       setRoundingMode_0 m'_26
									    val x_12910: word8 = 
									       toWord8Unsafe_1 x_12908
									 in
									    x_12910
									 end
								      TO_ZERO_0 => 
									 let
									    val x_12903: real64 = 
									       Real64_realTrunc (x_12863)
									    val x_12904: word8 = 
									       toWord8Unsafe_1 x_12903
									 in
									    x_12904
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_12901: real64 = 
									       Real64_realFloor (x_12863)
									    val x_12902: word8 = 
									       toWord8Unsafe_1 x_12901
									 in
									    x_12902
									 end
								in
								   x_12900
								end
							     false => 
								let
								   val x_12886: real64
										* real64 = 
								      (maxWord_8,
								       one_7)
								   val x_12887: real64 = 
								      +_2 x_12886
								   val x_12888: real64
										* real64 = 
								      (x_12863,
								       x_12887)
								   val x_12889: bool = 
								      <_4 x_12888
								   val x_12890: word8 = 
								      case x_12889 of
								      true => 
									 let
									    val x_12892: word8 = 
									       case x_12861 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_12
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_12
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_12894: real64
												  * real64 = 
											(x_12863,
											 maxWord_8)
										     val x_12895: real64 = 
											-_2 x_12894
										     val x_12896: real64
												  * real64 = 
											(x_12895,
											 half_1)
										     val x_12897: bool = 
											>=_4 x_12896
										     val x_12898: word8 = 
											case x_12897 of
											true => 
											   let
											      val x_12899: word8 = 
												 raise x_8290
											   in
											      x_12899
											   end
											false => 
											   let
											   in
											      maxWord'_12
											   end
										  in
										     x_12898
										  end
									       TO_POSINF_0 => 
										  let
										     val x_12893: word8 = 
											raise x_8290
										  in
										     x_12893
										  end
									 in
									    x_12892
									 end
								      false => 
									 let
									    val x_12891: word8 = 
									       raise x_8290
									 in
									    x_12891
									 end
								in
								   x_12890
								end
						       in
							  x_12885
						       end
						    false => 
						       let
							  val x_12871: real64 = 
							     ~_1 one_7
							  val x_12872: real64
								       * real64 = 
							     (x_12863, x_12871)
							  val x_12873: bool = 
							     >_3 x_12872
							  val x_12874: word8 = 
							     case x_12873 of
							     true => 
								let
								   val x_12876: word8 = 
								      case x_12861 of
								      TO_NEGINF_0 => 
									 let
									    val x_12882: word8 = 
									       raise x_8290
									 in
									    x_12882
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8909
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12877: real64 = 
									       ~_1 half_1
									    val x_12878: real64
											 * real64 = 
									       (x_12863,
										x_12877)
									    val x_12879: bool = 
									       <_4 x_12878
									    val x_12880: word8 = 
									       case x_12879 of
									       true => 
										  let
										     val x_12881: word8 = 
											raise x_8290
										  in
										     x_12881
										  end
									       false => 
										  let
										  in
										     x_8909
										  end
									 in
									    x_12880
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8909
									 end
								in
								   x_12876
								end
							     false => 
								let
								   val x_12875: word8 = 
								      raise x_8290
								in
								   x_12875
								end
						       in
							  x_12874
						       end
					      in
						 x_12870
					      end
				 in
				    x_12865
				 end
			   in
			      x_12862
			   end
		     in
			x_12860
		     end
	       val x_12955: word32 -> word16 = 
		  fn x_12956: word32 => 
		  let
		     val x_12957: word16 * word32 = 
			(maxWord'_1, x_12956)
		     val x_12958: word16 = 
			>>_5 x_12957
		     val x_12959: word16 * word32 = 
			(x_12958, x_12956)
		     val x_12960: word16 = 
			<<_5 x_12959
		  in
		     x_12960
		  end
	       val x_12961: word32 * word32 = 
		  (precision_8, wordSize_1)
	       val x_12962: bool = 
		  <=_0 x_12961
	       val x_12963: IEEEReal.RoundingMode.t_0 -> real64 -> word16 = 
		  case x_12962 of
		  true => 
		     let
			val x_13018: word32 * word32 = 
			   (wordSize_1, precision_8)
			val trim_13: word32 = 
			   x_8548 x_13018
			val x_13019: word32 = 
			   sextdFromInt32ToWord32_0 trim_13
			val maxWord'_15: word16 = 
			   x_12955 x_13019
			val maxWord_11: real64 = 
			   fromWord16Unsafe_1 maxWord'_15
			val x_13020: IEEEReal.RoundingMode.t_0
				     -> real64 -> word16 = 
			   fn x_13021: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_13022: real64 -> word16 = 
				 fn x_13023: real64 => 
				 let
				    val x_13024: IEEEReal.float_class_0 = 
				       class_1 x_13023
				    val x_13025: word16 = 
				       case x_13024 of
				       INF_0 => 
					  let
					     val x_13027: word16 = 
						raise x_8290
					  in
					     x_13027
					  end
				       NAN_0 => 
					  let
					     val x_13026: word16 = 
						raise x_8285
					  in
					     x_13026
					  end
					 _ => let
						 val x_13028: real64 * real64 = 
						    (zero_8, x_13023)
						 val x_13029: bool = 
						    <=_3 x_13028
						 val x_13030: word16 = 
						    case x_13029 of
						    true => 
						       let
							  val x_13043: real64
								       * real64 = 
							     (x_13023,
							      maxWord_11)
							  val x_13044: bool = 
							     <=_3 x_13043
							  val x_13045: word16 = 
							     case x_13044 of
							     true => 
								let
								   val x_13047: word16 = 
								      case x_13021 of
								      TO_POSINF_0 => 
									 let
									    val x_13058: real64 = 
									       Real64_realCeil (x_13023)
									    val x_13059: word16 = 
									       toWord16Unsafe_1 x_13058
									 in
									    x_13059
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13052: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_13053: unit = 
									       ()
									    val m'_29: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_13053
									    val x_13054: unit = 
									       setRoundingMode_0 x_13052
									    val x_13055: real64 = 
									       round_1 x_13023
									    val x_13056: unit = 
									       setRoundingMode_0 m'_29
									    val x_13057: word16 = 
									       toWord16Unsafe_1 x_13055
									 in
									    x_13057
									 end
								      TO_ZERO_0 => 
									 let
									    val x_13050: real64 = 
									       Real64_realTrunc (x_13023)
									    val x_13051: word16 = 
									       toWord16Unsafe_1 x_13050
									 in
									    x_13051
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_13048: real64 = 
									       Real64_realFloor (x_13023)
									    val x_13049: word16 = 
									       toWord16Unsafe_1 x_13048
									 in
									    x_13049
									 end
								in
								   x_13047
								end
							     false => 
								let
								   val x_13046: word16 = 
								      raise x_8290
								in
								   x_13046
								end
						       in
							  x_13045
						       end
						    false => 
						       let
							  val x_13031: real64 = 
							     ~_1 one_7
							  val x_13032: real64
								       * real64 = 
							     (x_13023, x_13031)
							  val x_13033: bool = 
							     >_3 x_13032
							  val x_13034: word16 = 
							     case x_13033 of
							     true => 
								let
								   val x_13036: word16 = 
								      case x_13021 of
								      TO_NEGINF_0 => 
									 let
									    val x_13042: word16 = 
									       raise x_8290
									 in
									    x_13042
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8947
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13037: real64 = 
									       ~_1 half_1
									    val x_13038: real64
											 * real64 = 
									       (x_13023,
										x_13037)
									    val x_13039: bool = 
									       <_4 x_13038
									    val x_13040: word16 = 
									       case x_13039 of
									       true => 
										  let
										     val x_13041: word16 = 
											raise x_8290
										  in
										     x_13041
										  end
									       false => 
										  let
										  in
										     x_8947
										  end
									 in
									    x_13040
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8947
									 end
								in
								   x_13036
								end
							     false => 
								let
								   val x_13035: word16 = 
								      raise x_8290
								in
								   x_13035
								end
						       in
							  x_13034
						       end
					      in
						 x_13030
					      end
				 in
				    x_13025
				 end
			   in
			      x_13022
			   end
		     in
			x_13020
		     end
		  false => 
		     let
			val x_12964: word32 = 
			   0x0
			val maxWord'_14: word16 = 
			   x_12955 x_12964
			val maxWord_10: real64 = 
			   fromWord16Unsafe_1 maxWord'_14
			val x_12965: IEEEReal.RoundingMode.t_0
				     -> real64 -> word16 = 
			   fn x_12966: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_12967: real64 -> word16 = 
				 fn x_12968: real64 => 
				 let
				    val x_12969: IEEEReal.float_class_0 = 
				       class_1 x_12968
				    val x_12970: word16 = 
				       case x_12969 of
				       INF_0 => 
					  let
					     val x_12972: word16 = 
						raise x_8290
					  in
					     x_12972
					  end
				       NAN_0 => 
					  let
					     val x_12971: word16 = 
						raise x_8285
					  in
					     x_12971
					  end
					 _ => let
						 val x_12973: real64 * real64 = 
						    (zero_8, x_12968)
						 val x_12974: bool = 
						    <=_3 x_12973
						 val x_12975: word16 = 
						    case x_12974 of
						    true => 
						       let
							  val x_12988: real64
								       * real64 = 
							     (x_12968,
							      maxWord_10)
							  val x_12989: bool = 
							     <=_3 x_12988
							  val x_12990: word16 = 
							     case x_12989 of
							     true => 
								let
								   val x_13005: word16 = 
								      case x_12966 of
								      TO_POSINF_0 => 
									 let
									    val x_13016: real64 = 
									       Real64_realCeil (x_12968)
									    val x_13017: word16 = 
									       toWord16Unsafe_1 x_13016
									 in
									    x_13017
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13010: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_13011: unit = 
									       ()
									    val m'_28: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_13011
									    val x_13012: unit = 
									       setRoundingMode_0 x_13010
									    val x_13013: real64 = 
									       round_1 x_12968
									    val x_13014: unit = 
									       setRoundingMode_0 m'_28
									    val x_13015: word16 = 
									       toWord16Unsafe_1 x_13013
									 in
									    x_13015
									 end
								      TO_ZERO_0 => 
									 let
									    val x_13008: real64 = 
									       Real64_realTrunc (x_12968)
									    val x_13009: word16 = 
									       toWord16Unsafe_1 x_13008
									 in
									    x_13009
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_13006: real64 = 
									       Real64_realFloor (x_12968)
									    val x_13007: word16 = 
									       toWord16Unsafe_1 x_13006
									 in
									    x_13007
									 end
								in
								   x_13005
								end
							     false => 
								let
								   val x_12991: real64
										* real64 = 
								      (maxWord_10,
								       one_7)
								   val x_12992: real64 = 
								      +_2 x_12991
								   val x_12993: real64
										* real64 = 
								      (x_12968,
								       x_12992)
								   val x_12994: bool = 
								      <_4 x_12993
								   val x_12995: word16 = 
								      case x_12994 of
								      true => 
									 let
									    val x_12997: word16 = 
									       case x_12966 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_14
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_14
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_12999: real64
												  * real64 = 
											(x_12968,
											 maxWord_10)
										     val x_13000: real64 = 
											-_2 x_12999
										     val x_13001: real64
												  * real64 = 
											(x_13000,
											 half_1)
										     val x_13002: bool = 
											>=_4 x_13001
										     val x_13003: word16 = 
											case x_13002 of
											true => 
											   let
											      val x_13004: word16 = 
												 raise x_8290
											   in
											      x_13004
											   end
											false => 
											   let
											   in
											      maxWord'_14
											   end
										  in
										     x_13003
										  end
									       TO_POSINF_0 => 
										  let
										     val x_12998: word16 = 
											raise x_8290
										  in
										     x_12998
										  end
									 in
									    x_12997
									 end
								      false => 
									 let
									    val x_12996: word16 = 
									       raise x_8290
									 in
									    x_12996
									 end
								in
								   x_12995
								end
						       in
							  x_12990
						       end
						    false => 
						       let
							  val x_12976: real64 = 
							     ~_1 one_7
							  val x_12977: real64
								       * real64 = 
							     (x_12968, x_12976)
							  val x_12978: bool = 
							     >_3 x_12977
							  val x_12979: word16 = 
							     case x_12978 of
							     true => 
								let
								   val x_12981: word16 = 
								      case x_12966 of
								      TO_NEGINF_0 => 
									 let
									    val x_12987: word16 = 
									       raise x_8290
									 in
									    x_12987
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    x_8947
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_12982: real64 = 
									       ~_1 half_1
									    val x_12983: real64
											 * real64 = 
									       (x_12968,
										x_12982)
									    val x_12984: bool = 
									       <_4 x_12983
									    val x_12985: word16 = 
									       case x_12984 of
									       true => 
										  let
										     val x_12986: word16 = 
											raise x_8290
										  in
										     x_12986
										  end
									       false => 
										  let
										  in
										     x_8947
										  end
									 in
									    x_12985
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    x_8947
									 end
								in
								   x_12981
								end
							     false => 
								let
								   val x_12980: word16 = 
								      raise x_8290
								in
								   x_12980
								end
						       in
							  x_12979
						       end
					      in
						 x_12975
					      end
				 in
				    x_12970
				 end
			   in
			      x_12967
			   end
		     in
			x_12965
		     end
	       val x_13060: word32 -> word32 = 
		  fn x_13061: word32 => 
		  let
		     val x_13062: word32 * word32 = 
			(maxWord'_2, x_13061)
		     val x_13063: word32 = 
			>>_6 x_13062
		     val x_13064: word32 * word32 = 
			(x_13063, x_13061)
		     val x_13065: word32 = 
			<<_6 x_13064
		  in
		     x_13065
		  end
	       val x_13066: word32 * word32 = 
		  (precision_8, wordSize_2)
	       val x_13067: bool = 
		  <=_0 x_13066
	       val x_13068: IEEEReal.RoundingMode.t_0 -> real64 -> word32 = 
		  case x_13067 of
		  true => 
		     let
			val x_13123: word32 * word32 = 
			   (wordSize_2, precision_8)
			val trim_14: word32 = 
			   x_8548 x_13123
			val x_13124: word32 = 
			   sextdFromInt32ToWord32_0 trim_14
			val maxWord'_17: word32 = 
			   x_13060 x_13124
			val maxWord_13: real64 = 
			   fromWord32Unsafe_1 maxWord'_17
			val x_13125: IEEEReal.RoundingMode.t_0
				     -> real64 -> word32 = 
			   fn x_13126: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_13127: real64 -> word32 = 
				 fn x_13128: real64 => 
				 let
				    val x_13129: IEEEReal.float_class_0 = 
				       class_1 x_13128
				    val x_13130: word32 = 
				       case x_13129 of
				       INF_0 => 
					  let
					     val x_13132: word32 = 
						raise x_8290
					  in
					     x_13132
					  end
				       NAN_0 => 
					  let
					     val x_13131: word32 = 
						raise x_8285
					  in
					     x_13131
					  end
					 _ => let
						 val x_13133: real64 * real64 = 
						    (zero_8, x_13128)
						 val x_13134: bool = 
						    <=_3 x_13133
						 val x_13135: word32 = 
						    case x_13134 of
						    true => 
						       let
							  val x_13148: real64
								       * real64 = 
							     (x_13128,
							      maxWord_13)
							  val x_13149: bool = 
							     <=_3 x_13148
							  val x_13150: word32 = 
							     case x_13149 of
							     true => 
								let
								   val x_13152: word32 = 
								      case x_13126 of
								      TO_POSINF_0 => 
									 let
									    val x_13163: real64 = 
									       Real64_realCeil (x_13128)
									    val x_13164: word32 = 
									       toWord32Unsafe_1 x_13163
									 in
									    x_13164
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13157: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_13158: unit = 
									       ()
									    val m'_31: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_13158
									    val x_13159: unit = 
									       setRoundingMode_0 x_13157
									    val x_13160: real64 = 
									       round_1 x_13128
									    val x_13161: unit = 
									       setRoundingMode_0 m'_31
									    val x_13162: word32 = 
									       toWord32Unsafe_1 x_13160
									 in
									    x_13162
									 end
								      TO_ZERO_0 => 
									 let
									    val x_13155: real64 = 
									       Real64_realTrunc (x_13128)
									    val x_13156: word32 = 
									       toWord32Unsafe_1 x_13155
									 in
									    x_13156
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_13153: real64 = 
									       Real64_realFloor (x_13128)
									    val x_13154: word32 = 
									       toWord32Unsafe_1 x_13153
									 in
									    x_13154
									 end
								in
								   x_13152
								end
							     false => 
								let
								   val x_13151: word32 = 
								      raise x_8290
								in
								   x_13151
								end
						       in
							  x_13150
						       end
						    false => 
						       let
							  val x_13136: real64 = 
							     ~_1 one_7
							  val x_13137: real64
								       * real64 = 
							     (x_13128, x_13136)
							  val x_13138: bool = 
							     >_3 x_13137
							  val x_13139: word32 = 
							     case x_13138 of
							     true => 
								let
								   val x_13141: word32 = 
								      case x_13126 of
								      TO_NEGINF_0 => 
									 let
									    val x_13147: word32 = 
									       raise x_8290
									 in
									    x_13147
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_2
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13142: real64 = 
									       ~_1 half_1
									    val x_13143: real64
											 * real64 = 
									       (x_13128,
										x_13142)
									    val x_13144: bool = 
									       <_4 x_13143
									    val x_13145: word32 = 
									       case x_13144 of
									       true => 
										  let
										     val x_13146: word32 = 
											raise x_8290
										  in
										     x_13146
										  end
									       false => 
										  let
										  in
										     zero_2
										  end
									 in
									    x_13145
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_2
									 end
								in
								   x_13141
								end
							     false => 
								let
								   val x_13140: word32 = 
								      raise x_8290
								in
								   x_13140
								end
						       in
							  x_13139
						       end
					      in
						 x_13135
					      end
				 in
				    x_13130
				 end
			   in
			      x_13127
			   end
		     in
			x_13125
		     end
		  false => 
		     let
			val x_13069: word32 = 
			   0x0
			val maxWord'_16: word32 = 
			   x_13060 x_13069
			val maxWord_12: real64 = 
			   fromWord32Unsafe_1 maxWord'_16
			val x_13070: IEEEReal.RoundingMode.t_0
				     -> real64 -> word32 = 
			   fn x_13071: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_13072: real64 -> word32 = 
				 fn x_13073: real64 => 
				 let
				    val x_13074: IEEEReal.float_class_0 = 
				       class_1 x_13073
				    val x_13075: word32 = 
				       case x_13074 of
				       INF_0 => 
					  let
					     val x_13077: word32 = 
						raise x_8290
					  in
					     x_13077
					  end
				       NAN_0 => 
					  let
					     val x_13076: word32 = 
						raise x_8285
					  in
					     x_13076
					  end
					 _ => let
						 val x_13078: real64 * real64 = 
						    (zero_8, x_13073)
						 val x_13079: bool = 
						    <=_3 x_13078
						 val x_13080: word32 = 
						    case x_13079 of
						    true => 
						       let
							  val x_13093: real64
								       * real64 = 
							     (x_13073,
							      maxWord_12)
							  val x_13094: bool = 
							     <=_3 x_13093
							  val x_13095: word32 = 
							     case x_13094 of
							     true => 
								let
								   val x_13110: word32 = 
								      case x_13071 of
								      TO_POSINF_0 => 
									 let
									    val x_13121: real64 = 
									       Real64_realCeil (x_13073)
									    val x_13122: word32 = 
									       toWord32Unsafe_1 x_13121
									 in
									    x_13122
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13115: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_13116: unit = 
									       ()
									    val m'_30: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_13116
									    val x_13117: unit = 
									       setRoundingMode_0 x_13115
									    val x_13118: real64 = 
									       round_1 x_13073
									    val x_13119: unit = 
									       setRoundingMode_0 m'_30
									    val x_13120: word32 = 
									       toWord32Unsafe_1 x_13118
									 in
									    x_13120
									 end
								      TO_ZERO_0 => 
									 let
									    val x_13113: real64 = 
									       Real64_realTrunc (x_13073)
									    val x_13114: word32 = 
									       toWord32Unsafe_1 x_13113
									 in
									    x_13114
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_13111: real64 = 
									       Real64_realFloor (x_13073)
									    val x_13112: word32 = 
									       toWord32Unsafe_1 x_13111
									 in
									    x_13112
									 end
								in
								   x_13110
								end
							     false => 
								let
								   val x_13096: real64
										* real64 = 
								      (maxWord_12,
								       one_7)
								   val x_13097: real64 = 
								      +_2 x_13096
								   val x_13098: real64
										* real64 = 
								      (x_13073,
								       x_13097)
								   val x_13099: bool = 
								      <_4 x_13098
								   val x_13100: word32 = 
								      case x_13099 of
								      true => 
									 let
									    val x_13102: word32 = 
									       case x_13071 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_16
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_16
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_13104: real64
												  * real64 = 
											(x_13073,
											 maxWord_12)
										     val x_13105: real64 = 
											-_2 x_13104
										     val x_13106: real64
												  * real64 = 
											(x_13105,
											 half_1)
										     val x_13107: bool = 
											>=_4 x_13106
										     val x_13108: word32 = 
											case x_13107 of
											true => 
											   let
											      val x_13109: word32 = 
												 raise x_8290
											   in
											      x_13109
											   end
											false => 
											   let
											   in
											      maxWord'_16
											   end
										  in
										     x_13108
										  end
									       TO_POSINF_0 => 
										  let
										     val x_13103: word32 = 
											raise x_8290
										  in
										     x_13103
										  end
									 in
									    x_13102
									 end
								      false => 
									 let
									    val x_13101: word32 = 
									       raise x_8290
									 in
									    x_13101
									 end
								in
								   x_13100
								end
						       in
							  x_13095
						       end
						    false => 
						       let
							  val x_13081: real64 = 
							     ~_1 one_7
							  val x_13082: real64
								       * real64 = 
							     (x_13073, x_13081)
							  val x_13083: bool = 
							     >_3 x_13082
							  val x_13084: word32 = 
							     case x_13083 of
							     true => 
								let
								   val x_13086: word32 = 
								      case x_13071 of
								      TO_NEGINF_0 => 
									 let
									    val x_13092: word32 = 
									       raise x_8290
									 in
									    x_13092
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_2
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13087: real64 = 
									       ~_1 half_1
									    val x_13088: real64
											 * real64 = 
									       (x_13073,
										x_13087)
									    val x_13089: bool = 
									       <_4 x_13088
									    val x_13090: word32 = 
									       case x_13089 of
									       true => 
										  let
										     val x_13091: word32 = 
											raise x_8290
										  in
										     x_13091
										  end
									       false => 
										  let
										  in
										     zero_2
										  end
									 in
									    x_13090
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_2
									 end
								in
								   x_13086
								end
							     false => 
								let
								   val x_13085: word32 = 
								      raise x_8290
								in
								   x_13085
								end
						       in
							  x_13084
						       end
					      in
						 x_13080
					      end
				 in
				    x_13075
				 end
			   in
			      x_13072
			   end
		     in
			x_13070
		     end
	       val x_13165: word32 -> word64 = 
		  fn x_13166: word32 => 
		  let
		     val x_13167: word64 * word32 = 
			(maxWord'_3, x_13166)
		     val x_13168: word64 = 
			>>_7 x_13167
		     val x_13169: word64 * word32 = 
			(x_13168, x_13166)
		     val x_13170: word64 = 
			<<_7 x_13169
		  in
		     x_13170
		  end
	       val x_13171: word32 * word32 = 
		  (precision_8, wordSize_3)
	       val x_13172: bool = 
		  <=_0 x_13171
	       val x_13173: IEEEReal.RoundingMode.t_0 -> real64 -> word64 = 
		  case x_13172 of
		  true => 
		     let
			val x_13228: word32 * word32 = 
			   (wordSize_3, precision_8)
			val trim_15: word32 = 
			   x_8548 x_13228
			val x_13229: word32 = 
			   sextdFromInt32ToWord32_0 trim_15
			val maxWord'_19: word64 = 
			   x_13165 x_13229
			val maxWord_15: real64 = 
			   fromWord64Unsafe_1 maxWord'_19
			val x_13230: IEEEReal.RoundingMode.t_0
				     -> real64 -> word64 = 
			   fn x_13231: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_13232: real64 -> word64 = 
				 fn x_13233: real64 => 
				 let
				    val x_13234: IEEEReal.float_class_0 = 
				       class_1 x_13233
				    val x_13235: word64 = 
				       case x_13234 of
				       INF_0 => 
					  let
					     val x_13237: word64 = 
						raise x_8290
					  in
					     x_13237
					  end
				       NAN_0 => 
					  let
					     val x_13236: word64 = 
						raise x_8285
					  in
					     x_13236
					  end
					 _ => let
						 val x_13238: real64 * real64 = 
						    (zero_8, x_13233)
						 val x_13239: bool = 
						    <=_3 x_13238
						 val x_13240: word64 = 
						    case x_13239 of
						    true => 
						       let
							  val x_13253: real64
								       * real64 = 
							     (x_13233,
							      maxWord_15)
							  val x_13254: bool = 
							     <=_3 x_13253
							  val x_13255: word64 = 
							     case x_13254 of
							     true => 
								let
								   val x_13257: word64 = 
								      case x_13231 of
								      TO_POSINF_0 => 
									 let
									    val x_13268: real64 = 
									       Real64_realCeil (x_13233)
									    val x_13269: word64 = 
									       toWord64Unsafe_1 x_13268
									 in
									    x_13269
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13262: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_13263: unit = 
									       ()
									    val m'_33: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_13263
									    val x_13264: unit = 
									       setRoundingMode_0 x_13262
									    val x_13265: real64 = 
									       round_1 x_13233
									    val x_13266: unit = 
									       setRoundingMode_0 m'_33
									    val x_13267: word64 = 
									       toWord64Unsafe_1 x_13265
									 in
									    x_13267
									 end
								      TO_ZERO_0 => 
									 let
									    val x_13260: real64 = 
									       Real64_realTrunc (x_13233)
									    val x_13261: word64 = 
									       toWord64Unsafe_1 x_13260
									 in
									    x_13261
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_13258: real64 = 
									       Real64_realFloor (x_13233)
									    val x_13259: word64 = 
									       toWord64Unsafe_1 x_13258
									 in
									    x_13259
									 end
								in
								   x_13257
								end
							     false => 
								let
								   val x_13256: word64 = 
								      raise x_8290
								in
								   x_13256
								end
						       in
							  x_13255
						       end
						    false => 
						       let
							  val x_13241: real64 = 
							     ~_1 one_7
							  val x_13242: real64
								       * real64 = 
							     (x_13233, x_13241)
							  val x_13243: bool = 
							     >_3 x_13242
							  val x_13244: word64 = 
							     case x_13243 of
							     true => 
								let
								   val x_13246: word64 = 
								      case x_13231 of
								      TO_NEGINF_0 => 
									 let
									    val x_13252: word64 = 
									       raise x_8290
									 in
									    x_13252
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_4
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13247: real64 = 
									       ~_1 half_1
									    val x_13248: real64
											 * real64 = 
									       (x_13233,
										x_13247)
									    val x_13249: bool = 
									       <_4 x_13248
									    val x_13250: word64 = 
									       case x_13249 of
									       true => 
										  let
										     val x_13251: word64 = 
											raise x_8290
										  in
										     x_13251
										  end
									       false => 
										  let
										  in
										     zero_4
										  end
									 in
									    x_13250
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_4
									 end
								in
								   x_13246
								end
							     false => 
								let
								   val x_13245: word64 = 
								      raise x_8290
								in
								   x_13245
								end
						       in
							  x_13244
						       end
					      in
						 x_13240
					      end
				 in
				    x_13235
				 end
			   in
			      x_13232
			   end
		     in
			x_13230
		     end
		  false => 
		     let
			val x_13174: word32 = 
			   0x0
			val maxWord'_18: word64 = 
			   x_13165 x_13174
			val maxWord_14: real64 = 
			   fromWord64Unsafe_1 maxWord'_18
			val x_13175: IEEEReal.RoundingMode.t_0
				     -> real64 -> word64 = 
			   fn x_13176: IEEEReal.RoundingMode.t_0 => 
			   let
			      val x_13177: real64 -> word64 = 
				 fn x_13178: real64 => 
				 let
				    val x_13179: IEEEReal.float_class_0 = 
				       class_1 x_13178
				    val x_13180: word64 = 
				       case x_13179 of
				       INF_0 => 
					  let
					     val x_13182: word64 = 
						raise x_8290
					  in
					     x_13182
					  end
				       NAN_0 => 
					  let
					     val x_13181: word64 = 
						raise x_8285
					  in
					     x_13181
					  end
					 _ => let
						 val x_13183: real64 * real64 = 
						    (zero_8, x_13178)
						 val x_13184: bool = 
						    <=_3 x_13183
						 val x_13185: word64 = 
						    case x_13184 of
						    true => 
						       let
							  val x_13198: real64
								       * real64 = 
							     (x_13178,
							      maxWord_14)
							  val x_13199: bool = 
							     <=_3 x_13198
							  val x_13200: word64 = 
							     case x_13199 of
							     true => 
								let
								   val x_13215: word64 = 
								      case x_13176 of
								      TO_POSINF_0 => 
									 let
									    val x_13226: real64 = 
									       Real64_realCeil (x_13178)
									    val x_13227: word64 = 
									       toWord64Unsafe_1 x_13226
									 in
									    x_13227
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13220: IEEEReal.RoundingMode.t_0 = 
									       TO_NEAREST_0
									    val x_13221: unit = 
									       ()
									    val m'_32: IEEEReal.RoundingMode.t_0 = 
									       x_11480 x_13221
									    val x_13222: unit = 
									       setRoundingMode_0 x_13220
									    val x_13223: real64 = 
									       round_1 x_13178
									    val x_13224: unit = 
									       setRoundingMode_0 m'_32
									    val x_13225: word64 = 
									       toWord64Unsafe_1 x_13223
									 in
									    x_13225
									 end
								      TO_ZERO_0 => 
									 let
									    val x_13218: real64 = 
									       Real64_realTrunc (x_13178)
									    val x_13219: word64 = 
									       toWord64Unsafe_1 x_13218
									 in
									    x_13219
									 end
								      TO_NEGINF_0 => 
									 let
									    val x_13216: real64 = 
									       Real64_realFloor (x_13178)
									    val x_13217: word64 = 
									       toWord64Unsafe_1 x_13216
									 in
									    x_13217
									 end
								in
								   x_13215
								end
							     false => 
								let
								   val x_13201: real64
										* real64 = 
								      (maxWord_14,
								       one_7)
								   val x_13202: real64 = 
								      +_2 x_13201
								   val x_13203: real64
										* real64 = 
								      (x_13178,
								       x_13202)
								   val x_13204: bool = 
								      <_4 x_13203
								   val x_13205: word64 = 
								      case x_13204 of
								      true => 
									 let
									    val x_13207: word64 = 
									       case x_13176 of
									       TO_NEGINF_0 => 
										  let
										  in
										     maxWord'_18
										  end
									       TO_ZERO_0 => 
										  let
										  in
										     maxWord'_18
										  end
									       TO_NEAREST_0 => 
										  let
										     val x_13209: real64
												  * real64 = 
											(x_13178,
											 maxWord_14)
										     val x_13210: real64 = 
											-_2 x_13209
										     val x_13211: real64
												  * real64 = 
											(x_13210,
											 half_1)
										     val x_13212: bool = 
											>=_4 x_13211
										     val x_13213: word64 = 
											case x_13212 of
											true => 
											   let
											      val x_13214: word64 = 
												 raise x_8290
											   in
											      x_13214
											   end
											false => 
											   let
											   in
											      maxWord'_18
											   end
										  in
										     x_13213
										  end
									       TO_POSINF_0 => 
										  let
										     val x_13208: word64 = 
											raise x_8290
										  in
										     x_13208
										  end
									 in
									    x_13207
									 end
								      false => 
									 let
									    val x_13206: word64 = 
									       raise x_8290
									 in
									    x_13206
									 end
								in
								   x_13205
								end
						       in
							  x_13200
						       end
						    false => 
						       let
							  val x_13186: real64 = 
							     ~_1 one_7
							  val x_13187: real64
								       * real64 = 
							     (x_13178, x_13186)
							  val x_13188: bool = 
							     >_3 x_13187
							  val x_13189: word64 = 
							     case x_13188 of
							     true => 
								let
								   val x_13191: word64 = 
								      case x_13176 of
								      TO_NEGINF_0 => 
									 let
									    val x_13197: word64 = 
									       raise x_8290
									 in
									    x_13197
									 end
								      TO_ZERO_0 => 
									 let
									 in
									    zero_4
									 end
								      TO_NEAREST_0 => 
									 let
									    val x_13192: real64 = 
									       ~_1 half_1
									    val x_13193: real64
											 * real64 = 
									       (x_13178,
										x_13192)
									    val x_13194: bool = 
									       <_4 x_13193
									    val x_13195: word64 = 
									       case x_13194 of
									       true => 
										  let
										     val x_13196: word64 = 
											raise x_8290
										  in
										     x_13196
										  end
									       false => 
										  let
										  in
										     zero_4
										  end
									 in
									    x_13195
									 end
								      TO_POSINF_0 => 
									 let
									 in
									    zero_4
									 end
								in
								   x_13191
								end
							     false => 
								let
								   val x_13190: word64 = 
								      raise x_8290
								in
								   x_13190
								end
						       in
							  x_13189
						       end
					      in
						 x_13185
					      end
				 in
				    x_13180
				 end
			   in
			      x_13177
			   end
		     in
			x_13175
		     end
	       val ticksPerSecond_0: intInf = 
		  1000000000
	       val x_13270: intInf = 
		  1
	       val x_13271: intInf * intInf = 
		  (ticksPerSecond_0, x_13270)
	       val x_13272: bool = 
		  areSmall_0 x_13271
	       val x_13273: intInf = 
		  case x_13272 of
		  true => 
		     let
			val numw_0: word64 = 
			   dropTagCoerce_0 ticksPerSecond_0
			val numi_0: word64 = 
			   zextdFromWord64ToInt64_0 numw_0
			val denw_0: word64 = 
			   dropTagCoerce_0 x_13270
			val deni_0: word64 = 
			   zextdFromWord64ToInt64_0 denw_0
			val x_13283: word64 * word64 = 
			   (numw_0, badObjptrWord_0)
			val x_13284: bool = 
			   x_8372 x_13283
			val x_13285: bool = 
			   case x_13284 of
			   true => 
			      let
				 val x_13287: word64 = 
				    0xFFFFFFFFFFFFFFFF
				 val x_13288: word64 * word64 = 
				    (deni_0, x_13287)
				 val x_13289: bool = 
				    x_8372 x_13288
			      in
				 x_13289
			      end
			   false => 
			      let
				 val x_13286: bool = 
				    false
			      in
				 x_13286
			      end
			val x_13290: intInf = 
			   case x_13285 of
			   true => 
			      let
			      in
				 negBadIntInf_0
			      end
			   false => 
			      let
				 val x_13291: word64 * word64 = 
				    (numi_0, deni_0)
				 val ansi_0: word64 = 
				    quot_1 x_13291
				 val answ_0: word64 = 
				    zextdFromInt64ToWord64_0 ansi_0
				 val ans_0: word64 = 
				    addTag_0 answ_0
				 val x_13292: intInf = 
				    fromWord_0 ans_0
			      in
				 x_13292
			      end
		     in
			x_13290
		     end
		  false => 
		     let
			val nlimbs_0: word64 = 
			   numLimbs_0 ticksPerSecond_0
			val dlimbs_0: word64 = 
			   numLimbs_0 x_13270
			val x_13274: word64 * word64 = 
			   (nlimbs_0, dlimbs_0)
			val x_13275: bool = 
			   <_2 x_13274
			val x_13276: intInf = 
			   case x_13275 of
			   true => 
			      let
			      in
				 zero_6
			      end
			   false => 
			      let
				 val x_13277: word64 * word64 = 
				    (nlimbs_0, dlimbs_0)
				 val x_13278: word64 = 
				    x_8628 x_13277
				 val x_13279: word64 = 
				    0x2
				 val x_13280: word64 * word64 = 
				    (x_13278, x_13279)
				 val x_13281: word64 = 
				    reserve_0 x_13280
				 val x_13282: intInf = 
				    1000000000
			      in
				 x_13282
			      end
		     in
			x_13276
		     end
	       val x_13293: unit = 
		  ()
	       val x_13294: unit ref = 
		  Ref_ref[unit] (x_13293)
	       val x_13295: exn = 
		  BlockingNotSupported_0 x_13294
	       val x_13296: unit = 
		  ()
	       val x_13297: unit ref = 
		  Ref_ref[unit] (x_13296)
	       val x_13298: exn = 
		  ClosedStream_0 x_13297
	       val x_13299: unit = 
		  ()
	       val x_13300: unit ref = 
		  Ref_ref[unit] (x_13299)
	       val x_13301: exn -> Primitive.Option.t_1 = 
		  fn x_13302: exn => 
		  let
		     val x_13303: unit -> Primitive.Option.t_1 = 
			fn unit_19: unit => 
			let
			   val x_13304: Primitive.Option.t_1 = 
			      NONE_1
			in
			   x_13304
			end
		     val x_13305: Primitive.Option.t_1 = 
			case x_13302 of
			Io_0 x_13306: unit ref
				      * (exn * word8 vector * word8 vector) => 
			   let
			      val x_13307: exn * word8 vector * word8 vector = 
				 #1 x_13306
			      val x_13308: unit ref = 
				 #0 x_13306
			      val x_13309: bool = 
				 MLton_equal[unit ref] (x_13308, x_13300)
			      val x_13310: Primitive.Option.t_1 = 
				 case x_13309 of
				 true => 
				    let
				       val x_13313: word8 vector = 
					  #2 x_13307
				       val x_13314: word8 vector = 
					  #1 x_13307
				       val x_13315: exn = 
					  #0 x_13307
				       val x_13316: list_7 = 
					  nil_7
				       val x_13317: word8 vector = 
					  exnMessage_0 x_13315
				       val x_13318: word8 vector * list_7 = 
					  (x_13317, x_13316)
				       val x_13319: list_7 = 
					  ::_7 x_13318
				       val x_13320: word8 vector = 
					  "\" failed with "
				       val x_13321: word8 vector * list_7 = 
					  (x_13320, x_13319)
				       val x_13322: list_7 = 
					  ::_7 x_13321
				       val x_13323: word8 vector * list_7 = 
					  (x_13313, x_13322)
				       val x_13324: list_7 = 
					  ::_7 x_13323
				       val x_13325: word8 vector = 
					  " \""
				       val x_13326: word8 vector * list_7 = 
					  (x_13325, x_13324)
				       val x_13327: list_7 = 
					  ::_7 x_13326
				       val x_13328: word8 vector * list_7 = 
					  (x_13314, x_13327)
				       val x_13329: list_7 = 
					  ::_7 x_13328
				       val x_13330: word8 vector = 
					  "Io: "
				       val x_13331: word8 vector * list_7 = 
					  (x_13330, x_13329)
				       val x_13332: list_7 = 
					  ::_7 x_13331
				       val x_13333: word8 vector = 
					  concat_3 x_13332
				       val x_13334: Primitive.Option.t_1 = 
					  SOME_1 x_13333
				    in
				       x_13334
				    end
				 false => 
				    let
				       val x_13311: unit = 
					  ()
				       val x_13312: Primitive.Option.t_1 = 
					  x_13303 x_13311
				    in
				       x_13312
				    end
			   in
			      x_13310
			   end
			  _ => let
				  val x_13335: unit = 
				     ()
				  val x_13336: Primitive.Option.t_1 = 
				     x_13303 x_13335
			       in
				  x_13336
			       end
		  in
		     x_13305
		  end
	       val x_13337: list_0 = 
		  x_8318 messagers_0
	       val x_13338: (exn -> Primitive.Option.t_1) * list_0 = 
		  (x_13301, x_13337)
	       val x_13339: list_0 = 
		  ::_0 x_13338
	       val x_13340: unit = 
		  Ref_assign[list_0] (messagers_0, x_13339)
	       val x_13341: word64 -> Time.time_0 = 
		  fn x_13342: word64 => 
		  let
		     val x_13343: intInf = 
			sextdFromInt64_0 x_13342
		     val x_13344: intInf * intInf = 
			(x_13343, x_13273)
		     val x_13345: bool = 
			areSmall_0 x_13344
		     val x_13346: Primitive.Option.t_5 = 
			case x_13345 of
			true => 
			   let
			      val x_13348: Primitive.Option.t_5 = 
				 let
				    val lhsw_0: word64 = 
				       dropTagCoerce_0 x_13343
				    val lhsi_0: word64 = 
				       zextdFromWord64ToInt64_0 lhsw_0
				    val rhsw_0: word64 = 
				       dropTagCoerce_0 x_13273
				    val rhsi_0: word64 = 
				       zextdFromWord64ToInt64_0 rhsw_0
				    val x_13349: word64 = 
				       let
					  val x_13350: word64 = 
					     WordS64_mulCheck (lhsi_0, rhsi_0)
				       in
					  x_13350
				       end
				       handle x_13351 => let
							    val x_13352: unit
									 -> word64 = 
							       fn unit_20: unit => 
							       let
								  val x_13353: word64 = 
								     raise x_13351
							       in
								  x_13353
							       end
							    val x_13354: word64 = 
							       case x_13351 of
							       Overflow x_13355: unit ref => 
								  let
								     val x_13356: bool = 
									MLton_equal[unit ref] (x_13355,
											       x_8183)
								     val x_13357: word64 = 
									case x_13356 of
									true => 
									   let
									      val x_13360: word64 = 
										 raise x_8290
									   in
									      x_13360
									   end
									false => 
									   let
									      val x_13358: unit = 
										 ()
									      val x_13359: word64 = 
										 x_13352 x_13358
									   in
									      x_13359
									   end
								  in
								     x_13357
								  end
								 _ => let
									 val x_13361: unit = 
									    ()
									 val x_13362: word64 = 
									    x_13352 x_13361
								      in
									 x_13362
								      end
							 in
							    x_13354
							 end
				    val answ_1: word64 = 
				       zextdFromInt64ToWord64_0 x_13349
				    val ans_1: word64 = 
				       addTag_0 answ_1
				    val x_13363: word64 = 
				       Word64_xorb (ans_1, answ_1)
				    val x_13364: word64 = 
				       zextdFromWord64ToInt64_0 x_13363
				    val x_13365: word64 = 
				       0x0
				    val x_13366: word64 * word64 = 
				       (x_13364, x_13365)
				    val x_13367: bool = 
				       >=_2 x_13366
				    val x_13368: Primitive.Option.t_5 = 
				       case x_13367 of
				       true => 
					  let
					     val x_13370: intInf = 
						fromWord_0 ans_1
					     val x_13371: Primitive.Option.t_5 = 
						SOME_5 x_13370
					  in
					     x_13371
					  end
				       false => 
					  let
					     val x_13369: Primitive.Option.t_5 = 
						NONE_5
					  in
					     x_13369
					  end
				 in
				    x_13368
				 end
				 handle x_13372 => let
						      val x_13373: unit
								   -> Primitive.Option.t_5 = 
							 fn unit_21: unit => 
							 let
							    val x_13374: Primitive.Option.t_5 = 
							       raise x_13372
							 in
							    x_13374
							 end
						      val x_13375: Primitive.Option.t_5 = 
							 case x_13372 of
							 Overflow_0 x_13376: unit ref => 
							    let
							       val x_13377: bool = 
								  MLton_equal[unit ref] (x_13376,
											 x_8289)
							       val x_13378: Primitive.Option.t_5 = 
								  case x_13377 of
								  true => 
								     let
									val x_13381: Primitive.Option.t_5 = 
									   NONE_5
								     in
									x_13381
								     end
								  false => 
								     let
									val x_13379: unit = 
									   ()
									val x_13380: Primitive.Option.t_5 = 
									   x_13373 x_13379
								     in
									x_13380
								     end
							    in
							       x_13378
							    end
							   _ => let
								   val x_13382: unit = 
								      ()
								   val x_13383: Primitive.Option.t_5 = 
								      x_13373 x_13382
								in
								   x_13383
								end
						   in
						      x_13375
						   end
			   in
			      x_13348
			   end
			false => 
			   let
			      val x_13347: Primitive.Option.t_5 = 
				 NONE_5
			   in
			      x_13347
			   end
		     val x_13384: intInf = 
			case x_13346 of
			NONE_5 => 
			   let
			      val x_13386: word64 = 
				 numLimbs_0 x_13343
			      val x_13387: word64 = 
				 numLimbs_0 x_13273
			      val x_13388: word64 * word64 = 
				 (x_13386, x_13387)
			      val x_13389: word64 = 
				 x_8588 x_13388
			      val x_13390: word64 * word64 = 
				 (x_13389, x_9439)
			      val x_13391: word64 = 
				 reserve_0 x_13390
			      val x_13392: intInf = 
				 IntInf_mul (x_13343, x_13273, x_13391)
			   in
			      x_13392
			   end
			SOME_5 x_13385: intInf => 
			   let
			   in
			      x_13385
			   end
		     val x_13393: Time.time_0 = 
			T_2 x_13384
		  in
		     x_13393
		  end
	       val x_13394: word32 = 
		  0x1
	       val stdout_0: word32 = 
		  fromRep_0 x_13394
	       val x_13395: word32 = 
		  0x2
	       val stderr_0: word32 = 
		  fromRep_0 x_13395
	       val x_13396: word64 = 
		  0x0
	       val empty_0: word32 = 
		  zextdFromWord64ToInt32_0 x_13396
	       val x_13397: list_4 -> word32 = 
		  fn x_13398: list_4 => 
		  let
		     val rec 
			loop_24: list_4 * word32 -> word32 = 
			   fn x_13399: list_4 * word32 => 
			   let
			      val b_43: word32 = 
				 #1 x_13399
			      val l_3: list_4 = 
				 #0 x_13399
			      val x_13400: word32 = 
				 case l_3 of
				 nil_4 => 
				    let
				    in
				       b_43
				    end
				 ::_4 x_13401: word32 * list_4 => 
				    let
				       val x_13402: list_4 = 
					  #1 x_13401
				       val x_13403: word32 = 
					  #0 x_13401
				       val x_13404: word32 = 
					  idFromInt32ToWord32_0 x_13403
				       val x_13405: word32 = 
					  idFromInt32ToWord32_0 b_43
				       val x_13406: word32 = 
					  Word32_orb (x_13404, x_13405)
				       val x_13407: word32 = 
					  idFromWord32ToInt32_0 x_13406
				       val x_13408: list_4 * word32 = 
					  (x_13402, x_13407)
				       val x_13409: word32 = 
					  loop_24 x_13408
				    in
				       x_13409
				    end
			   in
			      x_13400
			   end
		     val x_13410: list_4 * word32 = 
			(x_13398, empty_0)
		     val x_13411: word32 = 
			loop_24 x_13410
		  in
		     x_13411
		  end
	       val x_13412: word32 -> PosixFileSys.ST.stat_0 = 
		  fn x_13413: word32 => 
		  let
		     val x_13414: word32 = 
			toRep_1 x_13413
		     val x_13415: word32 = 
			0xFFFFFFFF
		     val x_13416: word32 = 
			sextdFromInt32ToInt32_0 x_13415
		     val x_13417: unit = 
			()
		     val x_13418: unit = 
			atomicBegin_0 x_13417
		     val x_13419: list_8
				  * (word32 -> PosixFileSys.ST.stat_0)
				  * word32 = 
			let
			   val x_13420: word32 = 
			      Posix_FileSys_Stat_fstat (x_13414)
			   val x_13421: word32 -> PosixFileSys.ST.stat_0 = 
			      fn x_13422: word32 => 
			      let
				 val x_13423: word64 = 
				    Posix_FileSys_Stat_getDev ()
				 val x_13424: word64 = 
				    Posix_FileSys_Stat_getINo ()
				 val x_13425: word32 = 
				    Posix_FileSys_Stat_getMode ()
				 val x_13426: word64 = 
				    Posix_FileSys_Stat_getNLink ()
				 val res_1: word32 = 
				    zextdFromWord64ToInt32_0 x_13426
				 val x_13427: word64 = 
				    zextdFromInt32ToWord64_0 res_1
				 val x_13428: word64 * word64 = 
				    (x_13426, x_13427)
				 val x_13429: bool = 
				    x_8372 x_13428
				 val x_13430: word32 = 
				    case x_13429 of
				    true => 
				       let
				       in
					  res_1
				       end
				    false => 
				       let
					  val x_13431: word32 = 
					     raise x_8290
				       in
					  x_13431
				       end
				 val x_13432: word32 * word32 = 
				    (sizeInBits_64, sizeInBits_32)
				 val x_13433: bool = 
				    <=_0 x_13432
				 val x_13434: bool = 
				    case x_13433 of
				    true => 
				       let
					  val x_13436: word32 = 
					     0x0
					  val x_13437: word32 * word32 = 
					     (x_13430, x_13436)
					  val x_13438: bool = 
					     <_1 x_13437
				       in
					  x_13438
				       end
				    false => 
				       let
					  val x_13435: bool = 
					     false
				       in
					  x_13435
				       end
				 val x_13439: word32 = 
				    case x_13434 of
				    true => 
				       let
					  val x_13440: word32 = 
					     raise x_8290
				       in
					  x_13440
				       end
				    false => 
				       let
				       in
					  x_13430
				       end
				 val x_13441: word32 = 
				    Posix_FileSys_Stat_getUId ()
				 val x_13442: word32 = 
				    Posix_FileSys_Stat_getGId ()
				 val x_13443: word64 = 
				    Posix_FileSys_Stat_getSize ()
				 val x_13444: word64 = 
				    Posix_FileSys_Stat_getATime ()
				 val x_13445: Time.time_0 = 
				    x_13341 x_13444
				 val x_13446: word64 = 
				    Posix_FileSys_Stat_getMTime ()
				 val x_13447: Time.time_0 = 
				    x_13341 x_13446
				 val x_13448: word64 = 
				    Posix_FileSys_Stat_getCTime ()
				 val x_13449: Time.time_0 = 
				    x_13341 x_13448
				 val x_13450: Time.time_0
					      * Time.time_0
					      * word64
					      * word32
					      * word64
					      * word32
					      * Time.time_0
					      * word32
					      * word64
					      * word32 = 
				    (x_13445,
				     x_13449,
				     x_13423,
				     x_13442,
				     x_13424,
				     x_13425,
				     x_13447,
				     x_13439,
				     x_13443,
				     x_13441)
				 val x_13451: PosixFileSys.ST.stat_0 = 
				    T_3 x_13450
			      in
				 x_13451
			      end
			   val x_13452: list_8 = 
			      nil_8
			   val x_13453: list_8
					* (word32 -> PosixFileSys.ST.stat_0)
					* word32 = 
			      (x_13452, x_13421, x_13420)
			in
			   x_13453
			end
			handle x_13454 => let
					     val x_13455: unit = 
						()
					     val x_13456: unit = 
						atomicEnd_0 x_13455
					     val x_13457: list_8
							  * (word32
							     -> PosixFileSys.ST.stat_0)
							  * word32 = 
						raise x_13454
					  in
					     x_13457
					  end
		     val return_0: word32 = 
			#2 x_13419
		     val post_0: word32 -> PosixFileSys.ST.stat_0 = 
			#1 x_13419
		     val handlers_0: list_8 = 
			#0 x_13419
		     val return_1: word32 = 
			x_8661 return_0
		     val x_13458: word32 * word32 = 
			(x_13416, return_1)
		     val x_13459: bool = 
			x_8367 x_13458
		     val x_13460: PosixFileSys.ST.stat_0 = 
			case x_13459 of
			true => 
			   let
			      val x_13474: word32 = 
				 Posix_Error_getErrno ()
			      val e_0: word32 = 
				 fromRep_1 x_13474
			      val x_13475: unit = 
				 ()
			      val x_13476: unit = 
				 atomicEnd_0 x_13475
			      val rec 
				 loop_25: list_8 -> Primitive.Option.t_20 = 
				    fn x_13477: list_8 => 
				    let
				       val x_13478: Primitive.Option.t_20 = 
					  case x_13477 of
					  nil_8 => 
					     let
						val x_13488: Primitive.Option.t_20 = 
						   NONE_18
					     in
						x_13488
					     end
					  ::_8 x_13479: (word32
							 * (unit
							    -> PosixFileSys.ST.stat_0))
							* list_8 => 
					     let
						val x_13480: list_8 = 
						   #1 x_13479
						val x_13481: word32
							     * (unit
								-> PosixFileSys.ST.stat_0) = 
						   #0 x_13479
						val x_13482: word32 = 
						   #0 x_13481
						val x_13483: word32 * word32 = 
						   (e_0, x_13482)
						val x_13484: bool = 
						   x_8367 x_13483
						val x_13485: Primitive.Option.t_20 = 
						   case x_13484 of
						   true => 
						      let
							 val x_13487: Primitive.Option.t_20 = 
							    SOME_20 x_13481
						      in
							 x_13487
						      end
						   false => 
						      let
							 val x_13486: Primitive.Option.t_20 = 
							    loop_25 x_13480
						      in
							 x_13486
						      end
					     in
						x_13485
					     end
				    in
				       x_13478
				    end
			      val x_13489: Primitive.Option.t_20 = 
				 loop_25 handlers_0
			      val x_13490: PosixFileSys.ST.stat_0 = 
				 case x_13489 of
				 NONE_18 => 
				    let
				       val x_13495: word8 vector = 
					  errorMsg_0 e_0
				       val x_13496: Primitive.Option.t_0 = 
					  SOME_0 e_0
				       val x_13497: word8 vector
						    * Primitive.Option.t_0 = 
					  (x_13495, x_13496)
				       val x_13498: unit ref
						    * (word8 vector
						       * Primitive.Option.t_0) = 
					  (x_11324, x_13497)
				       val x_13499: exn = 
					  SysErr_0 x_13498
				       val x_13500: PosixFileSys.ST.stat_0 = 
					  raise x_13499
				    in
				       x_13500
				    end
				 SOME_20 x_13491: word32
						  * (unit
						     -> PosixFileSys.ST.stat_0) => 
				    let
				       val x_13492: unit
						    -> PosixFileSys.ST.stat_0 = 
					  #1 x_13491
				       val x_13493: unit = 
					  ()
				       val x_13494: PosixFileSys.ST.stat_0 = 
					  x_13492 x_13493
				    in
				       x_13494
				    end
			   in
			      x_13490
			   end
			false => 
			   let
			      val x_13461: DynamicWind.try.t_3 = 
				 let
				    val x_13462: PosixFileSys.ST.stat_0 = 
				       post_0 return_1
				    val x_13463: DynamicWind.try.t_3 = 
				       A_3 x_13462
				 in
				    x_13463
				 end
				 handle x_13464 => let
						      val x_13465: DynamicWind.try.t_3 = 
							 E_3 x_13464
						   in
						      x_13465
						   end
			      val x_13466: PosixFileSys.ST.stat_0 = 
				 case x_13461 of
				 A_3 x_13471: PosixFileSys.ST.stat_0 => 
				    let
				       val x_13472: unit = 
					  ()
				       val x_13473: unit = 
					  atomicEnd_0 x_13472
				    in
				       x_13471
				    end
				 E_3 x_13467: exn => 
				    let
				       val x_13468: unit = 
					  ()
				       val x_13469: unit = 
					  atomicEnd_0 x_13468
				       val x_13470: PosixFileSys.ST.stat_0 = 
					  raise x_13467
				    in
				       x_13470
				    end
			   in
			      x_13466
			   end
		  in
		     x_13460
		  end
	       val rec 
		  setfl_0: word32 * word32 -> unit = 
		     fn x_13501: word32 * word32 => 
		     let
			val flags_0: word32 = 
			   #1 x_13501
			val fd_0: word32 = 
			   #0 x_13501
			val x_13502: unit -> word32 = 
			   fn x_13503: unit => 
			   let
			      val x_13504: word32 = 
				 toRep_1 fd_0
			      val x_13505: word32 = 
				 Posix_IO_fcntl3 (x_13504, F_SETFL_0, flags_0)
			   in
			      x_13505
			   end
			val x_13506: word32 = 
			   0xFFFFFFFF
			val x_13507: word32 = 
			   sextdFromInt32ToInt32_0 x_13506
			val rec 
			   errUnblocked_0: word32 * list_10 -> word32 = 
			      fn x_13508: word32 * list_10 => 
			      let
				 val handlers_1: list_10 = 
				    #1 x_13508
				 val errno_0: word32 = 
				    #0 x_13508
				 val rec 
				    loop_26: list_10 -> Primitive.Option.t_19 = 
				       fn x_13509: list_10 => 
				       let
					  val x_13510: Primitive.Option.t_19 = 
					     case x_13509 of
					     nil_10 => 
						let
						   val x_13520: Primitive.Option.t_19 = 
						      NONE_17
						in
						   x_13520
						end
					     ::_10 x_13511: (word32
							     * (unit -> word32))
							    * list_10 => 
						let
						   val x_13512: list_10 = 
						      #1 x_13511
						   val x_13513: word32
								* (unit
								   -> word32) = 
						      #0 x_13511
						   val x_13514: word32 = 
						      #0 x_13513
						   val x_13515: word32 * word32 = 
						      (errno_0, x_13514)
						   val x_13516: bool = 
						      x_8367 x_13515
						   val x_13517: Primitive.Option.t_19 = 
						      case x_13516 of
						      true => 
							 let
							    val x_13519: Primitive.Option.t_19 = 
							       SOME_19 x_13513
							 in
							    x_13519
							 end
						      false => 
							 let
							    val x_13518: Primitive.Option.t_19 = 
							       loop_26 x_13512
							 in
							    x_13518
							 end
						in
						   x_13517
						end
				       in
					  x_13510
				       end
				 val x_13521: Primitive.Option.t_19 = 
				    loop_26 handlers_1
				 val x_13522: word32 = 
				    case x_13521 of
				    NONE_17 => 
				       let
					  val x_13527: word32 * word32 = 
					     (errno_0, intr_0)
					  val x_13528: bool = 
					     x_8367 x_13527
					  val x_13529: bool = 
					     case x_13528 of
					     true => 
						let
						   val x_13531: bool = 
						      x_8321 restartFlag_0
						in
						   x_13531
						end
					     false => 
						let
						   val x_13530: bool = 
						      false
						in
						   x_13530
						end
					  val x_13532: word32 = 
					     case x_13529 of
					     true => 
						let
						   val x_13534: unit = 
						      ()
						   val x_13535: word32 = 
						      atomicState_0 x_13534
						   val x_13536: word32 = 
						      0x0
						   val x_13537: word32 * word32 = 
						      (x_13535, x_13536)
						   val x_13538: bool = 
						      x_8367 x_13537
						   val x_13539: word32 = 
						      case x_13538 of
						      true => 
							 let
							    val x_13604: unit = 
							       ()
							    val x_13605: unit = 
							       atomicBegin_0 x_13604
							    val x_13606: list_10
									 * (word32
									    -> word32)
									 * word32 = 
							       let
								  val x_13607: unit = 
								     ()
								  val return_5: word32 = 
								     x_13502 x_13607
								  val x_13608: word32
									       -> word32 = 
								     fn x_13609: word32 => 
								     let
								     in
									x_13609
								     end
								  val x_13610: list_10 = 
								     nil_10
								  val x_13611: list_10
									       * (word32
										  -> word32)
									       * word32 = 
								     (x_13610,
								      x_13608,
								      return_5)
							       in
								  x_13611
							       end
							       handle x_13612 => let
										    val x_13613: unit = 
										       ()
										    val x_13614: unit = 
										       atomicEnd_0 x_13613
										    val x_13615: list_10
												 * (word32
												    -> word32)
												 * word32 = 
										       raise x_13612
										 in
										    x_13615
										 end
							    val return_6: word32 = 
							       #2 x_13606
							    val post_2: word32
									-> word32 = 
							       #1 x_13606
							    val handlers_3: list_10 = 
							       #0 x_13606
							    val return_7: word32 = 
							       x_8661 return_6
							    val x_13616: word32
									 * word32 = 
							       (x_13507,
								return_7)
							    val x_13617: bool = 
							       x_8367 x_13616
							    val x_13618: word32 = 
							       case x_13617 of
							       true => 
								  let
								     val x_13632: word32 = 
									Posix_Error_getErrno ()
								     val e_2: word32 = 
									fromRep_1 x_13632
								     val x_13633: unit = 
									()
								     val x_13634: unit = 
									atomicEnd_0 x_13633
								     val x_13635: word32
										  * list_10 = 
									(e_2,
									 handlers_3)
								     val x_13636: word32 = 
									errUnblocked_0 x_13635
								  in
								     x_13636
								  end
							       false => 
								  let
								     val x_13619: DynamicWind.try.t_1 = 
									let
									   val x_13620: word32 = 
									      post_2 return_7
									   val x_13621: DynamicWind.try.t_1 = 
									      A_1 x_13620
									in
									   x_13621
									end
									handle x_13622 => let
											     val x_13623: DynamicWind.try.t_1 = 
												E_1 x_13622
											  in
											     x_13623
											  end
								     val x_13624: word32 = 
									case x_13619 of
									A_1 x_13629: word32 => 
									   let
									      val x_13630: unit = 
										 ()
									      val x_13631: unit = 
										 atomicEnd_0 x_13630
									   in
									      x_13629
									   end
									E_1 x_13625: exn => 
									   let
									      val x_13626: unit = 
										 ()
									      val x_13627: unit = 
										 atomicEnd_0 x_13626
									      val x_13628: word32 = 
										 raise x_13625
									   in
									      x_13628
									   end
								  in
								     x_13624
								  end
							 in
							    x_13618
							 end
						      false => 
							 let
							    val x_13540: unit
									 -> unit
									    -> unit = 
							       Ref_deref[unit
									 -> unit
									    -> unit] (blocker_0)
							    val x_13541: unit = 
							       ()
							    val finish_0: unit
									  -> unit = 
							       x_13540 x_13541
							    val x_13542: DynamicWind.try.t_1 = 
							       let
								  val x_13543: unit = 
								     ()
								  val x_13544: unit = 
								     atomicBegin_0 x_13543
								  val x_13545: list_10
									       * (word32
										  -> word32)
									       * word32 = 
								     let
									val x_13546: unit = 
									   ()
									val return_2: word32 = 
									   x_13502 x_13546
									val x_13547: word32
										     -> word32 = 
									   fn x_13548: word32 => 
									   let
									   in
									      x_13548
									   end
									val x_13549: list_10 = 
									   nil_10
									val x_13550: list_10
										     * (word32
											-> word32)
										     * word32 = 
									   (x_13549,
									    x_13547,
									    return_2)
								     in
									x_13550
								     end
								     handle x_13551 => let
											  val x_13552: unit = 
											     ()
											  val x_13553: unit = 
											     atomicEnd_0 x_13552
											  val x_13554: list_10
												       * (word32
													  -> word32)
												       * word32 = 
											     raise x_13551
										       in
											  x_13554
										       end
								  val return_3: word32 = 
								     #2 x_13545
								  val post_1: word32
									      -> word32 = 
								     #1 x_13545
								  val handlers_2: list_10 = 
								     #0 x_13545
								  val return_4: word32 = 
								     x_8661 return_3
								  val x_13555: word32
									       * word32 = 
								     (x_13507,
								      return_4)
								  val x_13556: bool = 
								     x_8367 x_13555
								  val x_13557: word32 = 
								     case x_13556 of
								     true => 
									let
									   val x_13571: word32 = 
									      Posix_Error_getErrno ()
									   val e_1: word32 = 
									      fromRep_1 x_13571
									   val x_13572: unit = 
									      ()
									   val x_13573: unit = 
									      atomicEnd_0 x_13572
									   val rec 
									      loop_27: list_10
										       -> Primitive.Option.t_19 = 
										 fn x_13574: list_10 => 
										 let
										    val x_13575: Primitive.Option.t_19 = 
										       case x_13574 of
										       nil_10 => 
											  let
											     val x_13585: Primitive.Option.t_19 = 
												NONE_17
											  in
											     x_13585
											  end
										       ::_10 x_13576: (word32
												       * (unit
													  -> word32))
												      * list_10 => 
											  let
											     val x_13577: list_10 = 
												#1 x_13576
											     val x_13578: word32
													  * (unit
													     -> word32) = 
												#0 x_13576
											     val x_13579: word32 = 
												#0 x_13578
											     val x_13580: word32
													  * word32 = 
												(e_1,
												 x_13579)
											     val x_13581: bool = 
												x_8367 x_13580
											     val x_13582: Primitive.Option.t_19 = 
												case x_13581 of
												true => 
												   let
												      val x_13584: Primitive.Option.t_19 = 
													 SOME_19 x_13578
												   in
												      x_13584
												   end
												false => 
												   let
												      val x_13583: Primitive.Option.t_19 = 
													 loop_27 x_13577
												   in
												      x_13583
												   end
											  in
											     x_13582
											  end
										 in
										    x_13575
										 end
									   val x_13586: Primitive.Option.t_19 = 
									      loop_27 handlers_2
									   val x_13587: word32 = 
									      case x_13586 of
									      NONE_17 => 
										 let
										    val x_13592: word32 = 
										       raiseSys_1 e_1
										 in
										    x_13592
										 end
									      SOME_19 x_13588: word32
											       * (unit
												  -> word32) => 
										 let
										    val x_13589: unit
												 -> word32 = 
										       #1 x_13588
										    val x_13590: unit = 
										       ()
										    val x_13591: word32 = 
										       x_13589 x_13590
										 in
										    x_13591
										 end
									in
									   x_13587
									end
								     false => 
									let
									   val x_13558: DynamicWind.try.t_1 = 
									      let
										 val x_13559: word32 = 
										    post_1 return_4
										 val x_13560: DynamicWind.try.t_1 = 
										    A_1 x_13559
									      in
										 x_13560
									      end
									      handle x_13561 => let
												   val x_13562: DynamicWind.try.t_1 = 
												      E_1 x_13561
												in
												   x_13562
												end
									   val x_13563: word32 = 
									      case x_13558 of
									      A_1 x_13568: word32 => 
										 let
										    val x_13569: unit = 
										       ()
										    val x_13570: unit = 
										       atomicEnd_0 x_13569
										 in
										    x_13568
										 end
									      E_1 x_13564: exn => 
										 let
										    val x_13565: unit = 
										       ()
										    val x_13566: unit = 
										       atomicEnd_0 x_13565
										    val x_13567: word32 = 
										       raise x_13564
										 in
										    x_13567
										 end
									in
									   x_13563
									end
								  val x_13593: DynamicWind.try.t_1 = 
								     A_1 x_13557
							       in
								  x_13593
							       end
							       handle x_13594 => let
										    val x_13595: DynamicWind.try.t_1 = 
										       E_1 x_13594
										 in
										    x_13595
										 end
							    val x_13596: word32 = 
							       case x_13542 of
							       A_1 x_13601: word32 => 
								  let
								     val x_13602: unit = 
									()
								     val x_13603: unit = 
									finish_0 x_13602
								  in
								     x_13601
								  end
							       E_1 x_13597: exn => 
								  let
								     val x_13598: unit = 
									()
								     val x_13599: unit = 
									finish_0 x_13598
								     val x_13600: word32 = 
									raise x_13597
								  in
								     x_13600
								  end
							 in
							    x_13596
							 end
						in
						   x_13539
						end
					     false => 
						let
						   val x_13533: word32 = 
						      raiseSys_1 errno_0
						in
						   x_13533
						end
				       in
					  x_13532
				       end
				    SOME_19 x_13523: word32 * (unit -> word32) => 
				       let
					  val x_13524: unit -> word32 = 
					     #1 x_13523
					  val x_13525: unit = 
					     ()
					  val x_13526: word32 = 
					     x_13524 x_13525
				       in
					  x_13526
				       end
			      in
				 x_13522
			      end
			val x_13637: unit = 
			   ()
			val x_13638: unit = 
			   atomicBegin_0 x_13637
			val x_13639: list_10 * (word32 -> word32) * word32 = 
			   let
			      val x_13640: unit = 
				 ()
			      val return_8: word32 = 
				 x_13502 x_13640
			      val x_13641: word32 -> word32 = 
				 fn x_13642: word32 => 
				 let
				 in
				    x_13642
				 end
			      val x_13643: list_10 = 
				 nil_10
			      val x_13644: list_10 * (word32 -> word32) * word32 = 
				 (x_13643, x_13641, return_8)
			   in
			      x_13644
			   end
			   handle x_13645 => let
						val x_13646: unit = 
						   ()
						val x_13647: unit = 
						   atomicEnd_0 x_13646
						val x_13648: list_10
							     * (word32 -> word32)
							     * word32 = 
						   raise x_13645
					     in
						x_13648
					     end
			val return_9: word32 = 
			   #2 x_13639
			val post_3: word32 -> word32 = 
			   #1 x_13639
			val handlers_4: list_10 = 
			   #0 x_13639
			val return_10: word32 = 
			   x_8661 return_9
			val x_13649: word32 * word32 = 
			   (x_13507, return_10)
			val x_13650: bool = 
			   x_8367 x_13649
			val x_13651: word32 = 
			   case x_13650 of
			   true => 
			      let
				 val x_13665: word32 = 
				    Posix_Error_getErrno ()
				 val e_3: word32 = 
				    fromRep_1 x_13665
				 val x_13666: unit = 
				    ()
				 val x_13667: unit = 
				    atomicEnd_0 x_13666
				 val x_13668: word32 * list_10 = 
				    (e_3, handlers_4)
				 val x_13669: word32 = 
				    errUnblocked_0 x_13668
			      in
				 x_13669
			      end
			   false => 
			      let
				 val x_13652: DynamicWind.try.t_1 = 
				    let
				       val x_13653: word32 = 
					  post_3 return_10
				       val x_13654: DynamicWind.try.t_1 = 
					  A_1 x_13653
				    in
				       x_13654
				    end
				    handle x_13655 => let
							 val x_13656: DynamicWind.try.t_1 = 
							    E_1 x_13655
						      in
							 x_13656
						      end
				 val x_13657: word32 = 
				    case x_13652 of
				    A_1 x_13662: word32 => 
				       let
					  val x_13663: unit = 
					     ()
					  val x_13664: unit = 
					     atomicEnd_0 x_13663
				       in
					  x_13662
				       end
				    E_1 x_13658: exn => 
				       let
					  val x_13659: unit = 
					     ()
					  val x_13660: unit = 
					     atomicEnd_0 x_13659
					  val x_13661: word32 = 
					     raise x_13658
				       in
					  x_13661
				       end
			      in
				 x_13657
			      end
			val x_13670: unit = 
			   ()
		     in
			x_13670
		     end
	       val rec 
		  lseek_0: word32 * word64 * PosixIO.whence_0 -> word64 = 
		     fn x_13671: word32 * word64 * PosixIO.whence_0 => 
		     let
			val w_11: PosixIO.whence_0 = 
			   #2 x_13671
			val n_20: word64 = 
			   #1 x_13671
			val fd_1: word32 = 
			   #0 x_13671
			val x_13672: word32 = 
			   0xFFFFFFFF
			val x_13673: word64 = 
			   sextdFromInt32ToInt64_0 x_13672
			val x_13674: unit = 
			   ()
			val x_13675: unit = 
			   atomicBegin_0 x_13674
			val x_13676: list_9 * (word64 -> word64) * word64 = 
			   let
			      val x_13677: word32 = 
				 toRep_1 fd_1
			      val x_13678: word32 = 
				 case w_11 of
				 SEEK_SET_0 => 
				    let
				    in
				       SEEK_SET_1
				    end
				 SEEK_END_0 => 
				    let
				    in
				       SEEK_END_1
				    end
				 SEEK_CUR_0 => 
				    let
				    in
				       SEEK_CUR_1
				    end
			      val x_13679: word64 = 
				 Posix_IO_lseek (x_13677, n_20, x_13678)
			      val x_13680: word64 -> word64 = 
				 fn x_13681: word64 => 
				 let
				 in
				    x_13681
				 end
			      val x_13682: list_9 = 
				 nil_9
			      val x_13683: list_9 * (word64 -> word64) * word64 = 
				 (x_13682, x_13680, x_13679)
			   in
			      x_13683
			   end
			   handle x_13684 => let
						val x_13685: unit = 
						   ()
						val x_13686: unit = 
						   atomicEnd_0 x_13685
						val x_13687: list_9
							     * (word64 -> word64)
							     * word64 = 
						   raise x_13684
					     in
						x_13687
					     end
			val return_11: word64 = 
			   #2 x_13676
			val post_4: word64 -> word64 = 
			   #1 x_13676
			val handlers_5: list_9 = 
			   #0 x_13676
			val x_13688: word64 * word64 = 
			   (x_13673, return_11)
			val x_13689: bool = 
			   x_8372 x_13688
			val x_13690: word64 = 
			   case x_13689 of
			   true => 
			      let
				 val x_13704: word32 = 
				    Posix_Error_getErrno ()
				 val e_4: word32 = 
				    fromRep_1 x_13704
				 val x_13705: unit = 
				    ()
				 val x_13706: unit = 
				    atomicEnd_0 x_13705
				 val rec 
				    loop_28: list_9 -> Primitive.Option.t_21 = 
				       fn x_13707: list_9 => 
				       let
					  val x_13708: Primitive.Option.t_21 = 
					     case x_13707 of
					     nil_9 => 
						let
						   val x_13718: Primitive.Option.t_21 = 
						      NONE_19
						in
						   x_13718
						end
					     ::_9 x_13709: (word32
							    * (unit -> word64))
							   * list_9 => 
						let
						   val x_13710: list_9 = 
						      #1 x_13709
						   val x_13711: word32
								* (unit
								   -> word64) = 
						      #0 x_13709
						   val x_13712: word32 = 
						      #0 x_13711
						   val x_13713: word32 * word32 = 
						      (e_4, x_13712)
						   val x_13714: bool = 
						      x_8367 x_13713
						   val x_13715: Primitive.Option.t_21 = 
						      case x_13714 of
						      true => 
							 let
							    val x_13717: Primitive.Option.t_21 = 
							       SOME_21 x_13711
							 in
							    x_13717
							 end
						      false => 
							 let
							    val x_13716: Primitive.Option.t_21 = 
							       loop_28 x_13710
							 in
							    x_13716
							 end
						in
						   x_13715
						end
				       in
					  x_13708
				       end
				 val x_13719: Primitive.Option.t_21 = 
				    loop_28 handlers_5
				 val x_13720: word64 = 
				    case x_13719 of
				    NONE_19 => 
				       let
					  val x_13725: word64 = 
					     raiseSys_2 e_4
				       in
					  x_13725
				       end
				    SOME_21 x_13721: word32 * (unit -> word64) => 
				       let
					  val x_13722: unit -> word64 = 
					     #1 x_13721
					  val x_13723: unit = 
					     ()
					  val x_13724: word64 = 
					     x_13722 x_13723
				       in
					  x_13724
				       end
			      in
				 x_13720
			      end
			   false => 
			      let
				 val x_13691: DynamicWind.try.t_2 = 
				    let
				       val x_13692: word64 = 
					  post_4 return_11
				       val x_13693: DynamicWind.try.t_2 = 
					  A_2 x_13692
				    in
				       x_13693
				    end
				    handle x_13694 => let
							 val x_13695: DynamicWind.try.t_2 = 
							    E_2 x_13694
						      in
							 x_13695
						      end
				 val x_13696: word64 = 
				    case x_13691 of
				    A_2 x_13701: word64 => 
				       let
					  val x_13702: unit = 
					     ()
					  val x_13703: unit = 
					     atomicEnd_0 x_13702
				       in
					  x_13701
				       end
				    E_2 x_13697: exn => 
				       let
					  val x_13698: unit = 
					     ()
					  val x_13699: unit = 
					     atomicEnd_0 x_13698
					  val x_13700: word64 = 
					     raise x_13697
				       in
					  x_13700
				       end
			      in
				 x_13696
			      end
		     in
			x_13690
		     end
	       val x_13726: word32 = 
		  0x0
	       val pos0_0: word64 = 
		  sextdFromInt32ToInt64_0 x_13726
	       val chunkSize_0: word32 = 
		  sextdFromInt32ToInt32_0 bufSize_0
	       val someElem_0: word8 = 
		  0x0
	       val rec 
		  liftExn_0: word8 vector -> word8 vector -> exn -> unit = 
		     fn x_13727: word8 vector => 
		     let
			val x_13728: word8 vector -> exn -> unit = 
			   fn x_13729: word8 vector => 
			   let
			      val x_13730: exn -> unit = 
				 fn x_13731: exn => 
				 let
				    val x_13732: exn
						 * word8 vector
						 * word8 vector = 
				       (x_13731, x_13729, x_13727)
				    val x_13733: unit ref
						 * (exn
						    * word8 vector
						    * word8 vector) = 
				       (x_13300, x_13732)
				    val x_13734: exn = 
				       Io_0 x_13733
				    val x_13735: unit = 
				       raise x_13734
				 in
				    x_13735
				 end
			   in
			      x_13730
			   end
		     in
			x_13728
		     end
	       val rec 
		  terminated_0: StreamIOExtra.state_0 -> bool = 
		     fn x_13736: StreamIOExtra.state_0 => 
		     let
			val x_13737: bool = 
			   case x_13736 of
			   Active_0 => 
			      let
				 val x_13738: bool = 
				    true
			      in
				 x_13738
			      end
			     _ => let
				     val x_13739: bool = 
					false
				  in
				     x_13739
				  end
			val x_13740: bool = 
			   not_0 x_13737
		     in
			x_13740
		     end
	       val rec 
		  outstreamWriter_0: StreamIOExtra.outstream_0
				     -> PrimIO.writer_0 = 
		     fn x_13741: StreamIOExtra.outstream_0 => 
		     let
			val x_13742: PrimIO.writer_0 = 
			   case x_13741 of
			   Out_0 x_13743: PrimIO.writer_0
					  * StreamIOExtra.bufferMode_0 ref
					  * StreamIOExtra.state_0 ref
					  * PrimIO.writer_0 => 
			      let
				 val x_13744: PrimIO.writer_0 = 
				    #3 x_13743
			      in
				 x_13744
			      end
		     in
			x_13742
		     end
	       val rec 
		  outstreamName_0: StreamIOExtra.outstream_0 -> word8 vector = 
		     fn x_13745: StreamIOExtra.outstream_0 => 
		     let
			val x_13746: PrimIO.writer_0 = 
			   outstreamWriter_0 x_13745
			val x_13747: word8 vector = 
			   case x_13746 of
			   WR_0 x_13748: Primitive.Option.t_7
					 * Primitive.Option.t_8
					 * word32
					 * (unit -> unit)
					 * Primitive.Option.t_9
					 * Primitive.Option.t_9
					 * Primitive.Option.t_0
					 * word8 vector
					 * Primitive.Option.t_14
					 * Primitive.Option.t_9
					 * Primitive.Option.t_10
					 * Primitive.Option.t_11
					 * Primitive.Option.t_15
					 * Primitive.Option.t_16 => 
			      let
				 val x_13749: word8 vector = 
				    #7 x_13748
			      in
				 x_13749
			      end
		     in
			x_13747
		     end
	       val rec 
		  flushBuf_0: PrimIO.writer_0 * StreamIOExtra.buf_0 -> unit = 
		     fn x_13750: PrimIO.writer_0 * StreamIOExtra.buf_0 => 
		     let
			val x_13751: StreamIOExtra.buf_0 = 
			   #1 x_13750
			val x_13752: PrimIO.writer_0 = 
			   #0 x_13750
			val x_13753: unit = 
			   case x_13751 of
			   Buf_0 x_13754: word8 array * word32 ref => 
			      let
				 val x_13755: word32 ref = 
				    #1 x_13754
				 val x_13756: word8 array = 
				    #0 x_13754
				 val size'_0: word32 = 
				    x_8306 x_13755
				 val x_13757: word32 = 
				    0x0
				 val x_13758: word32 ref * word32 = 
				    (x_13755, x_13757)
				 val x_13759: unit = 
				    x_8337 x_13758
				 val x_13760: word32 = 
				    0x0
				 val x_13761: Primitive.Option.t_0 = 
				    SOME_0 size'_0
				 val x_13762: word8 array
					      * word32
					      * Primitive.Option.t_0 = 
				    (x_13756, x_13760, x_13761)
				 val x_13763: PrimSequence.Slice.t_0 = 
				    slice_8 x_13762
				 val x_13764: Primitive.Option.t_10 = 
				    case x_13752 of
				    WR_0 x_13765: Primitive.Option.t_7
						  * Primitive.Option.t_8
						  * word32
						  * (unit -> unit)
						  * Primitive.Option.t_9
						  * Primitive.Option.t_9
						  * Primitive.Option.t_0
						  * word8 vector
						  * Primitive.Option.t_14
						  * Primitive.Option.t_9
						  * Primitive.Option.t_10
						  * Primitive.Option.t_11
						  * Primitive.Option.t_15
						  * Primitive.Option.t_16 => 
				       let
					  val x_13766: Primitive.Option.t_10 = 
					     #10 x_13765
				       in
					  x_13766
				       end
				 val x_13767: unit = 
				    case x_13764 of
				    NONE_10 => 
				       let
					  val x_13793: unit = 
					     raise x_13295
				       in
					  x_13793
				       end
				    SOME_10 x_13768: PrimSequence.Slice.t_0
						     -> word32 => 
				       let
					  val x_13769: word8 array
						       * word32
						       * word32 = 
					     base_13 x_13763
					  val sz_0: word32 = 
					     #2 x_13769
					  val i_37: word32 = 
					     #1 x_13769
					  val b_44: word8 array = 
					     #0 x_13769
					  val x_13770: word32 * word32 = 
					     (i_37, sz_0)
					  val max_0: word32 = 
					     x_8508 x_13770
					  val rec 
					     loop_29: word32 -> unit = 
						fn x_13771: word32 => 
						let
						   val x_13772: word32 * word32 = 
						      (x_13771, max_0)
						   val x_13773: bool = 
						      x_8367 x_13772
						   val x_13774: unit = 
						      case x_13773 of
						      true => 
							 let
							    val x_13791: unit = 
							       ()
							 in
							    x_13791
							 end
						      false => 
							 let
							    val x_13775: word32
									 * word32 = 
							       (max_0, x_13771)
							    val x_13776: word32 = 
							       x_8548 x_13775
							    val x_13777: Primitive.Option.t_0 = 
							       SOME_0 x_13776
							    val x_13778: word8 array
									 * word32
									 * Primitive.Option.t_0 = 
							       (b_44,
								x_13771,
								x_13777)
							    val x_13779: PrimSequence.Slice.t_0 = 
							       slice_8 x_13778
							    val j_0: word32 = 
							       x_13768 x_13779
							    val x_13780: word32 = 
							       0x0
							    val x_13781: word32
									 * word32 = 
							       (j_0, x_13780)
							    val x_13782: bool = 
							       x_8367 x_13781
							    val x_13783: unit = 
							       case x_13782 of
							       true => 
								  let
								     val x_13787: word8 vector = 
									"partial write"
								     val x_13788: unit ref
										  * word8 vector = 
									(x_9554,
									 x_13787)
								     val x_13789: exn = 
									Fail_0 x_13788
								     val x_13790: unit = 
									raise x_13789
								  in
								     x_13790
								  end
							       false => 
								  let
								     val x_13784: word32
										  * word32 = 
									(x_13771,
									 j_0)
								     val x_13785: word32 = 
									x_8508 x_13784
								     val x_13786: unit = 
									loop_29 x_13785
								  in
								     x_13786
								  end
							 in
							    x_13783
							 end
						in
						   x_13774
						end
					  val x_13792: unit = 
					     loop_29 i_37
				       in
					  x_13792
				       end
			      in
				 x_13767
			      end
		     in
			x_13753
		     end
	       val rec 
		  flushOut_0: StreamIOExtra.outstream_0 -> unit = 
		     fn x_13794: StreamIOExtra.outstream_0 => 
		     let
			val x_13795: unit = 
			   case x_13794 of
			   Out_0 x_13796: PrimIO.writer_0
					  * StreamIOExtra.bufferMode_0 ref
					  * StreamIOExtra.state_0 ref
					  * PrimIO.writer_0 => 
			      let
				 val x_13797: StreamIOExtra.state_0 ref = 
				    #2 x_13796
				 val x_13798: StreamIOExtra.bufferMode_0 ref = 
				    #1 x_13796
				 val x_13799: PrimIO.writer_0 = 
				    #0 x_13796
				 val x_13800: StreamIOExtra.state_0 = 
				    x_8300 x_13797
				 val x_13801: bool = 
				    terminated_0 x_13800
				 val x_13802: unit = 
				    case x_13801 of
				    true => 
				       let
					  val x_13819: unit = 
					     ()
				       in
					  x_13819
				       end
				    false => 
				       let
					  val x_13803: StreamIOExtra.bufferMode_0 = 
					     x_8315 x_13798
					  val x_13804: unit = 
					     case x_13803 of
					     NO_BUF_1 => 
						let
						   val x_13818: unit = 
						      ()
						in
						   x_13818
						end
					     BLOCK_BUF_1 x_13808: StreamIOExtra.buf_0 => 
						let
						   val x_13809: unit = 
						      let
							 val x_13810: PrimIO.writer_0
								      * StreamIOExtra.buf_0 = 
							    (x_13799, x_13808)
							 val x_13811: unit = 
							    flushBuf_0 x_13810
						      in
							 x_13811
						      end
						      handle x_13812 => let
									   val x_13813: word8 vector = 
									      outstreamName_0 x_13794
									   val x_13814: word8 vector
											-> exn
											   -> unit = 
									      liftExn_0 x_13813
									   val x_13815: word8 vector = 
									      "flushOut"
									   val x_13816: exn
											-> unit = 
									      x_13814 x_13815
									   val x_13817: unit = 
									      x_13816 x_13812
									in
									   x_13817
									end
						in
						   x_13809
						end
					     LINE_BUF_1 x_13805: StreamIOExtra.buf_0 => 
						let
						   val x_13806: PrimIO.writer_0
								* StreamIOExtra.buf_0 = 
						      (x_13799, x_13805)
						   val x_13807: unit = 
						      flushBuf_0 x_13806
						in
						   x_13807
						end
				       in
					  x_13804
				       end
			      in
				 x_13802
			      end
		     in
			x_13795
		     end
	       val x_13820: list_5 = 
		  nil_5
	       val openOutstreams_0: list_5 ref = 
		  Ref_ref[list_5] (x_13820)
	       val x_13821: unit -> unit = 
		  fn x_13822: unit => 
		  let
		     val x_13823: unit = 
			()
		     val x_13824: list_5 = 
			x_8303 openOutstreams_0
		     val rec 
			loop_30: list_5 * unit -> unit = 
			   fn x_13825: list_5 * unit => 
			   let
			      val b_45: unit = 
				 #1 x_13825
			      val l_4: list_5 = 
				 #0 x_13825
			      val x_13826: unit = 
				 case l_4 of
				 nil_5 => 
				    let
				    in
				       b_45
				    end
				 ::_5 x_13827: (StreamIOExtra.outstream_0 * bool)
					       * list_5 => 
				    let
				       val x_13828: list_5 = 
					  #1 x_13827
				       val x_13829: StreamIOExtra.outstream_0
						    * bool = 
					  #0 x_13827
				       val close_0: bool = 
					  #1 x_13829
				       val os_0: StreamIOExtra.outstream_0 = 
					  #0 x_13829
				       val x_13830: unit = 
					  case close_0 of
					  true => 
					     let
						val x_13832: unit = 
						   case os_0 of
						   Out_0 x_13833: PrimIO.writer_0
								  * StreamIOExtra.bufferMode_0 ref
								  * StreamIOExtra.state_0 ref
								  * PrimIO.writer_0 => 
						      let
							 val x_13834: StreamIOExtra.state_0 ref = 
							    #2 x_13833
							 val x_13835: StreamIOExtra.state_0 = 
							    x_8300 x_13834
							 val x_13836: bool = 
							    case x_13835 of
							    Closed_0 => 
							       let
								  val x_13837: bool = 
								     true
							       in
								  x_13837
							       end
							      _ => let
								      val x_13838: bool = 
									 false
								   in
								      x_13838
								   end
							 val x_13839: unit = 
							    case x_13836 of
							    true => 
							       let
								  val x_13878: unit = 
								     ()
							       in
								  x_13878
							       end
							    false => 
							       let
								  val x_13840: unit = 
								     let
									val x_13841: unit = 
									   flushOut_0 os_0
									val x_13842: StreamIOExtra.state_0 = 
									   x_8300 x_13834
									val x_13843: bool = 
									   terminated_0 x_13842
									val x_13844: unit = 
									   case x_13843 of
									   true => 
									      let
										 val x_13851: unit = 
										    ()
									      in
										 x_13851
									      end
									   false => 
									      let
										 val x_13845: PrimIO.writer_0 = 
										    outstreamWriter_0 os_0
										 val x_13846: unit
											      -> unit = 
										    case x_13845 of
										    WR_0 x_13847: Primitive.Option.t_7
												  * Primitive.Option.t_8
												  * word32
												  * (unit
												     -> unit)
												  * Primitive.Option.t_9
												  * Primitive.Option.t_9
												  * Primitive.Option.t_0
												  * word8 vector
												  * Primitive.Option.t_14
												  * Primitive.Option.t_9
												  * Primitive.Option.t_10
												  * Primitive.Option.t_11
												  * Primitive.Option.t_15
												  * Primitive.Option.t_16 => 
										       let
											  val x_13848: unit
												       -> unit = 
											     #3 x_13847
										       in
											  x_13848
										       end
										 val x_13849: unit = 
										    ()
										 val x_13850: unit = 
										    x_13846 x_13849
									      in
										 x_13850
									      end
									val x_13852: StreamIOExtra.state_0 = 
									   Closed_0
									val x_13853: unit = 
									   Ref_assign[StreamIOExtra.state_0] (x_13834,
													      x_13852)
									val x_13854: unit = 
									   case os_0 of
									   Out_0 x_13855: PrimIO.writer_0
											  * StreamIOExtra.bufferMode_0 ref
											  * StreamIOExtra.state_0 ref
											  * PrimIO.writer_0 => 
									      let
										 val x_13856: StreamIOExtra.bufferMode_0 ref = 
										    #1 x_13855
										 val rec 
										    doit_0: StreamIOExtra.buf_0
											    -> unit = 
										       fn x_13857: StreamIOExtra.buf_0 => 
										       let
											  val x_13858: unit = 
											     case x_13857 of
											     Buf_0 x_13859: word8 array
													    * word32 ref => 
												let
												   val x_13860: word32 ref = 
												      #1 x_13859
												   val x_13861: word8 array = 
												      #0 x_13859
												   val x_13862: word32 = 
												      length_18 x_13861
												   val x_13863: word32 ref
														* word32 = 
												      (x_13860,
												       x_13862)
												   val x_13864: unit = 
												      x_8337 x_13863
												in
												   x_13864
												end
										       in
											  x_13858
										       end
										 val x_13865: StreamIOExtra.bufferMode_0 = 
										    x_8315 x_13856
										 val x_13866: unit = 
										    case x_13865 of
										    BLOCK_BUF_1 x_13870: StreamIOExtra.buf_0 => 
										       let
											  val x_13871: unit = 
											     doit_0 x_13870
										       in
											  x_13871
										       end
										    NO_BUF_1 => 
										       let
											  val x_13869: unit = 
											     ()
										       in
											  x_13869
										       end
										    LINE_BUF_1 x_13867: StreamIOExtra.buf_0 => 
										       let
											  val x_13868: unit = 
											     doit_0 x_13867
										       in
											  x_13868
										       end
									      in
										 x_13866
									      end
								     in
									x_13854
								     end
								     handle x_13872 => let
											  val x_13873: word8 vector = 
											     outstreamName_0 os_0
											  val x_13874: word8 vector
												       -> exn
													  -> unit = 
											     liftExn_0 x_13873
											  val x_13875: word8 vector = 
											     "closeOut"
											  val x_13876: exn
												       -> unit = 
											     x_13874 x_13875
											  val x_13877: unit = 
											     x_13876 x_13872
										       in
											  x_13877
										       end
							       in
								  x_13840
							       end
						      in
							 x_13839
						      end
					     in
						x_13832
					     end
					  false => 
					     let
						val x_13831: unit = 
						   flushOut_0 os_0
					     in
						x_13831
					     end
				       val x_13879: list_5 * unit = 
					  (x_13828, x_13830)
				       val x_13880: unit = 
					  loop_30 x_13879
				    in
				       x_13880
				    end
			   in
			      x_13826
			   end
		     val x_13881: list_5 * unit = 
			(x_13824, x_13823)
		     val x_13882: unit = 
			loop_30 x_13881
		  in
		     x_13882
		  end
	       val x_13883: list_2 = 
		  x_8297 atExit_0
	       val x_13884: (unit -> unit) * list_2 = 
		  (x_13821, x_13883)
	       val x_13885: list_2 = 
		  ::_2 x_13884
	       val x_13886: unit = 
		  Ref_assign[list_2] (atExit_0, x_13885)
	       val rec 
		  get_0: ImperativeIOExtra.Outstream.t_0
			 -> StreamIOExtra.outstream_0 = 
		     fn x_13887: ImperativeIOExtra.Outstream.t_0 => 
		     let
			val x_13888: StreamIOExtra.outstream_0 = 
			   case x_13887 of
			   T_6 x_13889: StreamIOExtra.outstream_0 ref => 
			      let
				 val x_13890: StreamIOExtra.outstream_0 = 
				    Ref_deref[StreamIOExtra.outstream_0] (x_13889)
			      in
				 x_13890
			      end
		     in
			x_13888
		     end
	       val rec 
		  output_0: ImperativeIOExtra.Outstream.t_0 * word8 vector
			    -> unit = 
		     fn x_13891: ImperativeIOExtra.Outstream.t_0 * word8 vector => 
		     let
			val v_0: word8 vector = 
			   #1 x_13891
			val os_1: ImperativeIOExtra.Outstream.t_0 = 
			   #0 x_13891
			val x_13892: StreamIOExtra.outstream_0 = 
			   get_0 os_1
			val x_13893: unit = 
			   case x_13892 of
			   Out_0 x_13894: PrimIO.writer_0
					  * StreamIOExtra.bufferMode_0 ref
					  * StreamIOExtra.state_0 ref
					  * PrimIO.writer_0 => 
			      let
				 val x_13895: StreamIOExtra.state_0 ref = 
				    #2 x_13894
				 val x_13896: StreamIOExtra.bufferMode_0 ref = 
				    #1 x_13894
				 val x_13897: PrimIO.writer_0 = 
				    #0 x_13894
				 val x_13898: StreamIOExtra.state_0 = 
				    x_8300 x_13895
				 val x_13899: bool = 
				    terminated_0 x_13898
				 val x_13900: unit = 
				    case x_13899 of
				    true => 
				       let
					  val x_14189: word8 vector = 
					     outstreamName_0 x_13892
					  val x_14190: word8 vector
						       -> exn -> unit = 
					     liftExn_0 x_14189
					  val x_14191: word8 vector = 
					     "output"
					  val x_14192: exn -> unit = 
					     x_14190 x_14191
					  val x_14193: unit = 
					     x_14192 x_13298
				       in
					  x_14193
				       end
				    false => 
				       let
					  val x_13901: unit = 
					     let
						val rec 
						   put_0: unit -> unit = 
						      fn x_13902: unit => 
						      let
							 val x_13903: PrimSequence.Slice.t_1 = 
							    full_10 v_0
							 val x_13904: Primitive.Option.t_15 = 
							    case x_13897 of
							    WR_0 x_13905: Primitive.Option.t_7
									  * Primitive.Option.t_8
									  * word32
									  * (unit
									     -> unit)
									  * Primitive.Option.t_9
									  * Primitive.Option.t_9
									  * Primitive.Option.t_0
									  * word8 vector
									  * Primitive.Option.t_14
									  * Primitive.Option.t_9
									  * Primitive.Option.t_10
									  * Primitive.Option.t_11
									  * Primitive.Option.t_15
									  * Primitive.Option.t_16 => 
							       let
								  val x_13906: Primitive.Option.t_15 = 
								     #12 x_13905
							       in
								  x_13906
							       end
							 val x_13907: unit = 
							    case x_13904 of
							    NONE_13 => 
							       let
								  val x_13965: unit = 
								     raise x_13295
							       in
								  x_13965
							       end
							    SOME_15 x_13908: PrimSequence.Slice.t_1
									     -> word32 => 
							       let
								  val x_13909: word8 vector
									       * word32
									       * word32 = 
								     base_12 x_13903
								  val sz_1: word32 = 
								     #2 x_13909
								  val i_38: word32 = 
								     #1 x_13909
								  val b_46: word8 vector = 
								     #0 x_13909
								  val x_13910: word32
									       * word32 = 
								     (i_38, sz_1)
								  val max_1: word32 = 
								     x_8508 x_13910
								  val rec 
								     loop_31: word32
									      -> unit = 
									fn x_13911: word32 => 
									let
									   val x_13912: word32
											* word32 = 
									      (x_13911,
									       max_1)
									   val x_13913: bool = 
									      x_8367 x_13912
									   val x_13914: unit = 
									      case x_13913 of
									      true => 
										 let
										    val x_13963: unit = 
										       ()
										 in
										    x_13963
										 end
									      false => 
										 let
										    val x_13915: word32
												 * word32 = 
										       (max_1,
											x_13911)
										    val x_13916: word32 = 
										       x_8548 x_13915
										    val x_13917: PrimSequence.Slice.t_1 = 
										       full_10 b_46
										    val x_13918: PrimSequence.Slice.t_1 = 
										       let
											  val x_13919: word64 = 
											     sextdFromInt32ToInt64_0 x_13911
											  val x_13920: word64 = 
											     sextdFromInt32ToInt64_0 x_13916
											  val x_13921: PrimSequence.Slice.t_1 = 
											     case x_13917 of
											     T_5 x_13922: word64
													  * word8 vector
													  * word64 => 
												let
												   val x_13923: word64 = 
												      #2 x_13922
												   val x_13924: word8 vector = 
												      #1 x_13922
												   val x_13925: word64 = 
												      #0 x_13922
												   val x_13926: word64
														* word64 = 
												      (x_13919,
												       x_13925)
												   val x_13927: bool = 
												      >_4 x_13926
												   val x_13928: bool = 
												      case x_13927 of
												      true => 
													 let
													    val x_13933: bool = 
													       true
													 in
													    x_13933
													 end
												      false => 
													 let
													    val x_13929: word64
															 * word64 = 
													       (x_13925,
														x_13919)
													    val x_13930: word64 = 
													       -?_1 x_13929
													    val x_13931: word64
															 * word64 = 
													       (x_13920,
														x_13930)
													    val x_13932: bool = 
													       >_4 x_13931
													 in
													    x_13932
													 end
												   val x_13934: PrimSequence.Slice.t_1 = 
												      case x_13928 of
												      true => 
													 let
													    val x_13939: PrimSequence.Slice.t_1 = 
													       raise x_8296
													 in
													    x_13939
													 end
												      false => 
													 let
													    val x_13935: word64
															 * word64 = 
													       (x_13923,
														x_13919)
													    val x_13936: word64 = 
													       +?_1 x_13935
													    val x_13937: word64
															 * word8 vector
															 * word64 = 
													       (x_13920,
														x_13924,
														x_13936)
													    val x_13938: PrimSequence.Slice.t_1 = 
													       T_5 x_13937
													 in
													    x_13938
													 end
												in
												   x_13934
												end
										       in
											  x_13921
										       end
										       handle x_13940 => let
													    val x_13941: unit
															 -> PrimSequence.Slice.t_1 = 
													       fn unit_22: unit => 
													       let
														  val x_13942: PrimSequence.Slice.t_1 = 
														     raise x_13940
													       in
														  x_13942
													       end
													    val x_13943: PrimSequence.Slice.t_1 = 
													       case x_13940 of
													       Overflow_0 x_13944: unit ref => 
														  let
														     val x_13945: bool = 
															MLton_equal[unit ref] (x_13944,
																	       x_8289)
														     val x_13946: PrimSequence.Slice.t_1 = 
															case x_13945 of
															true => 
															   let
															      val x_13949: PrimSequence.Slice.t_1 = 
																 raise x_8296
															   in
															      x_13949
															   end
															false => 
															   let
															      val x_13947: unit = 
																 ()
															      val x_13948: PrimSequence.Slice.t_1 = 
																 x_13941 x_13947
															   in
															      x_13948
															   end
														  in
														     x_13946
														  end
														 _ => let
															 val x_13950: unit = 
															    ()
															 val x_13951: PrimSequence.Slice.t_1 = 
															    x_13941 x_13950
														      in
															 x_13951
														      end
													 in
													    x_13943
													 end
										    val j_1: word32 = 
										       x_13908 x_13918
										    val x_13952: word32 = 
										       0x0
										    val x_13953: word32
												 * word32 = 
										       (j_1,
											x_13952)
										    val x_13954: bool = 
										       x_8367 x_13953
										    val x_13955: unit = 
										       case x_13954 of
										       true => 
											  let
											     val x_13959: word8 vector = 
												"partial write"
											     val x_13960: unit ref
													  * word8 vector = 
												(x_9554,
												 x_13959)
											     val x_13961: exn = 
												Fail_0 x_13960
											     val x_13962: unit = 
												raise x_13961
											  in
											     x_13962
											  end
										       false => 
											  let
											     val x_13956: word32
													  * word32 = 
												(x_13911,
												 j_1)
											     val x_13957: word32 = 
												x_8508 x_13956
											     val x_13958: unit = 
												loop_31 x_13957
											  in
											     x_13958
											  end
										 in
										    x_13955
										 end
									in
									   x_13914
									end
								  val x_13964: unit = 
								     loop_31 i_38
							       in
								  x_13964
							       end
						      in
							 x_13907
						      end
						val x_13966: StreamIOExtra.bufferMode_0 = 
						   x_8315 x_13896
						val x_13967: unit = 
						   case x_13966 of
						   NO_BUF_1 => 
						      let
							 val x_14181: unit = 
							    ()
							 val x_14182: unit = 
							    put_0 x_14181
						      in
							 x_14182
						      end
						   BLOCK_BUF_1 x_14090: StreamIOExtra.buf_0 => 
						      let
							 val x_14091: unit = 
							    case x_14090 of
							    Buf_0 x_14092: word8 array
									   * word32 ref => 
							       let
								  val x_14093: word32 ref = 
								     #1 x_14092
								  val x_14094: word8 array = 
								     #0 x_14092
								  val curSize_1: word32 = 
								     x_8306 x_14093
								  val x_14095: word32 = 
								     let
									val x_14096: word64 = 
									   x_8686 v_0
									val x_14097: word32 = 
									   x_8890 x_14096
								     in
									x_14097
								     end
								     handle x_14098 => let
											  val x_14099: unit
												       -> word32 = 
											     fn unit_25: unit => 
											     let
												val x_14100: word32 = 
												   raise x_14098
											     in
												x_14100
											     end
											  val x_14101: word32 = 
											     case x_14098 of
											     Overflow_0 x_14102: unit ref => 
												let
												   val x_14103: bool = 
												      MLton_equal[unit ref] (x_14102,
															     x_8289)
												   val x_14104: word32 = 
												      case x_14103 of
												      true => 
													 let
													    val x_14107: word8 vector = 
													       "Sequence.length"
													    val x_14108: unit ref
															 * word8 vector = 
													       (x_9554,
														x_14107)
													    val x_14109: exn = 
													       Fail_0 x_14108
													    val x_14110: word32 = 
													       raise x_14109
													 in
													    x_14110
													 end
												      false => 
													 let
													    val x_14105: unit = 
													       ()
													    val x_14106: word32 = 
													       x_14099 x_14105
													 in
													    x_14106
													 end
												in
												   x_14104
												end
											       _ => let
												       val x_14111: unit = 
													  ()
												       val x_14112: word32 = 
													  x_14099 x_14111
												    in
												       x_14112
												    end
										       in
											  x_14101
										       end
								  val x_14113: word32
									       * word32 = 
								     (curSize_1,
								      x_14095)
								  val newSize_1: word32 = 
								     x_8508 x_14113
								  val x_14114: word32 = 
								     length_18 x_14094
								  val x_14115: word32
									       * word32 = 
								     (newSize_1,
								      x_14114)
								  val x_14116: bool = 
								     >=_1 x_14115
								  val x_14117: bool = 
								     case x_14116 of
								     true => 
									let
									   val x_14119: bool = 
									      true
									in
									   x_14119
									end
								     false => 
									let
									   val x_14118: bool = 
									      false
									in
									   x_14118
									end
								  val x_14120: unit = 
								     case x_14117 of
								     true => 
									let
									   val x_14177: PrimIO.writer_0
											* StreamIOExtra.buf_0 = 
									      (x_13897,
									       x_14090)
									   val x_14178: unit = 
									      flushBuf_0 x_14177
									   val x_14179: unit = 
									      ()
									   val x_14180: unit = 
									      put_0 x_14179
									in
									   x_14180
									end
								     false => 
									let
									   val x_14121: unit = 
									      let
										 val x_14122: word64 = 
										    sextdFromInt32ToInt64_0 curSize_1
										 val x_14123: PrimSequence.Slice.t_1 = 
										    full_10 v_0
										 val x_14124: word64 = 
										    length_17 x_14123
										 val x_14125: Primitive.Option.t_23 = 
										    SOME_23 x_14124
										 val x_14126: PrimSequence.Slice.t_0 = 
										    full_11 x_14094
										 val x_14127: PrimSequence.Slice.t_0
											      * word64
											      * Primitive.Option.t_23 = 
										    (x_14126,
										     x_14122,
										     x_14125)
										 val x_14128: PrimSequence.Slice.t_0 = 
										    subslice_4 x_14127
										 val x_14129: unit = 
										    ()
										 val x_14130: unit = 
										    case x_14128 of
										    T_4 x_14131: word64
												 * word8 array
												 * word64 => 
										       let
											  val x_14132: word64 = 
											     #2 x_14131
											  val x_14133: word8 array = 
											     #1 x_14131
											  val x_14134: word64 = 
											     #0 x_14131
											  val x_14135: word64 = 
											     0x1
											  val x_14136: word64
												       * word64 = 
											     (x_14134,
											      x_14135)
											  val len_5: word64 = 
											     -?_1 x_14136
											  val x_14137: word64
												       * word64 = 
											     (x_14132,
											      len_5)
											  val max_4: word64 = 
											     +?_1 x_14137
											  val rec 
											     loop_34: word64
												      * unit
												      -> unit = 
												fn x_14138: word64
													    * unit => 
												let
												   val b_48: unit = 
												      #1 x_14138
												   val i_40: word64 = 
												      #0 x_14138
												   val x_14139: word64
														* word64 = 
												      (i_40,
												       max_4)
												   val x_14140: bool = 
												      >_1 x_14139
												   val x_14141: unit = 
												      case x_14140 of
												      true => 
													 let
													 in
													    b_48
													 end
												      false => 
													 let
													    val x_14142: word64 = 
													       0x1
													    val x_14143: word64
															 * word64 = 
													       (i_40,
														x_14142)
													    val x_14144: word64 = 
													       +?_1 x_14143
													    val x_14145: word64
															 * word64 = 
													       (i_40,
														x_14132)
													    val x_14146: word64 = 
													       -?_1 x_14145
													    val x_14147: word8 array
															 * word64 = 
													       (x_14133,
														i_40)
													    val x_14148: word8 = 
													       x_8672 x_14147
													    val x_14149: PrimSequence.Slice.t_1
															 * word64 = 
													       (x_14123,
														x_14146)
													    val x_14150: word8 = 
													       unsafeSub_6 x_14149
													    val x_14151: unit = 
													       case x_14128 of
													       T_4 x_14152: word64
															    * word8 array
															    * word64 => 
														  let
														     val x_14153: word64 = 
															#2 x_14152
														     val x_14154: word8 array = 
															#1 x_14152
														     val x_14155: word64
																  * word64 = 
															(x_14153,
															 x_14146)
														     val x_14156: word64 = 
															+?_1 x_14155
														     val x_14157: word8 array
																  * word64
																  * word8 = 
															(x_14154,
															 x_14156,
															 x_14150)
														     val x_14158: unit = 
															x_8677 x_14157
														  in
														     x_14158
														  end
													    val x_14159: word64
															 * unit = 
													       (x_14144,
														x_14151)
													    val x_14160: unit = 
													       loop_34 x_14159
													 in
													    x_14160
													 end
												in
												   x_14141
												end
											  val x_14161: word64
												       * unit = 
											     (x_14132,
											      x_14129)
											  val x_14162: unit = 
											     loop_34 x_14161
										       in
											  x_14162
										       end
									      in
										 x_14130
									      end
									      handle x_14163 => let
												   val x_14164: unit
														-> unit = 
												      fn unit_26: unit => 
												      let
													 val x_14165: unit = 
													    raise x_14163
												      in
													 x_14165
												      end
												   val x_14166: unit = 
												      case x_14163 of
												      Overflow_0 x_14167: unit ref => 
													 let
													    val x_14168: bool = 
													       MLton_equal[unit ref] (x_14167,
																      x_8289)
													    val x_14169: unit = 
													       case x_14168 of
													       true => 
														  let
														     val x_14172: unit = 
															raise x_8296
														  in
														     x_14172
														  end
													       false => 
														  let
														     val x_14170: unit = 
															()
														     val x_14171: unit = 
															x_14164 x_14170
														  in
														     x_14171
														  end
													 in
													    x_14169
													 end
													_ => let
														val x_14173: unit = 
														   ()
														val x_14174: unit = 
														   x_14164 x_14173
													     in
														x_14174
													     end
												in
												   x_14166
												end
									   val x_14175: word32 ref
											* word32 = 
									      (x_14093,
									       newSize_1)
									   val x_14176: unit = 
									      x_8337 x_14175
									in
									   x_14176
									end
							       in
								  x_14120
							       end
						      in
							 x_14091
						      end
						   LINE_BUF_1 x_13968: StreamIOExtra.buf_0 => 
						      let
							 val x_13969: unit = 
							    case x_13968 of
							    Buf_0 x_13970: word8 array
									   * word32 ref => 
							       let
								  val x_13971: word32 ref = 
								     #1 x_13970
								  val x_13972: word8 array = 
								     #0 x_13970
								  val curSize_0: word32 = 
								     x_8306 x_13971
								  val x_13973: word32 = 
								     let
									val x_13974: word64 = 
									   x_8686 v_0
									val x_13975: word32 = 
									   x_8890 x_13974
								     in
									x_13975
								     end
								     handle x_13976 => let
											  val x_13977: unit
												       -> word32 = 
											     fn unit_23: unit => 
											     let
												val x_13978: word32 = 
												   raise x_13976
											     in
												x_13978
											     end
											  val x_13979: word32 = 
											     case x_13976 of
											     Overflow_0 x_13980: unit ref => 
												let
												   val x_13981: bool = 
												      MLton_equal[unit ref] (x_13980,
															     x_8289)
												   val x_13982: word32 = 
												      case x_13981 of
												      true => 
													 let
													    val x_13985: word8 vector = 
													       "Sequence.length"
													    val x_13986: unit ref
															 * word8 vector = 
													       (x_9554,
														x_13985)
													    val x_13987: exn = 
													       Fail_0 x_13986
													    val x_13988: word32 = 
													       raise x_13987
													 in
													    x_13988
													 end
												      false => 
													 let
													    val x_13983: unit = 
													       ()
													    val x_13984: word32 = 
													       x_13977 x_13983
													 in
													    x_13984
													 end
												in
												   x_13982
												end
											       _ => let
												       val x_13989: unit = 
													  ()
												       val x_13990: word32 = 
													  x_13977 x_13989
												    in
												       x_13990
												    end
										       in
											  x_13979
										       end
								  val x_13991: word32
									       * word32 = 
								     (curSize_0,
								      x_13973)
								  val newSize_0: word32 = 
								     x_8508 x_13991
								  val x_13992: word32 = 
								     length_18 x_13972
								  val x_13993: word32
									       * word32 = 
								     (newSize_0,
								      x_13992)
								  val x_13994: bool = 
								     >=_1 x_13993
								  val x_13995: bool = 
								     case x_13994 of
								     true => 
									let
									   val x_14028: bool = 
									      true
									in
									   x_14028
									end
								     false => 
									let
									   val x_13996: PrimSequence.Slice.t_1 = 
									      full_10 v_0
									   val x_13997: Primitive.Option.t_26 = 
									      case x_13996 of
									      T_5 x_13998: word64
											   * word8 vector
											   * word64 => 
										 let
										    val x_13999: word64 = 
										       #2 x_13998
										    val x_14000: word8 vector = 
										       #1 x_13998
										    val x_14001: word64 = 
										       #0 x_13998
										    val x_14002: word64 = 
										       0x1
										    val x_14003: word64
												 * word64 = 
										       (x_14001,
											x_14002)
										    val len_3: word64 = 
										       -?_1 x_14003
										    val x_14004: word64
												 * word64 = 
										       (x_13999,
											len_3)
										    val max_2: word64 = 
										       +?_1 x_14004
										    val rec 
										       loop_32: word64
												-> Primitive.Option.t_26 = 
											  fn x_14005: word64 => 
											  let
											     val x_14006: word64
													  * word64 = 
												(x_14005,
												 max_2)
											     val x_14007: bool = 
												>_1 x_14006
											     val x_14008: Primitive.Option.t_26 = 
												case x_14007 of
												true => 
												   let
												      val x_14022: Primitive.Option.t_26 = 
													 NONE_24
												   in
												      x_14022
												   end
												false => 
												   let
												      val x_14009: word64
														   * word64 = 
													 (x_14005,
													  x_13999)
												      val x_14010: word64 = 
													 -?_1 x_14009
												      val x_14011: word8 vector
														   * word64 = 
													 (x_14000,
													  x_14005)
												      val x_14012: word8 = 
													 x_8689 x_14011
												      val z_0: word64
													       * word8 = 
													 (x_14010,
													  x_14012)
												      val x_14013: word8 = 
													 0xA
												      val x_14014: word8
														   * word8 = 
													 (x_14012,
													  x_14013)
												      val x_14015: bool = 
													 x_8377 x_14014
												      val x_14016: Primitive.Option.t_26 = 
													 case x_14015 of
													 true => 
													    let
													       val x_14021: Primitive.Option.t_26 = 
														  SOME_26 z_0
													    in
													       x_14021
													    end
													 false => 
													    let
													       val x_14017: word64 = 
														  0x1
													       val x_14018: word64
															    * word64 = 
														  (x_14005,
														   x_14017)
													       val x_14019: word64 = 
														  +?_1 x_14018
													       val x_14020: Primitive.Option.t_26 = 
														  loop_32 x_14019
													    in
													       x_14020
													    end
												   in
												      x_14016
												   end
											  in
											     x_14008
											  end
										    val x_14023: Primitive.Option.t_26 = 
										       loop_32 x_13999
										 in
										    x_14023
										 end
									   val x_14024: bool = 
									      case x_13997 of
									      NONE_24 => 
										 let
										    val x_14027: bool = 
										       false
										 in
										    x_14027
										 end
									      SOME_26 x_14025: word64
											       * word8 => 
										 let
										    val x_14026: bool = 
										       true
										 in
										    x_14026
										 end
									in
									   x_14024
									end
								  val x_14029: unit = 
								     case x_13995 of
								     true => 
									let
									   val x_14086: PrimIO.writer_0
											* StreamIOExtra.buf_0 = 
									      (x_13897,
									       x_13968)
									   val x_14087: unit = 
									      flushBuf_0 x_14086
									   val x_14088: unit = 
									      ()
									   val x_14089: unit = 
									      put_0 x_14088
									in
									   x_14089
									end
								     false => 
									let
									   val x_14030: unit = 
									      let
										 val x_14031: word64 = 
										    sextdFromInt32ToInt64_0 curSize_0
										 val x_14032: PrimSequence.Slice.t_1 = 
										    full_10 v_0
										 val x_14033: word64 = 
										    length_17 x_14032
										 val x_14034: Primitive.Option.t_23 = 
										    SOME_23 x_14033
										 val x_14035: PrimSequence.Slice.t_0 = 
										    full_11 x_13972
										 val x_14036: PrimSequence.Slice.t_0
											      * word64
											      * Primitive.Option.t_23 = 
										    (x_14035,
										     x_14031,
										     x_14034)
										 val x_14037: PrimSequence.Slice.t_0 = 
										    subslice_4 x_14036
										 val x_14038: unit = 
										    ()
										 val x_14039: unit = 
										    case x_14037 of
										    T_4 x_14040: word64
												 * word8 array
												 * word64 => 
										       let
											  val x_14041: word64 = 
											     #2 x_14040
											  val x_14042: word8 array = 
											     #1 x_14040
											  val x_14043: word64 = 
											     #0 x_14040
											  val x_14044: word64 = 
											     0x1
											  val x_14045: word64
												       * word64 = 
											     (x_14043,
											      x_14044)
											  val len_4: word64 = 
											     -?_1 x_14045
											  val x_14046: word64
												       * word64 = 
											     (x_14041,
											      len_4)
											  val max_3: word64 = 
											     +?_1 x_14046
											  val rec 
											     loop_33: word64
												      * unit
												      -> unit = 
												fn x_14047: word64
													    * unit => 
												let
												   val b_47: unit = 
												      #1 x_14047
												   val i_39: word64 = 
												      #0 x_14047
												   val x_14048: word64
														* word64 = 
												      (i_39,
												       max_3)
												   val x_14049: bool = 
												      >_1 x_14048
												   val x_14050: unit = 
												      case x_14049 of
												      true => 
													 let
													 in
													    b_47
													 end
												      false => 
													 let
													    val x_14051: word64 = 
													       0x1
													    val x_14052: word64
															 * word64 = 
													       (i_39,
														x_14051)
													    val x_14053: word64 = 
													       +?_1 x_14052
													    val x_14054: word64
															 * word64 = 
													       (i_39,
														x_14041)
													    val x_14055: word64 = 
													       -?_1 x_14054
													    val x_14056: word8 array
															 * word64 = 
													       (x_14042,
														i_39)
													    val x_14057: word8 = 
													       x_8672 x_14056
													    val x_14058: PrimSequence.Slice.t_1
															 * word64 = 
													       (x_14032,
														x_14055)
													    val x_14059: word8 = 
													       unsafeSub_6 x_14058
													    val x_14060: unit = 
													       case x_14037 of
													       T_4 x_14061: word64
															    * word8 array
															    * word64 => 
														  let
														     val x_14062: word64 = 
															#2 x_14061
														     val x_14063: word8 array = 
															#1 x_14061
														     val x_14064: word64
																  * word64 = 
															(x_14062,
															 x_14055)
														     val x_14065: word64 = 
															+?_1 x_14064
														     val x_14066: word8 array
																  * word64
																  * word8 = 
															(x_14063,
															 x_14065,
															 x_14059)
														     val x_14067: unit = 
															x_8677 x_14066
														  in
														     x_14067
														  end
													    val x_14068: word64
															 * unit = 
													       (x_14053,
														x_14060)
													    val x_14069: unit = 
													       loop_33 x_14068
													 in
													    x_14069
													 end
												in
												   x_14050
												end
											  val x_14070: word64
												       * unit = 
											     (x_14041,
											      x_14038)
											  val x_14071: unit = 
											     loop_33 x_14070
										       in
											  x_14071
										       end
									      in
										 x_14039
									      end
									      handle x_14072 => let
												   val x_14073: unit
														-> unit = 
												      fn unit_24: unit => 
												      let
													 val x_14074: unit = 
													    raise x_14072
												      in
													 x_14074
												      end
												   val x_14075: unit = 
												      case x_14072 of
												      Overflow_0 x_14076: unit ref => 
													 let
													    val x_14077: bool = 
													       MLton_equal[unit ref] (x_14076,
																      x_8289)
													    val x_14078: unit = 
													       case x_14077 of
													       true => 
														  let
														     val x_14081: unit = 
															raise x_8296
														  in
														     x_14081
														  end
													       false => 
														  let
														     val x_14079: unit = 
															()
														     val x_14080: unit = 
															x_14073 x_14079
														  in
														     x_14080
														  end
													 in
													    x_14078
													 end
													_ => let
														val x_14082: unit = 
														   ()
														val x_14083: unit = 
														   x_14073 x_14082
													     in
														x_14083
													     end
												in
												   x_14075
												end
									   val x_14084: word32 ref
											* word32 = 
									      (x_13971,
									       newSize_0)
									   val x_14085: unit = 
									      x_8337 x_14084
									in
									   x_14085
									end
							       in
								  x_14029
							       end
						      in
							 x_13969
						      end
					     in
						x_13967
					     end
					     handle x_14183 => let
								  val x_14184: word8 vector = 
								     outstreamName_0 x_13892
								  val x_14185: word8 vector
									       -> exn
										  -> unit = 
								     liftExn_0 x_14184
								  val x_14186: word8 vector = 
								     "output"
								  val x_14187: exn
									       -> unit = 
								     x_14185 x_14186
								  val x_14188: unit = 
								     x_14187 x_14183
							       in
								  x_14188
							       end
				       in
					  x_13901
				       end
			      in
				 x_13900
			      end
		     in
			x_13893
		     end
	       val rec 
		  newOut_0: bool
			    * IO.buffer_mode_0
			    * bool
			    * word32
			    * word8 vector
			    -> ImperativeIOExtra.Outstream.t_0 = 
		     fn x_14194: bool
				 * IO.buffer_mode_0
				 * bool
				 * word32
				 * word8 vector => 
		     let
			val name_1: word8 vector = 
			   #4 x_14194
			val fd_2: word32 = 
			   #3 x_14194
			val closeAtExit_0: bool = 
			   #2 x_14194
			val bufferMode_0: IO.buffer_mode_0 = 
			   #1 x_14194
			val appendMode_0: bool = 
			   #0 x_14194
			val x_14195: bool = 
			   true
			val x_14196: bool = 
			   false
			val closed_0: bool ref = 
			   Ref_ref[bool] (x_14196)
			val x_14197: PosixFileSys.ST.stat_0 = 
			   x_13412 fd_2
			val x_14198: word32 = 
			   case x_14197 of
			   T_3 x_14199: Time.time_0
					* Time.time_0
					* word64
					* word32
					* word64
					* word32
					* Time.time_0
					* word32
					* word64
					* word32 => 
			      let
				 val x_14200: word32 = 
				    #5 x_14199
			      in
				 x_14200
			      end
			val x_14201: word32 = 
			   Posix_FileSys_ST_isReg (x_14198)
			val x_14202: word32 * word32 = 
			   (x_14201, zero_3)
			val x_14203: bool = 
			   x_8382 x_14202
			val x_14204: Primitive.Option.t_9
				     * Primitive.Option.t_9
				     * word64 ref
				     * Primitive.Option.t_14
				     * Primitive.Option.t_9 = 
			   case x_14203 of
			   true => 
			      let
				 val pos_0: word64 ref = 
				    Ref_ref[word64] (pos0_0)
				 val rec 
				    getPos_0: unit -> word64 = 
				       fn x_14211: unit => 
				       let
					  val x_14212: word64 = 
					     x_8312 pos_0
				       in
					  x_14212
				       end
				 val rec 
				    setPos_0: word64 -> unit = 
				       fn x_14213: word64 => 
				       let
					  val x_14214: bool = 
					     x_8321 closed_0
					  val x_14215: unit = 
					     case x_14214 of
					     true => 
						let
						   val x_14217: unit = 
						      raise x_13298
						in
						   x_14217
						end
					     false => 
						let
						   val x_14216: unit = 
						      ()
						in
						   x_14216
						end
					  val x_14218: PosixIO.whence_0 = 
					     SEEK_SET_0
					  val x_14219: word32
						       * word64
						       * PosixIO.whence_0 = 
					     (fd_2, x_14213, x_14218)
					  val x_14220: word64 = 
					     lseek_0 x_14219
					  val x_14221: word64 ref * word64 = 
					     (pos_0, x_14220)
					  val x_14222: unit = 
					     x_8357 x_14221
				       in
					  x_14222
				       end
				 val rec 
				    endPos_0: unit -> word64 = 
				       fn x_14223: unit => 
				       let
					  val x_14224: bool = 
					     x_8321 closed_0
					  val x_14225: unit = 
					     case x_14224 of
					     true => 
						let
						   val x_14227: unit = 
						      raise x_13298
						in
						   x_14227
						end
					     false => 
						let
						   val x_14226: unit = 
						      ()
						in
						   x_14226
						end
					  val x_14228: PosixFileSys.ST.stat_0 = 
					     x_13412 fd_2
					  val x_14229: word64 = 
					     case x_14228 of
					     T_3 x_14230: Time.time_0
							  * Time.time_0
							  * word64
							  * word32
							  * word64
							  * word32
							  * Time.time_0
							  * word32
							  * word64
							  * word32 => 
						let
						   val x_14231: word64 = 
						      #8 x_14230
						in
						   x_14231
						end
				       in
					  x_14229
				       end
				 val rec 
				    verifyPos_0: unit -> word64 = 
				       fn x_14232: unit => 
				       let
					  val x_14233: PosixIO.whence_0 = 
					     SEEK_CUR_0
					  val x_14234: word32
						       * word64
						       * PosixIO.whence_0 = 
					     (fd_2, pos0_0, x_14233)
					  val curPos_0: word64 = 
					     lseek_0 x_14234
					  val x_14235: word64 ref * word64 = 
					     (pos_0, curPos_0)
					  val x_14236: unit = 
					     x_8357 x_14235
				       in
					  curPos_0
				       end
				 val x_14237: unit = 
				    ()
				 val x_14238: word64 = 
				    verifyPos_0 x_14237
				 val x_14239: Primitive.Option.t_9 = 
				    SOME_9 getPos_0
				 val x_14240: Primitive.Option.t_14 = 
				    SOME_14 setPos_0
				 val x_14241: Primitive.Option.t_9 = 
				    SOME_9 endPos_0
				 val x_14242: Primitive.Option.t_9 = 
				    SOME_9 verifyPos_0
				 val x_14243: Primitive.Option.t_9
					      * Primitive.Option.t_9
					      * word64 ref
					      * Primitive.Option.t_14
					      * Primitive.Option.t_9 = 
				    (x_14241, x_14239, pos_0, x_14240, x_14242)
			      in
				 x_14243
			      end
			   false => 
			      let
				 val x_14205: word64 ref = 
				    Ref_ref[word64] (pos0_0)
				 val x_14206: Primitive.Option.t_9 = 
				    NONE_9
				 val x_14207: Primitive.Option.t_14 = 
				    NONE_12
				 val x_14208: Primitive.Option.t_9 = 
				    NONE_9
				 val x_14209: Primitive.Option.t_9 = 
				    NONE_9
				 val x_14210: Primitive.Option.t_9
					      * Primitive.Option.t_9
					      * word64 ref
					      * Primitive.Option.t_14
					      * Primitive.Option.t_9 = 
				    (x_14208, x_14206, x_14205, x_14207, x_14209)
			      in
				 x_14210
			      end
			val verifyPos_1: Primitive.Option.t_9 = 
			   #4 x_14204
			val setPos_1: Primitive.Option.t_14 = 
			   #3 x_14204
			val pos_1: word64 ref = 
			   #2 x_14204
			val getPos_1: Primitive.Option.t_9 = 
			   #1 x_14204
			val endPos_1: Primitive.Option.t_9 = 
			   #0 x_14204
			val rec 
			   incPos_0: word32 -> word32 = 
			      fn x_14244: word32 => 
			      let
				 val x_14245: word64 = 
				    x_8312 pos_1
				 val x_14246: word64 = 
				    sextdFromInt32ToInt64_0 x_14244
				 val x_14247: word64 * word64 = 
				    (x_14245, x_14246)
				 val x_14248: word64 = 
				    x_8588 x_14247
				 val x_14249: word64 ref * word64 = 
				    (pos_1, x_14248)
				 val x_14250: unit = 
				    x_8357 x_14249
			      in
				 x_14244
			      end
			val blocking_0: bool ref = 
			   Ref_ref[bool] (x_14195)
			val x_14251: list_4 = 
			   case appendMode_0 of
			   true => 
			      let
				 val x_14253: list_4 = 
				    nil_4
				 val x_14254: word32 * list_4 = 
				    (APPEND_0, x_14253)
				 val x_14255: list_4 = 
				    ::_4 x_14254
			      in
				 x_14255
			      end
			   false => 
			      let
				 val x_14252: list_4 = 
				    nil_4
			      in
				 x_14252
			      end
			val appendFlgs_0: word32 = 
			   x_13397 x_14251
			val rec 
			   putV_0: word32 * PrimSequence.Slice.t_1 -> word32 = 
			      fn x_14256: word32 * PrimSequence.Slice.t_1 => 
			      let
				 val sl_1: PrimSequence.Slice.t_1 = 
				    #1 x_14256
				 val fd_3: word32 = 
				    #0 x_14256
				 val x_14257: word8 vector * word32 * word32 = 
				    base_12 sl_1
				 val sz_2: word32 = 
				    #2 x_14257
				 val i_41: word32 = 
				    #1 x_14257
				 val buf_0: word8 vector = 
				    #0 x_14257
				 val x_14258: word64 = 
				    0xFFFFFFFFFFFFFFFF
				 val x_14259: word64 = 
				    sextdFromInt64ToInt64_0 x_14258
				 val x_14260: unit -> word64 = 
				    fn x_14261: unit => 
				    let
				       val x_14262: word32 = 
					  toRep_1 fd_3
				       val x_14263: word32 = 
					  sextdFromInt32ToInt32_0 i_41
				       val x_14264: word64 = 
					  sextdFromInt32ToWord64_0 sz_2
				       val x_14265: word64 = 
					  Posix_IO_writeChar8Vec (x_14262,
								  buf_0,
								  x_14263,
								  x_14264)
				    in
				       x_14265
				    end
				 val rec 
				    errUnblocked_1: word32 * list_9 -> word64 = 
				       fn x_14266: word32 * list_9 => 
				       let
					  val handlers_6: list_9 = 
					     #1 x_14266
					  val errno_1: word32 = 
					     #0 x_14266
					  val rec 
					     loop_35: list_9
						      -> Primitive.Option.t_21 = 
						fn x_14267: list_9 => 
						let
						   val x_14268: Primitive.Option.t_21 = 
						      case x_14267 of
						      nil_9 => 
							 let
							    val x_14278: Primitive.Option.t_21 = 
							       NONE_19
							 in
							    x_14278
							 end
						      ::_9 x_14269: (word32
								     * (unit
									-> word64))
								    * list_9 => 
							 let
							    val x_14270: list_9 = 
							       #1 x_14269
							    val x_14271: word32
									 * (unit
									    -> word64) = 
							       #0 x_14269
							    val x_14272: word32 = 
							       #0 x_14271
							    val x_14273: word32
									 * word32 = 
							       (errno_1, x_14272)
							    val x_14274: bool = 
							       x_8367 x_14273
							    val x_14275: Primitive.Option.t_21 = 
							       case x_14274 of
							       true => 
								  let
								     val x_14277: Primitive.Option.t_21 = 
									SOME_21 x_14271
								  in
								     x_14277
								  end
							       false => 
								  let
								     val x_14276: Primitive.Option.t_21 = 
									loop_35 x_14270
								  in
								     x_14276
								  end
							 in
							    x_14275
							 end
						in
						   x_14268
						end
					  val x_14279: Primitive.Option.t_21 = 
					     loop_35 handlers_6
					  val x_14280: word64 = 
					     case x_14279 of
					     NONE_19 => 
						let
						   val x_14285: word32 * word32 = 
						      (errno_1, intr_0)
						   val x_14286: bool = 
						      x_8367 x_14285
						   val x_14287: bool = 
						      case x_14286 of
						      true => 
							 let
							    val x_14289: bool = 
							       x_8321 restartFlag_0
							 in
							    x_14289
							 end
						      false => 
							 let
							    val x_14288: bool = 
							       false
							 in
							    x_14288
							 end
						   val x_14290: word64 = 
						      case x_14287 of
						      true => 
							 let
							    val x_14292: unit = 
							       ()
							    val x_14293: word32 = 
							       atomicState_0 x_14292
							    val x_14294: word32 = 
							       0x0
							    val x_14295: word32
									 * word32 = 
							       (x_14293, x_14294)
							    val x_14296: bool = 
							       x_8367 x_14295
							    val x_14297: word64 = 
							       case x_14296 of
							       true => 
								  let
								     val x_14362: unit = 
									()
								     val x_14363: unit = 
									atomicBegin_0 x_14362
								     val x_14364: list_9
										  * (word64
										     -> word64)
										  * word64 = 
									let
									   val x_14365: unit = 
									      ()
									   val return_14: word64 = 
									      x_14260 x_14365
									   val x_14366: word64
											-> word64 = 
									      fn x_14367: word64 => 
									      let
									      in
										 x_14367
									      end
									   val x_14368: list_9 = 
									      nil_9
									   val x_14369: list_9
											* (word64
											   -> word64)
											* word64 = 
									      (x_14368,
									       x_14366,
									       return_14)
									in
									   x_14369
									end
									handle x_14370 => let
											     val x_14371: unit = 
												()
											     val x_14372: unit = 
												atomicEnd_0 x_14371
											     val x_14373: list_9
													  * (word64
													     -> word64)
													  * word64 = 
												raise x_14370
											  in
											     x_14373
											  end
								     val return_15: word64 = 
									#2 x_14364
								     val post_6: word64
										 -> word64 = 
									#1 x_14364
								     val handlers_8: list_9 = 
									#0 x_14364
								     val x_14374: word64
										  * word64 = 
									(x_14259,
									 return_15)
								     val x_14375: bool = 
									x_8372 x_14374
								     val x_14376: word64 = 
									case x_14375 of
									true => 
									   let
									      val x_14390: word32 = 
										 Posix_Error_getErrno ()
									      val e_6: word32 = 
										 fromRep_1 x_14390
									      val x_14391: unit = 
										 ()
									      val x_14392: unit = 
										 atomicEnd_0 x_14391
									      val x_14393: word32
											   * list_9 = 
										 (e_6,
										  handlers_8)
									      val x_14394: word64 = 
										 errUnblocked_1 x_14393
									   in
									      x_14394
									   end
									false => 
									   let
									      val x_14377: DynamicWind.try.t_2 = 
										 let
										    val x_14378: word64 = 
										       post_6 return_15
										    val x_14379: DynamicWind.try.t_2 = 
										       A_2 x_14378
										 in
										    x_14379
										 end
										 handle x_14380 => let
												      val x_14381: DynamicWind.try.t_2 = 
													 E_2 x_14380
												   in
												      x_14381
												   end
									      val x_14382: word64 = 
										 case x_14377 of
										 A_2 x_14387: word64 => 
										    let
										       val x_14388: unit = 
											  ()
										       val x_14389: unit = 
											  atomicEnd_0 x_14388
										    in
										       x_14387
										    end
										 E_2 x_14383: exn => 
										    let
										       val x_14384: unit = 
											  ()
										       val x_14385: unit = 
											  atomicEnd_0 x_14384
										       val x_14386: word64 = 
											  raise x_14383
										    in
										       x_14386
										    end
									   in
									      x_14382
									   end
								  in
								     x_14376
								  end
							       false => 
								  let
								     val x_14298: unit
										  -> unit
										     -> unit = 
									Ref_deref[unit
										  -> unit
										     -> unit] (blocker_0)
								     val x_14299: unit = 
									()
								     val finish_1: unit
										   -> unit = 
									x_14298 x_14299
								     val x_14300: DynamicWind.try.t_2 = 
									let
									   val x_14301: unit = 
									      ()
									   val x_14302: unit = 
									      atomicBegin_0 x_14301
									   val x_14303: list_9
											* (word64
											   -> word64)
											* word64 = 
									      let
										 val x_14304: unit = 
										    ()
										 val return_12: word64 = 
										    x_14260 x_14304
										 val x_14305: word64
											      -> word64 = 
										    fn x_14306: word64 => 
										    let
										    in
										       x_14306
										    end
										 val x_14307: list_9 = 
										    nil_9
										 val x_14308: list_9
											      * (word64
												 -> word64)
											      * word64 = 
										    (x_14307,
										     x_14305,
										     return_12)
									      in
										 x_14308
									      end
									      handle x_14309 => let
												   val x_14310: unit = 
												      ()
												   val x_14311: unit = 
												      atomicEnd_0 x_14310
												   val x_14312: list_9
														* (word64
														   -> word64)
														* word64 = 
												      raise x_14309
												in
												   x_14312
												end
									   val return_13: word64 = 
									      #2 x_14303
									   val post_5: word64
										       -> word64 = 
									      #1 x_14303
									   val handlers_7: list_9 = 
									      #0 x_14303
									   val x_14313: word64
											* word64 = 
									      (x_14259,
									       return_13)
									   val x_14314: bool = 
									      x_8372 x_14313
									   val x_14315: word64 = 
									      case x_14314 of
									      true => 
										 let
										    val x_14329: word32 = 
										       Posix_Error_getErrno ()
										    val e_5: word32 = 
										       fromRep_1 x_14329
										    val x_14330: unit = 
										       ()
										    val x_14331: unit = 
										       atomicEnd_0 x_14330
										    val rec 
										       loop_36: list_9
												-> Primitive.Option.t_21 = 
											  fn x_14332: list_9 => 
											  let
											     val x_14333: Primitive.Option.t_21 = 
												case x_14332 of
												nil_9 => 
												   let
												      val x_14343: Primitive.Option.t_21 = 
													 NONE_19
												   in
												      x_14343
												   end
												::_9 x_14334: (word32
													       * (unit
														  -> word64))
													      * list_9 => 
												   let
												      val x_14335: list_9 = 
													 #1 x_14334
												      val x_14336: word32
														   * (unit
														      -> word64) = 
													 #0 x_14334
												      val x_14337: word32 = 
													 #0 x_14336
												      val x_14338: word32
														   * word32 = 
													 (e_5,
													  x_14337)
												      val x_14339: bool = 
													 x_8367 x_14338
												      val x_14340: Primitive.Option.t_21 = 
													 case x_14339 of
													 true => 
													    let
													       val x_14342: Primitive.Option.t_21 = 
														  SOME_21 x_14336
													    in
													       x_14342
													    end
													 false => 
													    let
													       val x_14341: Primitive.Option.t_21 = 
														  loop_36 x_14335
													    in
													       x_14341
													    end
												   in
												      x_14340
												   end
											  in
											     x_14333
											  end
										    val x_14344: Primitive.Option.t_21 = 
										       loop_36 handlers_7
										    val x_14345: word64 = 
										       case x_14344 of
										       NONE_19 => 
											  let
											     val x_14350: word64 = 
												raiseSys_2 e_5
											  in
											     x_14350
											  end
										       SOME_21 x_14346: word32
													* (unit
													   -> word64) => 
											  let
											     val x_14347: unit
													  -> word64 = 
												#1 x_14346
											     val x_14348: unit = 
												()
											     val x_14349: word64 = 
												x_14347 x_14348
											  in
											     x_14349
											  end
										 in
										    x_14345
										 end
									      false => 
										 let
										    val x_14316: DynamicWind.try.t_2 = 
										       let
											  val x_14317: word64 = 
											     post_5 return_13
											  val x_14318: DynamicWind.try.t_2 = 
											     A_2 x_14317
										       in
											  x_14318
										       end
										       handle x_14319 => let
													    val x_14320: DynamicWind.try.t_2 = 
													       E_2 x_14319
													 in
													    x_14320
													 end
										    val x_14321: word64 = 
										       case x_14316 of
										       A_2 x_14326: word64 => 
											  let
											     val x_14327: unit = 
												()
											     val x_14328: unit = 
												atomicEnd_0 x_14327
											  in
											     x_14326
											  end
										       E_2 x_14322: exn => 
											  let
											     val x_14323: unit = 
												()
											     val x_14324: unit = 
												atomicEnd_0 x_14323
											     val x_14325: word64 = 
												raise x_14322
											  in
											     x_14325
											  end
										 in
										    x_14321
										 end
									   val x_14351: DynamicWind.try.t_2 = 
									      A_2 x_14315
									in
									   x_14351
									end
									handle x_14352 => let
											     val x_14353: DynamicWind.try.t_2 = 
												E_2 x_14352
											  in
											     x_14353
											  end
								     val x_14354: word64 = 
									case x_14300 of
									A_2 x_14359: word64 => 
									   let
									      val x_14360: unit = 
										 ()
									      val x_14361: unit = 
										 finish_1 x_14360
									   in
									      x_14359
									   end
									E_2 x_14355: exn => 
									   let
									      val x_14356: unit = 
										 ()
									      val x_14357: unit = 
										 finish_1 x_14356
									      val x_14358: word64 = 
										 raise x_14355
									   in
									      x_14358
									   end
								  in
								     x_14354
								  end
							 in
							    x_14297
							 end
						      false => 
							 let
							    val x_14291: word64 = 
							       raiseSys_2 errno_1
							 in
							    x_14291
							 end
						in
						   x_14290
						end
					     SOME_21 x_14281: word32
							      * (unit -> word64) => 
						let
						   val x_14282: unit -> word64 = 
						      #1 x_14281
						   val x_14283: unit = 
						      ()
						   val x_14284: word64 = 
						      x_14282 x_14283
						in
						   x_14284
						end
				       in
					  x_14280
				       end
				 val x_14395: unit = 
				    ()
				 val x_14396: unit = 
				    atomicBegin_0 x_14395
				 val x_14397: list_9
					      * (word64 -> word64)
					      * word64 = 
				    let
				       val x_14398: unit = 
					  ()
				       val return_16: word64 = 
					  x_14260 x_14398
				       val x_14399: word64 -> word64 = 
					  fn x_14400: word64 => 
					  let
					  in
					     x_14400
					  end
				       val x_14401: list_9 = 
					  nil_9
				       val x_14402: list_9
						    * (word64 -> word64)
						    * word64 = 
					  (x_14401, x_14399, return_16)
				    in
				       x_14402
				    end
				    handle x_14403 => let
							 val x_14404: unit = 
							    ()
							 val x_14405: unit = 
							    atomicEnd_0 x_14404
							 val x_14406: list_9
								      * (word64
									 -> word64)
								      * word64 = 
							    raise x_14403
						      in
							 x_14406
						      end
				 val return_17: word64 = 
				    #2 x_14397
				 val post_7: word64 -> word64 = 
				    #1 x_14397
				 val handlers_9: list_9 = 
				    #0 x_14397
				 val x_14407: word64 * word64 = 
				    (x_14259, return_17)
				 val x_14408: bool = 
				    x_8372 x_14407
				 val x_14409: word64 = 
				    case x_14408 of
				    true => 
				       let
					  val x_14423: word32 = 
					     Posix_Error_getErrno ()
					  val e_7: word32 = 
					     fromRep_1 x_14423
					  val x_14424: unit = 
					     ()
					  val x_14425: unit = 
					     atomicEnd_0 x_14424
					  val x_14426: word32 * list_9 = 
					     (e_7, handlers_9)
					  val x_14427: word64 = 
					     errUnblocked_1 x_14426
				       in
					  x_14427
				       end
				    false => 
				       let
					  val x_14410: DynamicWind.try.t_2 = 
					     let
						val x_14411: word64 = 
						   post_7 return_17
						val x_14412: DynamicWind.try.t_2 = 
						   A_2 x_14411
					     in
						x_14412
					     end
					     handle x_14413 => let
								  val x_14414: DynamicWind.try.t_2 = 
								     E_2 x_14413
							       in
								  x_14414
							       end
					  val x_14415: word64 = 
					     case x_14410 of
					     A_2 x_14420: word64 => 
						let
						   val x_14421: unit = 
						      ()
						   val x_14422: unit = 
						      atomicEnd_0 x_14421
						in
						   x_14420
						end
					     E_2 x_14416: exn => 
						let
						   val x_14417: unit = 
						      ()
						   val x_14418: unit = 
						      atomicEnd_0 x_14417
						   val x_14419: word64 = 
						      raise x_14416
						in
						   x_14419
						end
				       in
					  x_14415
				       end
				 val bytesWrote_0: word32 = 
				    x_8890 x_14409
				 val x_14428: word32 = 
				    incPos_0 bytesWrote_0
			      in
				 x_14428
			      end
			val rec 
			   putA_0: word32 * PrimSequence.Slice.t_0 -> word32 = 
			      fn x_14429: word32 * PrimSequence.Slice.t_0 => 
			      let
				 val sl_2: PrimSequence.Slice.t_0 = 
				    #1 x_14429
				 val fd_4: word32 = 
				    #0 x_14429
				 val x_14430: word8 array * word32 * word32 = 
				    base_13 sl_2
				 val sz_3: word32 = 
				    #2 x_14430
				 val i_42: word32 = 
				    #1 x_14430
				 val buf_1: word8 array = 
				    #0 x_14430
				 val x_14431: word64 = 
				    0xFFFFFFFFFFFFFFFF
				 val x_14432: word64 = 
				    sextdFromInt64ToInt64_0 x_14431
				 val x_14433: unit -> word64 = 
				    fn x_14434: unit => 
				    let
				       val x_14435: word32 = 
					  toRep_1 fd_4
				       val x_14436: word32 = 
					  sextdFromInt32ToInt32_0 i_42
				       val x_14437: word64 = 
					  sextdFromInt32ToWord64_0 sz_3
				       val x_14438: word64 = 
					  Posix_IO_writeChar8Arr (x_14435,
								  buf_1,
								  x_14436,
								  x_14437)
				    in
				       x_14438
				    end
				 val rec 
				    errUnblocked_2: word32 * list_9 -> word64 = 
				       fn x_14439: word32 * list_9 => 
				       let
					  val handlers_10: list_9 = 
					     #1 x_14439
					  val errno_2: word32 = 
					     #0 x_14439
					  val rec 
					     loop_37: list_9
						      -> Primitive.Option.t_21 = 
						fn x_14440: list_9 => 
						let
						   val x_14441: Primitive.Option.t_21 = 
						      case x_14440 of
						      nil_9 => 
							 let
							    val x_14451: Primitive.Option.t_21 = 
							       NONE_19
							 in
							    x_14451
							 end
						      ::_9 x_14442: (word32
								     * (unit
									-> word64))
								    * list_9 => 
							 let
							    val x_14443: list_9 = 
							       #1 x_14442
							    val x_14444: word32
									 * (unit
									    -> word64) = 
							       #0 x_14442
							    val x_14445: word32 = 
							       #0 x_14444
							    val x_14446: word32
									 * word32 = 
							       (errno_2, x_14445)
							    val x_14447: bool = 
							       x_8367 x_14446
							    val x_14448: Primitive.Option.t_21 = 
							       case x_14447 of
							       true => 
								  let
								     val x_14450: Primitive.Option.t_21 = 
									SOME_21 x_14444
								  in
								     x_14450
								  end
							       false => 
								  let
								     val x_14449: Primitive.Option.t_21 = 
									loop_37 x_14443
								  in
								     x_14449
								  end
							 in
							    x_14448
							 end
						in
						   x_14441
						end
					  val x_14452: Primitive.Option.t_21 = 
					     loop_37 handlers_10
					  val x_14453: word64 = 
					     case x_14452 of
					     NONE_19 => 
						let
						   val x_14458: word32 * word32 = 
						      (errno_2, intr_0)
						   val x_14459: bool = 
						      x_8367 x_14458
						   val x_14460: bool = 
						      case x_14459 of
						      true => 
							 let
							    val x_14462: bool = 
							       x_8321 restartFlag_0
							 in
							    x_14462
							 end
						      false => 
							 let
							    val x_14461: bool = 
							       false
							 in
							    x_14461
							 end
						   val x_14463: word64 = 
						      case x_14460 of
						      true => 
							 let
							    val x_14465: unit = 
							       ()
							    val x_14466: word32 = 
							       atomicState_0 x_14465
							    val x_14467: word32 = 
							       0x0
							    val x_14468: word32
									 * word32 = 
							       (x_14466, x_14467)
							    val x_14469: bool = 
							       x_8367 x_14468
							    val x_14470: word64 = 
							       case x_14469 of
							       true => 
								  let
								     val x_14535: unit = 
									()
								     val x_14536: unit = 
									atomicBegin_0 x_14535
								     val x_14537: list_9
										  * (word64
										     -> word64)
										  * word64 = 
									let
									   val x_14538: unit = 
									      ()
									   val return_20: word64 = 
									      x_14433 x_14538
									   val x_14539: word64
											-> word64 = 
									      fn x_14540: word64 => 
									      let
									      in
										 x_14540
									      end
									   val x_14541: list_9 = 
									      nil_9
									   val x_14542: list_9
											* (word64
											   -> word64)
											* word64 = 
									      (x_14541,
									       x_14539,
									       return_20)
									in
									   x_14542
									end
									handle x_14543 => let
											     val x_14544: unit = 
												()
											     val x_14545: unit = 
												atomicEnd_0 x_14544
											     val x_14546: list_9
													  * (word64
													     -> word64)
													  * word64 = 
												raise x_14543
											  in
											     x_14546
											  end
								     val return_21: word64 = 
									#2 x_14537
								     val post_9: word64
										 -> word64 = 
									#1 x_14537
								     val handlers_12: list_9 = 
									#0 x_14537
								     val x_14547: word64
										  * word64 = 
									(x_14432,
									 return_21)
								     val x_14548: bool = 
									x_8372 x_14547
								     val x_14549: word64 = 
									case x_14548 of
									true => 
									   let
									      val x_14563: word32 = 
										 Posix_Error_getErrno ()
									      val e_9: word32 = 
										 fromRep_1 x_14563
									      val x_14564: unit = 
										 ()
									      val x_14565: unit = 
										 atomicEnd_0 x_14564
									      val x_14566: word32
											   * list_9 = 
										 (e_9,
										  handlers_12)
									      val x_14567: word64 = 
										 errUnblocked_2 x_14566
									   in
									      x_14567
									   end
									false => 
									   let
									      val x_14550: DynamicWind.try.t_2 = 
										 let
										    val x_14551: word64 = 
										       post_9 return_21
										    val x_14552: DynamicWind.try.t_2 = 
										       A_2 x_14551
										 in
										    x_14552
										 end
										 handle x_14553 => let
												      val x_14554: DynamicWind.try.t_2 = 
													 E_2 x_14553
												   in
												      x_14554
												   end
									      val x_14555: word64 = 
										 case x_14550 of
										 A_2 x_14560: word64 => 
										    let
										       val x_14561: unit = 
											  ()
										       val x_14562: unit = 
											  atomicEnd_0 x_14561
										    in
										       x_14560
										    end
										 E_2 x_14556: exn => 
										    let
										       val x_14557: unit = 
											  ()
										       val x_14558: unit = 
											  atomicEnd_0 x_14557
										       val x_14559: word64 = 
											  raise x_14556
										    in
										       x_14559
										    end
									   in
									      x_14555
									   end
								  in
								     x_14549
								  end
							       false => 
								  let
								     val x_14471: unit
										  -> unit
										     -> unit = 
									Ref_deref[unit
										  -> unit
										     -> unit] (blocker_0)
								     val x_14472: unit = 
									()
								     val finish_2: unit
										   -> unit = 
									x_14471 x_14472
								     val x_14473: DynamicWind.try.t_2 = 
									let
									   val x_14474: unit = 
									      ()
									   val x_14475: unit = 
									      atomicBegin_0 x_14474
									   val x_14476: list_9
											* (word64
											   -> word64)
											* word64 = 
									      let
										 val x_14477: unit = 
										    ()
										 val return_18: word64 = 
										    x_14433 x_14477
										 val x_14478: word64
											      -> word64 = 
										    fn x_14479: word64 => 
										    let
										    in
										       x_14479
										    end
										 val x_14480: list_9 = 
										    nil_9
										 val x_14481: list_9
											      * (word64
												 -> word64)
											      * word64 = 
										    (x_14480,
										     x_14478,
										     return_18)
									      in
										 x_14481
									      end
									      handle x_14482 => let
												   val x_14483: unit = 
												      ()
												   val x_14484: unit = 
												      atomicEnd_0 x_14483
												   val x_14485: list_9
														* (word64
														   -> word64)
														* word64 = 
												      raise x_14482
												in
												   x_14485
												end
									   val return_19: word64 = 
									      #2 x_14476
									   val post_8: word64
										       -> word64 = 
									      #1 x_14476
									   val handlers_11: list_9 = 
									      #0 x_14476
									   val x_14486: word64
											* word64 = 
									      (x_14432,
									       return_19)
									   val x_14487: bool = 
									      x_8372 x_14486
									   val x_14488: word64 = 
									      case x_14487 of
									      true => 
										 let
										    val x_14502: word32 = 
										       Posix_Error_getErrno ()
										    val e_8: word32 = 
										       fromRep_1 x_14502
										    val x_14503: unit = 
										       ()
										    val x_14504: unit = 
										       atomicEnd_0 x_14503
										    val rec 
										       loop_38: list_9
												-> Primitive.Option.t_21 = 
											  fn x_14505: list_9 => 
											  let
											     val x_14506: Primitive.Option.t_21 = 
												case x_14505 of
												nil_9 => 
												   let
												      val x_14516: Primitive.Option.t_21 = 
													 NONE_19
												   in
												      x_14516
												   end
												::_9 x_14507: (word32
													       * (unit
														  -> word64))
													      * list_9 => 
												   let
												      val x_14508: list_9 = 
													 #1 x_14507
												      val x_14509: word32
														   * (unit
														      -> word64) = 
													 #0 x_14507
												      val x_14510: word32 = 
													 #0 x_14509
												      val x_14511: word32
														   * word32 = 
													 (e_8,
													  x_14510)
												      val x_14512: bool = 
													 x_8367 x_14511
												      val x_14513: Primitive.Option.t_21 = 
													 case x_14512 of
													 true => 
													    let
													       val x_14515: Primitive.Option.t_21 = 
														  SOME_21 x_14509
													    in
													       x_14515
													    end
													 false => 
													    let
													       val x_14514: Primitive.Option.t_21 = 
														  loop_38 x_14508
													    in
													       x_14514
													    end
												   in
												      x_14513
												   end
											  in
											     x_14506
											  end
										    val x_14517: Primitive.Option.t_21 = 
										       loop_38 handlers_11
										    val x_14518: word64 = 
										       case x_14517 of
										       NONE_19 => 
											  let
											     val x_14523: word64 = 
												raiseSys_2 e_8
											  in
											     x_14523
											  end
										       SOME_21 x_14519: word32
													* (unit
													   -> word64) => 
											  let
											     val x_14520: unit
													  -> word64 = 
												#1 x_14519
											     val x_14521: unit = 
												()
											     val x_14522: word64 = 
												x_14520 x_14521
											  in
											     x_14522
											  end
										 in
										    x_14518
										 end
									      false => 
										 let
										    val x_14489: DynamicWind.try.t_2 = 
										       let
											  val x_14490: word64 = 
											     post_8 return_19
											  val x_14491: DynamicWind.try.t_2 = 
											     A_2 x_14490
										       in
											  x_14491
										       end
										       handle x_14492 => let
													    val x_14493: DynamicWind.try.t_2 = 
													       E_2 x_14492
													 in
													    x_14493
													 end
										    val x_14494: word64 = 
										       case x_14489 of
										       A_2 x_14499: word64 => 
											  let
											     val x_14500: unit = 
												()
											     val x_14501: unit = 
												atomicEnd_0 x_14500
											  in
											     x_14499
											  end
										       E_2 x_14495: exn => 
											  let
											     val x_14496: unit = 
												()
											     val x_14497: unit = 
												atomicEnd_0 x_14496
											     val x_14498: word64 = 
												raise x_14495
											  in
											     x_14498
											  end
										 in
										    x_14494
										 end
									   val x_14524: DynamicWind.try.t_2 = 
									      A_2 x_14488
									in
									   x_14524
									end
									handle x_14525 => let
											     val x_14526: DynamicWind.try.t_2 = 
												E_2 x_14525
											  in
											     x_14526
											  end
								     val x_14527: word64 = 
									case x_14473 of
									A_2 x_14532: word64 => 
									   let
									      val x_14533: unit = 
										 ()
									      val x_14534: unit = 
										 finish_2 x_14533
									   in
									      x_14532
									   end
									E_2 x_14528: exn => 
									   let
									      val x_14529: unit = 
										 ()
									      val x_14530: unit = 
										 finish_2 x_14529
									      val x_14531: word64 = 
										 raise x_14528
									   in
									      x_14531
									   end
								  in
								     x_14527
								  end
							 in
							    x_14470
							 end
						      false => 
							 let
							    val x_14464: word64 = 
							       raiseSys_2 errno_2
							 in
							    x_14464
							 end
						in
						   x_14463
						end
					     SOME_21 x_14454: word32
							      * (unit -> word64) => 
						let
						   val x_14455: unit -> word64 = 
						      #1 x_14454
						   val x_14456: unit = 
						      ()
						   val x_14457: word64 = 
						      x_14455 x_14456
						in
						   x_14457
						end
				       in
					  x_14453
				       end
				 val x_14568: unit = 
				    ()
				 val x_14569: unit = 
				    atomicBegin_0 x_14568
				 val x_14570: list_9
					      * (word64 -> word64)
					      * word64 = 
				    let
				       val x_14571: unit = 
					  ()
				       val return_22: word64 = 
					  x_14433 x_14571
				       val x_14572: word64 -> word64 = 
					  fn x_14573: word64 => 
					  let
					  in
					     x_14573
					  end
				       val x_14574: list_9 = 
					  nil_9
				       val x_14575: list_9
						    * (word64 -> word64)
						    * word64 = 
					  (x_14574, x_14572, return_22)
				    in
				       x_14575
				    end
				    handle x_14576 => let
							 val x_14577: unit = 
							    ()
							 val x_14578: unit = 
							    atomicEnd_0 x_14577
							 val x_14579: list_9
								      * (word64
									 -> word64)
								      * word64 = 
							    raise x_14576
						      in
							 x_14579
						      end
				 val return_23: word64 = 
				    #2 x_14570
				 val post_10: word64 -> word64 = 
				    #1 x_14570
				 val handlers_13: list_9 = 
				    #0 x_14570
				 val x_14580: word64 * word64 = 
				    (x_14432, return_23)
				 val x_14581: bool = 
				    x_8372 x_14580
				 val x_14582: word64 = 
				    case x_14581 of
				    true => 
				       let
					  val x_14596: word32 = 
					     Posix_Error_getErrno ()
					  val e_10: word32 = 
					     fromRep_1 x_14596
					  val x_14597: unit = 
					     ()
					  val x_14598: unit = 
					     atomicEnd_0 x_14597
					  val x_14599: word32 * list_9 = 
					     (e_10, handlers_13)
					  val x_14600: word64 = 
					     errUnblocked_2 x_14599
				       in
					  x_14600
				       end
				    false => 
				       let
					  val x_14583: DynamicWind.try.t_2 = 
					     let
						val x_14584: word64 = 
						   post_10 return_23
						val x_14585: DynamicWind.try.t_2 = 
						   A_2 x_14584
					     in
						x_14585
					     end
					     handle x_14586 => let
								  val x_14587: DynamicWind.try.t_2 = 
								     E_2 x_14586
							       in
								  x_14587
							       end
					  val x_14588: word64 = 
					     case x_14583 of
					     A_2 x_14593: word64 => 
						let
						   val x_14594: unit = 
						      ()
						   val x_14595: unit = 
						      atomicEnd_0 x_14594
						in
						   x_14593
						end
					     E_2 x_14589: exn => 
						let
						   val x_14590: unit = 
						      ()
						   val x_14591: unit = 
						      atomicEnd_0 x_14590
						   val x_14592: word64 = 
						      raise x_14589
						in
						   x_14592
						end
				       in
					  x_14588
				       end
				 val bytesWrote_1: word32 = 
				    x_8890 x_14582
				 val x_14601: word32 = 
				    incPos_0 bytesWrote_1
			      in
				 x_14601
			      end
			val close_1: unit -> unit = 
			   fn x_14602: unit => 
			   let
			      val x_14603: bool = 
				 x_8321 closed_0
			      val x_14604: unit = 
				 case x_14603 of
				 true => 
				    let
				       val x_14777: unit = 
					  ()
				    in
				       x_14777
				    end
				 false => 
				    let
				       val x_14605: bool = 
					  true
				       val x_14606: bool ref * bool = 
					  (closed_0, x_14605)
				       val x_14607: unit = 
					  x_8342 x_14606
				       val x_14608: unit -> word32 = 
					  fn x_14609: unit => 
					  let
					     val x_14610: word32 = 
						toRep_1 fd_2
					     val x_14611: word32 = 
						Posix_IO_close (x_14610)
					  in
					     x_14611
					  end
				       val x_14612: word32 = 
					  0xFFFFFFFF
				       val x_14613: word32 = 
					  sextdFromInt32ToInt32_0 x_14612
				       val rec 
					  errUnblocked_3: word32 * list_10
							  -> word32 = 
					     fn x_14614: word32 * list_10 => 
					     let
						val handlers_14: list_10 = 
						   #1 x_14614
						val errno_3: word32 = 
						   #0 x_14614
						val rec 
						   loop_39: list_10
							    -> Primitive.Option.t_19 = 
						      fn x_14615: list_10 => 
						      let
							 val x_14616: Primitive.Option.t_19 = 
							    case x_14615 of
							    nil_10 => 
							       let
								  val x_14626: Primitive.Option.t_19 = 
								     NONE_17
							       in
								  x_14626
							       end
							    ::_10 x_14617: (word32
									    * (unit
									       -> word32))
									   * list_10 => 
							       let
								  val x_14618: list_10 = 
								     #1 x_14617
								  val x_14619: word32
									       * (unit
										  -> word32) = 
								     #0 x_14617
								  val x_14620: word32 = 
								     #0 x_14619
								  val x_14621: word32
									       * word32 = 
								     (errno_3,
								      x_14620)
								  val x_14622: bool = 
								     x_8367 x_14621
								  val x_14623: Primitive.Option.t_19 = 
								     case x_14622 of
								     true => 
									let
									   val x_14625: Primitive.Option.t_19 = 
									      SOME_19 x_14619
									in
									   x_14625
									end
								     false => 
									let
									   val x_14624: Primitive.Option.t_19 = 
									      loop_39 x_14618
									in
									   x_14624
									end
							       in
								  x_14623
							       end
						      in
							 x_14616
						      end
						val x_14627: Primitive.Option.t_19 = 
						   loop_39 handlers_14
						val x_14628: word32 = 
						   case x_14627 of
						   NONE_17 => 
						      let
							 val x_14633: word32
								      * word32 = 
							    (errno_3, intr_0)
							 val x_14634: bool = 
							    x_8367 x_14633
							 val x_14635: bool = 
							    case x_14634 of
							    true => 
							       let
								  val x_14637: bool = 
								     x_8321 restartFlag_0
							       in
								  x_14637
							       end
							    false => 
							       let
								  val x_14636: bool = 
								     false
							       in
								  x_14636
							       end
							 val x_14638: word32 = 
							    case x_14635 of
							    true => 
							       let
								  val x_14640: unit = 
								     ()
								  val x_14641: word32 = 
								     atomicState_0 x_14640
								  val x_14642: word32 = 
								     0x0
								  val x_14643: word32
									       * word32 = 
								     (x_14641,
								      x_14642)
								  val x_14644: bool = 
								     x_8367 x_14643
								  val x_14645: word32 = 
								     case x_14644 of
								     true => 
									let
									   val x_14710: unit = 
									      ()
									   val x_14711: unit = 
									      atomicBegin_0 x_14710
									   val x_14712: list_10
											* (word32
											   -> word32)
											* word32 = 
									      let
										 val x_14713: unit = 
										    ()
										 val return_27: word32 = 
										    x_14608 x_14713
										 val x_14714: word32
											      -> word32 = 
										    fn x_14715: word32 => 
										    let
										    in
										       x_14715
										    end
										 val x_14716: list_10 = 
										    nil_10
										 val x_14717: list_10
											      * (word32
												 -> word32)
											      * word32 = 
										    (x_14716,
										     x_14714,
										     return_27)
									      in
										 x_14717
									      end
									      handle x_14718 => let
												   val x_14719: unit = 
												      ()
												   val x_14720: unit = 
												      atomicEnd_0 x_14719
												   val x_14721: list_10
														* (word32
														   -> word32)
														* word32 = 
												      raise x_14718
												in
												   x_14721
												end
									   val return_28: word32 = 
									      #2 x_14712
									   val post_12: word32
											-> word32 = 
									      #1 x_14712
									   val handlers_16: list_10 = 
									      #0 x_14712
									   val return_29: word32 = 
									      x_8661 return_28
									   val x_14722: word32
											* word32 = 
									      (x_14613,
									       return_29)
									   val x_14723: bool = 
									      x_8367 x_14722
									   val x_14724: word32 = 
									      case x_14723 of
									      true => 
										 let
										    val x_14738: word32 = 
										       Posix_Error_getErrno ()
										    val e_12: word32 = 
										       fromRep_1 x_14738
										    val x_14739: unit = 
										       ()
										    val x_14740: unit = 
										       atomicEnd_0 x_14739
										    val x_14741: word32
												 * list_10 = 
										       (e_12,
											handlers_16)
										    val x_14742: word32 = 
										       errUnblocked_3 x_14741
										 in
										    x_14742
										 end
									      false => 
										 let
										    val x_14725: DynamicWind.try.t_1 = 
										       let
											  val x_14726: word32 = 
											     post_12 return_29
											  val x_14727: DynamicWind.try.t_1 = 
											     A_1 x_14726
										       in
											  x_14727
										       end
										       handle x_14728 => let
													    val x_14729: DynamicWind.try.t_1 = 
													       E_1 x_14728
													 in
													    x_14729
													 end
										    val x_14730: word32 = 
										       case x_14725 of
										       A_1 x_14735: word32 => 
											  let
											     val x_14736: unit = 
												()
											     val x_14737: unit = 
												atomicEnd_0 x_14736
											  in
											     x_14735
											  end
										       E_1 x_14731: exn => 
											  let
											     val x_14732: unit = 
												()
											     val x_14733: unit = 
												atomicEnd_0 x_14732
											     val x_14734: word32 = 
												raise x_14731
											  in
											     x_14734
											  end
										 in
										    x_14730
										 end
									in
									   x_14724
									end
								     false => 
									let
									   val x_14646: unit
											-> unit
											   -> unit = 
									      Ref_deref[unit
											-> unit
											   -> unit] (blocker_0)
									   val x_14647: unit = 
									      ()
									   val finish_3: unit
											 -> unit = 
									      x_14646 x_14647
									   val x_14648: DynamicWind.try.t_1 = 
									      let
										 val x_14649: unit = 
										    ()
										 val x_14650: unit = 
										    atomicBegin_0 x_14649
										 val x_14651: list_10
											      * (word32
												 -> word32)
											      * word32 = 
										    let
										       val x_14652: unit = 
											  ()
										       val return_24: word32 = 
											  x_14608 x_14652
										       val x_14653: word32
												    -> word32 = 
											  fn x_14654: word32 => 
											  let
											  in
											     x_14654
											  end
										       val x_14655: list_10 = 
											  nil_10
										       val x_14656: list_10
												    * (word32
												       -> word32)
												    * word32 = 
											  (x_14655,
											   x_14653,
											   return_24)
										    in
										       x_14656
										    end
										    handle x_14657 => let
													 val x_14658: unit = 
													    ()
													 val x_14659: unit = 
													    atomicEnd_0 x_14658
													 val x_14660: list_10
														      * (word32
															 -> word32)
														      * word32 = 
													    raise x_14657
												      in
													 x_14660
												      end
										 val return_25: word32 = 
										    #2 x_14651
										 val post_11: word32
											      -> word32 = 
										    #1 x_14651
										 val handlers_15: list_10 = 
										    #0 x_14651
										 val return_26: word32 = 
										    x_8661 return_25
										 val x_14661: word32
											      * word32 = 
										    (x_14613,
										     return_26)
										 val x_14662: bool = 
										    x_8367 x_14661
										 val x_14663: word32 = 
										    case x_14662 of
										    true => 
										       let
											  val x_14677: word32 = 
											     Posix_Error_getErrno ()
											  val e_11: word32 = 
											     fromRep_1 x_14677
											  val x_14678: unit = 
											     ()
											  val x_14679: unit = 
											     atomicEnd_0 x_14678
											  val rec 
											     loop_40: list_10
												      -> Primitive.Option.t_19 = 
												fn x_14680: list_10 => 
												let
												   val x_14681: Primitive.Option.t_19 = 
												      case x_14680 of
												      nil_10 => 
													 let
													    val x_14691: Primitive.Option.t_19 = 
													       NONE_17
													 in
													    x_14691
													 end
												      ::_10 x_14682: (word32
														      * (unit
															 -> word32))
														     * list_10 => 
													 let
													    val x_14683: list_10 = 
													       #1 x_14682
													    val x_14684: word32
															 * (unit
															    -> word32) = 
													       #0 x_14682
													    val x_14685: word32 = 
													       #0 x_14684
													    val x_14686: word32
															 * word32 = 
													       (e_11,
														x_14685)
													    val x_14687: bool = 
													       x_8367 x_14686
													    val x_14688: Primitive.Option.t_19 = 
													       case x_14687 of
													       true => 
														  let
														     val x_14690: Primitive.Option.t_19 = 
															SOME_19 x_14684
														  in
														     x_14690
														  end
													       false => 
														  let
														     val x_14689: Primitive.Option.t_19 = 
															loop_40 x_14683
														  in
														     x_14689
														  end
													 in
													    x_14688
													 end
												in
												   x_14681
												end
											  val x_14692: Primitive.Option.t_19 = 
											     loop_40 handlers_15
											  val x_14693: word32 = 
											     case x_14692 of
											     NONE_17 => 
												let
												   val x_14698: word32 = 
												      raiseSys_1 e_11
												in
												   x_14698
												end
											     SOME_19 x_14694: word32
													      * (unit
														 -> word32) => 
												let
												   val x_14695: unit
														-> word32 = 
												      #1 x_14694
												   val x_14696: unit = 
												      ()
												   val x_14697: word32 = 
												      x_14695 x_14696
												in
												   x_14697
												end
										       in
											  x_14693
										       end
										    false => 
										       let
											  val x_14664: DynamicWind.try.t_1 = 
											     let
												val x_14665: word32 = 
												   post_11 return_26
												val x_14666: DynamicWind.try.t_1 = 
												   A_1 x_14665
											     in
												x_14666
											     end
											     handle x_14667 => let
														  val x_14668: DynamicWind.try.t_1 = 
														     E_1 x_14667
													       in
														  x_14668
													       end
											  val x_14669: word32 = 
											     case x_14664 of
											     A_1 x_14674: word32 => 
												let
												   val x_14675: unit = 
												      ()
												   val x_14676: unit = 
												      atomicEnd_0 x_14675
												in
												   x_14674
												end
											     E_1 x_14670: exn => 
												let
												   val x_14671: unit = 
												      ()
												   val x_14672: unit = 
												      atomicEnd_0 x_14671
												   val x_14673: word32 = 
												      raise x_14670
												in
												   x_14673
												end
										       in
											  x_14669
										       end
										 val x_14699: DynamicWind.try.t_1 = 
										    A_1 x_14663
									      in
										 x_14699
									      end
									      handle x_14700 => let
												   val x_14701: DynamicWind.try.t_1 = 
												      E_1 x_14700
												in
												   x_14701
												end
									   val x_14702: word32 = 
									      case x_14648 of
									      A_1 x_14707: word32 => 
										 let
										    val x_14708: unit = 
										       ()
										    val x_14709: unit = 
										       finish_3 x_14708
										 in
										    x_14707
										 end
									      E_1 x_14703: exn => 
										 let
										    val x_14704: unit = 
										       ()
										    val x_14705: unit = 
										       finish_3 x_14704
										    val x_14706: word32 = 
										       raise x_14703
										 in
										    x_14706
										 end
									in
									   x_14702
									end
							       in
								  x_14645
							       end
							    false => 
							       let
								  val x_14639: word32 = 
								     raiseSys_1 errno_3
							       in
								  x_14639
							       end
						      in
							 x_14638
						      end
						   SOME_19 x_14629: word32
								    * (unit
								       -> word32) => 
						      let
							 val x_14630: unit
								      -> word32 = 
							    #1 x_14629
							 val x_14631: unit = 
							    ()
							 val x_14632: word32 = 
							    x_14630 x_14631
						      in
							 x_14632
						      end
					     in
						x_14628
					     end
				       val x_14743: unit = 
					  ()
				       val x_14744: unit = 
					  atomicBegin_0 x_14743
				       val x_14745: list_10
						    * (word32 -> word32)
						    * word32 = 
					  let
					     val x_14746: unit = 
						()
					     val return_30: word32 = 
						x_14608 x_14746
					     val x_14747: word32 -> word32 = 
						fn x_14748: word32 => 
						let
						in
						   x_14748
						end
					     val x_14749: list_10 = 
						nil_10
					     val x_14750: list_10
							  * (word32 -> word32)
							  * word32 = 
						(x_14749, x_14747, return_30)
					  in
					     x_14750
					  end
					  handle x_14751 => let
							       val x_14752: unit = 
								  ()
							       val x_14753: unit = 
								  atomicEnd_0 x_14752
							       val x_14754: list_10
									    * (word32
									       -> word32)
									    * word32 = 
								  raise x_14751
							    in
							       x_14754
							    end
				       val return_31: word32 = 
					  #2 x_14745
				       val post_13: word32 -> word32 = 
					  #1 x_14745
				       val handlers_17: list_10 = 
					  #0 x_14745
				       val return_32: word32 = 
					  x_8661 return_31
				       val x_14755: word32 * word32 = 
					  (x_14613, return_32)
				       val x_14756: bool = 
					  x_8367 x_14755
				       val x_14757: word32 = 
					  case x_14756 of
					  true => 
					     let
						val x_14771: word32 = 
						   Posix_Error_getErrno ()
						val e_13: word32 = 
						   fromRep_1 x_14771
						val x_14772: unit = 
						   ()
						val x_14773: unit = 
						   atomicEnd_0 x_14772
						val x_14774: word32 * list_10 = 
						   (e_13, handlers_17)
						val x_14775: word32 = 
						   errUnblocked_3 x_14774
					     in
						x_14775
					     end
					  false => 
					     let
						val x_14758: DynamicWind.try.t_1 = 
						   let
						      val x_14759: word32 = 
							 post_13 return_32
						      val x_14760: DynamicWind.try.t_1 = 
							 A_1 x_14759
						   in
						      x_14760
						   end
						   handle x_14761 => let
									val x_14762: DynamicWind.try.t_1 = 
									   E_1 x_14761
								     in
									x_14762
								     end
						val x_14763: word32 = 
						   case x_14758 of
						   A_1 x_14768: word32 => 
						      let
							 val x_14769: unit = 
							    ()
							 val x_14770: unit = 
							    atomicEnd_0 x_14769
						      in
							 x_14768
						      end
						   E_1 x_14764: exn => 
						      let
							 val x_14765: unit = 
							    ()
							 val x_14766: unit = 
							    atomicEnd_0 x_14765
							 val x_14767: word32 = 
							    raise x_14764
						      in
							 x_14767
						      end
					     in
						x_14763
					     end
				       val x_14776: unit = 
					  ()
				    in
				       x_14776
				    end
			   in
			      x_14604
			   end
			val x_14778: Primitive.Option.t_7 = 
			   NONE_7
			val x_14779: Primitive.Option.t_8 = 
			   NONE_8
			val x_14780: word32 = 
			   toRep_1 fd_2
			val x_14781: Primitive.Option.t_0 = 
			   SOME_0 x_14780
			val x_14782: bool = 
			   true
			val x_14783: PrimSequence.Slice.t_0 -> word32 = 
			   fn x_14784: PrimSequence.Slice.t_0 => 
			   let
			      val x_14785: bool = 
				 x_8321 closed_0
			      val x_14786: unit = 
				 case x_14785 of
				 true => 
				    let
				       val x_14788: unit = 
					  raise x_13298
				    in
				       x_14788
				    end
				 false => 
				    let
				       val x_14787: unit = 
					  ()
				    in
				       x_14787
				    end
			      val x_14789: bool = 
				 x_8321 blocking_0
			      val x_14790: unit = 
				 case x_14789 of
				 true => 
				    let
				       val x_14803: unit = 
					  ()
				    in
				       x_14803
				    end
				 false => 
				    let
				       val x_14791: bool ref * bool = 
					  (blocking_0, x_14782)
				       val x_14792: unit = 
					  x_8342 x_14791
				       val x_14793: bool = 
					  x_8321 blocking_0
				       val x_14794: word32 = 
					  case x_14793 of
					  true => 
					     let
					     in
						appendFlgs_0
					     end
					  false => 
					     let
						val x_14795: list_4 = 
						   nil_4
						val x_14796: word32 * list_4 = 
						   (appendFlgs_0, x_14795)
						val x_14797: list_4 = 
						   ::_4 x_14796
						val x_14798: word32 * list_4 = 
						   (NONBLOCK_0, x_14797)
						val x_14799: list_4 = 
						   ::_4 x_14798
						val x_14800: word32 = 
						   x_13397 x_14799
					     in
						x_14800
					     end
				       val x_14801: word32 * word32 = 
					  (fd_2, x_14794)
				       val x_14802: unit = 
					  setfl_0 x_14801
				    in
				       x_14802
				    end
			      val x_14804: word32 * PrimSequence.Slice.t_0 = 
				 (fd_2, x_14784)
			      val x_14805: word32 = 
				 putA_0 x_14804
			   in
			      x_14805
			   end
			val x_14806: Primitive.Option.t_10 = 
			   SOME_10 x_14783
			val x_14807: bool = 
			   false
			val x_14808: PrimSequence.Slice.t_0
				     -> Primitive.Option.t_0 = 
			   fn x_14809: PrimSequence.Slice.t_0 => 
			   let
			      val x_14810: Primitive.Option.t_0 = 
				 let
				    val x_14811: bool = 
				       x_8321 closed_0
				    val x_14812: unit = 
				       case x_14811 of
				       true => 
					  let
					     val x_14814: unit = 
						raise x_13298
					  in
					     x_14814
					  end
				       false => 
					  let
					     val x_14813: unit = 
						()
					  in
					     x_14813
					  end
				    val x_14815: bool = 
				       x_8321 blocking_0
				    val x_14816: unit = 
				       case x_14815 of
				       true => 
					  let
					     val x_14829: unit = 
						()
					  in
					     x_14829
					  end
				       false => 
					  let
					     val x_14817: bool ref * bool = 
						(blocking_0, x_14807)
					     val x_14818: unit = 
						x_8342 x_14817
					     val x_14819: bool = 
						x_8321 blocking_0
					     val x_14820: word32 = 
						case x_14819 of
						true => 
						   let
						   in
						      appendFlgs_0
						   end
						false => 
						   let
						      val x_14821: list_4 = 
							 nil_4
						      val x_14822: word32
								   * list_4 = 
							 (appendFlgs_0, x_14821)
						      val x_14823: list_4 = 
							 ::_4 x_14822
						      val x_14824: word32
								   * list_4 = 
							 (NONBLOCK_0, x_14823)
						      val x_14825: list_4 = 
							 ::_4 x_14824
						      val x_14826: word32 = 
							 x_13397 x_14825
						   in
						      x_14826
						   end
					     val x_14827: word32 * word32 = 
						(fd_2, x_14820)
					     val x_14828: unit = 
						setfl_0 x_14827
					  in
					     x_14828
					  end
				    val x_14830: word32 * PrimSequence.Slice.t_0 = 
				       (fd_2, x_14809)
				    val x_14831: word32 = 
				       putA_0 x_14830
				    val x_14832: Primitive.Option.t_0 = 
				       SOME_0 x_14831
				 in
				    x_14832
				 end
				 handle x_14833 => let
						      val x_14834: exn
								   -> Primitive.Option.t_0 = 
							 fn x_14835: exn => 
							 let
							    val x_14836: Primitive.Option.t_0 = 
							       raise x_14835
							 in
							    x_14836
							 end
						      val x_14837: unit
								   -> Primitive.Option.t_0 = 
							 fn unit_27: unit => 
							 let
							    val x_14838: Primitive.Option.t_0 = 
							       x_14834 x_14833
							 in
							    x_14838
							 end
						      val x_14839: Primitive.Option.t_0 = 
							 case x_14833 of
							 SysErr_0 x_14840: unit ref
									   * (word8 vector
									      * Primitive.Option.t_0) => 
							    let
							       val x_14841: word8 vector
									    * Primitive.Option.t_0 = 
								  #1 x_14840
							       val x_14842: unit ref = 
								  #0 x_14840
							       val x_14843: bool = 
								  MLton_equal[unit ref] (x_14842,
											 x_11324)
							       val x_14844: Primitive.Option.t_0 = 
								  case x_14843 of
								  true => 
								     let
									val x_14847: Primitive.Option.t_0 = 
									   #1 x_14841
									val x_14848: Primitive.Option.t_0 = 
									   case x_14847 of
									   SOME_0 x_14849: word32 => 
									      let
										 val x_14850: word32
											      * word32 = 
										    (x_14849,
										     again_0)
										 val x_14851: bool = 
										    x_8367 x_14850
										 val x_14852: Primitive.Option.t_0 = 
										    case x_14851 of
										    true => 
										       let
											  val x_14854: Primitive.Option.t_0 = 
											     NONE_0
										       in
											  x_14854
										       end
										    false => 
										       let
											  val x_14853: Primitive.Option.t_0 = 
											     raise x_14833
										       in
											  x_14853
										       end
									      in
										 x_14852
									      end
									     _ => let
										     val x_14855: Primitive.Option.t_0 = 
											x_14834 x_14833
										  in
										     x_14855
										  end
								     in
									x_14848
								     end
								  false => 
								     let
									val x_14845: unit = 
									   ()
									val x_14846: Primitive.Option.t_0 = 
									   x_14837 x_14845
								     in
									x_14846
								     end
							    in
							       x_14844
							    end
							   _ => let
								   val x_14856: unit = 
								      ()
								   val x_14857: Primitive.Option.t_0 = 
								      x_14837 x_14856
								in
								   x_14857
								end
						   in
						      x_14839
						   end
			   in
			      x_14810
			   end
			val x_14858: Primitive.Option.t_11 = 
			   SOME_11 x_14808
			val x_14859: bool = 
			   true
			val x_14860: PrimSequence.Slice.t_1 -> word32 = 
			   fn x_14861: PrimSequence.Slice.t_1 => 
			   let
			      val x_14862: bool = 
				 x_8321 closed_0
			      val x_14863: unit = 
				 case x_14862 of
				 true => 
				    let
				       val x_14865: unit = 
					  raise x_13298
				    in
				       x_14865
				    end
				 false => 
				    let
				       val x_14864: unit = 
					  ()
				    in
				       x_14864
				    end
			      val x_14866: bool = 
				 x_8321 blocking_0
			      val x_14867: unit = 
				 case x_14866 of
				 true => 
				    let
				       val x_14880: unit = 
					  ()
				    in
				       x_14880
				    end
				 false => 
				    let
				       val x_14868: bool ref * bool = 
					  (blocking_0, x_14859)
				       val x_14869: unit = 
					  x_8342 x_14868
				       val x_14870: bool = 
					  x_8321 blocking_0
				       val x_14871: word32 = 
					  case x_14870 of
					  true => 
					     let
					     in
						appendFlgs_0
					     end
					  false => 
					     let
						val x_14872: list_4 = 
						   nil_4
						val x_14873: word32 * list_4 = 
						   (appendFlgs_0, x_14872)
						val x_14874: list_4 = 
						   ::_4 x_14873
						val x_14875: word32 * list_4 = 
						   (NONBLOCK_0, x_14874)
						val x_14876: list_4 = 
						   ::_4 x_14875
						val x_14877: word32 = 
						   x_13397 x_14876
					     in
						x_14877
					     end
				       val x_14878: word32 * word32 = 
					  (fd_2, x_14871)
				       val x_14879: unit = 
					  setfl_0 x_14878
				    in
				       x_14879
				    end
			      val x_14881: word32 * PrimSequence.Slice.t_1 = 
				 (fd_2, x_14861)
			      val x_14882: word32 = 
				 putV_0 x_14881
			   in
			      x_14882
			   end
			val x_14883: Primitive.Option.t_15 = 
			   SOME_15 x_14860
			val x_14884: bool = 
			   false
			val x_14885: PrimSequence.Slice.t_1
				     -> Primitive.Option.t_0 = 
			   fn x_14886: PrimSequence.Slice.t_1 => 
			   let
			      val x_14887: Primitive.Option.t_0 = 
				 let
				    val x_14888: bool = 
				       x_8321 closed_0
				    val x_14889: unit = 
				       case x_14888 of
				       true => 
					  let
					     val x_14891: unit = 
						raise x_13298
					  in
					     x_14891
					  end
				       false => 
					  let
					     val x_14890: unit = 
						()
					  in
					     x_14890
					  end
				    val x_14892: bool = 
				       x_8321 blocking_0
				    val x_14893: unit = 
				       case x_14892 of
				       true => 
					  let
					     val x_14906: unit = 
						()
					  in
					     x_14906
					  end
				       false => 
					  let
					     val x_14894: bool ref * bool = 
						(blocking_0, x_14884)
					     val x_14895: unit = 
						x_8342 x_14894
					     val x_14896: bool = 
						x_8321 blocking_0
					     val x_14897: word32 = 
						case x_14896 of
						true => 
						   let
						   in
						      appendFlgs_0
						   end
						false => 
						   let
						      val x_14898: list_4 = 
							 nil_4
						      val x_14899: word32
								   * list_4 = 
							 (appendFlgs_0, x_14898)
						      val x_14900: list_4 = 
							 ::_4 x_14899
						      val x_14901: word32
								   * list_4 = 
							 (NONBLOCK_0, x_14900)
						      val x_14902: list_4 = 
							 ::_4 x_14901
						      val x_14903: word32 = 
							 x_13397 x_14902
						   in
						      x_14903
						   end
					     val x_14904: word32 * word32 = 
						(fd_2, x_14897)
					     val x_14905: unit = 
						setfl_0 x_14904
					  in
					     x_14905
					  end
				    val x_14907: word32 * PrimSequence.Slice.t_1 = 
				       (fd_2, x_14886)
				    val x_14908: word32 = 
				       putV_0 x_14907
				    val x_14909: Primitive.Option.t_0 = 
				       SOME_0 x_14908
				 in
				    x_14909
				 end
				 handle x_14910 => let
						      val x_14911: exn
								   -> Primitive.Option.t_0 = 
							 fn x_14912: exn => 
							 let
							    val x_14913: Primitive.Option.t_0 = 
							       raise x_14912
							 in
							    x_14913
							 end
						      val x_14914: unit
								   -> Primitive.Option.t_0 = 
							 fn unit_28: unit => 
							 let
							    val x_14915: Primitive.Option.t_0 = 
							       x_14911 x_14910
							 in
							    x_14915
							 end
						      val x_14916: Primitive.Option.t_0 = 
							 case x_14910 of
							 SysErr_0 x_14917: unit ref
									   * (word8 vector
									      * Primitive.Option.t_0) => 
							    let
							       val x_14918: word8 vector
									    * Primitive.Option.t_0 = 
								  #1 x_14917
							       val x_14919: unit ref = 
								  #0 x_14917
							       val x_14920: bool = 
								  MLton_equal[unit ref] (x_14919,
											 x_11324)
							       val x_14921: Primitive.Option.t_0 = 
								  case x_14920 of
								  true => 
								     let
									val x_14924: Primitive.Option.t_0 = 
									   #1 x_14918
									val x_14925: Primitive.Option.t_0 = 
									   case x_14924 of
									   SOME_0 x_14926: word32 => 
									      let
										 val x_14927: word32
											      * word32 = 
										    (x_14926,
										     again_0)
										 val x_14928: bool = 
										    x_8367 x_14927
										 val x_14929: Primitive.Option.t_0 = 
										    case x_14928 of
										    true => 
										       let
											  val x_14931: Primitive.Option.t_0 = 
											     NONE_0
										       in
											  x_14931
										       end
										    false => 
										       let
											  val x_14930: Primitive.Option.t_0 = 
											     raise x_14910
										       in
											  x_14930
										       end
									      in
										 x_14929
									      end
									     _ => let
										     val x_14932: Primitive.Option.t_0 = 
											x_14911 x_14910
										  in
										     x_14932
										  end
								     in
									x_14925
								     end
								  false => 
								     let
									val x_14922: unit = 
									   ()
									val x_14923: Primitive.Option.t_0 = 
									   x_14914 x_14922
								     in
									x_14923
								     end
							    in
							       x_14921
							    end
							   _ => let
								   val x_14933: unit = 
								      ()
								   val x_14934: Primitive.Option.t_0 = 
								      x_14914 x_14933
								in
								   x_14934
								end
						   in
						      x_14916
						   end
			   in
			      x_14887
			   end
			val x_14935: Primitive.Option.t_16 = 
			   SOME_16 x_14885
			val x_14936: Primitive.Option.t_7
				     * Primitive.Option.t_8
				     * word32
				     * (unit -> unit)
				     * Primitive.Option.t_9
				     * Primitive.Option.t_9
				     * Primitive.Option.t_0
				     * word8 vector
				     * Primitive.Option.t_14
				     * Primitive.Option.t_9
				     * Primitive.Option.t_10
				     * Primitive.Option.t_11
				     * Primitive.Option.t_15
				     * Primitive.Option.t_16 = 
			   (x_14778,
			    x_14779,
			    chunkSize_0,
			    close_1,
			    endPos_1,
			    getPos_1,
			    x_14781,
			    name_1,
			    setPos_1,
			    verifyPos_1,
			    x_14806,
			    x_14858,
			    x_14883,
			    x_14935)
			val x_14937: PrimIO.writer_0 = 
			   WR_0 x_14936
			val x_14938: Primitive.Option.t_15 = 
			   SOME_15 x_14860
			val x_14939: Primitive.Option.t_16 = 
			   SOME_16 x_14885
			val x_14940: Primitive.Option.t_10 = 
			   SOME_10 x_14783
			val x_14941: Primitive.Option.t_11 = 
			   SOME_11 x_14808
			val x_14942: Primitive.Option.t_7
				     * Primitive.Option.t_8
				     * word32
				     * (unit -> unit)
				     * Primitive.Option.t_9
				     * Primitive.Option.t_9
				     * Primitive.Option.t_0
				     * word8 vector
				     * Primitive.Option.t_14
				     * Primitive.Option.t_9
				     * Primitive.Option.t_10
				     * Primitive.Option.t_11
				     * Primitive.Option.t_15
				     * Primitive.Option.t_16 = 
			   (x_14778,
			    x_14779,
			    chunkSize_0,
			    close_1,
			    endPos_1,
			    getPos_1,
			    x_14781,
			    name_1,
			    setPos_1,
			    verifyPos_1,
			    x_14940,
			    x_14941,
			    x_14938,
			    x_14939)
			val x_14943: PrimIO.writer_0 = 
			   WR_0 x_14942
			val x_14944: StreamIOExtra.state_0 = 
			   Active_0
			val x_14945: StreamIOExtra.state_0 ref = 
			   Ref_ref[StreamIOExtra.state_0] (x_14944)
			val x_14946: StreamIOExtra.bufferMode_0 = 
			   case bufferMode_0 of
			   NO_BUF_0 => 
			      let
				 val x_14961: StreamIOExtra.bufferMode_0 = 
				    NO_BUF_1
			      in
				 x_14961
			      end
			   BLOCK_BUF_0 => 
			      let
				 val x_14954: word32 = 
				    0x0
				 val x_14955: word32 ref = 
				    Ref_ref[word32] (x_14954)
				 val x_14956: word32 * word8 = 
				    (chunkSize_0, someElem_0)
				 val x_14957: word8 array = 
				    new_2 x_14956
				 val x_14958: word8 array * word32 ref = 
				    (x_14957, x_14955)
				 val x_14959: StreamIOExtra.buf_0 = 
				    Buf_0 x_14958
				 val x_14960: StreamIOExtra.bufferMode_0 = 
				    BLOCK_BUF_1 x_14959
			      in
				 x_14960
			      end
			   LINE_BUF_0 => 
			      let
				 val x_14947: word32 = 
				    0x0
				 val x_14948: word32 ref = 
				    Ref_ref[word32] (x_14947)
				 val x_14949: word32 * word8 = 
				    (chunkSize_0, someElem_0)
				 val x_14950: word8 array = 
				    new_2 x_14949
				 val x_14951: word8 array * word32 ref = 
				    (x_14950, x_14948)
				 val x_14952: StreamIOExtra.buf_0 = 
				    Buf_0 x_14951
				 val x_14953: StreamIOExtra.bufferMode_0 = 
				    LINE_BUF_1 x_14952
			      in
				 x_14953
			      end
			val x_14962: StreamIOExtra.bufferMode_0 ref = 
			   Ref_ref[StreamIOExtra.bufferMode_0] (x_14946)
			val x_14963: PrimIO.writer_0
				     * StreamIOExtra.bufferMode_0 ref
				     * StreamIOExtra.state_0 ref
				     * PrimIO.writer_0 = 
			   (x_14943, x_14962, x_14945, x_14937)
			val x_14964: StreamIOExtra.outstream_0 = 
			   Out_0 x_14963
			val x_14965: StreamIOExtra.outstream_0 * bool = 
			   (x_14964, closeAtExit_0)
			val x_14966: list_5 = 
			   x_8303 openOutstreams_0
			val x_14967: (StreamIOExtra.outstream_0 * bool) * list_5 = 
			   (x_14965, x_14966)
			val x_14968: list_5 = 
			   ::_5 x_14967
			val x_14969: unit = 
			   Ref_assign[list_5] (openOutstreams_0, x_14968)
			val x_14970: StreamIOExtra.outstream_0 ref = 
			   Ref_ref[StreamIOExtra.outstream_0] (x_14964)
			val x_14971: ImperativeIOExtra.Outstream.t_0 = 
			   T_6 x_14970
		     in
			x_14971
		     end
	       val x_14972: bool = 
		  true
	       val x_14973: IO.buffer_mode_0 = 
		  NO_BUF_0
	       val x_14974: bool = 
		  false
	       val x_14975: word8 vector = 
		  "<stderr>"
	       val x_14976: bool
			    * IO.buffer_mode_0
			    * bool
			    * word32
			    * word8 vector = 
		  (x_14972, x_14973, x_14974, stderr_0, x_14975)
	       val stdErr_0: ImperativeIOExtra.Outstream.t_0 = 
		  newOut_0 x_14976
	       val x_14977: bool = 
		  true
	       val x_14978: bool = 
		  false
	       val x_14979: word8 vector = 
		  "<stdout>"
	       val x_14980: word32 = 
		  toRep_1 stdout_0
	       val x_14981: word32 = 
		  Posix_ProcEnv_isatty (x_14980)
	       val x_14982: word32 * word32 = 
		  (x_14981, zero_3)
	       val x_14983: bool = 
		  x_8382 x_14982
	       val x_14984: IO.buffer_mode_0 = 
		  case x_14983 of
		  true => 
		     let
			val x_14986: IO.buffer_mode_0 = 
			   LINE_BUF_0
		     in
			x_14986
		     end
		  false => 
		     let
			val x_14985: IO.buffer_mode_0 = 
			   BLOCK_BUF_0
		     in
			x_14985
		     end
	       val x_14987: bool
			    * IO.buffer_mode_0
			    * bool
			    * word32
			    * word8 vector = 
		  (x_14977, x_14984, x_14978, stdout_0, x_14979)
	       val x_14988: ImperativeIOExtra.Outstream.t_0 = 
		  newOut_0 x_14987
	       val x_14989: word32 -> word32 = 
		  fn x_14990: word32 => 
		  let
		     val x_14991: word32 = 
			sextdFromInt32ToInt32_0 x_14990
		  in
		     x_14991
		  end
	       val x_14992: word32 = 
		  0x1
	       val failure_0: word32 = 
		  x_14989 x_14992
	       val x_14993: word32 = 
		  0x0
	       val success_0: word32 = 
		  x_14989 x_14993
	       val x_14994: bool = 
		  false
	       val exiting_0: bool ref = 
		  Ref_ref[bool] (x_14994)
	       val rec 
		  halt_1: word32 -> unit = 
		     fn x_14995: word32 => 
		     let
			val x_14996: word32 = 
			   toRep_0 x_14995
			val x_14997: unit = 
			   halt_0 x_14996
		     in
			x_14997
		     end
	       val rec 
		  exit_0: word32 -> unit = 
		     fn x_14998: word32 => 
		     let
			val x_14999: bool = 
			   x_8321 exiting_0
			val x_15000: unit = 
			   case x_14999 of
			   true => 
			      let
				 val x_15134: word8 vector = 
				    "MLton.Exit.exit"
				 val x_15135: unit ref * word8 vector = 
				    (x_9554, x_15134)
				 val x_15136: exn = 
				    Fail_0 x_15135
				 val x_15137: unit = 
				    raise x_15136
			      in
				 x_15137
			      end
			   false => 
			      let
				 val x_15001: bool = 
				    true
				 val x_15002: bool ref * bool = 
				    (exiting_0, x_15001)
				 val x_15003: unit = 
				    x_8342 x_15002
				 val x_15004: word32 = 
				    toRep_0 x_14998
				 val x_15005: word32 = 
				    sextdFromInt32ToInt32_0 x_15004
				 val x_15006: word32 = 
				    0x0
				 val x_15007: word32 * word32 = 
				    (x_15006, x_15005)
				 val x_15008: bool = 
				    <=_0 x_15007
				 val x_15009: bool = 
				    case x_15008 of
				    true => 
				       let
					  val x_15011: word32 = 
					     0x100
					  val x_15012: word32 * word32 = 
					     (x_15005, x_15011)
					  val x_15013: bool = 
					     <_1 x_15012
				       in
					  x_15013
				       end
				    false => 
				       let
					  val x_15010: bool = 
					     false
				       in
					  x_15010
				       end
				 val x_15014: unit = 
				    case x_15009 of
				    true => 
				       let
					  val x_15113: unit = 
					     ()
					  val x_15114: list_2 = 
					     x_8297 atExit_0
					  val rec 
					     loop_42: list_2 * unit -> unit = 
						fn x_15115: list_2 * unit => 
						let
						   val b_50: unit = 
						      #1 x_15115
						   val l_5: list_2 = 
						      #0 x_15115
						   val x_15116: unit = 
						      case l_5 of
						      nil_2 => 
							 let
							 in
							    b_50
							 end
						      ::_2 x_15117: (unit
								     -> unit)
								    * list_2 => 
							 let
							    val x_15118: list_2 = 
							       #1 x_15117
							    val x_15119: unit
									 -> unit = 
							       #0 x_15117
							    val x_15120: unit = 
							       let
								  val x_15121: unit = 
								     ()
								  val x_15122: unit = 
								     x_15119 x_15121
							       in
								  x_15122
							       end
							       handle x_15123 => let
										    val x_15124: unit = 
										       ()
										 in
										    x_15124
										 end
							    val x_15125: list_2
									 * unit = 
							       (x_15118, x_15120)
							    val x_15126: unit = 
							       loop_42 x_15125
							 in
							    x_15126
							 end
						in
						   x_15116
						end
					  val x_15127: list_2 * unit = 
					     (x_15114, x_15113)
					  val x_15128: unit = 
					     loop_42 x_15127
					  val x_15129: unit = 
					     halt_1 x_14998
					  val x_15130: word8 vector = 
					     "MLton.Exit.exit"
					  val x_15131: unit ref * word8 vector = 
					     (x_9554, x_15130)
					  val x_15132: exn = 
					     Fail_0 x_15131
					  val x_15133: unit = 
					     raise x_15132
				       in
					  x_15133
				       end
				    false => 
				       let
					  val x_15015: list_7 = 
					     nil_7
					  val x_15016: word8 vector = 
					     "exit must have 0 <= status < 256"
					  val x_15017: word8 vector * list_7 = 
					     (x_15016, x_15015)
					  val x_15018: list_7 = 
					     ::_7 x_15017
					  val x_15019: word8 vector = 
					     "): "
					  val x_15020: word8 vector * list_7 = 
					     (x_15019, x_15018)
					  val x_15021: list_7 = 
					     ::_7 x_15020
					  val x_15022: unit = 
					     ()
					  val x_15023: unit = 
					     atomicBegin_0 x_15022
					  val b_49: bool = 
					     x_8321 x_10218
					  val x_15024: word8 array = 
					     case b_49 of
					     true => 
						let
						   val x_15030: unit = 
						      ()
						   val x_15031: unit = 
						      atomicEnd_0 x_15030
						   val x_15032: unit = 
						      ()
						   val x_15033: word8 array = 
						      x_10210 x_15032
						in
						   x_15033
						end
					     false => 
						let
						   val x_15025: bool = 
						      true
						   val x_15026: bool ref * bool = 
						      (x_10218, x_15025)
						   val x_15027: unit = 
						      x_8342 x_15026
						   val x_15028: unit = 
						      ()
						   val x_15029: unit = 
						      atomicEnd_0 x_15028
						in
						   x_10216
						end
					  val x_15034: unit -> unit = 
					     fn x_15035: unit => 
					     let
						val x_15036: unit = 
						   case b_49 of
						   true => 
						      let
							 val x_15040: unit = 
							    ()
						      in
							 x_15040
						      end
						   false => 
						      let
							 val x_15037: bool = 
							    false
							 val x_15038: bool ref
								      * bool = 
							    (x_10218, x_15037)
							 val x_15039: unit = 
							    x_8342 x_15038
						      in
							 x_15039
						      end
					     in
						x_15036
					     end
					  val x_15041: DynamicWind.try.t_0 = 
					     let
						val x_15042: word32 = 
						   radixToInt_0 x_10219
						val radix_1: word32 = 
						   sextdFromInt32ToInt32_0 x_15042
						val rec 
						   loop_41: word32 * word32
							    -> word8 vector = 
						      fn x_15043: word32
								  * word32 => 
						      let
							 val i_43: word32 = 
							    #1 x_15043
							 val q_2: word32 = 
							    #0 x_15043
							 val x_15044: word32
								      * word32 = 
							    (radix_1, zero_3)
							 val x_15045: bool = 
							    x_8367 x_15044
							 val x_15046: word32 = 
							    case x_15045 of
							    true => 
							       let
								  val x_15057: word32 = 
								     raise x_8282
							       in
								  x_15057
							       end
							    false => 
							       let
								  val x_15047: word32
									       * word32 = 
								     (q_2,
								      minInt'_2)
								  val x_15048: bool = 
								     x_8367 x_15047
								  val x_15049: bool = 
								     case x_15048 of
								     true => 
									let
									   val x_15051: word32 = 
									      x_8530 one_3
									   val x_15052: word32
											* word32 = 
									      (radix_1,
									       x_15051)
									   val x_15053: bool = 
									      x_8367 x_15052
									in
									   x_15053
									end
								     false => 
									let
									   val x_15050: bool = 
									      false
									in
									   x_15050
									end
								  val x_15054: word32 = 
								     case x_15049 of
								     true => 
									let
									in
									   zero_3
									end
								     false => 
									let
									   val x_15055: word32
											* word32 = 
									      (q_2,
									       radix_1)
									   val x_15056: word32 = 
									      remUnsafe_0 x_15055
									in
									   x_15056
									end
							       in
								  x_15054
							       end
							 val x_15058: word32 = 
							    ~?_0 x_15046
							 val x_15059: word32 = 
							    sextdFromInt32ToInt32_0 x_15058
							 val x_15060: word8 = 
							    digitToChar_0 x_15059
							 val x_15061: word8 array
								      * word32
								      * word8 = 
							    (x_15024,
							     i_43,
							     x_15060)
							 val x_15062: unit = 
							    update_2 x_15061
							 val x_15063: word32
								      * word32 = 
							    (q_2, radix_1)
							 val q_3: word32 = 
							    quot_0 x_15063
							 val x_15064: word32
								      * word32 = 
							    (q_3, zero_3)
							 val x_15065: bool = 
							    x_8367 x_15064
							 val x_15066: word8 vector = 
							    case x_15065 of
							    true => 
							       let
								  val x_15072: word32
									       * word32 = 
								     (x_15005,
								      zero_3)
								  val x_15073: bool = 
								     <_1 x_15072
								  val x_15074: word32 = 
								     case x_15073 of
								     true => 
									let
									   val x_15075: word32 = 
									      0x1
									   val x_15076: word32
											* word32 = 
									      (i_43,
									       x_15075)
									   val i_44: word32 = 
									      x_8548 x_15076
									   val x_15077: word8 = 
									      0x7E
									   val x_15078: word8 array
											* word32
											* word8 = 
									      (x_15024,
									       i_44,
									       x_15077)
									   val x_15079: unit = 
									      update_2 x_15078
									in
									   i_44
									end
								     false => 
									let
									in
									   i_43
									end
								  val x_15080: Primitive.Option.t_0 = 
								     NONE_0
								  val x_15081: word8 array
									       * word32
									       * Primitive.Option.t_0 = 
								     (x_15024,
								      x_15074,
								      x_15080)
								  val x_15082: PrimSequence.Slice.t_0 = 
								     slice_8 x_15081
								  val x_15083: word8 vector = 
								     vector_7 x_15082
							       in
								  x_15083
							       end
							    false => 
							       let
								  val x_15067: word32 = 
								     0x1
								  val x_15068: word32
									       * word32 = 
								     (i_43,
								      x_15067)
								  val x_15069: word32 = 
								     x_8548 x_15068
								  val x_15070: word32
									       * word32 = 
								     (q_3,
								      x_15069)
								  val x_15071: word8 vector = 
								     loop_41 x_15070
							       in
								  x_15071
							       end
						      in
							 x_15066
						      end
						val x_15084: word32 * word32 = 
						   (x_15005, zero_3)
						val x_15085: bool = 
						   <_1 x_15084
						val x_15086: word32 = 
						   case x_15085 of
						   true => 
						      let
						      in
							 x_15005
						      end
						   false => 
						      let
							 val x_15087: word32 = 
							    ~?_0 x_15005
						      in
							 x_15087
						      end
						val x_15088: word32 = 
						   0x1
						val x_15089: word32 * word32 = 
						   (maxNumDigits_0, x_15088)
						val x_15090: word32 = 
						   x_8548 x_15089
						val x_15091: word32 * word32 = 
						   (x_15086, x_15090)
						val x_15092: word8 vector = 
						   loop_41 x_15091
						val x_15093: DynamicWind.try.t_0 = 
						   A_0 x_15092
					     in
						x_15093
					     end
					     handle x_15094 => let
								  val x_15095: DynamicWind.try.t_0 = 
								     E_0 x_15094
							       in
								  x_15095
							       end
					  val x_15096: word8 vector = 
					     case x_15041 of
					     A_0 x_15101: word8 vector => 
						let
						   val x_15102: unit = 
						      ()
						   val x_15103: unit = 
						      x_15034 x_15102
						in
						   x_15101
						end
					     E_0 x_15097: exn => 
						let
						   val x_15098: unit = 
						      ()
						   val x_15099: unit = 
						      x_15034 x_15098
						   val x_15100: word8 vector = 
						      raise x_15097
						in
						   x_15100
						end
					  val x_15104: word8 vector * list_7 = 
					     (x_15096, x_15021)
					  val x_15105: list_7 = 
					     ::_7 x_15104
					  val x_15106: word8 vector = 
					     "MLton.Exit.exit("
					  val x_15107: word8 vector * list_7 = 
					     (x_15106, x_15105)
					  val x_15108: list_7 = 
					     ::_7 x_15107
					  val x_15109: word8 vector = 
					     concat_3 x_15108
					  val x_15110: unit ref * word8 vector = 
					     (x_9554, x_15109)
					  val x_15111: exn = 
					     Fail_0 x_15110
					  val x_15112: unit = 
					     raise x_15111
				       in
					  x_15112
				       end
			      in
				 x_15014
			      end
		     in
			x_15000
		     end
	       val rec 
		  defaultTopLevelSuffix_0: unit -> unit = 
		     fn x_15138: unit => 
		     let
			val x_15139: unit = 
			   let
			      val x_15140: unit = 
				 exit_0 success_0
			      val x_15141: word8 vector = 
				 "Top-level suffix returned.\n"
			      val x_15142: unit = 
				 print_0 x_15141
			      val x_15143: unit = 
				 exit_0 failure_0
			   in
			      x_15143
			   end
			   handle x_15144 => let
						val x_15145: word8 vector = 
						   "Top-level suffix raised exception.\n"
						val x_15146: unit = 
						   print_0 x_15145
						val x_15147: unit = 
						   halt_1 failure_0
						val x_15148: word8 vector = 
						   "MLton.Exit.wrapSuffix"
						val x_15149: unit ref
							     * word8 vector = 
						   (x_9554, x_15148)
						val x_15150: exn = 
						   Fail_0 x_15149
						val x_15151: unit = 
						   raise x_15150
					     in
						x_15151
					     end
		     in
			x_15139
		     end
	       val rec 
		  defaultTopLevelHandler_0: exn -> unit = 
		     fn x_15152: exn => 
		     let
			val x_15153: unit = 
			   let
			      val x_15154: list_7 = 
				 nil_7
			      val x_15155: word8 vector = 
				 "\n"
			      val x_15156: word8 vector * list_7 = 
				 (x_15155, x_15154)
			      val x_15157: list_7 = 
				 ::_7 x_15156
			      val x_15158: word8 vector = 
				 exnMessage_0 x_15152
			      val x_15159: word8 vector * list_7 = 
				 (x_15158, x_15157)
			      val x_15160: list_7 = 
				 ::_7 x_15159
			      val x_15161: word8 vector = 
				 "unhandled exception: "
			      val x_15162: word8 vector * list_7 = 
				 (x_15161, x_15160)
			      val x_15163: list_7 = 
				 ::_7 x_15162
			      val x_15164: word8 vector = 
				 concat_3 x_15163
			      val x_15165: unit = 
				 print_0 x_15164
			      val x_15166: unit = 
				 exit_0 failure_0
			      val x_15167: word8 vector = 
				 "Top-level handler returned.\n"
			      val x_15168: unit = 
				 print_0 x_15167
			      val x_15169: unit = 
				 exit_0 failure_0
			   in
			      x_15169
			   end
			   handle x_15170 => let
						val x_15171: word8 vector = 
						   "Top-level handler raised exception.\n"
						val x_15172: unit = 
						   print_0 x_15171
						val x_15173: unit = 
						   halt_1 failure_0
						val x_15174: word8 vector = 
						   "MLton.Exn.wrapHandler"
						val x_15175: unit ref
							     * word8 vector = 
						   (x_9554, x_15174)
						val x_15176: exn = 
						   Fail_0 x_15175
						val x_15177: unit = 
						   raise x_15176
					     in
						x_15177
					     end
		     in
			x_15153
		     end
	       val rec 
		  topLevelHandler_0: exn -> unit = 
		     fn x_15178: exn => 
		     let
			val x_15179: exn -> unit = 
			   Ref_deref[exn -> unit] (x_8175)
			val x_15180: unit = 
			   x_15179 x_15178
			val x_15181: word8 vector = 
			   "MLton.Exn.topLevelHandler"
			val x_15182: unit ref * word8 vector = 
			   (x_9554, x_15181)
			val x_15183: exn = 
			   Fail_0 x_15182
			val x_15184: unit = 
			   raise x_15183
		     in
			x_15184
		     end
	       val rec 
		  die_0: word8 vector -> thread = 
		     fn x_15185: word8 vector => 
		     let
			val x_15186: unit = 
			   print_0 x_15185
			val x_15187: word32 = 
			   0x1
			val x_15188: unit = 
			   Posix_Process_exit (x_15187)
			val x_15189: unit = 
			   ()
			val x_15190: unit ref = 
			   Ref_ref[unit] (x_15189)
			val x_15191: exn = 
			   DieFailed_0 x_15190
			val x_15192: thread = 
			   raise x_15191
		     in
			x_15192
		     end
	       val x_15193: Primitive.Option.t_7 = 
		  NONE_7
	       val func_0: Primitive.Option.t_7 ref = 
		  Ref_ref[Primitive.Option.t_7] (x_15193)
	       val x_15194: unit = 
		  Thread_copyCurrent ()
	       val x_15195: Primitive.Option.t_7 = 
		  Ref_deref[Primitive.Option.t_7] (func_0)
	       val x_15196: thread = 
		  case x_15195 of
		  NONE_7 => 
		     let
			val x_15210: thread = 
			   GC_getSavedThread (x_8832)
		     in
			x_15210
		     end
		  SOME_7 x_15197: unit -> unit => 
		     let
			val x_15198: Primitive.Option.t_7 = 
			   NONE_7
			val x_15199: Primitive.Option.t_7 ref
				     * Primitive.Option.t_7 = 
			   (func_0, x_15198)
			val x_15200: unit = 
			   x_8327 x_15199
			val x_15201: unit = 
			   ()
			val x_15202: unit = 
			   atomicEnd_0 x_15201
			val x_15203: unit = 
			   let
			      val x_15204: unit = 
				 ()
			      val x_15205: unit = 
				 x_15197 x_15204
			   in
			      x_15205
			   end
			   handle x_15206 => let
						val x_15207: unit = 
						   topLevelHandler_0 x_15206
					     in
						x_15207
					     end
			val x_15208: word8 vector = 
			   "Thread didn't exit properly.\n"
			val x_15209: thread = 
			   die_0 x_15208
		     in
			x_15209
		     end
	       val x_15211: bool = 
		  false
	       val switching_0: bool ref = 
		  Ref_ref[bool] (x_15211)
	       val rec 
		  toPrimitive_0: MLtonThread.t_0 -> thread = 
		     fn x_15212: MLtonThread.t_0 => 
		     let
			val x_15213: thread = 
			   case x_15212 of
			   T_7 x_15214: MLtonThread.thread_0 ref => 
			      let
				 val x_15215: MLtonThread.thread_0 = 
				    x_8324 x_15214
				 val x_15216: thread = 
				    case x_15215 of
				    Dead_0 => 
				       let
					  val x_15507: word8 vector = 
					     "Thread.toPrimitive saw Dead.\n"
					  val x_15508: thread = 
					     die_0 x_15507
				       in
					  x_15508
				       end
				    New_0 x_15231: unit -> unit => 
				       let
					  val x_15232: unit = 
					     ()
					  val x_15233: unit = 
					     atomicBegin_0 x_15232
					  val x_15234: bool = 
					     x_8321 switching_0
					  val x_15235: thread = 
					     case x_15234 of
					     true => 
						let
						   val x_15501: unit = 
						      ()
						   val x_15502: unit = 
						      atomicEnd_0 x_15501
						   val x_15503: word8 vector = 
						      "nested Thread.switch"
						   val x_15504: unit ref
								* word8 vector = 
						      (x_9554, x_15503)
						   val x_15505: exn = 
						      Fail_0 x_15504
						   val x_15506: thread = 
						      raise x_15505
						in
						   x_15506
						end
					     false => 
						let
						   val x_15236: bool = 
						      true
						   val x_15237: bool ref * bool = 
						      (switching_0, x_15236)
						   val x_15238: unit = 
						      x_8342 x_15237
						   val x_15239: unit -> thread = 
						      fn x_15240: unit => 
						      let
							 val x_15241: word8 vector = 
							    "Thread.atomicSwitch didn't set r.\n"
							 val x_15242: thread = 
							    die_0 x_15241
						      in
							 x_15242
						      end
						   val r_0: (unit -> thread) ref = 
						      Ref_ref[unit -> thread] (x_15239)
						   val x_15243: (unit -> thread)
								-> unit = 
						      fn x_15244: unit -> thread => 
						      let
							 val x_15245: unit = 
							    Ref_assign[unit
								       -> thread] (r_0,
										   x_15244)
						      in
							 x_15245
						      end
						   val x_15246: thread = 
						      GC_getCurrentThread (x_8832)
						   val x_15247: ((unit -> thread)
								 -> unit)
								* thread = 
						      (x_15243, x_15246)
						   val x_15248: MLtonThread.thread_1 = 
						      Paused_1 x_15247
						   val t_0: MLtonThread.thread_1 ref = 
						      Ref_ref[MLtonThread.thread_1] (x_15248)
						   val x_15249: MLtonThread.t_0 = 
						      let
							 val x_15250: unit
								      -> unit = 
							    fn x_15251: unit => 
							    let
							       val x_15252: unit = 
								  ()
							       val x_15253: unit = 
								  atomicBegin_0 x_15252
							       val x_15254: bool = 
								  x_8321 switching_0
							       val x_15255: unit = 
								  case x_15254 of
								  true => 
								     let
									val x_15367: unit = 
									   ()
									val x_15368: unit = 
									   atomicEnd_0 x_15367
									val x_15369: word8 vector = 
									   "nested Thread.switch"
									val x_15370: unit ref
										     * word8 vector = 
									   (x_9554,
									    x_15369)
									val x_15371: exn = 
									   Fail_0 x_15370
									val x_15372: unit = 
									   raise x_15371
								     in
									x_15372
								     end
								  false => 
								     let
									val x_15256: bool = 
									   true
									val x_15257: bool ref
										     * bool = 
									   (switching_0,
									    x_15256)
									val x_15258: unit = 
									   x_8342 x_15257
									val x_15259: unit
										     -> unit = 
									   fn x_15260: unit => 
									   let
									      val x_15261: word8 vector = 
										 "Thread.atomicSwitch didn't set r.\n"
									      val x_15262: unit = 
										 print_0 x_15261
									      val x_15263: word32 = 
										 0x1
									      val x_15264: unit = 
										 Posix_Process_exit (x_15263)
									      val x_15265: unit = 
										 ()
									      val x_15266: unit ref = 
										 Ref_ref[unit] (x_15265)
									      val x_15267: exn = 
										 DieFailed_1 x_15266
									      val x_15268: unit = 
										 raise x_15267
									   in
									      x_15268
									   end
									val r_1: (unit
										  -> unit) ref = 
									   Ref_ref[unit
										   -> unit] (x_15259)
									val x_15269: (unit
										      -> unit)
										     -> unit = 
									   fn x_15270: unit
										       -> unit => 
									   let
									      val x_15271: unit = 
										 Ref_assign[unit
											    -> unit] (r_1,
												      x_15270)
									   in
									      x_15271
									   end
									val x_15272: thread = 
									   GC_getCurrentThread (x_8832)
									val x_15273: ((unit
										       -> unit)
										      -> unit)
										     * thread = 
									   (x_15269,
									    x_15272)
									val x_15274: MLtonThread.thread_0 = 
									   Paused_0 x_15273
									val t_1: MLtonThread.thread_0 ref = 
									   Ref_ref[MLtonThread.thread_0] (x_15274)
									val x_15275: MLtonThread.t_0 = 
									   let
									      val x_15276: MLtonThread.t_0 = 
										 T_7 t_1
									      val x_15277: thread = 
										 toPrimitive_0 x_15276
									      val x_15278: unit
											   -> thread = 
										 fn x_15279: unit => 
										 let
										 in
										    x_15277
										 end
									      val x_15280: MLtonThread.thread_1 = 
										 Ref_deref[MLtonThread.thread_1] (t_0)
									      val x_15281: MLtonThread.thread_0 = 
										 case x_15280 of
										 Dead_1 => 
										    let
										       val x_15305: word8 vector = 
											  "prepend to a Dead thread"
										       val x_15306: unit ref
												    * word8 vector = 
											  (x_9554,
											   x_15305)
										       val x_15307: exn = 
											  Fail_0 x_15306
										       val x_15308: MLtonThread.thread_0 = 
											  raise x_15307
										    in
										       x_15308
										    end
										 New_1 x_15299: thread
												-> unit => 
										    let
										       val x_15300: unit
												    -> unit = 
											  fn x_15301: unit => 
											  let
											     val x_15302: thread = 
												x_15278 x_15301
											     val x_15303: unit = 
												x_15299 x_15302
											  in
											     x_15303
											  end
										       val x_15304: MLtonThread.thread_0 = 
											  New_0 x_15300
										    in
										       x_15304
										    end
										 Paused_1 x_15287: ((unit
												     -> thread)
												    -> unit)
												   * thread => 
										    let
										       val x_15288: thread = 
											  #1 x_15287
										       val x_15289: (unit
												     -> thread)
												    -> unit = 
											  #0 x_15287
										       val x_15290: (unit
												     -> unit)
												    -> unit = 
											  fn x_15291: unit
												      -> unit => 
											  let
											     val x_15292: unit
													  -> thread = 
												fn x_15293: unit => 
												let
												   val x_15294: unit = 
												      x_15291 x_15293
												   val x_15295: thread = 
												      x_15278 x_15294
												in
												   x_15295
												end
											     val x_15296: unit = 
												x_15289 x_15292
											  in
											     x_15296
											  end
										       val x_15297: ((unit
												      -> unit)
												     -> unit)
												    * thread = 
											  (x_15290,
											   x_15288)
										       val x_15298: MLtonThread.thread_0 = 
											  Paused_0 x_15297
										    in
										       x_15298
										    end
										 Interrupted_1 x_15282: thread => 
										    let
										       val x_15283: word8 vector = 
											  "prepend to a Interrupted thread"
										       val x_15284: unit ref
												    * word8 vector = 
											  (x_9554,
											   x_15283)
										       val x_15285: exn = 
											  Fail_0 x_15284
										       val x_15286: MLtonThread.thread_0 = 
											  raise x_15285
										    in
										       x_15286
										    end
									      val x_15309: MLtonThread.thread_1 = 
										 Dead_1
									      val x_15310: MLtonThread.thread_1 ref
											   * MLtonThread.thread_1 = 
										 (t_0,
										  x_15309)
									      val x_15311: unit = 
										 x_8332 x_15310
									      val x_15312: MLtonThread.thread_0 ref = 
										 Ref_ref[MLtonThread.thread_0] (x_15281)
									      val x_15313: MLtonThread.t_0 = 
										 T_7 x_15312
									   in
									      x_15313
									   end
									   handle x_15314 => let
												val x_15315: MLtonThread.thread_0 = 
												   Dead_0
												val x_15316: MLtonThread.thread_0 ref
													     * MLtonThread.thread_0 = 
												   (t_1,
												    x_15315)
												val x_15317: unit = 
												   x_8362 x_15316
												val x_15318: bool = 
												   false
												val x_15319: bool ref
													     * bool = 
												   (switching_0,
												    x_15318)
												val x_15320: unit = 
												   x_8342 x_15319
												val x_15321: unit = 
												   ()
												val x_15322: unit = 
												   atomicEnd_0 x_15321
												val x_15323: MLtonThread.t_0 = 
												   raise x_15314
											     in
												x_15323
											     end
									val x_15324: unit = 
									   case x_15275 of
									   T_7 x_15325: MLtonThread.thread_0 ref => 
									      let
										 val x_15326: MLtonThread.thread_0 = 
										    x_8324 x_15325
										 val x_15327: MLtonThread.thread_0 = 
										    Dead_0
										 val x_15328: MLtonThread.thread_0 ref
											      * MLtonThread.thread_0 = 
										    (x_15325,
										     x_15327)
										 val x_15329: unit = 
										    x_8362 x_15328
										 val x_15330: MLtonThread.thread_0
											      * unit = 
										    (x_15326,
										     x_15329)
										 val x_15331: MLtonThread.thread_0 = 
										    before_2 x_15330
										 val x_15332: thread = 
										    case x_15331 of
										    Dead_0 => 
										       let
											  val x_15348: word8 vector = 
											     "switch to a Dead thread"
											  val x_15349: unit ref
												       * word8 vector = 
											     (x_9554,
											      x_15348)
											  val x_15350: exn = 
											     Fail_0 x_15349
											  val x_15351: MLtonThread.thread_0 = 
											     Dead_0
											  val x_15352: MLtonThread.thread_0 ref
												       * MLtonThread.thread_0 = 
											     (t_1,
											      x_15351)
											  val x_15353: unit = 
											     x_8362 x_15352
											  val x_15354: bool = 
											     false
											  val x_15355: bool ref
												       * bool = 
											     (switching_0,
											      x_15354)
											  val x_15356: unit = 
											     x_8342 x_15355
											  val x_15357: unit = 
											     ()
											  val x_15358: unit = 
											     atomicEnd_0 x_15357
											  val x_15359: thread = 
											     raise x_15350
										       in
											  x_15359
										       end
										    New_0 x_15341: unit
												   -> unit => 
										       let
											  val x_15342: unit = 
											     ()
											  val x_15343: unit = 
											     atomicBegin_0 x_15342
											  val x_15344: Primitive.Option.t_7 = 
											     SOME_7 x_15341
											  val x_15345: Primitive.Option.t_7 ref
												       * Primitive.Option.t_7 = 
											     (func_0,
											      x_15344)
											  val x_15346: unit = 
											     x_8327 x_15345
											  val x_15347: thread = 
											     Thread_copy (x_15196)
										       in
											  x_15347
										       end
										    Paused_0 x_15334: ((unit
													-> unit)
												       -> unit)
												      * thread => 
										       let
											  val x_15335: thread = 
											     #1 x_15334
											  val x_15336: (unit
													-> unit)
												       -> unit = 
											     #0 x_15334
											  val x_15337: unit
												       -> unit = 
											     fn x_15338: unit => 
											     let
												val x_15339: unit = 
												   ()
											     in
												x_15339
											     end
											  val x_15340: unit = 
											     x_15336 x_15337
										       in
											  x_15335
										       end
										    Interrupted_0 x_15333: thread => 
										       let
										       in
											  x_15333
										       end
										 val x_15360: bool = 
										    false
										 val x_15361: bool ref
											      * bool = 
										    (switching_0,
										     x_15360)
										 val x_15362: unit = 
										    x_8342 x_15361
										 val x_15363: unit = 
										    switchTo_0 x_15332
										 val x_15364: unit
											      -> unit = 
										    Ref_deref[unit
											      -> unit] (r_1)
										 val x_15365: unit = 
										    ()
										 val x_15366: unit = 
										    x_15364 x_15365
									      in
										 x_15366
									      end
								     in
									x_15324
								     end
							    in
							       x_15255
							    end
							 val x_15373: MLtonThread.t_0 = 
							    case x_15212 of
							    T_7 x_15374: MLtonThread.thread_0 ref => 
							       let
								  val x_15375: MLtonThread.thread_0 = 
								     x_8324 x_15374
								  val x_15376: MLtonThread.thread_0 = 
								     case x_15375 of
								     Dead_0 => 
									let
									   val x_15400: word8 vector = 
									      "prepend to a Dead thread"
									   val x_15401: unit ref
											* word8 vector = 
									      (x_9554,
									       x_15400)
									   val x_15402: exn = 
									      Fail_0 x_15401
									   val x_15403: MLtonThread.thread_0 = 
									      raise x_15402
									in
									   x_15403
									end
								     New_0 x_15394: unit
										    -> unit => 
									let
									   val x_15395: unit
											-> unit = 
									      fn x_15396: unit => 
									      let
										 val x_15397: unit = 
										    x_15250 x_15396
										 val x_15398: unit = 
										    x_15394 x_15397
									      in
										 x_15398
									      end
									   val x_15399: MLtonThread.thread_0 = 
									      New_0 x_15395
									in
									   x_15399
									end
								     Paused_0 x_15382: ((unit
											 -> unit)
											-> unit)
										       * thread => 
									let
									   val x_15383: thread = 
									      #1 x_15382
									   val x_15384: (unit
											 -> unit)
											-> unit = 
									      #0 x_15382
									   val x_15385: (unit
											 -> unit)
											-> unit = 
									      fn x_15386: unit
											  -> unit => 
									      let
										 val x_15387: unit
											      -> unit = 
										    fn x_15388: unit => 
										    let
										       val x_15389: unit = 
											  x_15386 x_15388
										       val x_15390: unit = 
											  x_15250 x_15389
										    in
										       x_15390
										    end
										 val x_15391: unit = 
										    x_15384 x_15387
									      in
										 x_15391
									      end
									   val x_15392: ((unit
											  -> unit)
											 -> unit)
											* thread = 
									      (x_15385,
									       x_15383)
									   val x_15393: MLtonThread.thread_0 = 
									      Paused_0 x_15392
									in
									   x_15393
									end
								     Interrupted_0 x_15377: thread => 
									let
									   val x_15378: word8 vector = 
									      "prepend to a Interrupted thread"
									   val x_15379: unit ref
											* word8 vector = 
									      (x_9554,
									       x_15378)
									   val x_15380: exn = 
									      Fail_0 x_15379
									   val x_15381: MLtonThread.thread_0 = 
									      raise x_15380
									in
									   x_15381
									end
								  val x_15404: MLtonThread.thread_0 = 
								     Dead_0
								  val x_15405: MLtonThread.thread_0 ref
									       * MLtonThread.thread_0 = 
								     (x_15374,
								      x_15404)
								  val x_15406: unit = 
								     x_8362 x_15405
								  val x_15407: MLtonThread.thread_0 ref = 
								     Ref_ref[MLtonThread.thread_0] (x_15376)
								  val x_15408: MLtonThread.t_0 = 
								     T_7 x_15407
							       in
								  x_15408
							       end
							 val x_15409: unit = 
							    ()
							 val x_15410: unit
								      -> unit = 
							    fn x_15411: unit => 
							    let
							    in
							       x_15409
							    end
							 val x_15412: MLtonThread.t_0 = 
							    case x_15373 of
							    T_7 x_15413: MLtonThread.thread_0 ref => 
							       let
								  val x_15414: MLtonThread.thread_0 = 
								     x_8324 x_15413
								  val x_15415: MLtonThread.thread_0 = 
								     case x_15414 of
								     Dead_0 => 
									let
									   val x_15439: word8 vector = 
									      "prepend to a Dead thread"
									   val x_15440: unit ref
											* word8 vector = 
									      (x_9554,
									       x_15439)
									   val x_15441: exn = 
									      Fail_0 x_15440
									   val x_15442: MLtonThread.thread_0 = 
									      raise x_15441
									in
									   x_15442
									end
								     New_0 x_15433: unit
										    -> unit => 
									let
									   val x_15434: unit
											-> unit = 
									      fn x_15435: unit => 
									      let
										 val x_15436: unit = 
										    x_15410 x_15435
										 val x_15437: unit = 
										    x_15433 x_15436
									      in
										 x_15437
									      end
									   val x_15438: MLtonThread.thread_0 = 
									      New_0 x_15434
									in
									   x_15438
									end
								     Paused_0 x_15421: ((unit
											 -> unit)
											-> unit)
										       * thread => 
									let
									   val x_15422: thread = 
									      #1 x_15421
									   val x_15423: (unit
											 -> unit)
											-> unit = 
									      #0 x_15421
									   val x_15424: (unit
											 -> unit)
											-> unit = 
									      fn x_15425: unit
											  -> unit => 
									      let
										 val x_15426: unit
											      -> unit = 
										    fn x_15427: unit => 
										    let
										       val x_15428: unit = 
											  x_15425 x_15427
										       val x_15429: unit = 
											  x_15410 x_15428
										    in
										       x_15429
										    end
										 val x_15430: unit = 
										    x_15423 x_15426
									      in
										 x_15430
									      end
									   val x_15431: ((unit
											  -> unit)
											 -> unit)
											* thread = 
									      (x_15424,
									       x_15422)
									   val x_15432: MLtonThread.thread_0 = 
									      Paused_0 x_15431
									in
									   x_15432
									end
								     Interrupted_0 x_15416: thread => 
									let
									   val x_15417: word8 vector = 
									      "prepend to a Interrupted thread"
									   val x_15418: unit ref
											* word8 vector = 
									      (x_9554,
									       x_15417)
									   val x_15419: exn = 
									      Fail_0 x_15418
									   val x_15420: MLtonThread.thread_0 = 
									      raise x_15419
									in
									   x_15420
									end
								  val x_15443: MLtonThread.thread_0 = 
								     Dead_0
								  val x_15444: MLtonThread.thread_0 ref
									       * MLtonThread.thread_0 = 
								     (x_15413,
								      x_15443)
								  val x_15445: unit = 
								     x_8362 x_15444
								  val x_15446: MLtonThread.thread_0 ref = 
								     Ref_ref[MLtonThread.thread_0] (x_15415)
								  val x_15447: MLtonThread.t_0 = 
								     T_7 x_15446
							       in
								  x_15447
							       end
						      in
							 x_15412
						      end
						      handle x_15448 => let
									   val x_15449: MLtonThread.thread_1 = 
									      Dead_1
									   val x_15450: MLtonThread.thread_1 ref
											* MLtonThread.thread_1 = 
									      (t_0,
									       x_15449)
									   val x_15451: unit = 
									      x_8332 x_15450
									   val x_15452: bool = 
									      false
									   val x_15453: bool ref
											* bool = 
									      (switching_0,
									       x_15452)
									   val x_15454: unit = 
									      x_8342 x_15453
									   val x_15455: unit = 
									      ()
									   val x_15456: unit = 
									      atomicEnd_0 x_15455
									   val x_15457: MLtonThread.t_0 = 
									      raise x_15448
									in
									   x_15457
									end
						   val x_15458: thread = 
						      case x_15249 of
						      T_7 x_15459: MLtonThread.thread_0 ref => 
							 let
							    val x_15460: MLtonThread.thread_0 = 
							       x_8324 x_15459
							    val x_15461: MLtonThread.thread_0 = 
							       Dead_0
							    val x_15462: MLtonThread.thread_0 ref
									 * MLtonThread.thread_0 = 
							       (x_15459, x_15461)
							    val x_15463: unit = 
							       x_8362 x_15462
							    val x_15464: MLtonThread.thread_0
									 * unit = 
							       (x_15460, x_15463)
							    val x_15465: MLtonThread.thread_0 = 
							       before_2 x_15464
							    val x_15466: thread = 
							       case x_15465 of
							       Dead_0 => 
								  let
								     val x_15482: word8 vector = 
									"switch to a Dead thread"
								     val x_15483: unit ref
										  * word8 vector = 
									(x_9554,
									 x_15482)
								     val x_15484: exn = 
									Fail_0 x_15483
								     val x_15485: MLtonThread.thread_1 = 
									Dead_1
								     val x_15486: MLtonThread.thread_1 ref
										  * MLtonThread.thread_1 = 
									(t_0,
									 x_15485)
								     val x_15487: unit = 
									x_8332 x_15486
								     val x_15488: bool = 
									false
								     val x_15489: bool ref
										  * bool = 
									(switching_0,
									 x_15488)
								     val x_15490: unit = 
									x_8342 x_15489
								     val x_15491: unit = 
									()
								     val x_15492: unit = 
									atomicEnd_0 x_15491
								     val x_15493: thread = 
									raise x_15484
								  in
								     x_15493
								  end
							       New_0 x_15475: unit
									      -> unit => 
								  let
								     val x_15476: unit = 
									()
								     val x_15477: unit = 
									atomicBegin_0 x_15476
								     val x_15478: Primitive.Option.t_7 = 
									SOME_7 x_15475
								     val x_15479: Primitive.Option.t_7 ref
										  * Primitive.Option.t_7 = 
									(func_0,
									 x_15478)
								     val x_15480: unit = 
									x_8327 x_15479
								     val x_15481: thread = 
									Thread_copy (x_15196)
								  in
								     x_15481
								  end
							       Paused_0 x_15468: ((unit
										   -> unit)
										  -> unit)
										 * thread => 
								  let
								     val x_15469: thread = 
									#1 x_15468
								     val x_15470: (unit
										   -> unit)
										  -> unit = 
									#0 x_15468
								     val x_15471: unit
										  -> unit = 
									fn x_15472: unit => 
									let
									   val x_15473: unit = 
									      ()
									in
									   x_15473
									end
								     val x_15474: unit = 
									x_15470 x_15471
								  in
								     x_15469
								  end
							       Interrupted_0 x_15467: thread => 
								  let
								  in
								     x_15467
								  end
							    val x_15494: bool = 
							       false
							    val x_15495: bool ref
									 * bool = 
							       (switching_0,
								x_15494)
							    val x_15496: unit = 
							       x_8342 x_15495
							    val x_15497: unit = 
							       switchTo_0 x_15466
							    val x_15498: unit
									 -> thread = 
							       Ref_deref[unit
									 -> thread] (r_0)
							    val x_15499: unit = 
							       ()
							    val x_15500: thread = 
							       x_15498 x_15499
							 in
							    x_15500
							 end
						in
						   x_15458
						end
				       in
					  x_15235
				       end
				    Paused_0 x_15221: ((unit -> unit) -> unit)
						      * thread => 
				       let
					  val x_15222: thread = 
					     #1 x_15221
					  val x_15223: (unit -> unit) -> unit = 
					     #0 x_15221
					  val x_15224: MLtonThread.thread_0 = 
					     Dead_0
					  val x_15225: MLtonThread.thread_0 ref
						       * MLtonThread.thread_0 = 
					     (x_15214, x_15224)
					  val x_15226: unit = 
					     x_8362 x_15225
					  val x_15227: unit -> unit = 
					     fn x_15228: unit => 
					     let
						val x_15229: unit = 
						   ()
					     in
						x_15229
					     end
					  val x_15230: unit = 
					     x_15223 x_15227
				       in
					  x_15222
				       end
				    Interrupted_0 x_15217: thread => 
				       let
					  val x_15218: MLtonThread.thread_0 = 
					     Dead_0
					  val x_15219: MLtonThread.thread_0 ref
						       * MLtonThread.thread_0 = 
					     (x_15214, x_15218)
					  val x_15220: unit = 
					     x_8362 x_15219
				       in
					  x_15217
				       end
			      in
				 x_15216
			      end
		     in
			x_15213
		     end
	       val x_15509: word32 = 
		  sextdFromInt32ToInt32_0 numExports_0
	       val x_15510: cpointer -> unit = 
		  fn x_15511: cpointer => 
		  let
		     val x_15512: word8 vector = 
			"undefined export"
		     val x_15513: unit ref * word8 vector = 
			(x_9554, x_15512)
		     val x_15514: exn = 
			Fail_0 x_15513
		     val x_15515: unit = 
			raise x_15514
		  in
		     x_15515
		  end
	       val x_15516: unit = 
		  ()
	       val x_15517: word64 = 
		  fromIntForLength_0 x_15509
	       val x_15518: bool = 
		  not_0 isMutable_1
	       val x_15519: bool = 
		  case x_15518 of
		  true => 
		     let
			val x_15521: word64 = 
			   0x0
			val x_15522: word64 * word64 = 
			   (x_15517, x_15521)
			val x_15523: bool = 
			   x_8372 x_15522
		     in
			x_15523
		     end
		  false => 
		     let
			val x_15520: bool = 
			   false
		     in
			x_15520
		     end
	       val x_15524: (cpointer -> unit) array = 
		  case x_15519 of
		  true => 
		     let
			val x_15530: (cpointer -> unit) array = 
			   Array_array0Const[cpointer -> unit] ()
		     in
			x_15530
		     end
		  false => 
		     let
			val x_15525: word64 * word64 = 
			   (x_15517, x_9217)
			val x_15526: bool = 
			   >_4 x_15525
			val x_15527: (cpointer -> unit) array = 
			   case x_15526 of
			   true => 
			      let
				 val x_15529: (cpointer -> unit) array = 
				    raise x_8293
			      in
				 x_15529
			      end
			   false => 
			      let
				 val x_15528: (cpointer -> unit) array = 
				    Array_array[cpointer -> unit] (x_15517)
			      in
				 x_15528
			      end
		     in
			x_15527
		     end
	       val rec 
		  loop_43: word64 * unit -> unit = 
		     fn x_15531: word64 * unit => 
		     let
			val b_51: unit = 
			   #1 x_15531
			val i_45: word64 = 
			   #0 x_15531
			val x_15532: word64 * word64 = 
			   (i_45, x_15517)
			val x_15533: bool = 
			   >=_2 x_15532
			val x_15534: unit = 
			   case x_15533 of
			   true => 
			      let
			      in
				 b_51
			      end
			   false => 
			      let
				 val x_15535: unit = 
				    ()
				 val x_15536: unit = 
				    Array_update[cpointer -> unit] (x_15524,
								    i_45,
								    x_15510)
				 val x_15537: word64 = 
				    0x1
				 val x_15538: word64 * word64 = 
				    (i_45, x_15537)
				 val x_15539: word64 = 
				    +?_1 x_15538
				 val x_15540: word64 * unit = 
				    (x_15539, x_15535)
				 val x_15541: unit = 
				    loop_43 x_15540
			      in
				 x_15541
			      end
		     in
			x_15534
		     end
	       val x_15542: word64 = 
		  0x0
	       val x_15543: word64 * unit = 
		  (x_15542, x_15516)
	       val b_52: unit = 
		  loop_43 x_15543
	       val x_15544: Primitive.Option.t_18 = 
		  NONE_16
	       val worker_0: Primitive.Option.t_18 ref = 
		  Ref_ref[Primitive.Option.t_18] (x_15544)
	       val rec 
		  handlerLoop_0: unit -> unit = 
		     fn x_15545: unit => 
		     let
			val x_15546: thread = 
			   GC_getSavedThread (x_8832)
			val x_15547: Primitive.Option.t_18 = 
			   x_8309 worker_0
			val x_15548: thread * Primitive.Option.t_17 ref = 
			   case x_15547 of
			   NONE_16 => 
			      let
				 val x_15556: Primitive.Option.t_18 = 
				    NONE_16
				 val thisWorker_0: Primitive.Option.t_18 ref = 
				    Ref_ref[Primitive.Option.t_18] (x_15556)
				 val x_15557: Primitive.Option.t_17 = 
				    NONE_15
				 val savedRef_0: Primitive.Option.t_17 ref = 
				    Ref_ref[Primitive.Option.t_17] (x_15557)
				 val rec 
				    workerLoop_0: unit -> unit = 
				       fn x_15558: unit => 
				       let
					  val x_15559: cpointer = 
					     FFI_getOpArgsResPtr ()
					  val x_15560: unit = 
					     ()
					  val x_15561: unit = 
					     atomicEnd_0 x_15560
					  val x_15562: word32 = 
					     0x0
					  val x_15563: word64 = 
					     sextdFromInt32ToInt64_0 x_15562
					  val x_15564: cpointer = 
					     CPointer_getCPointer (x_15559,
								   x_15563)
					  val x_15565: word32 = 
					     0x0
					  val x_15566: word64 = 
					     sextdFromInt32ToInt64_0 x_15565
					  val x_15567: word32 = 
					     CPointer_getWord32 (x_15564,
								 x_15566)
					  val x_15568: unit = 
					     let
						val x_15569: word32 = 
						   sextdFromInt32ToInt32_0 x_15567
						val x_15570: word64 = 
						   0x0
						val x_15571: word64 = 
						   Array_length[cpointer -> unit] (x_15524)
						val i_46: word64 = 
						   let
						      val x_15572: word64 = 
							 sextdFromInt32ToInt64_0 x_15569
						   in
						      x_15572
						   end
						   handle x_15573 => let
									val x_15574: unit
										     -> word64 = 
									   fn unit_29: unit => 
									   let
									      val x_15575: word64 = 
										 raise x_15573
									   in
									      x_15575
									   end
									val x_15576: word64 = 
									   case x_15573 of
									   Overflow_0 x_15577: unit ref => 
									      let
										 val x_15578: bool = 
										    MLton_equal[unit ref] (x_15577,
													   x_8289)
										 val x_15579: word64 = 
										    case x_15578 of
										    true => 
										       let
											  val x_15582: word64 = 
											     raise x_8296
										       in
											  x_15582
										       end
										    false => 
										       let
											  val x_15580: unit = 
											     ()
											  val x_15581: word64 = 
											     x_15574 x_15580
										       in
											  x_15581
										       end
									      in
										 x_15579
									      end
									     _ => let
										     val x_15583: unit = 
											()
										     val x_15584: word64 = 
											x_15574 x_15583
										  in
										     x_15584
										  end
								     in
									x_15576
								     end
						val x_15585: word64 * word64 = 
						   (i_46, x_15571)
						val x_15586: bool = 
						   >=_5 x_15585
						val x_15587: cpointer -> unit = 
						   case x_15586 of
						   true => 
						      let
							 val x_15591: cpointer
								      -> unit = 
							    raise x_8296
						      in
							 x_15591
						      end
						   false => 
						      let
							 val x_15588: word64
								      * word64 = 
							    (x_15570, i_46)
							 val x_15589: word64 = 
							    +?_1 x_15588
							 val x_15590: cpointer
								      -> unit = 
							    Array_sub[cpointer
								      -> unit] (x_15524,
										x_15589)
						      in
							 x_15590
						      end
						val x_15592: unit = 
						   x_15587 x_15559
					     in
						x_15592
					     end
					     handle x_15593 => let
								  val x_15594: word8 vector = 
								     "Call from C to SML raised exception.\n"
								  val x_15595: ImperativeIOExtra.Outstream.t_0
									       * word8 vector = 
								     (stdErr_0,
								      x_15594)
								  val x_15596: unit = 
								     output_0 x_15595
								  val x_15597: unit = 
								     topLevelHandler_0 x_15593
							       in
								  x_15597
							       end
					  val x_15598: unit = 
					     ()
					  val x_15599: unit = 
					     atomicBegin_0 x_15598
					  val x_15600: Primitive.Option.t_18 = 
					     x_8309 thisWorker_0
					  val x_15601: Primitive.Option.t_18 ref
						       * Primitive.Option.t_18 = 
					     (worker_0, x_15600)
					  val x_15602: unit = 
					     x_8352 x_15601
					  val x_15603: Primitive.Option.t_17 = 
					     Ref_deref[Primitive.Option.t_17] (savedRef_0)
					  val x_15604: thread = 
					     case x_15603 of
					     NONE_15 => 
						let
						   val x_15606: thread = 
						      raise x_9573
						in
						   x_15606
						end
					     SOME_17 x_15605: thread => 
						let
						in
						   x_15605
						end
					  val x_15607: unit = 
					     GC_setSavedThread (x_8832, x_15604)
					  val x_15608: Primitive.Option.t_17 = 
					     NONE_15
					  val x_15609: Primitive.Option.t_17 ref
						       * Primitive.Option.t_17 = 
					     (savedRef_0, x_15608)
					  val x_15610: unit = 
					     x_8347 x_15609
					  val x_15611: unit = 
					     Thread_returnToC ()
					  val x_15612: unit = 
					     ()
					  val x_15613: unit = 
					     workerLoop_0 x_15612
				       in
					  x_15613
				       end
				 val x_15614: MLtonThread.thread_0 = 
				    New_0 workerLoop_0
				 val x_15615: MLtonThread.thread_0 ref = 
				    Ref_ref[MLtonThread.thread_0] (x_15614)
				 val x_15616: MLtonThread.t_0 = 
				    T_7 x_15615
				 val workerThread_0: thread = 
				    toPrimitive_0 x_15616
				 val x_15617: thread * Primitive.Option.t_17 ref = 
				    (workerThread_0, savedRef_0)
				 val x_15618: Primitive.Option.t_18 = 
				    SOME_18 x_15617
				 val x_15619: Primitive.Option.t_18 ref
					      * Primitive.Option.t_18 = 
				    (thisWorker_0, x_15618)
				 val x_15620: unit = 
				    x_8352 x_15619
				 val x_15621: thread * Primitive.Option.t_17 ref = 
				    (workerThread_0, savedRef_0)
			      in
				 x_15621
			      end
			   SOME_18 x_15549: thread * Primitive.Option.t_17 ref => 
			      let
				 val x_15550: Primitive.Option.t_17 ref = 
				    #1 x_15549
				 val x_15551: thread = 
				    #0 x_15549
				 val x_15552: Primitive.Option.t_18 = 
				    NONE_16
				 val x_15553: Primitive.Option.t_18 ref
					      * Primitive.Option.t_18 = 
				    (worker_0, x_15552)
				 val x_15554: unit = 
				    x_8352 x_15553
				 val x_15555: thread * Primitive.Option.t_17 ref = 
				    (x_15551, x_15550)
			      in
				 x_15555
			      end
			val savedRef_1: Primitive.Option.t_17 ref = 
			   #1 x_15548
			val workerThread_1: thread = 
			   #0 x_15548
			val x_15622: Primitive.Option.t_17 = 
			   SOME_17 x_15546
			val x_15623: Primitive.Option.t_17 ref
				     * Primitive.Option.t_17 = 
			   (savedRef_1, x_15622)
			val x_15624: unit = 
			   x_8347 x_15623
			val x_15625: unit = 
			   switchTo_0 workerThread_1
			val x_15626: unit = 
			   ()
			val x_15627: unit = 
			   handlerLoop_0 x_15626
		     in
			x_15627
		     end
	       val x_15628: MLtonThread.thread_0 = 
		  New_0 handlerLoop_0
	       val x_15629: MLtonThread.thread_0 ref = 
		  Ref_ref[MLtonThread.thread_0] (x_15628)
	       val x_15630: MLtonThread.t_0 = 
		  T_7 x_15629
	       val handlerThread_0: thread = 
		  toPrimitive_0 x_15630
	       val x_15631: unit = 
		  GC_setCallFromCHandlerThread (x_8832, handlerThread_0)
	       val x_15632: word32 = 
		  0x0
	       val x_15633: cpointer -> unit = 
		  fn x_15634: cpointer => 
		  let
		     val x_15635: word8 vector = 
			"hihi\n"
		     val x_15636: ImperativeIOExtra.Outstream.t_0 * word8 vector = 
			(x_14988, x_15635)
		     val x_15637: unit = 
			output_0 x_15636
		     val x_15638: StreamIOExtra.outstream_0 = 
			get_0 x_14988
		     val x_15639: unit = 
			flushOut_0 x_15638
		     val x_15640: unit = 
			()
		  in
		     x_15640
		  end
	       val x_15641: word64 = 
		  0x0
	       val x_15642: word64 = 
		  Array_length[cpointer -> unit] (x_15524)
	       val i_47: word64 = 
		  let
		     val x_15643: word64 = 
			sextdFromInt32ToInt64_0 x_15632
		  in
		     x_15643
		  end
		  handle x_15644 => let
				       val x_15645: unit -> word64 = 
					  fn unit_30: unit => 
					  let
					     val x_15646: word64 = 
						raise x_15644
					  in
					     x_15646
					  end
				       val x_15647: word64 = 
					  case x_15644 of
					  Overflow_0 x_15648: unit ref => 
					     let
						val x_15649: bool = 
						   MLton_equal[unit ref] (x_15648,
									  x_8289)
						val x_15650: word64 = 
						   case x_15649 of
						   true => 
						      let
							 val x_15653: word64 = 
							    raise x_8296
						      in
							 x_15653
						      end
						   false => 
						      let
							 val x_15651: unit = 
							    ()
							 val x_15652: word64 = 
							    x_15645 x_15651
						      in
							 x_15652
						      end
					     in
						x_15650
					     end
					    _ => let
						    val x_15654: unit = 
						       ()
						    val x_15655: word64 = 
						       x_15645 x_15654
						 in
						    x_15655
						 end
				    in
				       x_15647
				    end
	       val x_15656: word64 * word64 = 
		  (i_47, x_15642)
	       val x_15657: bool = 
		  >=_5 x_15656
	       val x_15658: unit = 
		  case x_15657 of
		  true => 
		     let
			val x_15662: unit = 
			   raise x_8296
		     in
			x_15662
		     end
		  false => 
		     let
			val x_15659: word64 * word64 = 
			   (x_15641, i_47)
			val x_15660: word64 = 
			   +?_1 x_15659
			val x_15661: unit = 
			   Array_update[cpointer -> unit] (x_15524,
							   x_15660,
							   x_15633)
		     in
			x_15661
		     end
	       val x_15663: list_6 = 
		  nil_6
	       val all_0: list_6 ref = 
		  Ref_ref[list_6] (x_15663)
	       val rec 
		  make_1: cpointer -> MLtonProfile.Data.t_0 = 
		     fn x_15664: cpointer => 
		     let
			val x_15665: bool = 
			   false
			val x_15666: bool ref = 
			   Ref_ref[bool] (x_15665)
			val x_15667: bool = 
			   false
			val x_15668: bool ref = 
			   Ref_ref[bool] (x_15667)
			val x_15669: bool ref * bool ref * cpointer = 
			   (x_15666, x_15668, x_15664)
			val x_15670: MLtonProfile.Data.t_0 = 
			   T_8 x_15669
		     in
			x_15670
		     end
	       val x_15671: MLtonProfile.Data.t_0 = 
		  make_1 null_0
	       val r_2: MLtonProfile.Data.t_0 ref = 
		  Ref_ref[MLtonProfile.Data.t_0] (x_15671)
	       val rec 
		  current_0: unit -> MLtonProfile.Data.t_0 = 
		     fn x_15672: unit => 
		     let
			val x_15673: MLtonProfile.Data.t_0 = 
			   Ref_deref[MLtonProfile.Data.t_0] (r_2)
		     in
			x_15673
		     end
	       val rec 
		  init_0: unit -> unit = 
		     fn x_15674: unit => 
		     let
			val x_15675: cpointer = 
			   GC_getProfileCurrent (x_8832)
			val x_15676: MLtonProfile.Data.t_0 = 
			   make_1 x_15675
			val x_15677: unit = 
			   case x_15676 of
			   T_8 x_15678: bool ref * bool ref * cpointer => 
			      let
				 val x_15679: cpointer = 
				    #2 x_15678
				 val x_15680: bool ref = 
				    #1 x_15678
				 val x_15681: bool ref = 
				    #0 x_15678
				 val x_15682: bool = 
				    not_0 isOn_0
				 val x_15683: unit = 
				    case x_15682 of
				    true => 
				       let
					  val x_15704: unit = 
					     ()
				       in
					  x_15704
				       end
				    false => 
				       let
					  val x_15684: bool = 
					     x_8321 x_15680
					  val x_15685: unit = 
					     case x_15684 of
					     true => 
						let
						   val x_15700: word8 vector = 
						      "setCurrent of freed profile data"
						   val x_15701: unit ref
								* word8 vector = 
						      (x_9554, x_15700)
						   val x_15702: exn = 
						      Fail_0 x_15701
						   val x_15703: unit = 
						      raise x_15702
						in
						   x_15703
						end
					     false => 
						let
						   val x_15686: unit = 
						      ()
						   val x_15687: MLtonProfile.Data.t_0 = 
						      current_0 x_15686
						   val x_15688: unit = 
						      case x_15687 of
						      T_8 x_15689: bool ref
								   * bool ref
								   * cpointer => 
							 let
							    val x_15690: bool ref = 
							       #0 x_15689
							    val x_15691: bool = 
							       false
							    val x_15692: bool ref
									 * bool = 
							       (x_15690, x_15691)
							    val x_15693: unit = 
							       x_8342 x_15692
							    val x_15694: bool = 
							       true
							    val x_15695: bool ref
									 * bool = 
							       (x_15681, x_15694)
							    val x_15696: unit = 
							       x_8342 x_15695
							    val x_15697: unit = 
							       Ref_assign[MLtonProfile.Data.t_0] (r_2,
												  x_15676)
							    val x_15698: unit = 
							       GC_setProfileCurrent (x_8832,
										     x_15679)
							    val x_15699: unit = 
							       ()
							 in
							    x_15699
							 end
						in
						   x_15688
						end
				       in
					  x_15685
				       end
			      in
				 x_15683
			      end
		     in
			x_15677
		     end
	       val x_15705: bool = 
		  not_0 isOn_0
	       val x_15706: unit = 
		  case x_15705 of
		  true => 
		     let
			val x_15821: unit = 
			   ()
		     in
			x_15821
		     end
		  false => 
		     let
			val x_15707: unit -> unit = 
			   fn x_15708: unit => 
			   let
			      val x_15709: unit = 
				 GC_profileDone (x_8832)
			      val x_15710: unit = 
				 ()
			      val x_15711: MLtonProfile.Data.t_0 = 
				 current_0 x_15710
			      val x_15712: word8 vector = 
				 "mlmon.out"
			      val x_15713: unit = 
				 case x_15711 of
				 T_8 x_15714: bool ref * bool ref * cpointer => 
				    let
				       val x_15715: cpointer = 
					  #2 x_15714
				       val x_15716: bool ref = 
					  #1 x_15714
				       val x_15717: bool = 
					  not_0 isOn_0
				       val x_15718: unit = 
					  case x_15717 of
					  true => 
					     let
						val x_15789: unit = 
						   ()
					     in
						x_15789
					     end
					  false => 
					     let
						val x_15719: bool = 
						   x_8321 x_15716
						val x_15720: unit = 
						   case x_15719 of
						   true => 
						      let
							 val x_15785: word8 vector = 
							    "write of freed profile data"
							 val x_15786: unit ref
								      * word8 vector = 
							    (x_9554, x_15785)
							 val x_15787: exn = 
							    Fail_0 x_15786
							 val x_15788: unit = 
							    raise x_15787
						      in
							 x_15788
						      end
						   false => 
						      let
							 val x_15721: PrimSequence.Slice.t_1 = 
							    full_10 x_15712
							 val x_15722: PrimSequence.Slice.t_1 = 
							    full_10 x_10953
							 val x_15723: word64 = 
							    length_17 x_15721
							 val x_15724: word64 = 
							    0x0
							 val x_15725: word64
								      * word64 = 
							    (x_15723, x_15724)
							 val x_15726: bool = 
							    x_8372 x_15725
							 val x_15727: word8 vector = 
							    case x_15726 of
							    true => 
							       let
								  val x_15769: word8 vector = 
								     sequence_3 x_15722
							       in
								  x_15769
							       end
							    false => 
							       let
								  val x_15728: word64 = 
								     length_17 x_15722
								  val x_15729: word64 = 
								     0x0
								  val x_15730: word64
									       * word64 = 
								     (x_15728,
								      x_15729)
								  val x_15731: bool = 
								     x_8372 x_15730
								  val x_15732: word8 vector = 
								     case x_15731 of
								     true => 
									let
									   val x_15768: word8 vector = 
									      sequence_3 x_15721
									in
									   x_15768
									end
								     false => 
									let
									   val l1_0: word64 = 
									      length_17 x_15721
									   val l2_0: word64 = 
									      length_17 x_15722
									   val x_15733: word64
											* word64 = 
									      (l1_0,
									       l2_0)
									   val n_21: word64 = 
									      +?_1 x_15733
									   val x_15734: word64 = 
									      0x0
									   val x_15735: word64
											* PrimSequence.Slice.t_1 = 
									      (x_15734,
									       x_15721)
									   val a_18: word8 array = 
									      arrayUninit_1 n_21
									   val rec 
									      loop_44: word64
										       * (word64
											  * PrimSequence.Slice.t_1)
										       -> word64
											  * PrimSequence.Slice.t_1 = 
										 fn x_15736: word64
											     * (word64
												* PrimSequence.Slice.t_1) => 
										 let
										    val b_53: word64
											      * PrimSequence.Slice.t_1 = 
										       #1 x_15736
										    val i_48: word64 = 
										       #0 x_15736
										    val x_15737: word64
												 * word64 = 
										       (i_48,
											n_21)
										    val x_15738: bool = 
										       >=_2 x_15737
										    val x_15739: word64
												 * PrimSequence.Slice.t_1 = 
										       case x_15738 of
										       true => 
											  let
											  in
											     b_53
											  end
										       false => 
											  let
											     val sl_3: PrimSequence.Slice.t_1 = 
												#1 b_53
											     val i_49: word64 = 
												#0 b_53
											     val x_15740: word64 = 
												length_17 sl_3
											     val x_15741: word64
													  * word64 = 
												(i_49,
												 x_15740)
											     val x_15742: bool = 
												<_2 x_15741
											     val x_15743: word8
													  * (word64
													     * PrimSequence.Slice.t_1) = 
												case x_15742 of
												true => 
												   let
												      val x_15750: PrimSequence.Slice.t_1
														   * word64 = 
													 (sl_3,
													  i_49)
												      val x_15751: word8 = 
													 unsafeSub_6 x_15750
												      val x_15752: word64 = 
													 0x1
												      val x_15753: word64
														   * word64 = 
													 (i_49,
													  x_15752)
												      val x_15754: word64 = 
													 +?_1 x_15753
												      val x_15755: word64
														   * PrimSequence.Slice.t_1 = 
													 (x_15754,
													  sl_3)
												      val x_15756: word8
														   * (word64
														      * PrimSequence.Slice.t_1) = 
													 (x_15751,
													  x_15755)
												   in
												      x_15756
												   end
												false => 
												   let
												      val x_15744: word64 = 
													 0x0
												      val x_15745: PrimSequence.Slice.t_1
														   * word64 = 
													 (x_15722,
													  x_15744)
												      val x_15746: word8 = 
													 unsafeSub_6 x_15745
												      val x_15747: word64 = 
													 0x1
												      val x_15748: word64
														   * PrimSequence.Slice.t_1 = 
													 (x_15747,
													  x_15722)
												      val x_15749: word8
														   * (word64
														      * PrimSequence.Slice.t_1) = 
													 (x_15746,
													  x_15748)
												   in
												      x_15749
												   end
											     val b_54: word64
												       * PrimSequence.Slice.t_1 = 
												#1 x_15743
											     val x_15757: word8 = 
												#0 x_15743
											     val x_15758: word8 array
													  * word64
													  * word8 = 
												(a_18,
												 i_48,
												 x_15757)
											     val x_15759: unit = 
												x_8677 x_15758
											     val x_15760: word64 = 
												0x1
											     val x_15761: word64
													  * word64 = 
												(i_48,
												 x_15760)
											     val x_15762: word64 = 
												+?_1 x_15761
											     val x_15763: word64
													  * (word64
													     * PrimSequence.Slice.t_1) = 
												(x_15762,
												 b_54)
											     val x_15764: word64
													  * PrimSequence.Slice.t_1 = 
												loop_44 x_15763
											  in
											     x_15764
											  end
										 in
										    x_15739
										 end
									   val x_15765: word64 = 
									      0x0
									   val x_15766: word64
											* (word64
											   * PrimSequence.Slice.t_1) = 
									      (x_15765,
									       x_15735)
									   val b_55: word64
										     * PrimSequence.Slice.t_1 = 
									      loop_44 x_15766
									   val x_15767: word8 vector = 
									      x_8683 a_18
									in
									   x_15767
									end
							       in
								  x_15732
							       end
							 val x_15770: word8 = 
							    0x0
							 val x_15771: word64 = 
							    x_8686 x_15727
							 val x_15772: word64 = 
							    0x1
							 val x_15773: word64
								      * word64 = 
							    (x_15771, x_15772)
							 val x_15774: word64 = 
							    x_8628 x_15773
							 val x_15775: word8 vector
								      * word64 = 
							    (x_15727, x_15774)
							 val x_15776: word8 = 
							    x_8689 x_15775
							 val x_15777: word8
								      * word8 = 
							    (x_15770, x_15776)
							 val x_15778: bool = 
							    x_8377 x_15777
							 val x_15779: word8 vector = 
							    case x_15778 of
							    true => 
							       let
							       in
								  x_15727
							       end
							    false => 
							       let
								  val x_15780: word8 vector = 
								     "NullString.fromString"
								  val x_15781: unit ref
									       * word8 vector = 
								     (x_8287,
								      x_15780)
								  val x_15782: exn = 
								     Fail8_0 x_15781
								  val x_15783: word8 vector = 
								     raise x_15782
							       in
								  x_15783
							       end
							 val x_15784: unit = 
							    GC_profileWrite (x_8832,
									     x_15715,
									     x_15779)
						      in
							 x_15784
						      end
					     in
						x_15720
					     end
				    in
				       x_15718
				    end
			      val x_15790: unit = 
				 ()
			      val x_15791: list_6 = 
				 Ref_deref[list_6] (all_0)
			      val rec 
				 loop_45: list_6 * unit -> unit = 
				    fn x_15792: list_6 * unit => 
				    let
				       val b_56: unit = 
					  #1 x_15792
				       val l_6: list_6 = 
					  #0 x_15792
				       val x_15793: unit = 
					  case l_6 of
					  nil_6 => 
					     let
					     in
						b_56
					     end
					  ::_6 x_15794: MLtonProfile.Data.t_0
							* list_6 => 
					     let
						val x_15795: list_6 = 
						   #1 x_15794
						val x_15796: MLtonProfile.Data.t_0 = 
						   #0 x_15794
						val x_15797: cpointer = 
						   case x_15796 of
						   T_8 x_15798: bool ref
								* bool ref
								* cpointer => 
						      let
							 val x_15799: cpointer = 
							    #2 x_15798
						      in
							 x_15799
						      end
						val x_15800: unit = 
						   GC_profileFree (x_8832,
								   x_15797)
						val x_15801: list_6 * unit = 
						   (x_15795, x_15800)
						val x_15802: unit = 
						   loop_45 x_15801
					     in
						x_15802
					     end
				    in
				       x_15793
				    end
			      val x_15803: list_6 * unit = 
				 (x_15791, x_15790)
			      val x_15804: unit = 
				 loop_45 x_15803
			   in
			      x_15804
			   end
			val x_15805: list_2 = 
			   x_8297 atExit_0
			val x_15806: (unit -> unit) * list_2 = 
			   (x_15707, x_15805)
			val x_15807: list_2 = 
			   ::_2 x_15806
			val x_15808: unit = 
			   Ref_assign[list_2] (atExit_0, x_15807)
			val x_15809: unit -> unit = 
			   fn x_15810: unit => 
			   let
			      val x_15811: list_6 = 
				 nil_6
			      val x_15812: unit = 
				 Ref_assign[list_6] (all_0, x_15811)
			      val x_15813: unit = 
				 ()
			      val x_15814: unit = 
				 init_0 x_15813
			   in
			      x_15814
			   end
			val x_15815: list_2 = 
			   x_8297 atLoadWorld_0
			val x_15816: (unit -> unit) * list_2 = 
			   (x_15809, x_15815)
			val x_15817: list_2 = 
			   ::_2 x_15816
			val x_15818: unit = 
			   Ref_assign[list_2] (atLoadWorld_0, x_15817)
			val x_15819: unit = 
			   ()
			val x_15820: unit = 
			   init_0 x_15819
		     in
			x_15820
		     end
	       val x_15822: unit = 
		  Ref_assign[exn -> unit] (x_8175, defaultTopLevelHandler_0)
	       val x_15823: unit = 
		  Ref_assign[unit -> unit] (x_8181, defaultTopLevelSuffix_0)
	       val x_15824: unit -> unit = 
		  Ref_deref[unit -> unit] (x_8181)
	       val x_15825: unit = 
		  ()
	       val x_15826: unit = 
		  x_15824 x_15825
	    in
	       x_15826
	    end
	    handle x_15827 => let
				 val x_15828: exn -> unit = 
				    Ref_deref[exn -> unit] (x_8175)
				 val x_15829: unit = 
				    x_15828 x_15827
			      in
				 x_15829
			      end
      in
	 x_8176
      end
      handle x_15830 => let
			   val x_15831: word8 vector = 
			      "toplevel handler not installed"
			   val x_15832: unit = 
			      MLton_bug (x_15831)
			in
			   x_15832
			end
in
   x_8170
end
