MLton gd05531c-dirty (built Wed Jun 29 03:10:58 UTC 2016 on ip-10-11-0-169)
  created this file on Wed Jun 29 03:19:14 2016.
Do not edit this file.
Flag settings: 
   align: 8
   atMLtons: (@MLton, --)
   chunk: coalesce 4096
   closureConvertGlobalize: true
   closureConvertShrink: true
   codegen: c
   contifyIntoMain: false
   debug: true
   defaultChar: char8
   defaultWideChar: widechar32
   defaultInt: int32
   defaultReal: real64
   defaultWord: word32
   diag passes: []
   drop passes: []
   elaborate allowConstant (default): false
   elaborate allowConstant (enabled): true
   elaborate allowFFI (default): false
   elaborate allowFFI (enabled): true
   elaborate allowPrim (default): false
   elaborate allowPrim (enabled): true
   elaborate allowOverload (default): false
   elaborate allowOverload (enabled): true
   elaborate allowOptBar (default): false
   elaborate allowOptBar (enabled): true
   elaborate allowOptSemicolon (default): false
   elaborate allowOptSemicolon (enabled): true
   elaborate allowLineComments (default): false
   elaborate allowLineComments (enabled): true
   elaborate allowDoDecls (default): false
   elaborate allowDoDecls (enabled): true
   elaborate allowRecPunning (default): false
   elaborate allowRecPunning (enabled): true
   elaborate allowOrPats (default): false
   elaborate allowOrPats (enabled): true
   elaborate allowExtendedLiterals (default): false
   elaborate allowExtendedLiterals (enabled): true
   elaborate allowSigWithtype (default): false
   elaborate allowSigWithtype (enabled): true
   elaborate allowRebindEquals (default): false
   elaborate allowRebindEquals (enabled): true
   elaborate deadCode (default): false
   elaborate deadCode (enabled): true
   elaborate forceUsed (default): false
   elaborate forceUsed (enabled): true
   elaborate ffiStr (default): 
   elaborate ffiStr (enabled): true
   elaborate nonexhaustiveExnMatch (default): default
   elaborate nonexhaustiveExnMatch (enabled): true
   elaborate nonexhaustiveMatch (default): warn
   elaborate nonexhaustiveMatch (enabled): true
   elaborate redundantMatch (default): warn
   elaborate redundantMatch (enabled): true
   elaborate resolveScope (default): strdec
   elaborate resolveScope (enabled): true
   elaborate sequenceNonUnit (default): ignore
   elaborate sequenceNonUnit (enabled): true
   elaborate valrecConstr (default): warn
   elaborate valrecConstr (enabled): true
   elaborate warnUnused (default): false
   elaborate warnUnused (enabled): true
   elaborate only: false
   emit main: true
   export header: None
   exn history: false
   generated output format: executable
   gc check: Limit
   indentation: 3
   inlineIntoMain: true
   inlineLeafA: {loops = true, repeat = true, size = Some 20}
   inlineLeafB: {loops = true, repeat = true, size = Some 40}
   inlineNonRec: {small = 60, product = 320}
   input file: test2.xml
   keep AST: false
   keep CoreML: true
   keep def use: true
   keep dot: false
   keep Machine: true
   keep passes: []
   keep RSSA: true
   keep SSA: true
   keep SSA2: true
   keep SXML: true
   keep XML: true
   extra_: false
   lib dir: /home/jcmurphy/MLton/build/lib
   lib target dir: /home/jcmurphy/MLton/build/lib/targets/self
   loop passes: 1
   mark cards: true
   max function size: 10000
   mlb path vars: [{var = MLTON_ROOT, path = $(LIB_MLTON_DIR)/sml}, {var = SML_LIB, path = $(LIB_MLTON_DIR)/sml}]
   native commented: 0
   native live stack: false
   native optimize: 1
   native move hoist: true
   native copy prop: true
   native copy prop cutoff: 1000
   native cutoff: 100
   native live transfer: 8
   native shuffle: true
   native ieee fp: false
   native split: Some 20000
   optimizationPasses: [<ssa2::default>, <ssa::default>, <sxml::default>, <xml::default>]
   polyvariance: Some {hofo = true, rounds = 2, small = 30, product = 300}
   prefer abs paths: false
   prof passes: []
   profile: None
   profile branch: false
   profile C: []
   profile IL: ProfileSource
   profile include/exclude: [(Seq [Star [.], Or [Seq [Seq [[$], [(], [S], [M], [L], [_], [L], [I], [B], [)]]]], Star [.]], false)]
   profile raise: false
   profile stack: false
   profile val: false
   show basis: None
   show def-use: None
   show types: true
   target: self
   target arch: AMD64
   target OS: Linux
   type check: false
   verbosity: Pass
   warn unrecognized annotation: true
   warn deprecated features: true
   zone cut depth: 100


Datatypes:
SMLofNJ.SysInfo.os_kind = BEOS
			  | MACOS
			  | OS2
			  | UNIX
			  | WIN32
MLtonWorld.status = Clone
		    | Original
'a MLtonFinalizable.t = T of (unit -> unit) list ref
			     * ('a -> unit) list ref
			     * 'a ref
MLtonProfile.Data.t = T of bool ref * bool ref * cpointer
MLtonItimer.t = Prof
		| Real
		| Virtual
UnixSock.unix = UNIX
INetSock.inet = INET
Socket.shutdown_mode = NO_RECVS
		       | NO_SENDS
		       | NO_RECVS_OR_SENDS
Socket.active = ACTIVE
Socket.passive = PASSIVE
Socket.stream = MODE
Socket.dgram = DGRAM
Socket.sock_addr = SA of word8 vector
NetServDB.entry = T of word8 vector list * word8 vector * word32 * word8 vector
NetProtDB.entry = T of word8 vector list * word8 vector * word32
NetHostDB.entry = T of word32
		       * word8 vector list
		       * word8 vector list
		       * word8 vector
Timer.SysUsr.t = T of Time.time * Time.time
OS_IO.poll_info = PollInfo of word32 * (bool * bool * bool)
OS_IO.poll_desc = PollDesc of word32 * (bool * bool * bool)
OS_IO.iodesc_kind = K of word8 vector
('stdin, 'stdout, 'stderr) MLtonProcess.t = T of word32
						 * PosixProcess.exit_status Primitive.Option.t ref
						 * 'stderr MLtonProcess.Child.childt ref
						 * 'stdin MLtonProcess.Child.childt ref
						 * 'stdout MLtonProcess.Child.childt ref
MLtonProcess.Param.t = File of word8 vector
		       | FileDesc of word32
		       | Pipe
		       | Self
'use MLtonProcess.Child.childt = FileDesc of word32
				 | Stream of 'use * ('use -> unit)
				 | Term
MLtonSignal.Handler.t = Default
			| Handler of unit MLtonThread.t -> unit MLtonThread.t
			| Ignore
			| InvalidSignal
MLtonSignal.Mask.t = AllBut of word32 list
		     | Some of word32 list
MLtonThread.state = Normal
		    | InHandler
'a MLtonThread.t = T of 'a MLtonThread.thread ref
'a MLtonThread.thread = Dead
			| Interrupted of thread
			| New of 'a -> unit
			| Paused of ((unit -> 'a) -> unit) * thread
MLtonThread.AtomicState.t = NonAtomic
			    | Atomic of word32
OS_FileSys.file_id = FID of word64 * word64
ImperativeIOExtra.instream = In of PrimIO.reader
				   * word8 array
				   * word32 ref
				   * word32 ref
				   * PrimIO.reader
				   * ImperativeIOExtra.state ref
ImperativeIOExtra.state = Closed
			  | Open of bool
			  | Stream of StreamIOExtra.instream
ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
StreamIOExtra.Close.t = T of (unit -> unit)
			     * word8 vector
			     * StreamIOExtra.state ref ref
StreamIOExtra.instream = In of StreamIOExtra.buf
			       * (PrimIO.reader
				  * PrimIO.reader
				  * StreamIOExtra.state ref ref)
			       * word32
StreamIOExtra.buf = Buf of word64 Primitive.Option.t
			   * word8 vector
			   * StreamIOExtra.state ref
StreamIOExtra.state = Link of StreamIOExtra.buf
		      | Eos of StreamIOExtra.buf
		      | End
		      | Truncated
		      | Closed
StreamIOExtra.out_pos = OutPos of StreamIOExtra.outstream * word64
StreamIOExtra.outstream = Out of PrimIO.writer
				 * StreamIOExtra.bufferMode ref
				 * StreamIOExtra.state ref
				 * PrimIO.writer
StreamIOExtra.state = Active
		      | Terminated
		      | Closed
StreamIOExtra.bufferMode = NO_BUF
			   | LINE_BUF of StreamIOExtra.buf
			   | BLOCK_BUF of StreamIOExtra.buf
StreamIOExtra.buf = Buf of word8 array * word32 ref
ImperativeIOExtra.instream = In of PrimIO.reader
				   * word8 array
				   * word32 ref
				   * word32 ref
				   * PrimIO.reader
				   * ImperativeIOExtra.state ref
ImperativeIOExtra.state = Closed
			  | Open of bool
			  | Stream of StreamIOExtra.instream
ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
StreamIOExtra.Close.t = T of (unit -> unit)
			     * word8 vector
			     * StreamIOExtra.state ref ref
StreamIOExtra.instream = In of StreamIOExtra.buf
			       * (PrimIO.reader
				  * PrimIO.reader
				  * StreamIOExtra.state ref ref)
			       * word32
StreamIOExtra.buf = Buf of word64 Primitive.Option.t
			   * word8 vector
			   * StreamIOExtra.state ref
StreamIOExtra.state = Link of StreamIOExtra.buf
		      | Eos of StreamIOExtra.buf
		      | End
		      | Truncated
		      | Closed
StreamIOExtra.out_pos = OutPos of StreamIOExtra.outstream * word64
StreamIOExtra.outstream = Out of PrimIO.writer
				 * StreamIOExtra.bufferMode ref
				 * StreamIOExtra.state ref
				 * PrimIO.writer
StreamIOExtra.state = Active
		      | Terminated
		      | Closed
StreamIOExtra.bufferMode = NO_BUF
			   | LINE_BUF of StreamIOExtra.buf
			   | BLOCK_BUF of StreamIOExtra.buf
StreamIOExtra.buf = Buf of word8 array * word32 ref
PosixProcess.killpid_arg = K_PROC of word32
			   | K_SAME_GROUP
			   | K_GROUP of word32
PosixProcess.exit_status = W_EXITED
			   | W_EXITSTATUS of word8
			   | W_SIGNALED of word32
			   | W_STOPPED of word32
PosixProcess.waitpid_arg = W_ANY_CHILD
			   | W_CHILD of word32
			   | W_SAME_GROUP
			   | W_GROUP of word32
PosixIO.lock_type = F_RDLCK
		    | F_WRLCK
		    | F_UNLCK
PosixIO.whence = SEEK_SET
		 | SEEK_CUR
		 | SEEK_END
PosixFileSys.access_mode = A_READ
			   | A_WRITE
			   | A_EXEC
PosixFileSys.ST.stat = T of Time.time
			    * Time.time
			    * word64
			    * word32
			    * word64
			    * word32
			    * Time.time
			    * word32
			    * word64
			    * word32
PosixFileSys.open_mode = O_RDONLY
			 | O_WRONLY
			 | O_RDWR
PosixFileSys.dirstream = DS of word64 Primitive.Option.t ref
PrimIO.writer = WR of (unit -> unit) Primitive.Option.t
		      * (unit -> bool) Primitive.Option.t
		      * word32
		      * (unit -> unit)
		      * (unit -> word64) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
		      * word32 Primitive.Option.t
		      * word8 vector
		      * (word64 -> unit) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
PrimIO.reader = RD of (unit -> word32 Primitive.Option.t)
		      * (unit -> unit) Primitive.Option.t
		      * (unit -> bool) Primitive.Option.t
		      * word32
		      * (unit -> unit)
		      * (unit -> word64) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
		      * word32 Primitive.Option.t
		      * word8 vector
		      * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		      * (word32 -> word8 vector) Primitive.Option.t
		      * (word32 -> word8 vector Primitive.Option.t) Primitive.Option.t
		      * (word64 -> unit) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
PrimIO.writer = WR of (unit -> unit) Primitive.Option.t
		      * (unit -> bool) Primitive.Option.t
		      * word32
		      * (unit -> unit)
		      * (unit -> word64) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
		      * word32 Primitive.Option.t
		      * word8 vector
		      * (word64 -> unit) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
PrimIO.reader = RD of (unit -> word32 Primitive.Option.t)
		      * (unit -> unit) Primitive.Option.t
		      * (unit -> bool) Primitive.Option.t
		      * word32
		      * (unit -> unit)
		      * (unit -> word64) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
		      * word32 Primitive.Option.t
		      * word8 vector
		      * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		      * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		      * (word32 -> word8 vector) Primitive.Option.t
		      * (word32 -> word8 vector Primitive.Option.t) Primitive.Option.t
		      * (word64 -> unit) Primitive.Option.t
		      * (unit -> word64) Primitive.Option.t
IO.buffer_mode = NO_BUF
		 | LINE_BUF
		 | BLOCK_BUF
Date.t = T of word32
	      * word32
	      * bool Primitive.Option.t
	      * word32
	      * Date.month
	      * word32 Primitive.Option.t
	      * word32
	      * Date.weekday
	      * word32
	      * word32
Date.month = Jan
	     | Feb
	     | Mar
	     | Apr
	     | May
	     | Jun
	     | Jul
	     | Aug
	     | Sep
	     | Oct
	     | Nov
	     | Dec
Date.weekday = Mon
	       | Tue
	       | Wed
	       | Thu
	       | Fri
	       | Sat
	       | Sun
Time.time = T of intInf
Real.mode = Fix
	    | Gen
	    | Sci
Real.mode = Fix
	    | Gen
	    | Sci
IEEEReal.RoundingMode.t = TO_NEAREST
			  | TO_NEGINF
			  | TO_POSINF
			  | TO_ZERO
IEEEReal.float_class = INF
		       | NAN
		       | NORMAL
		       | SUBNORMAL
		       | ZERO
IEEEReal.real_order = LESS
		      | EQUAL
		      | GREATER
		      | UNORDERED
StringCvt.realfmt = SCI of word32 Primitive.Option.t
		    | FIX of word32 Primitive.Option.t
		    | GEN of word32 Primitive.Option.t
		    | EXACT
StringCvt.radix = BIN
		  | OCT
		  | DEC
		  | HEX
Array2.traversal = RowMajor
		   | ColMajor
'a One.t = T of (unit -> 'a) * 'a * bool ref
'a Primitive.IntInf.ans = Big of bool * bool * 'a
			  | Small of word64
Primitive.IntInf.rep = Big of word64 vector
		       | Small of word64
'a PrimSequence.Slice.t = T of word64 * 'a array * word64
'a PrimSequence.Slice.t = T of word64 * 'a vector * word64
'a DynamicWind.try.t = A of 'a
		       | E of exn
Primitive.MLton.Platform.OS.t = AIX
				| Cygwin
				| Darwin
				| FreeBSD
				| Hurd
				| HPUX
				| Linux
				| MinGW
				| NetBSD
				| OpenBSD
				| Solaris
Primitive.MLton.Platform.Format.t = Archive
				    | Executable
				    | LibArchive
				    | Library
Primitive.MLton.Platform.Arch.t = Alpha
				  | AMD64
				  | ARM
				  | ARM64
				  | HPPA
				  | IA64
				  | m68k
				  | MIPS
				  | PowerPC
				  | PowerPC64
				  | S390
				  | Sparc
				  | X86
Primitive.MLton.Codegen.t = AMD64
			    | C
			    | LLVM
			    | X86
Primitive.MLton.CallStack.t = T of word32 array
Primitive.MLton.Align.t = Align4
			  | Align8
'a Primitive.Option.t = NONE
			| SOME of 'a
Primitive.Order.t = LESS
		    | EQUAL
		    | GREATER
'a_0 list = nil
	    | :: of 'a_0 * 'a_0 list
bool = false
       | true


Overflow: None


Body:
let
   exception Bind
   exception Match
   exception Overflow
   val rec 
      not: bool -> bool = 
	 fn x_0: bool => 
	 let
	    val x_1766: bool = 
	       case x_0 of
	       true => 
		  let
		     val x_1768: bool = 
			false
		  in
		     x_1768
		  end
	       false => 
		  let
		     val x_1767: bool = 
			true
		  in
		     x_1767
		  end
	 in
	    x_1766
	 end
   val bufSize: word32 = 
      0x1000
   val name: exn -> word8 vector = 
      fn x_1: exn => 
      let
	 val x_1769: word8 vector = 
	    Exn_name (x_1)
      in
	 x_1769
      end
   exception Div
   exception Domain
   exception Fail8 of word8 vector
   exception Fail16 of word16 vector
   exception Fail32 of word32 vector
   exception Overflow
   exception Size
   exception Span
   exception Subscript
   val ('b, 'a) wrapOverflow: ('a -> 'b) -> 'a -> 'b = 
      let
	 val x_1770: ('a -> 'b) -> 'a -> 'b = 
	    fn x_2: 'a -> 'b => 
	    let
	       val x_1771: 'a -> 'b = 
		  fn x_3: 'a => 
		  let
		     val x_1772: 'b = 
			let
			   val x_1773: 'b = 
			      x_2 x_3
			in
			   x_1773
			end
			handle x_4 => let
					 val x_1774: 'b = 
					    case x_4 of
					    Overflow => 
					       let
						  val x_1775: exn = 
						     Overflow
						  val x_1776: 'b = 
						     raise x_1775
					       in
						  x_1776
					       end
					      _ => let
						      val x_1777: 'b = 
							 raise x_4
						   in
						      x_1777
						   end
				      in
					 x_1774
				      end
		  in
		     x_1772
		  end
	    in
	       x_1771
	    end
      in
	 x_1770
      end
   val 'a deref: 'a ref -> 'a = 
      let
	 val x_1778: 'a ref -> 'a = 
	    fn x_5: 'a ref => 
	    let
	       val x_1779: 'a = 
		  Ref_deref['a] (x_5)
	    in
	       x_1779
	    end
      in
	 x_1778
      end
   val 'a assign: 'a ref * 'a -> unit = 
      let
	 val x_1780: 'a ref * 'a -> unit = 
	    fn x_6: 'a ref * 'a => 
	    let
	       val x_7: 'a = 
		  #1 x_6
	       val x_8: 'a ref = 
		  #0 x_6
	       val x_1781: unit = 
		  Ref_assign['a] (x_8, x_7)
	    in
	       x_1781
	    end
      in
	 x_1780
      end
   val setHandler: (exn -> unit) -> unit = 
      fn x_10: exn -> unit => 
      let
	 val x_1782: unit = 
	    TopLevel_setHandler (x_10)
      in
	 x_1782
      end
   val setSuffix: (unit -> unit) -> unit = 
      fn x_11: unit -> unit => 
      let
	 val x_1783: unit = 
	    TopLevel_setSuffix (x_11)
      in
	 x_1783
      end
   val ''a =: ''a * ''a -> bool = 
      let
	 val x_1784: ''a * ''a -> bool = 
	    fn x_12: ''a * ''a => 
	    let
	       val x_13: ''a = 
		  #1 x_12
	       val x_14: ''a = 
		  #0 x_12
	       val x_1785: bool = 
		  MLton_equal[''a] (x_14, x_13)
	    in
	       x_1785
	    end
      in
	 x_1784
      end
   val ''a_2 <>: ''a_2 * ''a_2 -> bool = 
      let
	 val x_1786: ''a_2 * ''a_2 -> bool = 
	    fn x_15: ''a_2 * ''a_2 => 
	    let
	       val y: ''a_2 = 
		  #1 x_15
	       val x: ''a_2 = 
		  #0 x_15
	       val x_1787: ''a_2 * ''a_2 = 
		  (x, y)
	       val x_1788: bool = 
		  = (''a_2) x_1787
	       val x_1789: bool = 
		  not x_1788
	    in
	       x_1789
	    end
      in
	 x_1786
      end
   val idFromInt8ToWord8: word8 -> word8 = 
      fn x_16: word8 => 
      let
      in
	 x_16
      end
   val idFromInt16ToWord16: word16 -> word16 = 
      fn x_17: word16 => 
      let
      in
	 x_17
      end
   val idFromInt32ToWord32: word32 -> word32 = 
      fn x_18: word32 => 
      let
      in
	 x_18
      end
   val idFromInt64ToWord64: word64 -> word64 = 
      fn x_19: word64 => 
      let
      in
	 x_19
      end
   val idFromWord8ToInt8: word8 -> word8 = 
      fn x_20: word8 => 
      let
      in
	 x_20
      end
   val idFromWord16ToInt16: word16 -> word16 = 
      fn x_21: word16 => 
      let
      in
	 x_21
      end
   val idFromWord32ToInt32: word32 -> word32 = 
      fn x_22: word32 => 
      let
      in
	 x_22
      end
   val idFromWord64ToInt64: word64 -> word64 = 
      fn x_23: word64 => 
      let
      in
	 x_23
      end
   val zextdFromInt8ToInt16: word8 -> word16 = 
      fn x_25: word8 => 
      let
	 val x_1790: word16 = 
	    WordU8_extdToWord16 (x_25)
      in
	 x_1790
      end
   val zextdFromInt8ToInt32: word8 -> word32 = 
      fn x_26: word8 => 
      let
	 val x_1791: word32 = 
	    WordU8_extdToWord32 (x_26)
      in
	 x_1791
      end
   val zextdFromInt8ToInt64: word8 -> word64 = 
      fn x_27: word8 => 
      let
	 val x_1792: word64 = 
	    WordU8_extdToWord64 (x_27)
      in
	 x_1792
      end
   val zextdFromInt8ToWord16: word8 -> word16 = 
      fn x_29: word8 => 
      let
	 val x_1793: word16 = 
	    WordU8_extdToWord16 (x_29)
      in
	 x_1793
      end
   val zextdFromInt8ToWord32: word8 -> word32 = 
      fn x_30: word8 => 
      let
	 val x_1794: word32 = 
	    WordU8_extdToWord32 (x_30)
      in
	 x_1794
      end
   val zextdFromInt8ToWord64: word8 -> word64 = 
      fn x_31: word8 => 
      let
	 val x_1795: word64 = 
	    WordU8_extdToWord64 (x_31)
      in
	 x_1795
      end
   val zextdFromInt16ToInt8: word16 -> word8 = 
      fn x_32: word16 => 
      let
	 val x_1796: word8 = 
	    WordU16_extdToWord8 (x_32)
      in
	 x_1796
      end
   val zextdFromInt16ToInt32: word16 -> word32 = 
      fn x_34: word16 => 
      let
	 val x_1797: word32 = 
	    WordU16_extdToWord32 (x_34)
      in
	 x_1797
      end
   val zextdFromInt16ToInt64: word16 -> word64 = 
      fn x_35: word16 => 
      let
	 val x_1798: word64 = 
	    WordU16_extdToWord64 (x_35)
      in
	 x_1798
      end
   val zextdFromInt16ToWord8: word16 -> word8 = 
      fn x_36: word16 => 
      let
	 val x_1799: word8 = 
	    WordU16_extdToWord8 (x_36)
      in
	 x_1799
      end
   val zextdFromInt16ToWord32: word16 -> word32 = 
      fn x_38: word16 => 
      let
	 val x_1800: word32 = 
	    WordU16_extdToWord32 (x_38)
      in
	 x_1800
      end
   val zextdFromInt16ToWord64: word16 -> word64 = 
      fn x_39: word16 => 
      let
	 val x_1801: word64 = 
	    WordU16_extdToWord64 (x_39)
      in
	 x_1801
      end
   val zextdFromInt32ToInt8: word32 -> word8 = 
      fn x_40: word32 => 
      let
	 val x_1802: word8 = 
	    WordU32_extdToWord8 (x_40)
      in
	 x_1802
      end
   val zextdFromInt32ToInt16: word32 -> word16 = 
      fn x_41: word32 => 
      let
	 val x_1803: word16 = 
	    WordU32_extdToWord16 (x_41)
      in
	 x_1803
      end
   val zextdFromInt32ToInt32: word32 -> word32 = 
      fn x_42: word32 => 
      let
      in
	 x_42
      end
   val zextdFromInt32ToInt64: word32 -> word64 = 
      fn x_43: word32 => 
      let
	 val x_1804: word64 = 
	    WordU32_extdToWord64 (x_43)
      in
	 x_1804
      end
   val zextdFromInt32ToWord8: word32 -> word8 = 
      fn x_44: word32 => 
      let
	 val x_1805: word8 = 
	    WordU32_extdToWord8 (x_44)
      in
	 x_1805
      end
   val zextdFromInt32ToWord16: word32 -> word16 = 
      fn x_45: word32 => 
      let
	 val x_1806: word16 = 
	    WordU32_extdToWord16 (x_45)
      in
	 x_1806
      end
   val zextdFromInt32ToWord32: word32 -> word32 = 
      fn x_46: word32 => 
      let
      in
	 x_46
      end
   val zextdFromInt32ToWord64: word32 -> word64 = 
      fn x_47: word32 => 
      let
	 val x_1807: word64 = 
	    WordU32_extdToWord64 (x_47)
      in
	 x_1807
      end
   val zextdFromInt64ToInt8: word64 -> word8 = 
      fn x_48: word64 => 
      let
	 val x_1808: word8 = 
	    WordU64_extdToWord8 (x_48)
      in
	 x_1808
      end
   val zextdFromInt64ToInt16: word64 -> word16 = 
      fn x_49: word64 => 
      let
	 val x_1809: word16 = 
	    WordU64_extdToWord16 (x_49)
      in
	 x_1809
      end
   val zextdFromInt64ToInt32: word64 -> word32 = 
      fn x_50: word64 => 
      let
	 val x_1810: word32 = 
	    WordU64_extdToWord32 (x_50)
      in
	 x_1810
      end
   val zextdFromInt64ToWord8: word64 -> word8 = 
      fn x_52: word64 => 
      let
	 val x_1811: word8 = 
	    WordU64_extdToWord8 (x_52)
      in
	 x_1811
      end
   val zextdFromInt64ToWord16: word64 -> word16 = 
      fn x_53: word64 => 
      let
	 val x_1812: word16 = 
	    WordU64_extdToWord16 (x_53)
      in
	 x_1812
      end
   val zextdFromInt64ToWord32: word64 -> word32 = 
      fn x_54: word64 => 
      let
	 val x_1813: word32 = 
	    WordU64_extdToWord32 (x_54)
      in
	 x_1813
      end
   val zextdFromInt64ToWord64: word64 -> word64 = 
      fn x_55: word64 => 
      let
      in
	 x_55
      end
   val zextdFromWord8ToInt16: word8 -> word16 = 
      fn x_57: word8 => 
      let
	 val x_1814: word16 = 
	    WordU8_extdToWord16 (x_57)
      in
	 x_1814
      end
   val zextdFromWord8ToInt32: word8 -> word32 = 
      fn x_58: word8 => 
      let
	 val x_1815: word32 = 
	    WordU8_extdToWord32 (x_58)
      in
	 x_1815
      end
   val zextdFromWord8ToInt64: word8 -> word64 = 
      fn x_59: word8 => 
      let
	 val x_1816: word64 = 
	    WordU8_extdToWord64 (x_59)
      in
	 x_1816
      end
   val zextdFromWord8ToWord16: word8 -> word16 = 
      fn x_61: word8 => 
      let
	 val x_1817: word16 = 
	    WordU8_extdToWord16 (x_61)
      in
	 x_1817
      end
   val zextdFromWord8ToWord32: word8 -> word32 = 
      fn x_62: word8 => 
      let
	 val x_1818: word32 = 
	    WordU8_extdToWord32 (x_62)
      in
	 x_1818
      end
   val zextdFromWord8ToWord64: word8 -> word64 = 
      fn x_63: word8 => 
      let
	 val x_1819: word64 = 
	    WordU8_extdToWord64 (x_63)
      in
	 x_1819
      end
   val zextdFromWord16ToInt8: word16 -> word8 = 
      fn x_64: word16 => 
      let
	 val x_1820: word8 = 
	    WordU16_extdToWord8 (x_64)
      in
	 x_1820
      end
   val zextdFromWord16ToInt32: word16 -> word32 = 
      fn x_66: word16 => 
      let
	 val x_1821: word32 = 
	    WordU16_extdToWord32 (x_66)
      in
	 x_1821
      end
   val zextdFromWord16ToInt64: word16 -> word64 = 
      fn x_67: word16 => 
      let
	 val x_1822: word64 = 
	    WordU16_extdToWord64 (x_67)
      in
	 x_1822
      end
   val zextdFromWord16ToWord8: word16 -> word8 = 
      fn x_68: word16 => 
      let
	 val x_1823: word8 = 
	    WordU16_extdToWord8 (x_68)
      in
	 x_1823
      end
   val zextdFromWord16ToWord32: word16 -> word32 = 
      fn x_70: word16 => 
      let
	 val x_1824: word32 = 
	    WordU16_extdToWord32 (x_70)
      in
	 x_1824
      end
   val zextdFromWord16ToWord64: word16 -> word64 = 
      fn x_71: word16 => 
      let
	 val x_1825: word64 = 
	    WordU16_extdToWord64 (x_71)
      in
	 x_1825
      end
   val zextdFromWord32ToInt8: word32 -> word8 = 
      fn x_72: word32 => 
      let
	 val x_1826: word8 = 
	    WordU32_extdToWord8 (x_72)
      in
	 x_1826
      end
   val zextdFromWord32ToInt16: word32 -> word16 = 
      fn x_73: word32 => 
      let
	 val x_1827: word16 = 
	    WordU32_extdToWord16 (x_73)
      in
	 x_1827
      end
   val zextdFromWord32ToInt32: word32 -> word32 = 
      fn x_74: word32 => 
      let
      in
	 x_74
      end
   val zextdFromWord32ToInt64: word32 -> word64 = 
      fn x_75: word32 => 
      let
	 val x_1828: word64 = 
	    WordU32_extdToWord64 (x_75)
      in
	 x_1828
      end
   val zextdFromWord32ToWord8: word32 -> word8 = 
      fn x_76: word32 => 
      let
	 val x_1829: word8 = 
	    WordU32_extdToWord8 (x_76)
      in
	 x_1829
      end
   val zextdFromWord32ToWord16: word32 -> word16 = 
      fn x_77: word32 => 
      let
	 val x_1830: word16 = 
	    WordU32_extdToWord16 (x_77)
      in
	 x_1830
      end
   val zextdFromWord32ToWord32: word32 -> word32 = 
      fn x_78: word32 => 
      let
      in
	 x_78
      end
   val zextdFromWord32ToWord64: word32 -> word64 = 
      fn x_79: word32 => 
      let
	 val x_1831: word64 = 
	    WordU32_extdToWord64 (x_79)
      in
	 x_1831
      end
   val zextdFromWord64ToInt8: word64 -> word8 = 
      fn x_80: word64 => 
      let
	 val x_1832: word8 = 
	    WordU64_extdToWord8 (x_80)
      in
	 x_1832
      end
   val zextdFromWord64ToInt16: word64 -> word16 = 
      fn x_81: word64 => 
      let
	 val x_1833: word16 = 
	    WordU64_extdToWord16 (x_81)
      in
	 x_1833
      end
   val zextdFromWord64ToInt32: word64 -> word32 = 
      fn x_82: word64 => 
      let
	 val x_1834: word32 = 
	    WordU64_extdToWord32 (x_82)
      in
	 x_1834
      end
   val zextdFromWord64ToInt64: word64 -> word64 = 
      fn x_83: word64 => 
      let
      in
	 x_83
      end
   val zextdFromWord64ToWord8: word64 -> word8 = 
      fn x_84: word64 => 
      let
	 val x_1835: word8 = 
	    WordU64_extdToWord8 (x_84)
      in
	 x_1835
      end
   val zextdFromWord64ToWord16: word64 -> word16 = 
      fn x_85: word64 => 
      let
	 val x_1836: word16 = 
	    WordU64_extdToWord16 (x_85)
      in
	 x_1836
      end
   val zextdFromWord64ToWord32: word64 -> word32 = 
      fn x_86: word64 => 
      let
	 val x_1837: word32 = 
	    WordU64_extdToWord32 (x_86)
      in
	 x_1837
      end
   val zextdFromWord64ToWord64: word64 -> word64 = 
      fn x_87: word64 => 
      let
      in
	 x_87
      end
   val sextdFromInt8ToInt16: word8 -> word16 = 
      fn x_89: word8 => 
      let
	 val x_1838: word16 = 
	    WordS8_extdToWord16 (x_89)
      in
	 x_1838
      end
   val sextdFromInt8ToInt32: word8 -> word32 = 
      fn x_90: word8 => 
      let
	 val x_1839: word32 = 
	    WordS8_extdToWord32 (x_90)
      in
	 x_1839
      end
   val sextdFromInt8ToInt64: word8 -> word64 = 
      fn x_91: word8 => 
      let
	 val x_1840: word64 = 
	    WordS8_extdToWord64 (x_91)
      in
	 x_1840
      end
   val sextdFromInt8ToWord16: word8 -> word16 = 
      fn x_93: word8 => 
      let
	 val x_1841: word16 = 
	    WordS8_extdToWord16 (x_93)
      in
	 x_1841
      end
   val sextdFromInt8ToWord32: word8 -> word32 = 
      fn x_94: word8 => 
      let
	 val x_1842: word32 = 
	    WordS8_extdToWord32 (x_94)
      in
	 x_1842
      end
   val sextdFromInt8ToWord64: word8 -> word64 = 
      fn x_95: word8 => 
      let
	 val x_1843: word64 = 
	    WordS8_extdToWord64 (x_95)
      in
	 x_1843
      end
   val sextdFromInt16ToInt8: word16 -> word8 = 
      fn x_96: word16 => 
      let
	 val x_1844: word8 = 
	    WordS16_extdToWord8 (x_96)
      in
	 x_1844
      end
   val sextdFromInt16ToInt32: word16 -> word32 = 
      fn x_98: word16 => 
      let
	 val x_1845: word32 = 
	    WordS16_extdToWord32 (x_98)
      in
	 x_1845
      end
   val sextdFromInt16ToInt64: word16 -> word64 = 
      fn x_99: word16 => 
      let
	 val x_1846: word64 = 
	    WordS16_extdToWord64 (x_99)
      in
	 x_1846
      end
   val sextdFromInt16ToWord8: word16 -> word8 = 
      fn x_100: word16 => 
      let
	 val x_1847: word8 = 
	    WordS16_extdToWord8 (x_100)
      in
	 x_1847
      end
   val sextdFromInt16ToWord32: word16 -> word32 = 
      fn x_102: word16 => 
      let
	 val x_1848: word32 = 
	    WordS16_extdToWord32 (x_102)
      in
	 x_1848
      end
   val sextdFromInt16ToWord64: word16 -> word64 = 
      fn x_103: word16 => 
      let
	 val x_1849: word64 = 
	    WordS16_extdToWord64 (x_103)
      in
	 x_1849
      end
   val sextdFromInt32ToInt8: word32 -> word8 = 
      fn x_104: word32 => 
      let
	 val x_1850: word8 = 
	    WordS32_extdToWord8 (x_104)
      in
	 x_1850
      end
   val sextdFromInt32ToInt16: word32 -> word16 = 
      fn x_105: word32 => 
      let
	 val x_1851: word16 = 
	    WordS32_extdToWord16 (x_105)
      in
	 x_1851
      end
   val sextdFromInt32ToInt32: word32 -> word32 = 
      fn x_106: word32 => 
      let
      in
	 x_106
      end
   val sextdFromInt32ToInt64: word32 -> word64 = 
      fn x_107: word32 => 
      let
	 val x_1852: word64 = 
	    WordS32_extdToWord64 (x_107)
      in
	 x_1852
      end
   val sextdFromInt32ToWord8: word32 -> word8 = 
      fn x_108: word32 => 
      let
	 val x_1853: word8 = 
	    WordS32_extdToWord8 (x_108)
      in
	 x_1853
      end
   val sextdFromInt32ToWord16: word32 -> word16 = 
      fn x_109: word32 => 
      let
	 val x_1854: word16 = 
	    WordS32_extdToWord16 (x_109)
      in
	 x_1854
      end
   val sextdFromInt32ToWord32: word32 -> word32 = 
      fn x_110: word32 => 
      let
      in
	 x_110
      end
   val sextdFromInt32ToWord64: word32 -> word64 = 
      fn x_111: word32 => 
      let
	 val x_1855: word64 = 
	    WordS32_extdToWord64 (x_111)
      in
	 x_1855
      end
   val sextdFromInt64ToInt8: word64 -> word8 = 
      fn x_112: word64 => 
      let
	 val x_1856: word8 = 
	    WordS64_extdToWord8 (x_112)
      in
	 x_1856
      end
   val sextdFromInt64ToInt16: word64 -> word16 = 
      fn x_113: word64 => 
      let
	 val x_1857: word16 = 
	    WordS64_extdToWord16 (x_113)
      in
	 x_1857
      end
   val sextdFromInt64ToInt32: word64 -> word32 = 
      fn x_114: word64 => 
      let
	 val x_1858: word32 = 
	    WordS64_extdToWord32 (x_114)
      in
	 x_1858
      end
   val sextdFromInt64ToInt64: word64 -> word64 = 
      fn x_115: word64 => 
      let
      in
	 x_115
      end
   val sextdFromInt64ToWord8: word64 -> word8 = 
      fn x_116: word64 => 
      let
	 val x_1859: word8 = 
	    WordS64_extdToWord8 (x_116)
      in
	 x_1859
      end
   val sextdFromInt64ToWord16: word64 -> word16 = 
      fn x_117: word64 => 
      let
	 val x_1860: word16 = 
	    WordS64_extdToWord16 (x_117)
      in
	 x_1860
      end
   val sextdFromInt64ToWord32: word64 -> word32 = 
      fn x_118: word64 => 
      let
	 val x_1861: word32 = 
	    WordS64_extdToWord32 (x_118)
      in
	 x_1861
      end
   val sextdFromWord8ToInt16: word8 -> word16 = 
      fn x_121: word8 => 
      let
	 val x_1862: word16 = 
	    WordS8_extdToWord16 (x_121)
      in
	 x_1862
      end
   val sextdFromWord8ToInt32: word8 -> word32 = 
      fn x_122: word8 => 
      let
	 val x_1863: word32 = 
	    WordS8_extdToWord32 (x_122)
      in
	 x_1863
      end
   val sextdFromWord8ToInt64: word8 -> word64 = 
      fn x_123: word8 => 
      let
	 val x_1864: word64 = 
	    WordS8_extdToWord64 (x_123)
      in
	 x_1864
      end
   val sextdFromWord8ToWord16: word8 -> word16 = 
      fn x_125: word8 => 
      let
	 val x_1865: word16 = 
	    WordS8_extdToWord16 (x_125)
      in
	 x_1865
      end
   val sextdFromWord8ToWord32: word8 -> word32 = 
      fn x_126: word8 => 
      let
	 val x_1866: word32 = 
	    WordS8_extdToWord32 (x_126)
      in
	 x_1866
      end
   val sextdFromWord8ToWord64: word8 -> word64 = 
      fn x_127: word8 => 
      let
	 val x_1867: word64 = 
	    WordS8_extdToWord64 (x_127)
      in
	 x_1867
      end
   val sextdFromWord16ToInt8: word16 -> word8 = 
      fn x_128: word16 => 
      let
	 val x_1868: word8 = 
	    WordS16_extdToWord8 (x_128)
      in
	 x_1868
      end
   val sextdFromWord16ToInt32: word16 -> word32 = 
      fn x_130: word16 => 
      let
	 val x_1869: word32 = 
	    WordS16_extdToWord32 (x_130)
      in
	 x_1869
      end
   val sextdFromWord16ToInt64: word16 -> word64 = 
      fn x_131: word16 => 
      let
	 val x_1870: word64 = 
	    WordS16_extdToWord64 (x_131)
      in
	 x_1870
      end
   val sextdFromWord16ToWord8: word16 -> word8 = 
      fn x_132: word16 => 
      let
	 val x_1871: word8 = 
	    WordS16_extdToWord8 (x_132)
      in
	 x_1871
      end
   val sextdFromWord16ToWord32: word16 -> word32 = 
      fn x_134: word16 => 
      let
	 val x_1872: word32 = 
	    WordS16_extdToWord32 (x_134)
      in
	 x_1872
      end
   val sextdFromWord16ToWord64: word16 -> word64 = 
      fn x_135: word16 => 
      let
	 val x_1873: word64 = 
	    WordS16_extdToWord64 (x_135)
      in
	 x_1873
      end
   val sextdFromWord32ToInt8: word32 -> word8 = 
      fn x_136: word32 => 
      let
	 val x_1874: word8 = 
	    WordS32_extdToWord8 (x_136)
      in
	 x_1874
      end
   val sextdFromWord32ToInt16: word32 -> word16 = 
      fn x_137: word32 => 
      let
	 val x_1875: word16 = 
	    WordS32_extdToWord16 (x_137)
      in
	 x_1875
      end
   val sextdFromWord32ToInt64: word32 -> word64 = 
      fn x_139: word32 => 
      let
	 val x_1876: word64 = 
	    WordS32_extdToWord64 (x_139)
      in
	 x_1876
      end
   val sextdFromWord32ToWord8: word32 -> word8 = 
      fn x_140: word32 => 
      let
	 val x_1877: word8 = 
	    WordS32_extdToWord8 (x_140)
      in
	 x_1877
      end
   val sextdFromWord32ToWord16: word32 -> word16 = 
      fn x_141: word32 => 
      let
	 val x_1878: word16 = 
	    WordS32_extdToWord16 (x_141)
      in
	 x_1878
      end
   val sextdFromWord32ToWord64: word32 -> word64 = 
      fn x_143: word32 => 
      let
	 val x_1879: word64 = 
	    WordS32_extdToWord64 (x_143)
      in
	 x_1879
      end
   val sextdFromWord64ToInt8: word64 -> word8 = 
      fn x_144: word64 => 
      let
	 val x_1880: word8 = 
	    WordS64_extdToWord8 (x_144)
      in
	 x_1880
      end
   val sextdFromWord64ToInt16: word64 -> word16 = 
      fn x_145: word64 => 
      let
	 val x_1881: word16 = 
	    WordS64_extdToWord16 (x_145)
      in
	 x_1881
      end
   val sextdFromWord64ToInt32: word64 -> word32 = 
      fn x_146: word64 => 
      let
	 val x_1882: word32 = 
	    WordS64_extdToWord32 (x_146)
      in
	 x_1882
      end
   val sextdFromWord64ToWord8: word64 -> word8 = 
      fn x_148: word64 => 
      let
	 val x_1883: word8 = 
	    WordS64_extdToWord8 (x_148)
      in
	 x_1883
      end
   val sextdFromWord64ToWord16: word64 -> word16 = 
      fn x_149: word64 => 
      let
	 val x_1884: word16 = 
	    WordS64_extdToWord16 (x_149)
      in
	 x_1884
      end
   val sextdFromWord64ToWord32: word64 -> word32 = 
      fn x_150: word64 => 
      let
	 val x_1885: word32 = 
	    WordS64_extdToWord32 (x_150)
      in
	 x_1885
      end
   val sextdFromWord64ToWord64: word64 -> word64 = 
      fn x_151: word64 => 
      let
      in
	 x_151
      end
   val sizeInBits: word32 = 
      0x1
   val sizeInBits: word32 = 
      0x2
   val sizeInBits: word32 = 
      0x3
   val sizeInBits: word32 = 
      0x4
   val sizeInBits: word32 = 
      0x5
   val sizeInBits: word32 = 
      0x6
   val sizeInBits: word32 = 
      0x7
   val sizeInBits: word32 = 
      0x8
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val <<?: word8 * word32 -> word8 = 
      fn x_152: word8 * word32 => 
      let
	 val x_153: word32 = 
	    #1 x_152
	 val x_154: word8 = 
	    #0 x_152
	 val x_1886: word8 = 
	    Word8_lshift (x_154, x_153)
      in
	 x_1886
      end
   val notb: word8 -> word8 = 
      fn x_156: word8 => 
      let
	 val x_1887: word8 = 
	    Word8_notb (x_156)
      in
	 x_1887
      end
   val orb: word8 * word8 -> word8 = 
      fn x_157: word8 * word8 => 
      let
	 val x_158: word8 = 
	    #1 x_157
	 val x_159: word8 = 
	    #0 x_157
	 val x_1888: word8 = 
	    Word8_orb (x_159, x_158)
      in
	 x_1888
      end
   val >>?: word8 * word32 -> word8 = 
      fn x_163: word8 * word32 => 
      let
	 val x_164: word32 = 
	    #1 x_163
	 val x_165: word8 = 
	    #0 x_163
	 val x_1889: word8 = 
	    WordU8_rshift (x_165, x_164)
      in
	 x_1889
      end
   val sizeInBits: word32 = 
      0x9
   val sizeInBits: word32 = 
      0xA
   val sizeInBits: word32 = 
      0xB
   val sizeInBits: word32 = 
      0xC
   val sizeInBits: word32 = 
      0xD
   val sizeInBits: word32 = 
      0xE
   val sizeInBits: word32 = 
      0xF
   val sizeInBits: word32 = 
      0x10
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val <<?: word16 * word32 -> word16 = 
      fn x_166: word16 * word32 => 
      let
	 val x_167: word32 = 
	    #1 x_166
	 val x_168: word16 = 
	    #0 x_166
	 val x_1890: word16 = 
	    Word16_lshift (x_168, x_167)
      in
	 x_1890
      end
   val notb: word16 -> word16 = 
      fn x_170: word16 => 
      let
	 val x_1891: word16 = 
	    Word16_notb (x_170)
      in
	 x_1891
      end
   val orb: word16 * word16 -> word16 = 
      fn x_171: word16 * word16 => 
      let
	 val x_172: word16 = 
	    #1 x_171
	 val x_173: word16 = 
	    #0 x_171
	 val x_1892: word16 = 
	    Word16_orb (x_173, x_172)
      in
	 x_1892
      end
   val >>?: word16 * word32 -> word16 = 
      fn x_177: word16 * word32 => 
      let
	 val x_178: word32 = 
	    #1 x_177
	 val x_179: word16 = 
	    #0 x_177
	 val x_1893: word16 = 
	    WordU16_rshift (x_179, x_178)
      in
	 x_1893
      end
   val sizeInBits: word32 = 
      0x11
   val sizeInBits: word32 = 
      0x12
   val sizeInBits: word32 = 
      0x13
   val sizeInBits: word32 = 
      0x14
   val sizeInBits: word32 = 
      0x15
   val sizeInBits: word32 = 
      0x16
   val sizeInBits: word32 = 
      0x17
   val sizeInBits: word32 = 
      0x18
   val sizeInBits: word32 = 
      0x19
   val sizeInBits: word32 = 
      0x1A
   val sizeInBits: word32 = 
      0x1B
   val sizeInBits: word32 = 
      0x1C
   val sizeInBits: word32 = 
      0x1D
   val sizeInBits: word32 = 
      0x1E
   val sizeInBits: word32 = 
      0x1F
   val sizeInBits: word32 = 
      0x20
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val andb: word32 * word32 -> word32 = 
      fn x_183: word32 * word32 => 
      let
	 val x_184: word32 = 
	    #1 x_183
	 val x_185: word32 = 
	    #0 x_183
	 val x_1894: word32 = 
	    Word32_andb (x_185, x_184)
      in
	 x_1894
      end
   val <<?: word32 * word32 -> word32 = 
      fn x_186: word32 * word32 => 
      let
	 val x_187: word32 = 
	    #1 x_186
	 val x_188: word32 = 
	    #0 x_186
	 val x_1895: word32 = 
	    Word32_lshift (x_188, x_187)
      in
	 x_1895
      end
   val notb: word32 -> word32 = 
      fn x_190: word32 => 
      let
	 val x_1896: word32 = 
	    Word32_notb (x_190)
      in
	 x_1896
      end
   val orb: word32 * word32 -> word32 = 
      fn x_191: word32 * word32 => 
      let
	 val x_192: word32 = 
	    #1 x_191
	 val x_193: word32 = 
	    #0 x_191
	 val x_1897: word32 = 
	    Word32_orb (x_193, x_192)
      in
	 x_1897
      end
   val >>?: word32 * word32 -> word32 = 
      fn x_197: word32 * word32 => 
      let
	 val x_198: word32 = 
	    #1 x_197
	 val x_199: word32 = 
	    #0 x_197
	 val x_1898: word32 = 
	    WordU32_rshift (x_199, x_198)
      in
	 x_1898
      end
   val -: word32 * word32 -> word32 = 
      fn x_200: word32 * word32 => 
      let
	 val x_201: word32 = 
	    #1 x_200
	 val x_202: word32 = 
	    #0 x_200
	 val x_1899: word32 = 
	    Word32_sub (x_202, x_201)
      in
	 x_1899
      end
   val xorb: word32 * word32 -> word32 = 
      fn x_203: word32 * word32 => 
      let
	 val x_204: word32 = 
	    #1 x_203
	 val x_205: word32 = 
	    #0 x_203
	 val x_1900: word32 = 
	    Word32_xorb (x_205, x_204)
      in
	 x_1900
      end
   val <: word32 * word32 -> bool = 
      fn x_206: word32 * word32 => 
      let
	 val x_207: word32 = 
	    #1 x_206
	 val x_208: word32 = 
	    #0 x_206
	 val x_1901: bool = 
	    WordU32_lt (x_208, x_207)
      in
	 x_1901
      end
   val rec 
      >=: word32 * word32 -> bool = 
	 fn x_210: word32 * word32 => 
	 let
	    val b: word32 = 
	       #1 x_210
	    val a: word32 = 
	       #0 x_210
	    val x_1902: word32 * word32 = 
	       (a, b)
	    val x_1903: bool = 
	       < x_1902
	    val x_1904: bool = 
	       not x_1903
	 in
	    x_1904
	 end
   val sizeInBits: word32 = 
      0x40
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val +: word64 * word64 -> word64 = 
      fn x_211: word64 * word64 => 
      let
	 val x_212: word64 = 
	    #1 x_211
	 val x_213: word64 = 
	    #0 x_211
	 val x_1905: word64 = 
	    Word64_add (x_213, x_212)
      in
	 x_1905
      end
   val andb: word64 * word64 -> word64 = 
      fn x_214: word64 * word64 => 
      let
	 val x_215: word64 = 
	    #1 x_214
	 val x_216: word64 = 
	    #0 x_214
	 val x_1906: word64 = 
	    Word64_andb (x_216, x_215)
      in
	 x_1906
      end
   val <<?: word64 * word32 -> word64 = 
      fn x_217: word64 * word32 => 
      let
	 val x_218: word32 = 
	    #1 x_217
	 val x_219: word64 = 
	    #0 x_217
	 val x_1907: word64 = 
	    Word64_lshift (x_219, x_218)
      in
	 x_1907
      end
   val *: word64 * word64 -> word64 = 
      fn x_220: word64 * word64 => 
      let
	 val x_221: word64 = 
	    #1 x_220
	 val x_222: word64 = 
	    #0 x_220
	 val x_1908: word64 = 
	    WordU64_mul (x_222, x_221)
      in
	 x_1908
      end
   val ~: word64 -> word64 = 
      fn x_223: word64 => 
      let
	 val x_1909: word64 = 
	    Word64_neg (x_223)
      in
	 x_1909
      end
   val notb: word64 -> word64 = 
      fn x_224: word64 => 
      let
	 val x_1910: word64 = 
	    Word64_notb (x_224)
      in
	 x_1910
      end
   val orb: word64 * word64 -> word64 = 
      fn x_225: word64 * word64 => 
      let
	 val x_226: word64 = 
	    #1 x_225
	 val x_227: word64 = 
	    #0 x_225
	 val x_1911: word64 = 
	    Word64_orb (x_227, x_226)
      in
	 x_1911
      end
   val ~>>?: word64 * word32 -> word64 = 
      fn x_228: word64 * word32 => 
      let
	 val x_229: word32 = 
	    #1 x_228
	 val x_230: word64 = 
	    #0 x_228
	 val x_1912: word64 = 
	    WordS64_rshift (x_230, x_229)
      in
	 x_1912
      end
   val >>?: word64 * word32 -> word64 = 
      fn x_231: word64 * word32 => 
      let
	 val x_232: word32 = 
	    #1 x_231
	 val x_233: word64 = 
	    #0 x_231
	 val x_1913: word64 = 
	    WordU64_rshift (x_233, x_232)
      in
	 x_1913
      end
   val -: word64 * word64 -> word64 = 
      fn x_234: word64 * word64 => 
      let
	 val x_235: word64 = 
	    #1 x_234
	 val x_236: word64 = 
	    #0 x_234
	 val x_1914: word64 = 
	    Word64_sub (x_236, x_235)
      in
	 x_1914
      end
   val sizeInBits: word32 = 
      0x1
   val sizeInBits: word32 = 
      0x2
   val sizeInBits: word32 = 
      0x3
   val sizeInBits: word32 = 
      0x4
   val sizeInBits: word32 = 
      0x5
   val sizeInBits: word32 = 
      0x6
   val sizeInBits: word32 = 
      0x7
   val sizeInBits: word32 = 
      0x8
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word32 Primitive.Option.t = 
      SOME[word32] sizeInBits
   val sizeInBits: word32 = 
      0x9
   val sizeInBits: word32 = 
      0xA
   val sizeInBits: word32 = 
      0xB
   val sizeInBits: word32 = 
      0xC
   val sizeInBits: word32 = 
      0xD
   val sizeInBits: word32 = 
      0xE
   val sizeInBits: word32 = 
      0xF
   val sizeInBits: word32 = 
      0x10
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word32 Primitive.Option.t = 
      SOME[word32] sizeInBits
   val sizeInBits: word32 = 
      0x11
   val sizeInBits: word32 = 
      0x12
   val sizeInBits: word32 = 
      0x13
   val sizeInBits: word32 = 
      0x14
   val sizeInBits: word32 = 
      0x15
   val sizeInBits: word32 = 
      0x16
   val sizeInBits: word32 = 
      0x17
   val sizeInBits: word32 = 
      0x18
   val sizeInBits: word32 = 
      0x19
   val sizeInBits: word32 = 
      0x1A
   val sizeInBits: word32 = 
      0x1B
   val sizeInBits: word32 = 
      0x1C
   val sizeInBits: word32 = 
      0x1D
   val sizeInBits: word32 = 
      0x1E
   val sizeInBits: word32 = 
      0x1F
   val sizeInBits: word32 = 
      0x20
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word32 Primitive.Option.t = 
      SOME[word32] sizeInBits
   val x_1915: word32 * word32 -> word32 = 
      fn x_251: word32 * word32 => 
      let
	 val x_252: word32 = 
	    #1 x_251
	 val x_253: word32 = 
	    #0 x_251
	 val x_1916: word32 = 
	    WordS32_addCheck (x_253, x_252)
      in
	 x_1916
      end
   val +!: word32 * word32 -> word32 = 
      wrapOverflow (word32, word32 * word32) x_1915
   val +?: word32 * word32 -> word32 = 
      fn x_254: word32 * word32 => 
      let
	 val x_255: word32 = 
	    #1 x_254
	 val x_256: word32 = 
	    #0 x_254
	 val x_1917: word32 = 
	    Word32_add (x_256, x_255)
      in
	 x_1917
      end
   val x_1918: word32 * word32 -> word32 = 
      fn x_257: word32 * word32 => 
      let
	 val x_258: word32 = 
	    #1 x_257
	 val x_259: word32 = 
	    #0 x_257
	 val x_1919: word32 = 
	    WordS32_mulCheck (x_259, x_258)
      in
	 x_1919
      end
   val *!: word32 * word32 -> word32 = 
      wrapOverflow (word32, word32 * word32) x_1918
   val x_1920: word32 -> word32 = 
      fn x_263: word32 => 
      let
	 val x_1921: word32 = 
	    Word32_negCheck (x_263)
      in
	 x_1921
      end
   val ~!: word32 -> word32 = 
      wrapOverflow (word32, word32) x_1920
   val ~?: word32 -> word32 = 
      fn x_264: word32 => 
      let
	 val x_1922: word32 = 
	    Word32_neg (x_264)
      in
	 x_1922
      end
   val x_1923: word32 * word32 -> word32 = 
      fn x_268: word32 * word32 => 
      let
	 val x_269: word32 = 
	    #1 x_268
	 val x_270: word32 = 
	    #0 x_268
	 val x_1924: word32 = 
	    WordS32_subCheck (x_270, x_269)
      in
	 x_1924
      end
   val -!: word32 * word32 -> word32 = 
      wrapOverflow (word32, word32 * word32) x_1923
   val -?: word32 * word32 -> word32 = 
      fn x_271: word32 * word32 => 
      let
	 val x_272: word32 = 
	    #1 x_271
	 val x_273: word32 = 
	    #0 x_271
	 val x_1925: word32 = 
	    Word32_sub (x_273, x_272)
      in
	 x_1925
      end
   val remUnsafe: word32 * word32 -> word32 = 
      fn x_274: word32 * word32 => 
      let
	 val x_275: word32 = 
	    #1 x_274
	 val x_276: word32 = 
	    #0 x_274
	 val x_1926: word32 = 
	    WordS32_rem (x_276, x_275)
      in
	 x_1926
      end
   val <: word32 * word32 -> bool = 
      fn x_277: word32 * word32 => 
      let
	 val x_278: word32 = 
	    #1 x_277
	 val x_279: word32 = 
	    #0 x_277
	 val x_1927: bool = 
	    WordS32_lt (x_279, x_278)
      in
	 x_1927
      end
   val rec 
      <=: word32 * word32 -> bool = 
	 fn x_280: word32 * word32 => 
	 let
	    val b: word32 = 
	       #1 x_280
	    val a: word32 = 
	       #0 x_280
	    val x_1928: word32 * word32 = 
	       (b, a)
	    val x_1929: bool = 
	       < x_1928
	    val x_1930: bool = 
	       not x_1929
	 in
	    x_1930
	 end
   val rec 
      >: word32 * word32 -> bool = 
	 fn x_281: word32 * word32 => 
	 let
	    val b: word32 = 
	       #1 x_281
	    val a: word32 = 
	       #0 x_281
	    val x_1931: word32 * word32 = 
	       (b, a)
	    val x_1932: bool = 
	       < x_1931
	 in
	    x_1932
	 end
   val rec 
      >=: word32 * word32 -> bool = 
	 fn x_282: word32 * word32 => 
	 let
	    val b: word32 = 
	       #1 x_282
	    val a: word32 = 
	       #0 x_282
	    val x_1933: word32 * word32 = 
	       (b, a)
	    val x_1934: bool = 
	       <= x_1933
	 in
	    x_1934
	 end
   val sizeInBits: word32 = 
      0x40
   val sizeInBitsWord: word32 = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word32 Primitive.Option.t = 
      SOME[word32] sizeInBits
   val x_1935: word64 * word64 -> word64 = 
      fn x_283: word64 * word64 => 
      let
	 val x_284: word64 = 
	    #1 x_283
	 val x_285: word64 = 
	    #0 x_283
	 val x_1936: word64 = 
	    WordS64_addCheck (x_285, x_284)
      in
	 x_1936
      end
   val +!: word64 * word64 -> word64 = 
      wrapOverflow (word64, word64 * word64) x_1935
   val +?: word64 * word64 -> word64 = 
      fn x_286: word64 * word64 => 
      let
	 val x_287: word64 = 
	    #1 x_286
	 val x_288: word64 = 
	    #0 x_286
	 val x_1937: word64 = 
	    Word64_add (x_288, x_287)
      in
	 x_1937
      end
   val x_1938: word64 * word64 -> word64 = 
      fn x_289: word64 * word64 => 
      let
	 val x_290: word64 = 
	    #1 x_289
	 val x_291: word64 = 
	    #0 x_289
	 val x_1939: word64 = 
	    WordS64_mulCheck (x_291, x_290)
      in
	 x_1939
      end
   val *!: word64 * word64 -> word64 = 
      wrapOverflow (word64, word64 * word64) x_1938
   val x_1940: word64 -> word64 = 
      fn x_292: word64 => 
      let
	 val x_1941: word64 = 
	    Word64_negCheck (x_292)
      in
	 x_1941
      end
   val ~!: word64 -> word64 = 
      wrapOverflow (word64, word64) x_1940
   val ~?: word64 -> word64 = 
      fn x_293: word64 => 
      let
	 val x_1942: word64 = 
	    Word64_neg (x_293)
      in
	 x_1942
      end
   val x_1943: word64 * word64 -> word64 = 
      fn x_297: word64 * word64 => 
      let
	 val x_298: word64 = 
	    #1 x_297
	 val x_299: word64 = 
	    #0 x_297
	 val x_1944: word64 = 
	    WordS64_subCheck (x_299, x_298)
      in
	 x_1944
      end
   val -!: word64 * word64 -> word64 = 
      wrapOverflow (word64, word64 * word64) x_1943
   val -?: word64 * word64 -> word64 = 
      fn x_300: word64 * word64 => 
      let
	 val x_301: word64 = 
	    #1 x_300
	 val x_302: word64 = 
	    #0 x_300
	 val x_1945: word64 = 
	    Word64_sub (x_302, x_301)
      in
	 x_1945
      end
   val <: word64 * word64 -> bool = 
      fn x_306: word64 * word64 => 
      let
	 val x_307: word64 = 
	    #1 x_306
	 val x_308: word64 = 
	    #0 x_306
	 val x_1946: bool = 
	    WordS64_lt (x_308, x_307)
      in
	 x_1946
      end
   val rec 
      <=: word64 * word64 -> bool = 
	 fn x_309: word64 * word64 => 
	 let
	    val b: word64 = 
	       #1 x_309
	    val a: word64 = 
	       #0 x_309
	    val x_1947: word64 * word64 = 
	       (b, a)
	    val x_1948: bool = 
	       < x_1947
	    val x_1949: bool = 
	       not x_1948
	 in
	    x_1949
	 end
   val rec 
      >: word64 * word64 -> bool = 
	 fn x_310: word64 * word64 => 
	 let
	    val b: word64 = 
	       #1 x_310
	    val a: word64 = 
	       #0 x_310
	    val x_1950: word64 * word64 = 
	       (b, a)
	    val x_1951: bool = 
	       < x_1950
	 in
	    x_1951
	 end
   val rec 
      >=: word64 * word64 -> bool = 
	 fn x_311: word64 * word64 => 
	 let
	    val b: word64 = 
	       #1 x_311
	    val a: word64 = 
	       #0 x_311
	    val x_1952: word64 * word64 = 
	       (b, a)
	    val x_1953: bool = 
	       <= x_1952
	 in
	    x_1953
	 end
   val rec 
      max: word64 * word64 -> word64 = 
	 fn x_313: word64 * word64 => 
	 let
	    val y: word64 = 
	       #1 x_313
	    val x: word64 = 
	       #0 x_313
	    val x_1954: word64 * word64 = 
	       (x, y)
	    val x_1955: bool = 
	       < x_1954
	    val x_1956: word64 = 
	       case x_1955 of
	       true => 
		  let
		  in
		     y
		  end
	       false => 
		  let
		  in
		     x
		  end
	 in
	    x_1956
	 end
   val 'a_165 check: 'a_165 -> 'a_165 = 
      let
	 val x_1957: 'a_165 -> 'a_165 = 
	    fn x_314: 'a_165 => 
	    let
	    in
	       x_314
	    end
      in
	 x_1957
      end
   val 'a check_0: 'a -> 'a = 
      let
      in
	 check ('a)
      end
   val 'a arrayUnsafe: word64 -> 'a array = 
      let
	 val x_1958: word64 -> 'a array = 
	    fn x_315: word64 => 
	    let
	       val x_1959: 'a array = 
		  Array_array['a] (x_315)
	    in
	       x_1959
	    end
      in
	 x_1958
      end
   val 'a array0Const: unit -> 'a array = 
      let
	 val x_1960: unit -> 'a array = 
	    fn x_316: unit => 
	    let
	       val x_1961: 'a array = 
		  Array_array0Const['a] ()
	    in
	       x_1961
	    end
      in
	 x_1960
      end
   val 'a length: 'a array -> word64 = 
      let
	 val x_1962: 'a array -> word64 = 
	    fn x_317: 'a array => 
	    let
	       val x_1963: word64 = 
		  Array_length['a] (x_317)
	    in
	       x_1963
	    end
      in
	 x_1962
      end
   val 'a subUnsafe: 'a array * word64 -> 'a = 
      let
	 val x_1964: 'a array * word64 -> 'a = 
	    fn x_318: 'a array * word64 => 
	    let
	       val x_319: word64 = 
		  #1 x_318
	       val x_320: 'a array = 
		  #0 x_318
	       val x_1965: 'a = 
		  Array_sub['a] (x_320, x_319)
	    in
	       x_1965
	    end
      in
	 x_1964
      end
   val 'a updateUnsafe: 'a array * word64 * 'a -> unit = 
      let
	 val x_1966: 'a array * word64 * 'a -> unit = 
	    fn x_321: 'a array * word64 * 'a => 
	    let
	       val x_322: 'a = 
		  #2 x_321
	       val x_323: word64 = 
		  #1 x_321
	       val x_324: 'a array = 
		  #0 x_321
	       val x_1967: unit = 
		  Array_update['a] (x_324, x_323, x_322)
	    in
	       x_1967
	    end
      in
	 x_1966
      end
   val 'a fromArrayUnsafe: 'a array -> 'a vector = 
      let
	 val x_1968: 'a array -> 'a vector = 
	    fn x_325: 'a array => 
	    let
	       val x_1969: 'a vector = 
		  Array_toVector['a] (x_325)
	    in
	       x_1969
	    end
      in
	 x_1968
      end
   val 'a length: 'a vector -> word64 = 
      let
	 val x_1970: 'a vector -> word64 = 
	    fn x_326: 'a vector => 
	    let
	       val x_1971: word64 = 
		  Vector_length['a] (x_326)
	    in
	       x_1971
	    end
      in
	 x_1970
      end
   val 'a subUnsafe: 'a vector * word64 -> 'a = 
      let
	 val x_1972: 'a vector * word64 -> 'a = 
	    fn x_327: 'a vector * word64 => 
	    let
	       val x_328: word64 = 
		  #1 x_327
	       val x_329: 'a vector = 
		  #0 x_327
	       val x_1973: 'a = 
		  Vector_sub['a] (x_329, x_328)
	    in
	       x_1973
	    end
      in
	 x_1972
      end
   val rec 
      fromString: word8 vector -> word8 vector = 
	 fn x_330: word8 vector => 
	 let
	    val x_1974: word8 = 
	       0x0
	    val x_1975: word64 = 
	       length (word8) x_330
	    val x_1976: word64 = 
	       0x1
	    val x_1977: word64 * word64 = 
	       (x_1975, x_1976)
	    val x_1978: word64 = 
	       -! x_1977
	    val x_1979: word8 vector * word64 = 
	       (x_330, x_1978)
	    val x_1980: word8 = 
	       subUnsafe (word8) x_1979
	    val x_1981: word8 * word8 = 
	       (x_1974, x_1980)
	    val x_1982: bool = 
	       = (word8) x_1981
	    val x_1983: word8 vector = 
	       case x_1982 of
	       true => 
		  let
		  in
		     x_330
		  end
	       false => 
		  let
		     val x_1984: word8 vector = 
			"NullString.fromString"
		     val x_1985: exn = 
			Fail8 x_1984
		     val x_1986: word8 vector = 
			raise x_1985
		  in
		     x_1986
		  end
	 in
	    x_1983
	 end
   val +: intInf * intInf * word64 -> intInf = 
      fn x_331: intInf * intInf * word64 => 
      let
	 val x_332: word64 = 
	    #2 x_331
	 val x_333: intInf = 
	    #1 x_331
	 val x_334: intInf = 
	    #0 x_331
	 val x_1987: intInf = 
	    IntInf_add (x_334, x_333, x_332)
      in
	 x_1987
      end
   val fromWord: word64 -> intInf = 
      fn x_339: word64 => 
      let
	 val x_1988: intInf = 
	    Word_toIntInf (x_339)
      in
	 x_1988
      end
   val *: intInf * intInf * word64 -> intInf = 
      fn x_340: intInf * intInf * word64 => 
      let
	 val x_341: word64 = 
	    #2 x_340
	 val x_342: intInf = 
	    #1 x_340
	 val x_343: intInf = 
	    #0 x_340
	 val x_1989: intInf = 
	    IntInf_mul (x_343, x_342, x_341)
      in
	 x_1989
      end
   val toVector: intInf -> word64 vector = 
      fn x_355: intInf => 
      let
	 val x_1990: word64 vector = 
	    IntInf_toVector (x_355)
      in
	 x_1990
      end
   val toWord: intInf -> word64 = 
      fn x_356: intInf => 
      let
	 val x_1991: word64 = 
	    IntInf_toWord (x_356)
      in
	 x_1991
      end
   val idToWord8: word8 -> word8 = 
      fn x_360: word8 => 
      let
      in
	 x_360
      end
   val idFromWord8: word8 -> word8 = 
      fn x_361: word8 => 
      let
      in
	 x_361
      end
   val rec 
      <=: word8 * word8 -> bool = 
	 fn x_362: word8 * word8 => 
	 let
	    val b: word8 = 
	       #1 x_362
	    val a: word8 = 
	       #0 x_362
	    val x_1992: bool = 
	       WordU8_lt (b, a)
	    val x_1993: bool = 
	       not x_1992
	 in
	    x_1993
	 end
   val idToWord16: word16 -> word16 = 
      fn x_363: word16 => 
      let
      in
	 x_363
      end
   val idFromWord16: word16 -> word16 = 
      fn x_364: word16 => 
      let
      in
	 x_364
      end
   val idToWord32: word32 -> word32 = 
      fn x_365: word32 => 
      let
      in
	 x_365
      end
   val idFromWord32: word32 -> word32 = 
      fn x_366: word32 => 
      let
      in
	 x_366
      end
   val realSize: word32 = 
      0x20
   val exponentBias: word32 = 
      0x7F
   val precision: word32 = 
      0x18
   val acos: real32 -> real32 = 
      fn x_367: real32 => 
      let
	 val x_1994: real32 = 
	    Real32_Math_acos (x_367)
      in
	 x_1994
      end
   val asin: real32 -> real32 = 
      fn x_368: real32 => 
      let
	 val x_1995: real32 = 
	    Real32_Math_asin (x_368)
      in
	 x_1995
      end
   val atan: real32 -> real32 = 
      fn x_369: real32 => 
      let
	 val x_1996: real32 = 
	    Real32_Math_atan (x_369)
      in
	 x_1996
      end
   val atan2: real32 * real32 -> real32 = 
      fn x_370: real32 * real32 => 
      let
	 val x_371: real32 = 
	    #1 x_370
	 val x_372: real32 = 
	    #0 x_370
	 val x_1997: real32 = 
	    Real32_Math_atan2 (x_372, x_371)
      in
	 x_1997
      end
   val cos: real32 -> real32 = 
      fn x_373: real32 => 
      let
	 val x_1998: real32 = 
	    Real32_Math_cos (x_373)
      in
	 x_1998
      end
   val cosh: real32 -> real32 = 
      fn x_374: real32 => 
      let
	 val x_1999: real32 = 
	    Real32_Math_cosh (x_374)
      in
	 x_1999
      end
   val x_2000: cpointer = 
      Real32_Math_e ()
   val x_2001: word64 = 
      0x0
   val x_2002: real32 = 
      CPointer_getReal32 (x_2000, x_2001)
   val exp: real32 -> real32 = 
      fn x_378: real32 => 
      let
	 val x_2003: real32 = 
	    Real32_Math_exp (x_378)
      in
	 x_2003
      end
   val ln: real32 -> real32 = 
      fn x_379: real32 => 
      let
	 val x_2004: real32 = 
	    Real32_Math_ln (x_379)
      in
	 x_2004
      end
   val log10: real32 -> real32 = 
      fn x_380: real32 => 
      let
	 val x_2005: real32 = 
	    Real32_Math_log10 (x_380)
      in
	 x_2005
      end
   val x_2006: cpointer = 
      Real32_Math_pi ()
   val x_2007: word64 = 
      0x0
   val x_2008: real32 = 
      CPointer_getReal32 (x_2006, x_2007)
   val pow: real32 * real32 -> real32 = 
      fn x_384: real32 * real32 => 
      let
	 val x_385: real32 = 
	    #1 x_384
	 val x_386: real32 = 
	    #0 x_384
	 val x_2009: real32 = 
	    Real32_Math_pow (x_386, x_385)
      in
	 x_2009
      end
   val sin: real32 -> real32 = 
      fn x_387: real32 => 
      let
	 val x_2010: real32 = 
	    Real32_Math_sin (x_387)
      in
	 x_2010
      end
   val sinh: real32 -> real32 = 
      fn x_388: real32 => 
      let
	 val x_2011: real32 = 
	    Real32_Math_sinh (x_388)
      in
	 x_2011
      end
   val sqrt: real32 -> real32 = 
      fn x_389: real32 => 
      let
	 val x_2012: real32 = 
	    Real32_Math_sqrt (x_389)
      in
	 x_2012
      end
   val tan: real32 -> real32 = 
      fn x_390: real32 => 
      let
	 val x_2013: real32 = 
	    Real32_Math_tan (x_390)
      in
	 x_2013
      end
   val tanh: real32 -> real32 = 
      fn x_391: real32 => 
      let
	 val x_2014: real32 = 
	    Real32_Math_tanh (x_391)
      in
	 x_2014
      end
   val *: real32 * real32 -> real32 = 
      fn x_392: real32 * real32 => 
      let
	 val x_393: real32 = 
	    #1 x_392
	 val x_394: real32 = 
	    #0 x_392
	 val x_2015: real32 = 
	    Real32_mul (x_394, x_393)
      in
	 x_2015
      end
   val *+: real32 * real32 * real32 -> real32 = 
      fn x_395: real32 * real32 * real32 => 
      let
	 val x_396: real32 = 
	    #2 x_395
	 val x_397: real32 = 
	    #1 x_395
	 val x_398: real32 = 
	    #0 x_395
	 val x_2016: real32 = 
	    Real32_muladd (x_398, x_397, x_396)
      in
	 x_2016
      end
   val *-: real32 * real32 * real32 -> real32 = 
      fn x_399: real32 * real32 * real32 => 
      let
	 val x_400: real32 = 
	    #2 x_399
	 val x_401: real32 = 
	    #1 x_399
	 val x_402: real32 = 
	    #0 x_399
	 val x_2017: real32 = 
	    Real32_mulsub (x_402, x_401, x_400)
      in
	 x_2017
      end
   val +: real32 * real32 -> real32 = 
      fn x_403: real32 * real32 => 
      let
	 val x_404: real32 = 
	    #1 x_403
	 val x_405: real32 = 
	    #0 x_403
	 val x_2018: real32 = 
	    Real32_add (x_405, x_404)
      in
	 x_2018
      end
   val -: real32 * real32 -> real32 = 
      fn x_406: real32 * real32 => 
      let
	 val x_407: real32 = 
	    #1 x_406
	 val x_408: real32 = 
	    #0 x_406
	 val x_2019: real32 = 
	    Real32_sub (x_408, x_407)
      in
	 x_2019
      end
   val /: real32 * real32 -> real32 = 
      fn x_409: real32 * real32 => 
      let
	 val x_410: real32 = 
	    #1 x_409
	 val x_411: real32 = 
	    #0 x_409
	 val x_2020: real32 = 
	    Real32_div (x_411, x_410)
      in
	 x_2020
      end
   val ~: real32 -> real32 = 
      fn x_412: real32 => 
      let
	 val x_2021: real32 = 
	    Real32_neg (x_412)
      in
	 x_2021
      end
   val <: real32 * real32 -> bool = 
      fn x_413: real32 * real32 => 
      let
	 val x_414: real32 = 
	    #1 x_413
	 val x_415: real32 = 
	    #0 x_413
	 val x_2022: bool = 
	    Real32_lt (x_415, x_414)
      in
	 x_2022
      end
   val <=: real32 * real32 -> bool = 
      fn x_416: real32 * real32 => 
      let
	 val x_417: real32 = 
	    #1 x_416
	 val x_418: real32 = 
	    #0 x_416
	 val x_2023: bool = 
	    Real32_le (x_418, x_417)
      in
	 x_2023
      end
   val ==: real32 * real32 -> bool = 
      fn x_419: real32 * real32 => 
      let
	 val x_420: real32 = 
	    #1 x_419
	 val x_421: real32 = 
	    #0 x_419
	 val x_2024: bool = 
	    Real32_equal (x_421, x_420)
      in
	 x_2024
      end
   val abs: real32 -> real32 = 
      fn x_422: real32 => 
      let
	 val x_2025: real32 = 
	    Real32_abs (x_422)
      in
	 x_2025
      end
   val frexp: real32 * word32 ref -> real32 = 
      fn x_423: real32 * word32 ref => 
      let
	 val x_424: word32 ref = 
	    #1 x_423
	 val x_425: real32 = 
	    #0 x_423
	 val x_2026: real32 = 
	    Real32_frexp (x_425, x_424)
      in
	 x_2026
      end
   val gdtoa: real32 * word32 * word32 * word32 * word32 ref -> word64 = 
      fn x_426: real32 * word32 * word32 * word32 * word32 ref => 
      let
	 val x_427: word32 ref = 
	    #4 x_426
	 val x_428: word32 = 
	    #3 x_426
	 val x_429: word32 = 
	    #2 x_426
	 val x_430: word32 = 
	    #1 x_426
	 val x_431: real32 = 
	    #0 x_426
	 val x_2027: word64 = 
	    Real32_gdtoa (x_431, x_430, x_429, x_428, x_427)
      in
	 x_2027
      end
   val ldexp: real32 * word32 -> real32 = 
      fn x_432: real32 * word32 => 
      let
	 val x_433: word32 = 
	    #1 x_432
	 val x_434: real32 = 
	    #0 x_432
	 val x_2028: real32 = 
	    Real32_ldexp (x_434, x_433)
      in
	 x_2028
      end
   val modf: real32 * real32 ref -> real32 = 
      fn x_435: real32 * real32 ref => 
      let
	 val x_436: real32 ref = 
	    #1 x_435
	 val x_437: real32 = 
	    #0 x_435
	 val x_2029: real32 = 
	    Real32_modf (x_437, x_436)
      in
	 x_2029
      end
   val round: real32 -> real32 = 
      fn x_438: real32 => 
      let
	 val x_2030: real32 = 
	    Real32_round (x_438)
      in
	 x_2030
      end
   val strtor: word8 vector * word32 -> real32 = 
      fn x_442: word8 vector * word32 => 
      let
	 val x_443: word32 = 
	    #1 x_442
	 val x_444: word8 vector = 
	    #0 x_442
	 val x_2031: real32 = 
	    Real32_strtor (x_444, x_443)
      in
	 x_2031
      end
   val fromInt8Unsafe: word8 -> real32 = 
      fn x_445: word8 => 
      let
	 val x_2032: real32 = 
	    WordS8_rndToReal32 (x_445)
      in
	 x_2032
      end
   val fromInt16Unsafe: word16 -> real32 = 
      fn x_446: word16 => 
      let
	 val x_2033: real32 = 
	    WordS16_rndToReal32 (x_446)
      in
	 x_2033
      end
   val fromInt32Unsafe: word32 -> real32 = 
      fn x_447: word32 => 
      let
	 val x_2034: real32 = 
	    WordS32_rndToReal32 (x_447)
      in
	 x_2034
      end
   val fromInt64Unsafe: word64 -> real32 = 
      fn x_448: word64 => 
      let
	 val x_2035: real32 = 
	    WordS64_rndToReal32 (x_448)
      in
	 x_2035
      end
   val fromReal32Unsafe: real32 -> real32 = 
      fn x_449: real32 => 
      let
      in
	 x_449
      end
   val fromWord8Unsafe: word8 -> real32 = 
      fn x_450: word8 => 
      let
	 val x_2036: real32 = 
	    WordU8_rndToReal32 (x_450)
      in
	 x_2036
      end
   val fromWord16Unsafe: word16 -> real32 = 
      fn x_451: word16 => 
      let
	 val x_2037: real32 = 
	    WordU16_rndToReal32 (x_451)
      in
	 x_2037
      end
   val fromWord32Unsafe: word32 -> real32 = 
      fn x_452: word32 => 
      let
	 val x_2038: real32 = 
	    WordU32_rndToReal32 (x_452)
      in
	 x_2038
      end
   val fromWord64Unsafe: word64 -> real32 = 
      fn x_453: word64 => 
      let
	 val x_2039: real32 = 
	    WordU64_rndToReal32 (x_453)
      in
	 x_2039
      end
   val toInt8Unsafe: real32 -> word8 = 
      fn x_454: real32 => 
      let
	 val x_2040: word8 = 
	    Real32_rndToWordS8 (x_454)
      in
	 x_2040
      end
   val toInt16Unsafe: real32 -> word16 = 
      fn x_455: real32 => 
      let
	 val x_2041: word16 = 
	    Real32_rndToWordS16 (x_455)
      in
	 x_2041
      end
   val toInt32Unsafe: real32 -> word32 = 
      fn x_456: real32 => 
      let
	 val x_2042: word32 = 
	    Real32_rndToWordS32 (x_456)
      in
	 x_2042
      end
   val toInt64Unsafe: real32 -> word64 = 
      fn x_457: real32 => 
      let
	 val x_2043: word64 = 
	    Real32_rndToWordS64 (x_457)
      in
	 x_2043
      end
   val toReal32Unsafe: real32 -> real32 = 
      fn x_458: real32 => 
      let
      in
	 x_458
      end
   val toWord8Unsafe: real32 -> word8 = 
      fn x_459: real32 => 
      let
	 val x_2044: word8 = 
	    Real32_rndToWordU8 (x_459)
      in
	 x_2044
      end
   val toWord16Unsafe: real32 -> word16 = 
      fn x_460: real32 => 
      let
	 val x_2045: word16 = 
	    Real32_rndToWordU16 (x_460)
      in
	 x_2045
      end
   val toWord32Unsafe: real32 -> word32 = 
      fn x_461: real32 => 
      let
	 val x_2046: word32 = 
	    Real32_rndToWordU32 (x_461)
      in
	 x_2046
      end
   val toWord64Unsafe: real32 -> word64 = 
      fn x_462: real32 => 
      let
	 val x_2047: word64 = 
	    Real32_rndToWordU64 (x_462)
      in
	 x_2047
      end
   val rec 
      >: real32 * real32 -> bool = 
	 fn x_463: real32 * real32 => 
	 let
	    val b: real32 = 
	       #1 x_463
	    val a: real32 = 
	       #0 x_463
	    val x_2048: real32 * real32 = 
	       (b, a)
	    val x_2049: bool = 
	       < x_2048
	 in
	    x_2049
	 end
   val rec 
      >=: real32 * real32 -> bool = 
	 fn x_464: real32 * real32 => 
	 let
	    val b: real32 = 
	       #1 x_464
	    val a: real32 = 
	       #0 x_464
	    val x_2050: real32 * real32 = 
	       (b, a)
	    val x_2051: bool = 
	       <= x_2050
	 in
	    x_2051
	 end
   val realSize: word32 = 
      0x40
   val exponentBias: word32 = 
      0x3FF
   val precision: word32 = 
      0x35
   val acos: real64 -> real64 = 
      fn x_465: real64 => 
      let
	 val x_2052: real64 = 
	    Real64_Math_acos (x_465)
      in
	 x_2052
      end
   val asin: real64 -> real64 = 
      fn x_466: real64 => 
      let
	 val x_2053: real64 = 
	    Real64_Math_asin (x_466)
      in
	 x_2053
      end
   val atan: real64 -> real64 = 
      fn x_467: real64 => 
      let
	 val x_2054: real64 = 
	    Real64_Math_atan (x_467)
      in
	 x_2054
      end
   val atan2: real64 * real64 -> real64 = 
      fn x_468: real64 * real64 => 
      let
	 val x_469: real64 = 
	    #1 x_468
	 val x_470: real64 = 
	    #0 x_468
	 val x_2055: real64 = 
	    Real64_Math_atan2 (x_470, x_469)
      in
	 x_2055
      end
   val cos: real64 -> real64 = 
      fn x_471: real64 => 
      let
	 val x_2056: real64 = 
	    Real64_Math_cos (x_471)
      in
	 x_2056
      end
   val cosh: real64 -> real64 = 
      fn x_472: real64 => 
      let
	 val x_2057: real64 = 
	    Real64_Math_cosh (x_472)
      in
	 x_2057
      end
   val x_2058: cpointer = 
      Real64_Math_e ()
   val x_2059: word64 = 
      0x0
   val x_2060: real64 = 
      CPointer_getReal64 (x_2058, x_2059)
   val exp: real64 -> real64 = 
      fn x_476: real64 => 
      let
	 val x_2061: real64 = 
	    Real64_Math_exp (x_476)
      in
	 x_2061
      end
   val ln: real64 -> real64 = 
      fn x_477: real64 => 
      let
	 val x_2062: real64 = 
	    Real64_Math_ln (x_477)
      in
	 x_2062
      end
   val log10: real64 -> real64 = 
      fn x_478: real64 => 
      let
	 val x_2063: real64 = 
	    Real64_Math_log10 (x_478)
      in
	 x_2063
      end
   val x_2064: cpointer = 
      Real64_Math_pi ()
   val x_2065: word64 = 
      0x0
   val x_2066: real64 = 
      CPointer_getReal64 (x_2064, x_2065)
   val pow: real64 * real64 -> real64 = 
      fn x_482: real64 * real64 => 
      let
	 val x_483: real64 = 
	    #1 x_482
	 val x_484: real64 = 
	    #0 x_482
	 val x_2067: real64 = 
	    Real64_Math_pow (x_484, x_483)
      in
	 x_2067
      end
   val sin: real64 -> real64 = 
      fn x_485: real64 => 
      let
	 val x_2068: real64 = 
	    Real64_Math_sin (x_485)
      in
	 x_2068
      end
   val sinh: real64 -> real64 = 
      fn x_486: real64 => 
      let
	 val x_2069: real64 = 
	    Real64_Math_sinh (x_486)
      in
	 x_2069
      end
   val sqrt: real64 -> real64 = 
      fn x_487: real64 => 
      let
	 val x_2070: real64 = 
	    Real64_Math_sqrt (x_487)
      in
	 x_2070
      end
   val tan: real64 -> real64 = 
      fn x_488: real64 => 
      let
	 val x_2071: real64 = 
	    Real64_Math_tan (x_488)
      in
	 x_2071
      end
   val tanh: real64 -> real64 = 
      fn x_489: real64 => 
      let
	 val x_2072: real64 = 
	    Real64_Math_tanh (x_489)
      in
	 x_2072
      end
   val *: real64 * real64 -> real64 = 
      fn x_490: real64 * real64 => 
      let
	 val x_491: real64 = 
	    #1 x_490
	 val x_492: real64 = 
	    #0 x_490
	 val x_2073: real64 = 
	    Real64_mul (x_492, x_491)
      in
	 x_2073
      end
   val *+: real64 * real64 * real64 -> real64 = 
      fn x_493: real64 * real64 * real64 => 
      let
	 val x_494: real64 = 
	    #2 x_493
	 val x_495: real64 = 
	    #1 x_493
	 val x_496: real64 = 
	    #0 x_493
	 val x_2074: real64 = 
	    Real64_muladd (x_496, x_495, x_494)
      in
	 x_2074
      end
   val *-: real64 * real64 * real64 -> real64 = 
      fn x_497: real64 * real64 * real64 => 
      let
	 val x_498: real64 = 
	    #2 x_497
	 val x_499: real64 = 
	    #1 x_497
	 val x_500: real64 = 
	    #0 x_497
	 val x_2075: real64 = 
	    Real64_mulsub (x_500, x_499, x_498)
      in
	 x_2075
      end
   val +: real64 * real64 -> real64 = 
      fn x_501: real64 * real64 => 
      let
	 val x_502: real64 = 
	    #1 x_501
	 val x_503: real64 = 
	    #0 x_501
	 val x_2076: real64 = 
	    Real64_add (x_503, x_502)
      in
	 x_2076
      end
   val -: real64 * real64 -> real64 = 
      fn x_504: real64 * real64 => 
      let
	 val x_505: real64 = 
	    #1 x_504
	 val x_506: real64 = 
	    #0 x_504
	 val x_2077: real64 = 
	    Real64_sub (x_506, x_505)
      in
	 x_2077
      end
   val /: real64 * real64 -> real64 = 
      fn x_507: real64 * real64 => 
      let
	 val x_508: real64 = 
	    #1 x_507
	 val x_509: real64 = 
	    #0 x_507
	 val x_2078: real64 = 
	    Real64_div (x_509, x_508)
      in
	 x_2078
      end
   val ~: real64 -> real64 = 
      fn x_510: real64 => 
      let
	 val x_2079: real64 = 
	    Real64_neg (x_510)
      in
	 x_2079
      end
   val <: real64 * real64 -> bool = 
      fn x_511: real64 * real64 => 
      let
	 val x_512: real64 = 
	    #1 x_511
	 val x_513: real64 = 
	    #0 x_511
	 val x_2080: bool = 
	    Real64_lt (x_513, x_512)
      in
	 x_2080
      end
   val <=: real64 * real64 -> bool = 
      fn x_514: real64 * real64 => 
      let
	 val x_515: real64 = 
	    #1 x_514
	 val x_516: real64 = 
	    #0 x_514
	 val x_2081: bool = 
	    Real64_le (x_516, x_515)
      in
	 x_2081
      end
   val ==: real64 * real64 -> bool = 
      fn x_517: real64 * real64 => 
      let
	 val x_518: real64 = 
	    #1 x_517
	 val x_519: real64 = 
	    #0 x_517
	 val x_2082: bool = 
	    Real64_equal (x_519, x_518)
      in
	 x_2082
      end
   val abs: real64 -> real64 = 
      fn x_520: real64 => 
      let
	 val x_2083: real64 = 
	    Real64_abs (x_520)
      in
	 x_2083
      end
   val frexp: real64 * word32 ref -> real64 = 
      fn x_521: real64 * word32 ref => 
      let
	 val x_522: word32 ref = 
	    #1 x_521
	 val x_523: real64 = 
	    #0 x_521
	 val x_2084: real64 = 
	    Real64_frexp (x_523, x_522)
      in
	 x_2084
      end
   val gdtoa: real64 * word32 * word32 * word32 * word32 ref -> word64 = 
      fn x_524: real64 * word32 * word32 * word32 * word32 ref => 
      let
	 val x_525: word32 ref = 
	    #4 x_524
	 val x_526: word32 = 
	    #3 x_524
	 val x_527: word32 = 
	    #2 x_524
	 val x_528: word32 = 
	    #1 x_524
	 val x_529: real64 = 
	    #0 x_524
	 val x_2085: word64 = 
	    Real64_gdtoa (x_529, x_528, x_527, x_526, x_525)
      in
	 x_2085
      end
   val ldexp: real64 * word32 -> real64 = 
      fn x_530: real64 * word32 => 
      let
	 val x_531: word32 = 
	    #1 x_530
	 val x_532: real64 = 
	    #0 x_530
	 val x_2086: real64 = 
	    Real64_ldexp (x_532, x_531)
      in
	 x_2086
      end
   val modf: real64 * real64 ref -> real64 = 
      fn x_533: real64 * real64 ref => 
      let
	 val x_534: real64 ref = 
	    #1 x_533
	 val x_535: real64 = 
	    #0 x_533
	 val x_2087: real64 = 
	    Real64_modf (x_535, x_534)
      in
	 x_2087
      end
   val round: real64 -> real64 = 
      fn x_536: real64 => 
      let
	 val x_2088: real64 = 
	    Real64_round (x_536)
      in
	 x_2088
      end
   val strtor: word8 vector * word32 -> real64 = 
      fn x_540: word8 vector * word32 => 
      let
	 val x_541: word32 = 
	    #1 x_540
	 val x_542: word8 vector = 
	    #0 x_540
	 val x_2089: real64 = 
	    Real64_strtor (x_542, x_541)
      in
	 x_2089
      end
   val fromInt8Unsafe: word8 -> real64 = 
      fn x_543: word8 => 
      let
	 val x_2090: real64 = 
	    WordS8_rndToReal64 (x_543)
      in
	 x_2090
      end
   val fromInt16Unsafe: word16 -> real64 = 
      fn x_544: word16 => 
      let
	 val x_2091: real64 = 
	    WordS16_rndToReal64 (x_544)
      in
	 x_2091
      end
   val fromInt32Unsafe: word32 -> real64 = 
      fn x_545: word32 => 
      let
	 val x_2092: real64 = 
	    WordS32_rndToReal64 (x_545)
      in
	 x_2092
      end
   val fromInt64Unsafe: word64 -> real64 = 
      fn x_546: word64 => 
      let
	 val x_2093: real64 = 
	    WordS64_rndToReal64 (x_546)
      in
	 x_2093
      end
   val fromReal32Unsafe: real32 -> real64 = 
      fn x_547: real32 => 
      let
	 val x_2094: real64 = 
	    Real32_rndToReal64 (x_547)
      in
	 x_2094
      end
   val fromWord8Unsafe: word8 -> real64 = 
      fn x_548: word8 => 
      let
	 val x_2095: real64 = 
	    WordU8_rndToReal64 (x_548)
      in
	 x_2095
      end
   val fromWord16Unsafe: word16 -> real64 = 
      fn x_549: word16 => 
      let
	 val x_2096: real64 = 
	    WordU16_rndToReal64 (x_549)
      in
	 x_2096
      end
   val fromWord32Unsafe: word32 -> real64 = 
      fn x_550: word32 => 
      let
	 val x_2097: real64 = 
	    WordU32_rndToReal64 (x_550)
      in
	 x_2097
      end
   val fromWord64Unsafe: word64 -> real64 = 
      fn x_551: word64 => 
      let
	 val x_2098: real64 = 
	    WordU64_rndToReal64 (x_551)
      in
	 x_2098
      end
   val toInt8Unsafe: real64 -> word8 = 
      fn x_552: real64 => 
      let
	 val x_2099: word8 = 
	    Real64_rndToWordS8 (x_552)
      in
	 x_2099
      end
   val toInt16Unsafe: real64 -> word16 = 
      fn x_553: real64 => 
      let
	 val x_2100: word16 = 
	    Real64_rndToWordS16 (x_553)
      in
	 x_2100
      end
   val toInt32Unsafe: real64 -> word32 = 
      fn x_554: real64 => 
      let
	 val x_2101: word32 = 
	    Real64_rndToWordS32 (x_554)
      in
	 x_2101
      end
   val toInt64Unsafe: real64 -> word64 = 
      fn x_555: real64 => 
      let
	 val x_2102: word64 = 
	    Real64_rndToWordS64 (x_555)
      in
	 x_2102
      end
   val toReal32Unsafe: real64 -> real32 = 
      fn x_556: real64 => 
      let
	 val x_2103: real32 = 
	    Real64_rndToReal32 (x_556)
      in
	 x_2103
      end
   val toWord8Unsafe: real64 -> word8 = 
      fn x_557: real64 => 
      let
	 val x_2104: word8 = 
	    Real64_rndToWordU8 (x_557)
      in
	 x_2104
      end
   val toWord16Unsafe: real64 -> word16 = 
      fn x_558: real64 => 
      let
	 val x_2105: word16 = 
	    Real64_rndToWordU16 (x_558)
      in
	 x_2105
      end
   val toWord32Unsafe: real64 -> word32 = 
      fn x_559: real64 => 
      let
	 val x_2106: word32 = 
	    Real64_rndToWordU32 (x_559)
      in
	 x_2106
      end
   val toWord64Unsafe: real64 -> word64 = 
      fn x_560: real64 => 
      let
	 val x_2107: word64 = 
	    Real64_rndToWordU64 (x_560)
      in
	 x_2107
      end
   val rec 
      >: real64 * real64 -> bool = 
	 fn x_561: real64 * real64 => 
	 let
	    val b: real64 = 
	       #1 x_561
	    val a: real64 = 
	       #0 x_561
	    val x_2108: real64 * real64 = 
	       (b, a)
	    val x_2109: bool = 
	       < x_2108
	 in
	    x_2109
	 end
   val rec 
      >=: real64 * real64 -> bool = 
	 fn x_562: real64 * real64 => 
	 let
	    val b: real64 = 
	       #1 x_562
	    val a: real64 = 
	       #0 x_562
	    val x_2110: real64 * real64 = 
	       (b, a)
	    val x_2111: bool = 
	       <= x_2110
	 in
	    x_2111
	 end
   val subArr: word8 array * word64 -> word32 = 
      fn x_583: word8 array * word64 => 
      let
	 val x_584: word64 = 
	    #1 x_583
	 val x_585: word8 array = 
	    #0 x_583
	 val x_2112: word32 = 
	    Word8Array_subWord32 (x_585, x_584)
      in
	 x_2112
      end
   val subVec: word8 vector * word64 -> word32 = 
      fn x_586: word8 vector * word64 => 
      let
	 val x_587: word64 = 
	    #1 x_586
	 val x_588: word8 vector = 
	    #0 x_586
	 val x_2113: word32 = 
	    Word8Vector_subWord32 (x_588, x_587)
      in
	 x_2113
      end
   val castFromWord: word32 -> real32 = 
      fn x_603: word32 => 
      let
	 val x_2114: real32 = 
	    Word32_castToReal32 (x_603)
      in
	 x_2114
      end
   val castToWord: real32 -> word32 = 
      fn x_604: real32 => 
      let
	 val x_2115: word32 = 
	    Real32_castToWord32 (x_604)
      in
	 x_2115
      end
   val castFromWord: word64 -> real64 = 
      fn x_605: word64 => 
      let
	 val x_2116: real64 = 
	    Word64_castToReal64 (x_605)
      in
	 x_2116
      end
   val castToWord: real64 -> word64 = 
      fn x_606: real64 => 
      let
	 val x_2117: word64 = 
	    Real64_castToWord64 (x_606)
      in
	 x_2117
      end
   val halt: word32 -> unit = 
      fn x_607: word32 => 
      let
	 val x_2118: unit = 
	    MLton_halt (x_607)
      in
	 x_2118
      end
   val x_2119: cpointer = 
      gcStateAddress ()
   val x_2120: word64 = 
      0x0
   val x_2121: cpointer = 
      CPointer_getCPointer (x_2119, x_2120)
   val 'a extra: exn -> 'a = 
      let
	 val x_2122: exn -> 'a = 
	    fn x_621: exn => 
	    let
	       val x_2123: 'a = 
		  Exn_extra['a] (x_621)
	    in
	       x_2123
	    end
      in
	 x_2122
      end
   val 'a setExtendExtra: ('a -> 'a) -> unit = 
      let
	 val x_2124: ('a -> 'a) -> unit = 
	    fn x_622: 'a -> 'a => 
	    let
	       val x_2125: unit = 
		  Exn_setExtendExtra['a] (x_622)
	    in
	       x_2125
	    end
      in
	 x_2124
      end
   val numExports: word32 = 
      0x1
   val x_2126: Primitive.MLton.Platform.OS.t = 
      Linux
   val fromWord: word64 -> cpointer = 
      fn x_626: word64 => 
      let
	 val x_2127: cpointer = 
	    CPointer_fromWord (x_626)
      in
	 x_2127
      end
   val x_2128: word64 = 
      0x0
   val null: cpointer = 
      fromWord x_2128
   val getCPointer: cpointer * word64 -> cpointer = 
      fn x_628: cpointer * word64 => 
      let
	 val x_629: word64 = 
	    #1 x_628
	 val x_630: cpointer = 
	    #0 x_628
	 val x_2129: cpointer = 
	    CPointer_getCPointer (x_630, x_629)
      in
	 x_2129
      end
   val getInt32: cpointer * word64 -> word32 = 
      fn x_631: cpointer * word64 => 
      let
	 val x_632: word64 = 
	    #1 x_631
	 val x_633: cpointer = 
	    #0 x_631
	 val x_2130: word32 = 
	    CPointer_getWord32 (x_633, x_632)
      in
	 x_2130
      end
   val getWord32: cpointer * word64 -> word32 = 
      fn x_637: cpointer * word64 => 
      let
	 val x_638: word64 = 
	    #1 x_637
	 val x_639: cpointer = 
	    #0 x_637
	 val x_2131: word32 = 
	    CPointer_getWord32 (x_639, x_638)
      in
	 x_2131
      end
   val isOn: bool = 
      false
   val atomicState: unit -> word32 = 
      fn x_652: unit => 
      let
	 val x_2132: word32 = 
	    Thread_atomicState ()
      in
	 x_2132
      end
   val atomicBegin: unit -> unit = 
      fn x_653: unit => 
      let
	 val x_2133: unit = 
	    Thread_atomicBegin ()
      in
	 x_2133
      end
   val rec 
      atomicEnd: unit -> unit = 
	 fn x_654: unit => 
	 let
	    val x_2134: unit = 
	       ()
	    val x_2135: word32 = 
	       atomicState x_2134
	    val x_2136: word32 = 
	       0x0
	    val x_2137: word32 * word32 = 
	       (x_2135, x_2136)
	    val x_2138: bool = 
	       = (word32) x_2137
	    val x_2139: unit = 
	       case x_2138 of
	       true => 
		  let
		     val x_2141: word8 vector = 
			"Thread.atomicEnd"
		     val x_2142: exn = 
			Fail8 x_2141
		     val x_2143: unit = 
			raise x_2142
		  in
		     x_2143
		  end
	       false => 
		  let
		     val x_2140: unit = 
			Thread_atomicEnd ()
		  in
		     x_2140
		  end
	 in
	    x_2139
	 end
   val switchTo: thread -> unit = 
      fn x_668: thread => 
      let
	 val x_2144: unit = 
	    Thread_switchTo (x_668)
      in
	 x_2144
      end
   val getRoundingMode: unit -> word32 = 
      fn x_669: unit => 
      let
	 val x_2145: word32 = 
	    IEEEReal_getRoundingMode ()
      in
	 x_2145
      end
   val FE_DOWNWARD: word32 = 
      0x400
   val FE_NOSUPPORT: word32 = 
      0xFFFFFFFF
   val FE_TONEAREST: word32 = 
      0x0
   val FE_TOWARDZERO: word32 = 
      0xC00
   val FE_UPWARD: word32 = 
      0x800
   val bug: word8 vector -> unit = 
      fn x_671: word8 vector => 
      let
	 val x_2146: unit = 
	    MLton_bug (x_671)
      in
	 x_2146
      end
   val htons: word16 -> word16 = 
      fn x_672: word16 => 
      let
	 val x_2147: word16 = 
	    Net_htons (x_672)
      in
	 x_2147
      end
   val ntohs: word16 -> word16 = 
      fn x_673: word16 => 
      let
	 val x_2148: word16 = 
	    Net_ntohs (x_673)
      in
	 x_2148
      end
   val E2BIG: word32 = 
      0x7
   val EACCES: word32 = 
      0xD
   val EADDRINUSE: word32 = 
      0x62
   val EADDRNOTAVAIL: word32 = 
      0x63
   val EAFNOSUPPORT: word32 = 
      0x61
   val EAGAIN: word32 = 
      0xB
   val EALREADY: word32 = 
      0x72
   val EBADF: word32 = 
      0x9
   val EBADMSG: word32 = 
      0x4A
   val EBUSY: word32 = 
      0x10
   val ECANCELED: word32 = 
      0x7D
   val ECHILD: word32 = 
      0xA
   val ECONNABORTED: word32 = 
      0x67
   val ECONNREFUSED: word32 = 
      0x6F
   val ECONNRESET: word32 = 
      0x68
   val EDEADLK: word32 = 
      0x23
   val EDESTADDRREQ: word32 = 
      0x59
   val EDOM: word32 = 
      0x21
   val EDQUOT: word32 = 
      0x7A
   val EEXIST: word32 = 
      0x11
   val EFAULT: word32 = 
      0xE
   val EFBIG: word32 = 
      0x1B
   val EHOSTUNREACH: word32 = 
      0x71
   val EIDRM: word32 = 
      0x2B
   val EILSEQ: word32 = 
      0x54
   val EINPROGRESS: word32 = 
      0x73
   val EINTR: word32 = 
      0x4
   val EINVAL: word32 = 
      0x16
   val EIO: word32 = 
      0x5
   val EISCONN: word32 = 
      0x6A
   val EISDIR: word32 = 
      0x15
   val ELOOP: word32 = 
      0x28
   val EMFILE: word32 = 
      0x18
   val EMLINK: word32 = 
      0x1F
   val EMSGSIZE: word32 = 
      0x5A
   val EMULTIHOP: word32 = 
      0x48
   val ENAMETOOLONG: word32 = 
      0x24
   val ENETDOWN: word32 = 
      0x64
   val ENETRESET: word32 = 
      0x66
   val ENETUNREACH: word32 = 
      0x65
   val ENFILE: word32 = 
      0x17
   val ENOBUFS: word32 = 
      0x69
   val ENODATA: word32 = 
      0x3D
   val ENODEV: word32 = 
      0x13
   val ENOENT: word32 = 
      0x2
   val ENOEXEC: word32 = 
      0x8
   val ENOLCK: word32 = 
      0x25
   val ENOLINK: word32 = 
      0x43
   val ENOMEM: word32 = 
      0xC
   val ENOMSG: word32 = 
      0x2A
   val ENOPROTOOPT: word32 = 
      0x5C
   val ENOSPC: word32 = 
      0x1C
   val ENOSR: word32 = 
      0x3F
   val ENOSTR: word32 = 
      0x3C
   val ENOSYS: word32 = 
      0x26
   val ENOTCONN: word32 = 
      0x6B
   val ENOTDIR: word32 = 
      0x14
   val ENOTEMPTY: word32 = 
      0x27
   val ENOTSOCK: word32 = 
      0x58
   val ENOTSUP: word32 = 
      0x5F
   val ENOTTY: word32 = 
      0x19
   val ENXIO: word32 = 
      0x6
   val EOPNOTSUPP: word32 = 
      0x5F
   val EOVERFLOW: word32 = 
      0x4B
   val EPERM: word32 = 
      0x1
   val EPIPE: word32 = 
      0x20
   val EPROTO: word32 = 
      0x47
   val EPROTONOSUPPORT: word32 = 
      0x5D
   val EPROTOTYPE: word32 = 
      0x5B
   val ERANGE: word32 = 
      0x22
   val EROFS: word32 = 
      0x1E
   val ESPIPE: word32 = 
      0x1D
   val ESRCH: word32 = 
      0x3
   val ESTALE: word32 = 
      0x74
   val ETIME: word32 = 
      0x3E
   val ETIMEDOUT: word32 = 
      0x6E
   val ETXTBSY: word32 = 
      0x1A
   val EWOULDBLOCK: word32 = 
      0xB
   val EXDEV: word32 = 
      0x12
   val APPEND: word32 = 
      0x400
   val NONBLOCK: word32 = 
      0x800
   val fstat: word32 -> word32 = 
      fn x_678: word32 => 
      let
	 val x_2149: word32 = 
	    Posix_FileSys_Stat_fstat (x_678)
      in
	 x_2149
      end
   val F_SETFL: word32 = 
      0x4
   val fcntl3: word32 * word32 * word32 -> word32 = 
      fn x_690: word32 * word32 * word32 => 
      let
	 val x_691: word32 = 
	    #2 x_690
	 val x_692: word32 = 
	    #1 x_690
	 val x_693: word32 = 
	    #0 x_690
	 val x_2150: word32 = 
	    Posix_IO_fcntl3 (x_693, x_692, x_691)
      in
	 x_2150
      end
   val readChar8: word32 * word8 array * word32 * word64 -> word64 = 
      fn x_698: word32 * word8 array * word32 * word64 => 
      let
	 val x_699: word64 = 
	    #3 x_698
	 val x_700: word32 = 
	    #2 x_698
	 val x_701: word8 array = 
	    #1 x_698
	 val x_702: word32 = 
	    #0 x_698
	 val x_2151: word64 = 
	    Posix_IO_readChar8 (x_702, x_701, x_700, x_699)
      in
	 x_2151
      end
   val SEEK_CUR: word32 = 
      0x1
   val SEEK_END: word32 = 
      0x2
   val SEEK_SET: word32 = 
      0x0
   val settext: word32 -> unit = 
      fn x_703: word32 => 
      let
	 val x_2152: unit = 
	    Posix_IO_settext (x_703)
      in
	 x_2152
      end
   val writeChar8Arr: word32 * word8 array * word32 * word64 -> word64 = 
      fn x_704: word32 * word8 array * word32 * word64 => 
      let
	 val x_705: word64 = 
	    #3 x_704
	 val x_706: word32 = 
	    #2 x_704
	 val x_707: word8 array = 
	    #1 x_704
	 val x_708: word32 = 
	    #0 x_704
	 val x_2153: word64 = 
	    Posix_IO_writeChar8Arr (x_708, x_707, x_706, x_705)
      in
	 x_2153
      end
   val writeChar8Vec: word32 * word8 vector * word32 * word64 -> word64 = 
      fn x_709: word32 * word8 vector * word32 * word64 => 
      let
	 val x_710: word64 = 
	    #3 x_709
	 val x_711: word32 = 
	    #2 x_709
	 val x_712: word8 vector = 
	    #1 x_709
	 val x_713: word32 = 
	    #0 x_709
	 val x_2154: word64 = 
	    Posix_IO_writeChar8Vec (x_713, x_712, x_711, x_710)
      in
	 x_2154
      end
   val abs: real32 -> real32 = 
      fn x_716: real32 => 
      let
	 val x_2155: real32 = 
	    Real32_abs (x_716)
      in
	 x_2155
      end
   val add: real32 * real32 -> real32 = 
      fn x_717: real32 * real32 => 
      let
	 val x_718: real32 = 
	    #1 x_717
	 val x_719: real32 = 
	    #0 x_717
	 val x_2156: real32 = 
	    Real32_add (x_719, x_718)
      in
	 x_2156
      end
   val div: real32 * real32 -> real32 = 
      fn x_720: real32 * real32 => 
      let
	 val x_721: real32 = 
	    #1 x_720
	 val x_722: real32 = 
	    #0 x_720
	 val x_2157: real32 = 
	    Real32_div (x_722, x_721)
      in
	 x_2157
      end
   val equal: real32 * real32 -> bool = 
      fn x_723: real32 * real32 => 
      let
	 val x_724: real32 = 
	    #1 x_723
	 val x_725: real32 = 
	    #0 x_723
	 val x_2158: bool = 
	    Real32_equal (x_725, x_724)
      in
	 x_2158
      end
   val frexp: real32 * word32 ref -> real32 = 
      fn x_726: real32 * word32 ref => 
      let
	 val x_727: word32 ref = 
	    #1 x_726
	 val x_728: real32 = 
	    #0 x_726
	 val x_2159: real32 = 
	    Real32_frexp (x_728, x_727)
      in
	 x_2159
      end
   val gdtoa: real32 * word32 * word32 * word32 * word32 ref -> word64 = 
      fn x_729: real32 * word32 * word32 * word32 * word32 ref => 
      let
	 val x_730: word32 ref = 
	    #4 x_729
	 val x_731: word32 = 
	    #3 x_729
	 val x_732: word32 = 
	    #2 x_729
	 val x_733: word32 = 
	    #1 x_729
	 val x_734: real32 = 
	    #0 x_729
	 val x_2160: word64 = 
	    Real32_gdtoa (x_734, x_733, x_732, x_731, x_730)
      in
	 x_2160
      end
   val ldexp: real32 * word32 -> real32 = 
      fn x_735: real32 * word32 => 
      let
	 val x_736: word32 = 
	    #1 x_735
	 val x_737: real32 = 
	    #0 x_735
	 val x_2161: real32 = 
	    Real32_ldexp (x_737, x_736)
      in
	 x_2161
      end
   val le: real32 * real32 -> bool = 
      fn x_738: real32 * real32 => 
      let
	 val x_739: real32 = 
	    #1 x_738
	 val x_740: real32 = 
	    #0 x_738
	 val x_2162: bool = 
	    Real32_le (x_740, x_739)
      in
	 x_2162
      end
   val lt: real32 * real32 -> bool = 
      fn x_741: real32 * real32 => 
      let
	 val x_742: real32 = 
	    #1 x_741
	 val x_743: real32 = 
	    #0 x_741
	 val x_2163: bool = 
	    Real32_lt (x_743, x_742)
      in
	 x_2163
      end
   val acos: real32 -> real32 = 
      fn x_744: real32 => 
      let
	 val x_2164: real32 = 
	    Real32_Math_acos (x_744)
      in
	 x_2164
      end
   val asin: real32 -> real32 = 
      fn x_745: real32 => 
      let
	 val x_2165: real32 = 
	    Real32_Math_asin (x_745)
      in
	 x_2165
      end
   val atan: real32 -> real32 = 
      fn x_746: real32 => 
      let
	 val x_2166: real32 = 
	    Real32_Math_atan (x_746)
      in
	 x_2166
      end
   val atan2: real32 * real32 -> real32 = 
      fn x_747: real32 * real32 => 
      let
	 val x_748: real32 = 
	    #1 x_747
	 val x_749: real32 = 
	    #0 x_747
	 val x_2167: real32 = 
	    Real32_Math_atan2 (x_749, x_748)
      in
	 x_2167
      end
   val cos: real32 -> real32 = 
      fn x_750: real32 => 
      let
	 val x_2168: real32 = 
	    Real32_Math_cos (x_750)
      in
	 x_2168
      end
   val cosh: real32 -> real32 = 
      fn x_751: real32 => 
      let
	 val x_2169: real32 = 
	    Real32_Math_cosh (x_751)
      in
	 x_2169
      end
   val x_2170: unit -> real32 = 
      fn x_753: unit => 
      let
	 val x_2171: cpointer = 
	    Real32_Math_e ()
	 val x_2172: word64 = 
	    0x0
	 val x_2173: real32 = 
	    CPointer_getReal32 (x_2171, x_2172)
      in
	 x_2173
      end
   val exp: real32 -> real32 = 
      fn x_754: real32 => 
      let
	 val x_2174: real32 = 
	    Real32_Math_exp (x_754)
      in
	 x_2174
      end
   val ln: real32 -> real32 = 
      fn x_755: real32 => 
      let
	 val x_2175: real32 = 
	    Real32_Math_ln (x_755)
      in
	 x_2175
      end
   val log10: real32 -> real32 = 
      fn x_756: real32 => 
      let
	 val x_2176: real32 = 
	    Real32_Math_log10 (x_756)
      in
	 x_2176
      end
   val x_2177: unit -> real32 = 
      fn x_758: unit => 
      let
	 val x_2178: cpointer = 
	    Real32_Math_pi ()
	 val x_2179: word64 = 
	    0x0
	 val x_2180: real32 = 
	    CPointer_getReal32 (x_2178, x_2179)
      in
	 x_2180
      end
   val pow: real32 * real32 -> real32 = 
      fn x_759: real32 * real32 => 
      let
	 val x_760: real32 = 
	    #1 x_759
	 val x_761: real32 = 
	    #0 x_759
	 val x_2181: real32 = 
	    Real32_Math_pow (x_761, x_760)
      in
	 x_2181
      end
   val sin: real32 -> real32 = 
      fn x_762: real32 => 
      let
	 val x_2182: real32 = 
	    Real32_Math_sin (x_762)
      in
	 x_2182
      end
   val sinh: real32 -> real32 = 
      fn x_763: real32 => 
      let
	 val x_2183: real32 = 
	    Real32_Math_sinh (x_763)
      in
	 x_2183
      end
   val sqrt: real32 -> real32 = 
      fn x_764: real32 => 
      let
	 val x_2184: real32 = 
	    Real32_Math_sqrt (x_764)
      in
	 x_2184
      end
   val tan: real32 -> real32 = 
      fn x_765: real32 => 
      let
	 val x_2185: real32 = 
	    Real32_Math_tan (x_765)
      in
	 x_2185
      end
   val tanh: real32 -> real32 = 
      fn x_766: real32 => 
      let
	 val x_2186: real32 = 
	    Real32_Math_tanh (x_766)
      in
	 x_2186
      end
   val modf: real32 * real32 ref -> real32 = 
      fn x_767: real32 * real32 ref => 
      let
	 val x_768: real32 ref = 
	    #1 x_767
	 val x_769: real32 = 
	    #0 x_767
	 val x_2187: real32 = 
	    Real32_modf (x_769, x_768)
      in
	 x_2187
      end
   val mul: real32 * real32 -> real32 = 
      fn x_770: real32 * real32 => 
      let
	 val x_771: real32 = 
	    #1 x_770
	 val x_772: real32 = 
	    #0 x_770
	 val x_2188: real32 = 
	    Real32_mul (x_772, x_771)
      in
	 x_2188
      end
   val muladd: real32 * real32 * real32 -> real32 = 
      fn x_773: real32 * real32 * real32 => 
      let
	 val x_774: real32 = 
	    #2 x_773
	 val x_775: real32 = 
	    #1 x_773
	 val x_776: real32 = 
	    #0 x_773
	 val x_2189: real32 = 
	    Real32_muladd (x_776, x_775, x_774)
      in
	 x_2189
      end
   val mulsub: real32 * real32 * real32 -> real32 = 
      fn x_777: real32 * real32 * real32 => 
      let
	 val x_778: real32 = 
	    #2 x_777
	 val x_779: real32 = 
	    #1 x_777
	 val x_780: real32 = 
	    #0 x_777
	 val x_2190: real32 = 
	    Real32_mulsub (x_780, x_779, x_778)
      in
	 x_2190
      end
   val neg: real32 -> real32 = 
      fn x_781: real32 => 
      let
	 val x_2191: real32 = 
	    Real32_neg (x_781)
      in
	 x_2191
      end
   val round: real32 -> real32 = 
      fn x_782: real32 => 
      let
	 val x_2192: real32 = 
	    Real32_round (x_782)
      in
	 x_2192
      end
   val strtor: word8 vector * word32 -> real32 = 
      fn x_783: word8 vector * word32 => 
      let
	 val x_784: word32 = 
	    #1 x_783
	 val x_785: word8 vector = 
	    #0 x_783
	 val x_2193: real32 = 
	    Real32_strtor (x_785, x_784)
      in
	 x_2193
      end
   val sub: real32 * real32 -> real32 = 
      fn x_786: real32 * real32 => 
      let
	 val x_787: real32 = 
	    #1 x_786
	 val x_788: real32 = 
	    #0 x_786
	 val x_2194: real32 = 
	    Real32_sub (x_788, x_787)
      in
	 x_2194
      end
   val abs: real64 -> real64 = 
      fn x_789: real64 => 
      let
	 val x_2195: real64 = 
	    Real64_abs (x_789)
      in
	 x_2195
      end
   val add: real64 * real64 -> real64 = 
      fn x_790: real64 * real64 => 
      let
	 val x_791: real64 = 
	    #1 x_790
	 val x_792: real64 = 
	    #0 x_790
	 val x_2196: real64 = 
	    Real64_add (x_792, x_791)
      in
	 x_2196
      end
   val div: real64 * real64 -> real64 = 
      fn x_793: real64 * real64 => 
      let
	 val x_794: real64 = 
	    #1 x_793
	 val x_795: real64 = 
	    #0 x_793
	 val x_2197: real64 = 
	    Real64_div (x_795, x_794)
      in
	 x_2197
      end
   val equal: real64 * real64 -> bool = 
      fn x_796: real64 * real64 => 
      let
	 val x_797: real64 = 
	    #1 x_796
	 val x_798: real64 = 
	    #0 x_796
	 val x_2198: bool = 
	    Real64_equal (x_798, x_797)
      in
	 x_2198
      end
   val frexp: real64 * word32 ref -> real64 = 
      fn x_799: real64 * word32 ref => 
      let
	 val x_800: word32 ref = 
	    #1 x_799
	 val x_801: real64 = 
	    #0 x_799
	 val x_2199: real64 = 
	    Real64_frexp (x_801, x_800)
      in
	 x_2199
      end
   val gdtoa: real64 * word32 * word32 * word32 * word32 ref -> word64 = 
      fn x_802: real64 * word32 * word32 * word32 * word32 ref => 
      let
	 val x_803: word32 ref = 
	    #4 x_802
	 val x_804: word32 = 
	    #3 x_802
	 val x_805: word32 = 
	    #2 x_802
	 val x_806: word32 = 
	    #1 x_802
	 val x_807: real64 = 
	    #0 x_802
	 val x_2200: word64 = 
	    Real64_gdtoa (x_807, x_806, x_805, x_804, x_803)
      in
	 x_2200
      end
   val ldexp: real64 * word32 -> real64 = 
      fn x_808: real64 * word32 => 
      let
	 val x_809: word32 = 
	    #1 x_808
	 val x_810: real64 = 
	    #0 x_808
	 val x_2201: real64 = 
	    Real64_ldexp (x_810, x_809)
      in
	 x_2201
      end
   val le: real64 * real64 -> bool = 
      fn x_811: real64 * real64 => 
      let
	 val x_812: real64 = 
	    #1 x_811
	 val x_813: real64 = 
	    #0 x_811
	 val x_2202: bool = 
	    Real64_le (x_813, x_812)
      in
	 x_2202
      end
   val lt: real64 * real64 -> bool = 
      fn x_814: real64 * real64 => 
      let
	 val x_815: real64 = 
	    #1 x_814
	 val x_816: real64 = 
	    #0 x_814
	 val x_2203: bool = 
	    Real64_lt (x_816, x_815)
      in
	 x_2203
      end
   val acos: real64 -> real64 = 
      fn x_817: real64 => 
      let
	 val x_2204: real64 = 
	    Real64_Math_acos (x_817)
      in
	 x_2204
      end
   val asin: real64 -> real64 = 
      fn x_818: real64 => 
      let
	 val x_2205: real64 = 
	    Real64_Math_asin (x_818)
      in
	 x_2205
      end
   val atan: real64 -> real64 = 
      fn x_819: real64 => 
      let
	 val x_2206: real64 = 
	    Real64_Math_atan (x_819)
      in
	 x_2206
      end
   val atan2: real64 * real64 -> real64 = 
      fn x_820: real64 * real64 => 
      let
	 val x_821: real64 = 
	    #1 x_820
	 val x_822: real64 = 
	    #0 x_820
	 val x_2207: real64 = 
	    Real64_Math_atan2 (x_822, x_821)
      in
	 x_2207
      end
   val cos: real64 -> real64 = 
      fn x_823: real64 => 
      let
	 val x_2208: real64 = 
	    Real64_Math_cos (x_823)
      in
	 x_2208
      end
   val cosh: real64 -> real64 = 
      fn x_824: real64 => 
      let
	 val x_2209: real64 = 
	    Real64_Math_cosh (x_824)
      in
	 x_2209
      end
   val x_2210: unit -> real64 = 
      fn x_826: unit => 
      let
	 val x_2211: cpointer = 
	    Real64_Math_e ()
	 val x_2212: word64 = 
	    0x0
	 val x_2213: real64 = 
	    CPointer_getReal64 (x_2211, x_2212)
      in
	 x_2213
      end
   val exp: real64 -> real64 = 
      fn x_827: real64 => 
      let
	 val x_2214: real64 = 
	    Real64_Math_exp (x_827)
      in
	 x_2214
      end
   val ln: real64 -> real64 = 
      fn x_828: real64 => 
      let
	 val x_2215: real64 = 
	    Real64_Math_ln (x_828)
      in
	 x_2215
      end
   val log10: real64 -> real64 = 
      fn x_829: real64 => 
      let
	 val x_2216: real64 = 
	    Real64_Math_log10 (x_829)
      in
	 x_2216
      end
   val x_2217: unit -> real64 = 
      fn x_831: unit => 
      let
	 val x_2218: cpointer = 
	    Real64_Math_pi ()
	 val x_2219: word64 = 
	    0x0
	 val x_2220: real64 = 
	    CPointer_getReal64 (x_2218, x_2219)
      in
	 x_2220
      end
   val pow: real64 * real64 -> real64 = 
      fn x_832: real64 * real64 => 
      let
	 val x_833: real64 = 
	    #1 x_832
	 val x_834: real64 = 
	    #0 x_832
	 val x_2221: real64 = 
	    Real64_Math_pow (x_834, x_833)
      in
	 x_2221
      end
   val sin: real64 -> real64 = 
      fn x_835: real64 => 
      let
	 val x_2222: real64 = 
	    Real64_Math_sin (x_835)
      in
	 x_2222
      end
   val sinh: real64 -> real64 = 
      fn x_836: real64 => 
      let
	 val x_2223: real64 = 
	    Real64_Math_sinh (x_836)
      in
	 x_2223
      end
   val sqrt: real64 -> real64 = 
      fn x_837: real64 => 
      let
	 val x_2224: real64 = 
	    Real64_Math_sqrt (x_837)
      in
	 x_2224
      end
   val tan: real64 -> real64 = 
      fn x_838: real64 => 
      let
	 val x_2225: real64 = 
	    Real64_Math_tan (x_838)
      in
	 x_2225
      end
   val tanh: real64 -> real64 = 
      fn x_839: real64 => 
      let
	 val x_2226: real64 = 
	    Real64_Math_tanh (x_839)
      in
	 x_2226
      end
   val modf: real64 * real64 ref -> real64 = 
      fn x_840: real64 * real64 ref => 
      let
	 val x_841: real64 ref = 
	    #1 x_840
	 val x_842: real64 = 
	    #0 x_840
	 val x_2227: real64 = 
	    Real64_modf (x_842, x_841)
      in
	 x_2227
      end
   val mul: real64 * real64 -> real64 = 
      fn x_843: real64 * real64 => 
      let
	 val x_844: real64 = 
	    #1 x_843
	 val x_845: real64 = 
	    #0 x_843
	 val x_2228: real64 = 
	    Real64_mul (x_845, x_844)
      in
	 x_2228
      end
   val muladd: real64 * real64 * real64 -> real64 = 
      fn x_846: real64 * real64 * real64 => 
      let
	 val x_847: real64 = 
	    #2 x_846
	 val x_848: real64 = 
	    #1 x_846
	 val x_849: real64 = 
	    #0 x_846
	 val x_2229: real64 = 
	    Real64_muladd (x_849, x_848, x_847)
      in
	 x_2229
      end
   val mulsub: real64 * real64 * real64 -> real64 = 
      fn x_850: real64 * real64 * real64 => 
      let
	 val x_851: real64 = 
	    #2 x_850
	 val x_852: real64 = 
	    #1 x_850
	 val x_853: real64 = 
	    #0 x_850
	 val x_2230: real64 = 
	    Real64_mulsub (x_853, x_852, x_851)
      in
	 x_2230
      end
   val neg: real64 -> real64 = 
      fn x_854: real64 => 
      let
	 val x_2231: real64 = 
	    Real64_neg (x_854)
      in
	 x_2231
      end
   val round: real64 -> real64 = 
      fn x_855: real64 => 
      let
	 val x_2232: real64 = 
	    Real64_round (x_855)
      in
	 x_2232
      end
   val strtor: word8 vector * word32 -> real64 = 
      fn x_856: word8 vector * word32 => 
      let
	 val x_857: word32 = 
	    #1 x_856
	 val x_858: word8 vector = 
	    #0 x_856
	 val x_2233: real64 = 
	    Real64_strtor (x_858, x_857)
      in
	 x_2233
      end
   val sub: real64 * real64 -> real64 = 
      fn x_859: real64 * real64 => 
      let
	 val x_860: real64 = 
	    #1 x_859
	 val x_861: real64 = 
	    #0 x_859
	 val x_2234: real64 = 
	    Real64_sub (x_861, x_860)
      in
	 x_2234
      end
   val print: word8 vector -> unit = 
      fn x_862: word8 vector => 
      let
	 val x_2235: unit = 
	    Stdio_print (x_862)
      in
	 x_2235
      end
   val x_2236: exn -> unit = 
      fn x_863: exn => 
      let
	 val x_2237: word8 vector = 
	    "unhandled exception: "
	 val x_2238: unit = 
	    print x_2237
	 val x_2239: unit = 
	    case x_863 of
	    Fail8 x_2240: word8 vector => 
	       let
		  val x_2241: word8 vector = 
		     "Fail "
		  val x_2242: unit = 
		     print x_2241
		  val x_2243: unit = 
		     print x_2240
	       in
		  x_2243
	       end
	      _ => let
		      val x_2244: word8 vector = 
			 name x_863
		      val x_2245: unit = 
			 print x_2244
		   in
		      x_2245
		   end
	 val x_2246: word8 vector = 
	    "\n"
	 val x_2247: unit = 
	    print x_2246
	 val x_2248: word8 vector = 
	    "unhandled exception in Basis Library"
	 val x_2249: unit = 
	    bug x_2248
      in
	 x_2249
      end
   val x_2250: unit = 
      setHandler x_2236
   val x_2251: unit -> unit = 
      fn x_864: unit => 
      let
	 val x_2252: word32 = 
	    0x0
	 val x_2253: unit = 
	    halt x_2252
	 val x_2254: word8 vector = 
	    "missing suffix in Basis Library"
	 val x_2255: unit = 
	    bug x_2254
      in
	 x_2255
      end
   val x_2256: unit = 
      setSuffix x_2251
   val rec 'a 
      check: 'a * 'a -> unit = 
	 fn x_865: 'a * 'a => 
	 let
	    val x_2257: unit = 
	       ()
	 in
	    x_2257
	 end
   val x_2258: (real32 -> real32) * (real32 -> real32) = 
      (acos, acos)
   val x_2259: unit = 
      check (real32 -> real32) x_2258
   val x_2260: (real32 -> real32) * (real32 -> real32) = 
      (asin, asin)
   val x_2261: unit = 
      check (real32 -> real32) x_2260
   val x_2262: (real32 -> real32) * (real32 -> real32) = 
      (atan, atan)
   val x_2263: unit = 
      check (real32 -> real32) x_2262
   val x_2264: (real32 * real32 -> real32) * (real32 * real32 -> real32) = 
      (atan2, atan2)
   val x_2265: unit = 
      check (real32 * real32 -> real32) x_2264
   val x_2266: (real32 -> real32) * (real32 -> real32) = 
      (cos, cos)
   val x_2267: unit = 
      check (real32 -> real32) x_2266
   val x_2268: (real32 -> real32) * (real32 -> real32) = 
      (cosh, cosh)
   val x_2269: unit = 
      check (real32 -> real32) x_2268
   val x_2270: unit -> real32 = 
      fn x_866: unit => 
      let
      in
	 x_2002
      end
   val x_2271: (unit -> real32) * (unit -> real32) = 
      (x_2270, x_2170)
   val x_2272: unit = 
      check (unit -> real32) x_2271
   val x_2273: (real32 -> real32) * (real32 -> real32) = 
      (exp, exp)
   val x_2274: unit = 
      check (real32 -> real32) x_2273
   val x_2275: (real32 -> real32) * (real32 -> real32) = 
      (ln, ln)
   val x_2276: unit = 
      check (real32 -> real32) x_2275
   val x_2277: (real32 -> real32) * (real32 -> real32) = 
      (log10, log10)
   val x_2278: unit = 
      check (real32 -> real32) x_2277
   val x_2279: unit -> real32 = 
      fn x_867: unit => 
      let
      in
	 x_2008
      end
   val x_2280: (unit -> real32) * (unit -> real32) = 
      (x_2279, x_2177)
   val x_2281: unit = 
      check (unit -> real32) x_2280
   val x_2282: (real32 * real32 -> real32) * (real32 * real32 -> real32) = 
      (pow, pow)
   val x_2283: unit = 
      check (real32 * real32 -> real32) x_2282
   val x_2284: (real32 -> real32) * (real32 -> real32) = 
      (sin, sin)
   val x_2285: unit = 
      check (real32 -> real32) x_2284
   val x_2286: (real32 -> real32) * (real32 -> real32) = 
      (sinh, sinh)
   val x_2287: unit = 
      check (real32 -> real32) x_2286
   val x_2288: (real32 -> real32) * (real32 -> real32) = 
      (sqrt, sqrt)
   val x_2289: unit = 
      check (real32 -> real32) x_2288
   val x_2290: (real32 -> real32) * (real32 -> real32) = 
      (tan, tan)
   val x_2291: unit = 
      check (real32 -> real32) x_2290
   val x_2292: (real32 -> real32) * (real32 -> real32) = 
      (tanh, tanh)
   val x_2293: unit = 
      check (real32 -> real32) x_2292
   val x_2294: (real32 -> real32) * (real32 -> real32) = 
      (abs, abs)
   val x_2295: unit = 
      check (real32 -> real32) x_2294
   val x_2296: (real32 * real32 -> real32) * (real32 * real32 -> real32) = 
      (+, add)
   val x_2297: unit = 
      check (real32 * real32 -> real32) x_2296
   val x_2298: (real32 * real32 -> real32) * (real32 * real32 -> real32) = 
      (/, div)
   val x_2299: unit = 
      check (real32 * real32 -> real32) x_2298
   val x_2300: (real32 * real32 -> bool) * (real32 * real32 -> bool) = 
      (==, equal)
   val x_2301: unit = 
      check (real32 * real32 -> bool) x_2300
   val x_2302: (real32 * word32 ref -> real32) * (real32 * word32 ref -> real32) = 
      (frexp, frexp)
   val x_2303: unit = 
      check (real32 * word32 ref -> real32) x_2302
   val x_2304: (real32 * word32 * word32 * word32 * word32 ref -> word64)
	       * (real32 * word32 * word32 * word32 * word32 ref -> word64) = 
      (gdtoa, gdtoa)
   val x_2305: unit = 
      check (real32 * word32 * word32 * word32 * word32 ref -> word64) x_2304
   val x_2306: (real32 * word32 -> real32) * (real32 * word32 -> real32) = 
      (ldexp, ldexp)
   val x_2307: unit = 
      check (real32 * word32 -> real32) x_2306
   val x_2308: (real32 * real32 -> bool) * (real32 * real32 -> bool) = 
      (<=, le)
   val x_2309: unit = 
      check (real32 * real32 -> bool) x_2308
   val x_2310: (real32 * real32 -> bool) * (real32 * real32 -> bool) = 
      (<, lt)
   val x_2311: unit = 
      check (real32 * real32 -> bool) x_2310
   val x_2312: (real32 * real32 ref -> real32) * (real32 * real32 ref -> real32) = 
      (modf, modf)
   val x_2313: unit = 
      check (real32 * real32 ref -> real32) x_2312
   val x_2314: (real32 * real32 -> real32) * (real32 * real32 -> real32) = 
      (*, mul)
   val x_2315: unit = 
      check (real32 * real32 -> real32) x_2314
   val x_2316: (real32 * real32 * real32 -> real32)
	       * (real32 * real32 * real32 -> real32) = 
      (*+, muladd)
   val x_2317: unit = 
      check (real32 * real32 * real32 -> real32) x_2316
   val x_2318: (real32 * real32 * real32 -> real32)
	       * (real32 * real32 * real32 -> real32) = 
      (*-, mulsub)
   val x_2319: unit = 
      check (real32 * real32 * real32 -> real32) x_2318
   val x_2320: (real32 -> real32) * (real32 -> real32) = 
      (~, neg)
   val x_2321: unit = 
      check (real32 -> real32) x_2320
   val x_2322: (real32 -> real32) * (real32 -> real32) = 
      (round, round)
   val x_2323: unit = 
      check (real32 -> real32) x_2322
   val x_2324: (word8 vector * word32 -> real32)
	       * (word8 vector * word32 -> real32) = 
      (strtor, strtor)
   val x_2325: unit = 
      check (word8 vector * word32 -> real32) x_2324
   val x_2326: (real32 * real32 -> real32) * (real32 * real32 -> real32) = 
      (-, sub)
   val x_2327: unit = 
      check (real32 * real32 -> real32) x_2326
   val x_2328: (real64 -> real64) * (real64 -> real64) = 
      (acos, acos)
   val x_2329: unit = 
      check (real64 -> real64) x_2328
   val x_2330: (real64 -> real64) * (real64 -> real64) = 
      (asin, asin)
   val x_2331: unit = 
      check (real64 -> real64) x_2330
   val x_2332: (real64 -> real64) * (real64 -> real64) = 
      (atan, atan)
   val x_2333: unit = 
      check (real64 -> real64) x_2332
   val x_2334: (real64 * real64 -> real64) * (real64 * real64 -> real64) = 
      (atan2, atan2)
   val x_2335: unit = 
      check (real64 * real64 -> real64) x_2334
   val x_2336: (real64 -> real64) * (real64 -> real64) = 
      (cos, cos)
   val x_2337: unit = 
      check (real64 -> real64) x_2336
   val x_2338: (real64 -> real64) * (real64 -> real64) = 
      (cosh, cosh)
   val x_2339: unit = 
      check (real64 -> real64) x_2338
   val x_2340: unit -> real64 = 
      fn x_868: unit => 
      let
      in
	 x_2060
      end
   val x_2341: (unit -> real64) * (unit -> real64) = 
      (x_2340, x_2210)
   val x_2342: unit = 
      check (unit -> real64) x_2341
   val x_2343: (real64 -> real64) * (real64 -> real64) = 
      (exp, exp)
   val x_2344: unit = 
      check (real64 -> real64) x_2343
   val x_2345: (real64 -> real64) * (real64 -> real64) = 
      (ln, ln)
   val x_2346: unit = 
      check (real64 -> real64) x_2345
   val x_2347: (real64 -> real64) * (real64 -> real64) = 
      (log10, log10)
   val x_2348: unit = 
      check (real64 -> real64) x_2347
   val x_2349: unit -> real64 = 
      fn x_869: unit => 
      let
      in
	 x_2066
      end
   val x_2350: (unit -> real64) * (unit -> real64) = 
      (x_2349, x_2217)
   val x_2351: unit = 
      check (unit -> real64) x_2350
   val x_2352: (real64 * real64 -> real64) * (real64 * real64 -> real64) = 
      (pow, pow)
   val x_2353: unit = 
      check (real64 * real64 -> real64) x_2352
   val x_2354: (real64 -> real64) * (real64 -> real64) = 
      (sin, sin)
   val x_2355: unit = 
      check (real64 -> real64) x_2354
   val x_2356: (real64 -> real64) * (real64 -> real64) = 
      (sinh, sinh)
   val x_2357: unit = 
      check (real64 -> real64) x_2356
   val x_2358: (real64 -> real64) * (real64 -> real64) = 
      (sqrt, sqrt)
   val x_2359: unit = 
      check (real64 -> real64) x_2358
   val x_2360: (real64 -> real64) * (real64 -> real64) = 
      (tan, tan)
   val x_2361: unit = 
      check (real64 -> real64) x_2360
   val x_2362: (real64 -> real64) * (real64 -> real64) = 
      (tanh, tanh)
   val x_2363: unit = 
      check (real64 -> real64) x_2362
   val x_2364: (real64 -> real64) * (real64 -> real64) = 
      (abs, abs)
   val x_2365: unit = 
      check (real64 -> real64) x_2364
   val x_2366: (real64 * real64 -> real64) * (real64 * real64 -> real64) = 
      (+, add)
   val x_2367: unit = 
      check (real64 * real64 -> real64) x_2366
   val x_2368: (real64 * real64 -> real64) * (real64 * real64 -> real64) = 
      (/, div)
   val x_2369: unit = 
      check (real64 * real64 -> real64) x_2368
   val x_2370: (real64 * real64 -> bool) * (real64 * real64 -> bool) = 
      (==, equal)
   val x_2371: unit = 
      check (real64 * real64 -> bool) x_2370
   val x_2372: (real64 * word32 ref -> real64) * (real64 * word32 ref -> real64) = 
      (frexp, frexp)
   val x_2373: unit = 
      check (real64 * word32 ref -> real64) x_2372
   val x_2374: (real64 * word32 * word32 * word32 * word32 ref -> word64)
	       * (real64 * word32 * word32 * word32 * word32 ref -> word64) = 
      (gdtoa, gdtoa)
   val x_2375: unit = 
      check (real64 * word32 * word32 * word32 * word32 ref -> word64) x_2374
   val x_2376: (real64 * word32 -> real64) * (real64 * word32 -> real64) = 
      (ldexp, ldexp)
   val x_2377: unit = 
      check (real64 * word32 -> real64) x_2376
   val x_2378: (real64 * real64 -> bool) * (real64 * real64 -> bool) = 
      (<=, le)
   val x_2379: unit = 
      check (real64 * real64 -> bool) x_2378
   val x_2380: (real64 * real64 -> bool) * (real64 * real64 -> bool) = 
      (<, lt)
   val x_2381: unit = 
      check (real64 * real64 -> bool) x_2380
   val x_2382: (real64 * real64 ref -> real64) * (real64 * real64 ref -> real64) = 
      (modf, modf)
   val x_2383: unit = 
      check (real64 * real64 ref -> real64) x_2382
   val x_2384: (real64 * real64 -> real64) * (real64 * real64 -> real64) = 
      (*, mul)
   val x_2385: unit = 
      check (real64 * real64 -> real64) x_2384
   val x_2386: (real64 * real64 * real64 -> real64)
	       * (real64 * real64 * real64 -> real64) = 
      (*+, muladd)
   val x_2387: unit = 
      check (real64 * real64 * real64 -> real64) x_2386
   val x_2388: (real64 * real64 * real64 -> real64)
	       * (real64 * real64 * real64 -> real64) = 
      (*-, mulsub)
   val x_2389: unit = 
      check (real64 * real64 * real64 -> real64) x_2388
   val x_2390: (real64 -> real64) * (real64 -> real64) = 
      (~, neg)
   val x_2391: unit = 
      check (real64 -> real64) x_2390
   val x_2392: (real64 -> real64) * (real64 -> real64) = 
      (round, round)
   val x_2393: unit = 
      check (real64 -> real64) x_2392
   val x_2394: (word8 vector * word32 -> real64)
	       * (word8 vector * word32 -> real64) = 
      (strtor, strtor)
   val x_2395: unit = 
      check (word8 vector * word32 -> real64) x_2394
   val x_2396: (real64 * real64 -> real64) * (real64 * real64 -> real64) = 
      (-, sub)
   val x_2397: unit = 
      check (real64 * real64 -> real64) x_2396
   val rec ('a, 'b) 
      try: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) -> 'b = 
	 fn x_870: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) => 
	 let
	    val h: exn -> 'b = 
	       #2 x_870
	    val k: 'a -> 'b = 
	       #1 x_870
	    val f: unit -> 'a = 
	       #0 x_870
	    val x_2398: 'a DynamicWind.try.t = 
	       let
		  val x_2399: unit = 
		     ()
		  val x_2400: 'a = 
		     f x_2399
		  val x_2401: 'a DynamicWind.try.t = 
		     A['a] x_2400
	       in
		  x_2401
	       end
	       handle x_871 => let
				  val x_2402: 'a DynamicWind.try.t = 
				     E['a] x_871
			       in
				  x_2402
			       end
	    val x_2403: 'b = 
	       case x_2398 of
	       A['a] x_2406: 'a => 
		  let
		     val x_2407: 'b = 
			k x_2406
		  in
		     x_2407
		  end
	       E['a] x_2404: exn => 
		  let
		     val x_2405: 'b = 
			h x_2404
		  in
		     x_2405
		  end
	 in
	    x_2403
	 end
   val rec 'a_174 
      wind: (unit -> 'a_174) * (unit -> unit) -> 'a_174 = 
	 fn x_872: (unit -> 'a_174) * (unit -> unit) => 
	 let
	    val cleanup: unit -> unit = 
	       #1 x_872
	    val thunk: unit -> 'a_174 = 
	       #0 x_872
	    val x_2408: 'a_174 -> 'a_174 = 
	       fn x_874: 'a_174 => 
	       let
		  val x_2409: unit = 
		     ()
		  val x_2410: unit = 
		     cleanup x_2409
	       in
		  x_874
	       end
	    val x_2411: exn -> 'a_174 = 
	       fn x_873: exn => 
	       let
		  val x_2412: unit = 
		     ()
		  val x_2413: unit = 
		     cleanup x_2412
		  val x_2414: 'a_174 = 
		     raise x_873
	       in
		  x_2414
	       end
	    val x_2415: (unit -> 'a_174) * ('a_174 -> 'a_174) * (exn -> 'a_174) = 
	       (thunk, x_2408, x_2411)
	    val x_2416: 'a_174 = 
	       try ('a_174, 'a_174) x_2415
	 in
	    x_2416
	 end
   val 'a wind_0: (unit -> 'a) * (unit -> unit) -> 'a = 
      let
      in
	 wind ('a)
      end
   val rec (''s, ''l) 
      make: (''l -> ''s) * (''s -> ''l) -> ''l -> ''s = 
	 fn x_875: (''l -> ''s) * (''s -> ''l) => 
	 let
	    val zextdFromSmallToLarge: ''s -> ''l = 
	       #1 x_875
	    val zextdFromLargeToSmall: ''l -> ''s = 
	       #0 x_875
	    val x_2417: ''l -> ''s = 
	       fn x_876: ''l => 
	       let
		  val res: ''s = 
		     zextdFromLargeToSmall x_876
		  val x_2418: ''l = 
		     zextdFromSmallToLarge res
		  val x_2419: ''l * ''l = 
		     (x_876, x_2418)
		  val x_2420: bool = 
		     = (''l) x_2419
		  val x_2421: ''s = 
		     case x_2420 of
		     true => 
			let
			in
			   res
			end
		     false => 
			let
			   val x_2422: exn = 
			      Overflow
			   val x_2423: ''s = 
			      raise x_2422
			in
			   x_2423
			end
	       in
		  x_2421
	       end
	 in
	    x_2417
	 end
   val x_2424: (word16 -> word8) * (word8 -> word16) = 
      (zextdFromInt16ToInt8, zextdFromInt8ToInt16)
   val zchckFromInt16ToInt8: word16 -> word8 = 
      make (word8, word16) x_2424
   val x_2425: (word16 -> word8) * (word8 -> word16) = 
      (zextdFromInt16ToWord8, zextdFromWord8ToInt16)
   val zchckFromInt16ToWord8: word16 -> word8 = 
      make (word8, word16) x_2425
   val x_2426: (word32 -> word8) * (word8 -> word32) = 
      (zextdFromInt32ToInt8, zextdFromInt8ToInt32)
   val zchckFromInt32ToInt8: word32 -> word8 = 
      make (word8, word32) x_2426
   val x_2427: (word32 -> word16) * (word16 -> word32) = 
      (zextdFromInt32ToInt16, zextdFromInt16ToInt32)
   val zchckFromInt32ToInt16: word32 -> word16 = 
      make (word16, word32) x_2427
   val x_2428: (word32 -> word8) * (word8 -> word32) = 
      (zextdFromInt32ToWord8, zextdFromWord8ToInt32)
   val zchckFromInt32ToWord8: word32 -> word8 = 
      make (word8, word32) x_2428
   val x_2429: (word32 -> word16) * (word16 -> word32) = 
      (zextdFromInt32ToWord16, zextdFromWord16ToInt32)
   val zchckFromInt32ToWord16: word32 -> word16 = 
      make (word16, word32) x_2429
   val x_2430: (word64 -> word8) * (word8 -> word64) = 
      (zextdFromInt64ToInt8, zextdFromInt8ToInt64)
   val zchckFromInt64ToInt8: word64 -> word8 = 
      make (word8, word64) x_2430
   val x_2431: (word64 -> word16) * (word16 -> word64) = 
      (zextdFromInt64ToInt16, zextdFromInt16ToInt64)
   val zchckFromInt64ToInt16: word64 -> word16 = 
      make (word16, word64) x_2431
   val x_2432: (word64 -> word32) * (word32 -> word64) = 
      (zextdFromInt64ToInt32, zextdFromInt32ToInt64)
   val zchckFromInt64ToInt32: word64 -> word32 = 
      make (word32, word64) x_2432
   val x_2433: (word64 -> word8) * (word8 -> word64) = 
      (zextdFromInt64ToWord8, zextdFromWord8ToInt64)
   val zchckFromInt64ToWord8: word64 -> word8 = 
      make (word8, word64) x_2433
   val x_2434: (word64 -> word16) * (word16 -> word64) = 
      (zextdFromInt64ToWord16, zextdFromWord16ToInt64)
   val zchckFromInt64ToWord16: word64 -> word16 = 
      make (word16, word64) x_2434
   val x_2435: (word64 -> word32) * (word32 -> word64) = 
      (zextdFromInt64ToWord32, zextdFromWord32ToInt64)
   val zchckFromInt64ToWord32: word64 -> word32 = 
      make (word32, word64) x_2435
   val x_2436: (word16 -> word8) * (word8 -> word16) = 
      (zextdFromWord16ToInt8, zextdFromInt8ToWord16)
   val zchckFromWord16ToInt8: word16 -> word8 = 
      make (word8, word16) x_2436
   val x_2437: (word16 -> word8) * (word8 -> word16) = 
      (zextdFromWord16ToWord8, zextdFromWord8ToWord16)
   val zchckFromWord16ToWord8: word16 -> word8 = 
      make (word8, word16) x_2437
   val x_2438: (word32 -> word8) * (word8 -> word32) = 
      (zextdFromWord32ToInt8, zextdFromInt8ToWord32)
   val zchckFromWord32ToInt8: word32 -> word8 = 
      make (word8, word32) x_2438
   val x_2439: (word32 -> word16) * (word16 -> word32) = 
      (zextdFromWord32ToInt16, zextdFromInt16ToWord32)
   val zchckFromWord32ToInt16: word32 -> word16 = 
      make (word16, word32) x_2439
   val x_2440: (word32 -> word8) * (word8 -> word32) = 
      (zextdFromWord32ToWord8, zextdFromWord8ToWord32)
   val zchckFromWord32ToWord8: word32 -> word8 = 
      make (word8, word32) x_2440
   val x_2441: (word32 -> word16) * (word16 -> word32) = 
      (zextdFromWord32ToWord16, zextdFromWord16ToWord32)
   val zchckFromWord32ToWord16: word32 -> word16 = 
      make (word16, word32) x_2441
   val x_2442: (word64 -> word8) * (word8 -> word64) = 
      (zextdFromWord64ToInt8, zextdFromInt8ToWord64)
   val zchckFromWord64ToInt8: word64 -> word8 = 
      make (word8, word64) x_2442
   val x_2443: (word64 -> word16) * (word16 -> word64) = 
      (zextdFromWord64ToInt16, zextdFromInt16ToWord64)
   val zchckFromWord64ToInt16: word64 -> word16 = 
      make (word16, word64) x_2443
   val x_2444: (word64 -> word32) * (word32 -> word64) = 
      (zextdFromWord64ToInt32, zextdFromInt32ToWord64)
   val zchckFromWord64ToInt32: word64 -> word32 = 
      make (word32, word64) x_2444
   val x_2445: (word64 -> word8) * (word8 -> word64) = 
      (zextdFromWord64ToWord8, zextdFromWord8ToWord64)
   val zchckFromWord64ToWord8: word64 -> word8 = 
      make (word8, word64) x_2445
   val x_2446: (word64 -> word16) * (word16 -> word64) = 
      (zextdFromWord64ToWord16, zextdFromWord16ToWord64)
   val zchckFromWord64ToWord16: word64 -> word16 = 
      make (word16, word64) x_2446
   val x_2447: (word64 -> word32) * (word32 -> word64) = 
      (zextdFromWord64ToWord32, zextdFromWord32ToWord64)
   val zchckFromWord64ToWord32: word64 -> word32 = 
      make (word32, word64) x_2447
   val rec (''s, ''l) 
      make: (''l -> ''s) * (''s -> ''l) -> ''l -> ''s = 
	 fn x_877: (''l -> ''s) * (''s -> ''l) => 
	 let
	    val sextdFromSmallToLarge: ''s -> ''l = 
	       #1 x_877
	    val sextdFromLargeToSmall: ''l -> ''s = 
	       #0 x_877
	    val x_2448: ''l -> ''s = 
	       fn x_878: ''l => 
	       let
		  val res: ''s = 
		     sextdFromLargeToSmall x_878
		  val x_2449: ''l = 
		     sextdFromSmallToLarge res
		  val x_2450: ''l * ''l = 
		     (x_878, x_2449)
		  val x_2451: bool = 
		     = (''l) x_2450
		  val x_2452: ''s = 
		     case x_2451 of
		     true => 
			let
			in
			   res
			end
		     false => 
			let
			   val x_2453: exn = 
			      Overflow
			   val x_2454: ''s = 
			      raise x_2453
			in
			   x_2454
			end
	       in
		  x_2452
	       end
	 in
	    x_2448
	 end
   val x_2455: (word16 -> word8) * (word8 -> word16) = 
      (sextdFromInt16ToInt8, sextdFromInt8ToInt16)
   val schckFromInt16ToInt8: word16 -> word8 = 
      make (word8, word16) x_2455
   val x_2456: (word16 -> word8) * (word8 -> word16) = 
      (sextdFromInt16ToWord8, sextdFromWord8ToInt16)
   val schckFromInt16ToWord8: word16 -> word8 = 
      make (word8, word16) x_2456
   val x_2457: (word32 -> word8) * (word8 -> word32) = 
      (sextdFromInt32ToInt8, sextdFromInt8ToInt32)
   val schckFromInt32ToInt8: word32 -> word8 = 
      make (word8, word32) x_2457
   val x_2458: (word32 -> word16) * (word16 -> word32) = 
      (sextdFromInt32ToInt16, sextdFromInt16ToInt32)
   val schckFromInt32ToInt16: word32 -> word16 = 
      make (word16, word32) x_2458
   val x_2459: (word32 -> word8) * (word8 -> word32) = 
      (sextdFromInt32ToWord8, sextdFromWord8ToInt32)
   val schckFromInt32ToWord8: word32 -> word8 = 
      make (word8, word32) x_2459
   val x_2460: (word32 -> word16) * (word16 -> word32) = 
      (sextdFromInt32ToWord16, sextdFromWord16ToInt32)
   val schckFromInt32ToWord16: word32 -> word16 = 
      make (word16, word32) x_2460
   val x_2461: (word64 -> word8) * (word8 -> word64) = 
      (sextdFromInt64ToInt8, sextdFromInt8ToInt64)
   val schckFromInt64ToInt8: word64 -> word8 = 
      make (word8, word64) x_2461
   val x_2462: (word64 -> word16) * (word16 -> word64) = 
      (sextdFromInt64ToInt16, sextdFromInt16ToInt64)
   val schckFromInt64ToInt16: word64 -> word16 = 
      make (word16, word64) x_2462
   val x_2463: (word64 -> word32) * (word32 -> word64) = 
      (sextdFromInt64ToInt32, sextdFromInt32ToInt64)
   val schckFromInt64ToInt32: word64 -> word32 = 
      make (word32, word64) x_2463
   val x_2464: (word64 -> word8) * (word8 -> word64) = 
      (sextdFromInt64ToWord8, sextdFromWord8ToInt64)
   val schckFromInt64ToWord8: word64 -> word8 = 
      make (word8, word64) x_2464
   val x_2465: (word64 -> word16) * (word16 -> word64) = 
      (sextdFromInt64ToWord16, sextdFromWord16ToInt64)
   val schckFromInt64ToWord16: word64 -> word16 = 
      make (word16, word64) x_2465
   val x_2466: (word64 -> word32) * (word32 -> word64) = 
      (sextdFromInt64ToWord32, sextdFromWord32ToInt64)
   val schckFromInt64ToWord32: word64 -> word32 = 
      make (word32, word64) x_2466
   val x_2467: (word16 -> word8) * (word8 -> word16) = 
      (sextdFromWord16ToInt8, sextdFromInt8ToWord16)
   val schckFromWord16ToInt8: word16 -> word8 = 
      make (word8, word16) x_2467
   val x_2468: (word16 -> word8) * (word8 -> word16) = 
      (sextdFromWord16ToWord8, sextdFromWord8ToWord16)
   val schckFromWord16ToWord8: word16 -> word8 = 
      make (word8, word16) x_2468
   val x_2469: (word32 -> word8) * (word8 -> word32) = 
      (sextdFromWord32ToInt8, sextdFromInt8ToWord32)
   val schckFromWord32ToInt8: word32 -> word8 = 
      make (word8, word32) x_2469
   val x_2470: (word32 -> word16) * (word16 -> word32) = 
      (sextdFromWord32ToInt16, sextdFromInt16ToWord32)
   val schckFromWord32ToInt16: word32 -> word16 = 
      make (word16, word32) x_2470
   val x_2471: (word32 -> word8) * (word8 -> word32) = 
      (sextdFromWord32ToWord8, sextdFromWord8ToWord32)
   val schckFromWord32ToWord8: word32 -> word8 = 
      make (word8, word32) x_2471
   val x_2472: (word32 -> word16) * (word16 -> word32) = 
      (sextdFromWord32ToWord16, sextdFromWord16ToWord32)
   val schckFromWord32ToWord16: word32 -> word16 = 
      make (word16, word32) x_2472
   val x_2473: (word64 -> word8) * (word8 -> word64) = 
      (sextdFromWord64ToInt8, sextdFromInt8ToWord64)
   val schckFromWord64ToInt8: word64 -> word8 = 
      make (word8, word64) x_2473
   val x_2474: (word64 -> word16) * (word16 -> word64) = 
      (sextdFromWord64ToInt16, sextdFromInt16ToWord64)
   val schckFromWord64ToInt16: word64 -> word16 = 
      make (word16, word64) x_2474
   val x_2475: (word64 -> word32) * (word32 -> word64) = 
      (sextdFromWord64ToInt32, sextdFromInt32ToWord64)
   val schckFromWord64ToInt32: word64 -> word32 = 
      make (word32, word64) x_2475
   val x_2476: (word64 -> word8) * (word8 -> word64) = 
      (sextdFromWord64ToWord8, sextdFromWord8ToWord64)
   val schckFromWord64ToWord8: word64 -> word8 = 
      make (word8, word64) x_2476
   val x_2477: (word64 -> word16) * (word16 -> word64) = 
      (sextdFromWord64ToWord16, sextdFromWord16ToWord64)
   val schckFromWord64ToWord16: word64 -> word16 = 
      make (word16, word64) x_2477
   val x_2478: (word64 -> word32) * (word32 -> word64) = 
      (sextdFromWord64ToWord32, sextdFromWord32ToWord64)
   val schckFromWord64ToWord32: word64 -> word32 = 
      make (word32, word64) x_2478
   val x_2479: word32 * word32 = 
      (sizeInBits, sizeInBits)
   val x_2480: bool = 
      <> (word32) x_2479
   val x_2481: bool = 
      case x_2480 of
      true => 
	 let
	    val x_2484: bool = 
	       true
	 in
	    x_2484
	 end
      false => 
	 let
	    val x_2482: word32 * word32 = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_2483: bool = 
	       <> (word32) x_2482
	 in
	    x_2483
	 end
   val x_2485: unit = 
      case x_2481 of
      true => 
	 let
	    val x_2487: word8 vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_2488: exn = 
	       Fail8 x_2487
	    val x_2489: unit = 
	       raise x_2488
	 in
	    x_2489
	 end
      false => 
	 let
	    val x_2486: unit = 
	       ()
	 in
	    x_2486
	 end
   val x_2490: word32 = 
      0x0
   val zero: word8 = 
      zextdFromWord32ToWord8 x_2490
   val maxWord': word8 = 
      notb zero
   val x_2491: word32 = 
      0x0
   val zero: word8 = 
      zextdFromInt32ToInt8 x_2491
   val x_2492: word32 = 
      0x1
   val one: word8 = 
      zextdFromInt32ToInt8 x_2492
   val rec 
      makeShop: (word8 * word32 -> word8) -> word8 * word32 -> word8 = 
	 fn x_881: word8 * word32 -> word8 => 
	 let
	    val x_2493: word8 * word32 -> word8 = 
	       fn x_882: word8 * word32 => 
	       let
		  val w: word32 = 
		     #1 x_882
		  val x: word8 = 
		     #0 x_882
		  val x_2494: word8 = 
		     idFromInt8ToWord8 x
		  val x_2495: word8 * word32 = 
		     (x_2494, w)
		  val x_2496: word8 = 
		     x_881 x_2495
		  val x_2497: word8 = 
		     idFromWord8ToInt8 x_2496
	       in
		  x_2497
	       end
	 in
	    x_2493
	 end
   val <<?: word8 * word32 -> word8 = 
      makeShop <<?
   val >>?: word8 * word32 -> word8 = 
      makeShop >>?
   val x_2498: word32 = 
      0x1
   val x_2499: word32 * word32 = 
      (sizeInBitsWord, x_2498)
   val x_2500: word32 = 
      - x_2499
   val x_2501: word8 * word32 = 
      (one, x_2500)
   val minInt': word8 = 
      <<? x_2501
   val x_2502: word8 = 
      idFromInt8ToWord8 zero
   val x_2503: word8 = 
      notb x_2502
   val x_2504: word8 = 
      idFromWord8ToInt8 x_2503
   val x_2505: word32 = 
      0x1
   val x_2506: word8 * word32 = 
      (x_2504, x_2505)
   val maxInt': word8 = 
      >>? x_2506
   val x_2507: word32 * word32 = 
      (sizeInBits, sizeInBits)
   val x_2508: bool = 
      <> (word32) x_2507
   val x_2509: bool = 
      case x_2508 of
      true => 
	 let
	    val x_2512: bool = 
	       true
	 in
	    x_2512
	 end
      false => 
	 let
	    val x_2510: word32 * word32 = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_2511: bool = 
	       <> (word32) x_2510
	 in
	    x_2511
	 end
   val x_2513: unit = 
      case x_2509 of
      true => 
	 let
	    val x_2515: word8 vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_2516: exn = 
	       Fail8 x_2515
	    val x_2517: unit = 
	       raise x_2516
	 in
	    x_2517
	 end
      false => 
	 let
	    val x_2514: unit = 
	       ()
	 in
	    x_2514
	 end
   val x_2518: word32 = 
      0x0
   val zero: word16 = 
      zextdFromWord32ToWord16 x_2518
   val maxWord': word16 = 
      notb zero
   val x_2519: word32 = 
      0x0
   val zero: word16 = 
      zextdFromInt32ToInt16 x_2519
   val x_2520: word32 = 
      0x1
   val one: word16 = 
      zextdFromInt32ToInt16 x_2520
   val rec 
      makeShop: (word16 * word32 -> word16) -> word16 * word32 -> word16 = 
	 fn x_885: word16 * word32 -> word16 => 
	 let
	    val x_2521: word16 * word32 -> word16 = 
	       fn x_886: word16 * word32 => 
	       let
		  val w: word32 = 
		     #1 x_886
		  val x: word16 = 
		     #0 x_886
		  val x_2522: word16 = 
		     idFromInt16ToWord16 x
		  val x_2523: word16 * word32 = 
		     (x_2522, w)
		  val x_2524: word16 = 
		     x_885 x_2523
		  val x_2525: word16 = 
		     idFromWord16ToInt16 x_2524
	       in
		  x_2525
	       end
	 in
	    x_2521
	 end
   val <<?: word16 * word32 -> word16 = 
      makeShop <<?
   val >>?: word16 * word32 -> word16 = 
      makeShop >>?
   val x_2526: word32 = 
      0x1
   val x_2527: word32 * word32 = 
      (sizeInBitsWord, x_2526)
   val x_2528: word32 = 
      - x_2527
   val x_2529: word16 * word32 = 
      (one, x_2528)
   val minInt': word16 = 
      <<? x_2529
   val x_2530: word16 = 
      idFromInt16ToWord16 zero
   val x_2531: word16 = 
      notb x_2530
   val x_2532: word16 = 
      idFromWord16ToInt16 x_2531
   val x_2533: word32 = 
      0x1
   val x_2534: word16 * word32 = 
      (x_2532, x_2533)
   val maxInt': word16 = 
      >>? x_2534
   val x_2535: word32 * word32 = 
      (sizeInBits, sizeInBits)
   val x_2536: bool = 
      <> (word32) x_2535
   val x_2537: bool = 
      case x_2536 of
      true => 
	 let
	    val x_2540: bool = 
	       true
	 in
	    x_2540
	 end
      false => 
	 let
	    val x_2538: word32 * word32 = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_2539: bool = 
	       <> (word32) x_2538
	 in
	    x_2539
	 end
   val x_2541: unit = 
      case x_2537 of
      true => 
	 let
	    val x_2543: word8 vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_2544: exn = 
	       Fail8 x_2543
	    val x_2545: unit = 
	       raise x_2544
	 in
	    x_2545
	 end
      false => 
	 let
	    val x_2542: unit = 
	       ()
	 in
	    x_2542
	 end
   val x_2546: word32 = 
      0x0
   val zero: word32 = 
      zextdFromWord32ToWord32 x_2546
   val x_2547: word32 = 
      0x1
   val one: word32 = 
      zextdFromWord32ToWord32 x_2547
   val maxWord': word32 = 
      notb zero
   val x_2548: word32 = 
      0x0
   val zero: word32 = 
      zextdFromInt32ToInt32 x_2548
   val x_2549: word32 = 
      0x1
   val one: word32 = 
      zextdFromInt32ToInt32 x_2549
   val rec 
      makeShop: (word32 * word32 -> word32) -> word32 * word32 -> word32 = 
	 fn x_894: word32 * word32 -> word32 => 
	 let
	    val x_2550: word32 * word32 -> word32 = 
	       fn x_895: word32 * word32 => 
	       let
		  val w: word32 = 
		     #1 x_895
		  val x: word32 = 
		     #0 x_895
		  val x_2551: word32 = 
		     idFromInt32ToWord32 x
		  val x_2552: word32 * word32 = 
		     (x_2551, w)
		  val x_2553: word32 = 
		     x_894 x_2552
		  val x_2554: word32 = 
		     idFromWord32ToInt32 x_2553
	       in
		  x_2554
	       end
	 in
	    x_2550
	 end
   val <<?: word32 * word32 -> word32 = 
      makeShop <<?
   val x_2555: word32 * word32 -> word32 = 
      fn x_891: word32 * word32 => 
      let
	 val y: word32 = 
	    #1 x_891
	 val x: word32 = 
	    #0 x_891
	 val x_2556: word32 = 
	    idFromInt32ToWord32 x
	 val x_2557: word32 = 
	    idFromInt32ToWord32 y
	 val x_2558: word32 * word32 = 
	    (x_2556, x_2557)
	 val x_2559: word32 = 
	    orb x_2558
	 val x_2560: word32 = 
	    idFromWord32ToInt32 x_2559
      in
	 x_2560
      end
   val >>?: word32 * word32 -> word32 = 
      makeShop >>?
   val x_2561: word32 = 
      0x1
   val x_2562: word32 * word32 = 
      (sizeInBitsWord, x_2561)
   val x_2563: word32 = 
      - x_2562
   val x_2564: word32 * word32 = 
      (one, x_2563)
   val minInt': word32 = 
      <<? x_2564
   val x_2565: word32 = 
      idFromInt32ToWord32 zero
   val x_2566: word32 = 
      notb x_2565
   val x_2567: word32 = 
      idFromWord32ToInt32 x_2566
   val x_2568: word32 = 
      0x1
   val x_2569: word32 * word32 = 
      (x_2567, x_2568)
   val maxInt': word32 = 
      >>? x_2569
   val rec 
      quot: word32 * word32 -> word32 = 
	 fn x_897: word32 * word32 => 
	 let
	    val y: word32 = 
	       #1 x_897
	    val x: word32 = 
	       #0 x_897
	    val x_2570: word32 * word32 = 
	       (y, zero)
	    val x_2571: bool = 
	       = (word32) x_2570
	    val x_2572: word32 = 
	       case x_2571 of
	       true => 
		  let
		     val x_2584: exn = 
			Div
		     val x_2585: word32 = 
			raise x_2584
		  in
		     x_2585
		  end
	       false => 
		  let
		     val x_2573: word32 * word32 = 
			(x, minInt')
		     val x_2574: bool = 
			= (word32) x_2573
		     val x_2575: bool = 
			case x_2574 of
			true => 
			   let
			      val x_2577: word32 = 
				 ~! one
			      val x_2578: word32 * word32 = 
				 (y, x_2577)
			      val x_2579: bool = 
				 = (word32) x_2578
			   in
			      x_2579
			   end
			false => 
			   let
			      val x_2576: bool = 
				 false
			   in
			      x_2576
			   end
		     val x_2580: word32 = 
			case x_2575 of
			true => 
			   let
			      val x_2582: exn = 
				 Overflow
			      val x_2583: word32 = 
				 raise x_2582
			   in
			      x_2583
			   end
			false => 
			   let
			      val x_2581: word32 = 
				 WordS32_quot (x, y)
			   in
			      x_2581
			   end
		  in
		     x_2580
		  end
	 in
	    x_2572
	 end
   val x_2586: word32 * word32 = 
      (sizeInBits, sizeInBits)
   val x_2587: bool = 
      <> (word32) x_2586
   val x_2588: bool = 
      case x_2587 of
      true => 
	 let
	    val x_2591: bool = 
	       true
	 in
	    x_2591
	 end
      false => 
	 let
	    val x_2589: word32 * word32 = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_2590: bool = 
	       <> (word32) x_2589
	 in
	    x_2590
	 end
   val x_2592: unit = 
      case x_2588 of
      true => 
	 let
	    val x_2594: word8 vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_2595: exn = 
	       Fail8 x_2594
	    val x_2596: unit = 
	       raise x_2595
	 in
	    x_2596
	 end
      false => 
	 let
	    val x_2593: unit = 
	       ()
	 in
	    x_2593
	 end
   val x_2597: word32 = 
      0x0
   val zero: word64 = 
      zextdFromWord32ToWord64 x_2597
   val x_2598: word32 = 
      0x1
   val one: word64 = 
      zextdFromWord32ToWord64 x_2598
   val maxWord': word64 = 
      notb zero
   val x_2599: word32 = 
      0x0
   val zero: word64 = 
      zextdFromInt32ToInt64 x_2599
   val x_2600: word32 = 
      0x1
   val one: word64 = 
      zextdFromInt32ToInt64 x_2600
   val rec 
      makeShop: (word64 * word32 -> word64) -> word64 * word32 -> word64 = 
	 fn x_904: word64 * word32 -> word64 => 
	 let
	    val x_2601: word64 * word32 -> word64 = 
	       fn x_905: word64 * word32 => 
	       let
		  val w: word32 = 
		     #1 x_905
		  val x: word64 = 
		     #0 x_905
		  val x_2602: word64 = 
		     idFromInt64ToWord64 x
		  val x_2603: word64 * word32 = 
		     (x_2602, w)
		  val x_2604: word64 = 
		     x_904 x_2603
		  val x_2605: word64 = 
		     idFromWord64ToInt64 x_2604
	       in
		  x_2605
	       end
	 in
	    x_2601
	 end
   val <<?: word64 * word32 -> word64 = 
      makeShop <<?
   val ~>>?: word64 * word32 -> word64 = 
      makeShop ~>>?
   val >>?: word64 * word32 -> word64 = 
      makeShop >>?
   val x_2606: word32 = 
      0x1
   val x_2607: word32 * word32 = 
      (sizeInBitsWord, x_2606)
   val x_2608: word32 = 
      - x_2607
   val x_2609: word64 * word32 = 
      (one, x_2608)
   val minInt': word64 = 
      <<? x_2609
   val x_2610: word64 = 
      idFromInt64ToWord64 zero
   val x_2611: word64 = 
      notb x_2610
   val x_2612: word64 = 
      idFromWord64ToInt64 x_2611
   val x_2613: word32 = 
      0x1
   val x_2614: word64 * word32 = 
      (x_2612, x_2613)
   val maxInt': word64 = 
      >>? x_2614
   val rec 
      quot: word64 * word64 -> word64 = 
	 fn x_906: word64 * word64 => 
	 let
	    val y: word64 = 
	       #1 x_906
	    val x: word64 = 
	       #0 x_906
	    val x_2615: word64 * word64 = 
	       (y, zero)
	    val x_2616: bool = 
	       = (word64) x_2615
	    val x_2617: word64 = 
	       case x_2616 of
	       true => 
		  let
		     val x_2629: exn = 
			Div
		     val x_2630: word64 = 
			raise x_2629
		  in
		     x_2630
		  end
	       false => 
		  let
		     val x_2618: word64 * word64 = 
			(x, minInt')
		     val x_2619: bool = 
			= (word64) x_2618
		     val x_2620: bool = 
			case x_2619 of
			true => 
			   let
			      val x_2622: word64 = 
				 ~! one
			      val x_2623: word64 * word64 = 
				 (y, x_2622)
			      val x_2624: bool = 
				 = (word64) x_2623
			   in
			      x_2624
			   end
			false => 
			   let
			      val x_2621: bool = 
				 false
			   in
			      x_2621
			   end
		     val x_2625: word64 = 
			case x_2620 of
			true => 
			   let
			      val x_2627: exn = 
				 Overflow
			      val x_2628: word64 = 
				 raise x_2627
			   in
			      x_2628
			   end
			false => 
			   let
			      val x_2626: word64 = 
				 WordS64_quot (x, y)
			   in
			      x_2626
			   end
		  in
		     x_2625
		  end
	 in
	    x_2617
	 end
   val rec 
      ltu: word64 * word64 -> bool = 
	 fn x_908: word64 * word64 => 
	 let
	    val i': word64 = 
	       #1 x_908
	    val i: word64 = 
	       #0 x_908
	    val x_2631: word64 = 
	       idFromInt64ToWord64 i
	    val x_2632: word64 = 
	       idFromInt64ToWord64 i'
	    val x_2633: bool = 
	       WordU64_lt (x_2631, x_2632)
	 in
	    x_2633
	 end
   val rec 
      >: word64 * word64 -> bool = 
	 fn x_910: word64 * word64 => 
	 let
	    val b: word64 = 
	       #1 x_910
	    val a: word64 = 
	       #0 x_910
	    val x_2634: word64 * word64 = 
	       (b, a)
	    val x_2635: bool = 
	       ltu x_2634
	 in
	    x_2635
	 end
   val rec 
      >=: word64 * word64 -> bool = 
	 fn x_911: word64 * word64 => 
	 let
	    val b: word64 = 
	       #1 x_911
	    val a: word64 = 
	       #0 x_911
	    val x_2636: word64 * word64 = 
	       (a, b)
	    val x_2637: bool = 
	       ltu x_2636
	    val x_2638: bool = 
	       not x_2637
	 in
	    x_2638
	 end
   val 'a_471 fromArray: 'a_471 array -> 'a_471 vector = 
      let
      in
	 fromArrayUnsafe ('a_471)
      end
   val isMutable: bool = 
      false
   val 'a_472 length: 'a_472 vector -> word64 = 
      let
      in
	 length ('a_472)
      end
   val 'a_473 subUnsafe: 'a_473 vector * word64 -> 'a_473 = 
      let
      in
	 subUnsafe ('a_473)
      end
   val 'a subUnsafe_0: 'a vector * word64 -> 'a = 
      let
      in
	 subUnsafe ('a)
      end
   val 'a length_0: 'a vector -> word64 = 
      let
      in
	 length ('a)
      end
   val 'a fromArray_0: 'a array -> 'a vector = 
      let
      in
	 fromArray ('a)
      end
   val rec ('a_482, 'a_481, 'a_480) 
      o: ('a_482 -> 'a_481) * ('a_480 -> 'a_482) -> 'a_480 -> 'a_481 = 
	 fn x_912: ('a_482 -> 'a_481) * ('a_480 -> 'a_482) => 
	 let
	    val x_2639: 'a_480 -> 'a_481 = 
	       fn x_913: 'a_480 => 
	       let
		  val x_2640: 'a_480 -> 'a_482 = 
		     #1 x_912
		  val x_2641: 'a_482 -> 'a_481 = 
		     #0 x_912
		  val x_2642: 'a_482 = 
		     x_2640 x_913
		  val x_2643: 'a_481 = 
		     x_2641 x_2642
	       in
		  x_2643
	       end
	 in
	    x_2639
	 end
   val rec 
      valOf: word32 Primitive.Option.t -> word32 = 
	 fn x_914: word32 Primitive.Option.t => 
	 let
	    val x_2644: word32 = 
	       case x_914 of
	       SOME[word32] x_2646: word32 => 
		  let
		  in
		     x_2646
		  end
	       NONE[word32] => 
		  let
		     val x_2645: word32 = 
			0x0
		  in
		     x_2645
		  end
	 in
	    x_2644
	 end
   val rec 'a_483 
      doit: word32 * ('a_483 -> word64) * 'a_483 -> word64 = 
	 fn x_915: word32 * ('a_483 -> word64) * 'a_483 => 
	 let
	    val maxInt': 'a_483 = 
	       #2 x_915
	    val fromInt: 'a_483 -> word64 = 
	       #1 x_915
	    val precision: word32 = 
	       #0 x_915
	    val x_2647: word32 = 
	       valOf precision
	    val x_2648: word32 * word32 = 
	       (x_2647, precision)
	    val x_2649: bool = 
	       >= x_2648
	    val x_2650: word64 = 
	       case x_2649 of
	       true => 
		  let
		     val x_2651: word64 = 
			fromInt maxInt'
		  in
		     x_2651
		  end
	       false => 
		  let
		  in
		     maxInt'
		  end
	 in
	    x_2650
	 end
   val x_2652: word32 = 
      valOf precision
   val x_2653: word32 * (word8 -> word64) * word8 = 
      (x_2652, sextdFromInt8ToInt64, maxInt')
   val fInt8: word64 = 
      doit (word8) x_2653
   val x_2654: word32 = 
      valOf precision
   val x_2655: word32 * (word16 -> word64) * word16 = 
      (x_2654, sextdFromInt16ToInt64, maxInt')
   val fInt16: word64 = 
      doit (word16) x_2655
   val x_2656: word32 = 
      valOf precision
   val x_2657: word32 * (word32 -> word64) * word32 = 
      (x_2656, sextdFromInt32ToInt64, maxInt')
   val fInt32: word64 = 
      doit (word32) x_2657
   val x_2658: word32 = 
      valOf precision
   val x_2659: word32 * (word64 -> word64) * word64 = 
      (x_2658, sextdFromInt64ToInt64, maxInt')
   val fInt64: word64 = 
      doit (word64) x_2659
   val rec 'a_487 
      arrayUninit: word64 -> 'a_487 array = 
	 fn x_916: word64 => 
	 let
	    val x_2660: bool = 
	       not isMutable
	    val x_2661: bool = 
	       case x_2660 of
	       true => 
		  let
		     val x_2663: word64 = 
			0x0
		     val x_2664: word64 * word64 = 
			(x_916, x_2663)
		     val x_2665: bool = 
			= (word64) x_2664
		  in
		     x_2665
		  end
	       false => 
		  let
		     val x_2662: bool = 
			false
		  in
		     x_2662
		  end
	    val x_2666: 'a_487 array = 
	       case x_2661 of
	       true => 
		  let
		     val x_2673: unit = 
			()
		     val x_2674: 'a_487 array = 
			array0Const ('a_487) x_2673
		  in
		     x_2674
		  end
	       false => 
		  let
		     val x_2667: word64 * word64 = 
			(x_916, fInt32)
		     val x_2668: bool = 
			> x_2667
		     val x_2669: 'a_487 array = 
			case x_2668 of
			true => 
			   let
			      val x_2671: exn = 
				 Size
			      val x_2672: 'a_487 array = 
				 raise x_2671
			   in
			      x_2672
			   end
			false => 
			   let
			      val x_2670: 'a_487 array = 
				 arrayUnsafe ('a_487) x_916
			   in
			      x_2670
			   end
		  in
		     x_2669
		  end
	 in
	    x_2666
	 end
   exception GenerateAlreadyGotVector
   exception GenerateVectorNotFull
   val rec ('a_491, 'a_490) 
      unfoldi: word64 * 'a_491 * (word64 * 'a_491 -> 'a_490 * 'a_491)
	       -> 'a_490 vector * 'a_491 = 
	 fn x_917: word64 * 'a_491 * (word64 * 'a_491 -> 'a_490 * 'a_491) => 
	 let
	    val f: word64 * 'a_491 -> 'a_490 * 'a_491 = 
	       #2 x_917
	    val b: 'a_491 = 
	       #1 x_917
	    val n: word64 = 
	       #0 x_917
	    val a: 'a_490 array = 
	       arrayUninit ('a_490) n
	    val rec 
	       loop: word64 * 'a_491 -> 'a_491 = 
		  fn x_918: word64 * 'a_491 => 
		  let
		     val b: 'a_491 = 
			#1 x_918
		     val i: word64 = 
			#0 x_918
		     val x_2675: word64 * word64 = 
			(i, n)
		     val x_2676: bool = 
			>= x_2675
		     val x_2677: 'a_491 = 
			case x_2676 of
			true => 
			   let
			   in
			      b
			   end
			false => 
			   let
			      val x_2678: word64 * 'a_491 = 
				 (i, b)
			      val x_2679: 'a_490 * 'a_491 = 
				 f x_2678
			      val b: 'a_491 = 
				 #1 x_2679
			      val x: 'a_490 = 
				 #0 x_2679
			      val x_2680: 'a_490 array * word64 * 'a_490 = 
				 (a, i, x)
			      val x_2681: unit = 
				 updateUnsafe ('a_490) x_2680
			      val x_2682: word64 = 
				 0x1
			      val x_2683: word64 * word64 = 
				 (i, x_2682)
			      val x_2684: word64 = 
				 +? x_2683
			      val x_2685: word64 * 'a_491 = 
				 (x_2684, b)
			      val x_2686: 'a_491 = 
				 loop x_2685
			   in
			      x_2686
			   end
		  in
		     x_2677
		  end
	    val x_2687: word64 = 
	       0x0
	    val x_2688: word64 * 'a_491 = 
	       (x_2687, b)
	    val b: 'a_491 = 
	       loop x_2688
	    val x_2689: 'a_490 vector = 
	       fromArray_0 ('a_490) a
	    val x_2690: 'a_490 vector * 'a_491 = 
	       (x_2689, b)
	 in
	    x_2690
	 end
   val rec ('a_493, 'a_492) 
      unfold: word64 * 'a_492 * ('a_492 -> 'a_493 * 'a_492)
	      -> 'a_493 vector * 'a_492 = 
	 fn x_919: word64 * 'a_492 * ('a_492 -> 'a_493 * 'a_492) => 
	 let
	    val f: 'a_492 -> 'a_493 * 'a_492 = 
	       #2 x_919
	    val b: 'a_492 = 
	       #1 x_919
	    val n: word64 = 
	       #0 x_919
	    val x_2691: word64 * 'a_492 -> 'a_492 = 
	       fn x_920: word64 * 'a_492 => 
	       let
		  val x_2692: 'a_492 = 
		     #1 x_920
	       in
		  x_2692
	       end
	    val x_2693: ('a_492 -> 'a_493 * 'a_492)
			* (word64 * 'a_492 -> 'a_492) = 
	       (f, x_2691)
	    val x_2694: word64 * 'a_492 -> 'a_493 * 'a_492 = 
	       o ('a_492, 'a_493 * 'a_492, word64 * 'a_492) x_2693
	    val x_2695: word64 * 'a_492 * (word64 * 'a_492 -> 'a_493 * 'a_492) = 
	       (n, b, x_2694)
	    val x_2696: 'a_493 vector * 'a_492 = 
	       unfoldi ('a_492, 'a_493) x_2695
	 in
	    x_2696
	 end
   val rec 'a_494 
      tabulate: word64 * (word64 -> 'a_494) -> 'a_494 vector = 
	 fn x_921: word64 * (word64 -> 'a_494) => 
	 let
	    val f: word64 -> 'a_494 = 
	       #1 x_921
	    val n: word64 = 
	       #0 x_921
	    val x_2697: unit = 
	       ()
	    val x_2698: word64 * unit -> 'a_494 * unit = 
	       fn x_923: word64 * unit => 
	       let
		  val x_2699: word64 = 
		     #0 x_923
		  val x_2700: 'a_494 = 
		     f x_2699
		  val x_2701: unit = 
		     ()
		  val x_2702: 'a_494 * unit = 
		     (x_2700, x_2701)
	       in
		  x_2702
	       end
	    val x_2703: word64 * unit * (word64 * unit -> 'a_494 * unit) = 
	       (n, x_2697, x_2698)
	    val x_2704: 'a_494 vector * unit = 
	       unfoldi (unit, 'a_494) x_2703
	    val x_2705: 'a_494 vector = 
	       #0 x_2704
	 in
	    x_2705
	 end
   val rec 'a_496 
      length: 'a_496 PrimSequence.Slice.t -> word64 = 
	 fn x_924: 'a_496 PrimSequence.Slice.t => 
	 let
	    val x_2706: word64 = 
	       case x_924 of
	       T['a_496] x_2707: word64 * 'a_496 vector * word64 => 
		  let
		     val x_2708: word64 = 
			#0 x_2707
		  in
		     x_2708
		  end
	 in
	    x_2706
	 end
   val rec 'a_497 
      unsafeSub: 'a_497 PrimSequence.Slice.t * word64 -> 'a_497 = 
	 fn x_925: 'a_497 PrimSequence.Slice.t * word64 => 
	 let
	    val x_2709: word64 = 
	       #1 x_925
	    val x_2710: 'a_497 PrimSequence.Slice.t = 
	       #0 x_925
	    val x_2711: 'a_497 = 
	       case x_2710 of
	       T['a_497] x_2712: word64 * 'a_497 vector * word64 => 
		  let
		     val x_2713: word64 = 
			#2 x_2712
		     val x_2714: 'a_497 vector = 
			#1 x_2712
		     val x_2715: word64 * word64 = 
			(x_2713, x_2709)
		     val x_2716: word64 = 
			+? x_2715
		     val x_2717: 'a_497 vector * word64 = 
			(x_2714, x_2716)
		     val x_2718: 'a_497 = 
			subUnsafe_0 ('a_497) x_2717
		  in
		     x_2718
		  end
	 in
	    x_2711
	 end
   val rec 'a_498 
      sub: 'a_498 PrimSequence.Slice.t * word64 -> 'a_498 = 
	 fn x_926: 'a_498 PrimSequence.Slice.t * word64 => 
	 let
	    val x_2719: word64 = 
	       #1 x_926
	    val x_2720: 'a_498 PrimSequence.Slice.t = 
	       #0 x_926
	    val x_2721: 'a_498 = 
	       case x_2720 of
	       T['a_498] x_2722: word64 * 'a_498 vector * word64 => 
		  let
		     val x_2723: word64 = 
			#0 x_2722
		     val x_2724: word64 * word64 = 
			(x_2719, x_2723)
		     val x_2725: bool = 
			>= x_2724
		     val x_2726: 'a_498 = 
			case x_2725 of
			true => 
			   let
			      val x_2729: exn = 
				 Subscript
			      val x_2730: 'a_498 = 
				 raise x_2729
			   in
			      x_2730
			   end
			false => 
			   let
			      val x_2727: 'a_498 PrimSequence.Slice.t * word64 = 
				 (x_2720, x_2719)
			      val x_2728: 'a_498 = 
				 unsafeSub ('a_498) x_2727
			   in
			      x_2728
			   end
		  in
		     x_2726
		  end
	 in
	    x_2721
	 end
   val rec 'a 
      full: 'a vector -> 'a PrimSequence.Slice.t = 
	 fn x_927: 'a vector => 
	 let
	    val x_2731: word64 = 
	       0x0
	    val x_2732: word64 = 
	       length_0 ('a) x_927
	    val x_2733: word64 * 'a vector * word64 = 
	       (x_2732, x_927, x_2731)
	    val x_2734: 'a PrimSequence.Slice.t = 
	       T['a] x_2733
	 in
	    x_2734
	 end
   val rec 'a_505 
      unsafeSubslice: 'a_505 PrimSequence.Slice.t
		      * word64
		      * word64 Primitive.Option.t
		      -> 'a_505 PrimSequence.Slice.t = 
	 fn x_928: 'a_505 PrimSequence.Slice.t
		   * word64
		   * word64 Primitive.Option.t => 
	 let
	    val x_2735: word64 Primitive.Option.t = 
	       #2 x_928
	    val x_2736: word64 = 
	       #1 x_928
	    val x_2737: 'a_505 PrimSequence.Slice.t = 
	       #0 x_928
	    val x_2738: 'a_505 PrimSequence.Slice.t = 
	       case x_2737 of
	       T['a_505] x_2739: word64 * 'a_505 vector * word64 => 
		  let
		     val x_2740: word64 = 
			#2 x_2739
		     val x_2741: 'a_505 vector = 
			#1 x_2739
		     val x_2742: word64 = 
			#0 x_2739
		     val x_2743: word64 * word64 = 
			(x_2740, x_2736)
		     val x_2744: word64 = 
			+? x_2743
		     val x_2745: word64 = 
			case x_2735 of
			NONE[word64] => 
			   let
			      val x_2747: word64 * word64 = 
				 (x_2742, x_2736)
			      val x_2748: word64 = 
				 -? x_2747
			   in
			      x_2748
			   end
			SOME[word64] x_2746: word64 => 
			   let
			   in
			      x_2746
			   end
		     val x_2749: word64 * 'a_505 vector * word64 = 
			(x_2745, x_2741, x_2744)
		     val x_2750: 'a_505 PrimSequence.Slice.t = 
			T['a_505] x_2749
		  in
		     x_2750
		  end
	 in
	    x_2738
	 end
   val rec 'a_506 
      unsafeSlice: 'a_506 vector * word64 * word64 Primitive.Option.t
		   -> 'a_506 PrimSequence.Slice.t = 
	 fn x_929: 'a_506 vector * word64 * word64 Primitive.Option.t => 
	 let
	    val len: word64 Primitive.Option.t = 
	       #2 x_929
	    val start: word64 = 
	       #1 x_929
	    val seq: 'a_506 vector = 
	       #0 x_929
	    val x_2751: 'a_506 PrimSequence.Slice.t = 
	       full ('a_506) seq
	    val x_2752: 'a_506 PrimSequence.Slice.t
			* word64
			* word64 Primitive.Option.t = 
	       (x_2751, start, len)
	    val x_2753: 'a_506 PrimSequence.Slice.t = 
	       unsafeSubslice ('a_506) x_2752
	 in
	    x_2753
	 end
   val rec 'a_507 
      subslice: 'a_507 PrimSequence.Slice.t * word64 * word64 Primitive.Option.t
		-> 'a_507 PrimSequence.Slice.t = 
	 fn x_930: 'a_507 PrimSequence.Slice.t
		   * word64
		   * word64 Primitive.Option.t => 
	 let
	    val x_2754: word64 Primitive.Option.t = 
	       #2 x_930
	    val x_2755: word64 = 
	       #1 x_930
	    val x_2756: 'a_507 PrimSequence.Slice.t = 
	       #0 x_930
	    val x_2757: 'a_507 PrimSequence.Slice.t = 
	       case x_2756 of
	       T['a_507] x_2758: word64 * 'a_507 vector * word64 => 
		  let
		     val x_2759: word64 = 
			#2 x_2758
		     val x_2760: 'a_507 vector = 
			#1 x_2758
		     val x_2761: word64 = 
			#0 x_2758
		     val x_2762: 'a_507 PrimSequence.Slice.t = 
			case x_2754 of
			NONE[word64] => 
			   let
			      val x_2779: word64 * word64 = 
				 (x_2755, x_2761)
			      val x_2780: bool = 
				 > x_2779
			      val x_2781: 'a_507 PrimSequence.Slice.t = 
				 case x_2780 of
				 true => 
				    let
				       val x_2788: exn = 
					  Subscript
				       val x_2789: 'a_507 PrimSequence.Slice.t = 
					  raise x_2788
				    in
				       x_2789
				    end
				 false => 
				    let
				       val x_2782: word64 * word64 = 
					  (x_2759, x_2755)
				       val x_2783: word64 = 
					  +? x_2782
				       val x_2784: word64 * word64 = 
					  (x_2761, x_2755)
				       val x_2785: word64 = 
					  -? x_2784
				       val x_2786: word64
						   * 'a_507 vector
						   * word64 = 
					  (x_2785, x_2760, x_2783)
				       val x_2787: 'a_507 PrimSequence.Slice.t = 
					  T['a_507] x_2786
				    in
				       x_2787
				    end
			   in
			      x_2781
			   end
			SOME[word64] x_2763: word64 => 
			   let
			      val x_2764: word64 * word64 = 
				 (x_2755, x_2761)
			      val x_2765: bool = 
				 > x_2764
			      val x_2766: bool = 
				 case x_2765 of
				 true => 
				    let
				       val x_2771: bool = 
					  true
				    in
				       x_2771
				    end
				 false => 
				    let
				       val x_2767: word64 * word64 = 
					  (x_2761, x_2755)
				       val x_2768: word64 = 
					  -? x_2767
				       val x_2769: word64 * word64 = 
					  (x_2763, x_2768)
				       val x_2770: bool = 
					  > x_2769
				    in
				       x_2770
				    end
			      val x_2772: 'a_507 PrimSequence.Slice.t = 
				 case x_2766 of
				 true => 
				    let
				       val x_2777: exn = 
					  Subscript
				       val x_2778: 'a_507 PrimSequence.Slice.t = 
					  raise x_2777
				    in
				       x_2778
				    end
				 false => 
				    let
				       val x_2773: word64 * word64 = 
					  (x_2759, x_2755)
				       val x_2774: word64 = 
					  +? x_2773
				       val x_2775: word64
						   * 'a_507 vector
						   * word64 = 
					  (x_2763, x_2760, x_2774)
				       val x_2776: 'a_507 PrimSequence.Slice.t = 
					  T['a_507] x_2775
				    in
				       x_2776
				    end
			   in
			      x_2772
			   end
		  in
		     x_2762
		  end
	 in
	    x_2757
	 end
   val rec 'a_508 
      base: 'a_508 PrimSequence.Slice.t -> 'a_508 vector * word64 * word64 = 
	 fn x_931: 'a_508 PrimSequence.Slice.t => 
	 let
	    val x_2790: 'a_508 vector * word64 * word64 = 
	       case x_931 of
	       T['a_508] x_2791: word64 * 'a_508 vector * word64 => 
		  let
		     val x_2792: word64 = 
			#2 x_2791
		     val x_2793: 'a_508 vector = 
			#1 x_2791
		     val x_2794: word64 = 
			#0 x_2791
		     val x_2795: 'a_508 vector * word64 * word64 = 
			(x_2793, x_2792, x_2794)
		  in
		     x_2795
		  end
	 in
	    x_2790
	 end
   val rec ('a_512, 'a_511) 
      foldli: (word64 * 'a_512 * 'a_511 -> 'a_511)
	      -> 'a_511 -> 'a_512 PrimSequence.Slice.t -> 'a_511 = 
	 fn x_932: word64 * 'a_512 * 'a_511 -> 'a_511 => 
	 let
	    val x_2796: 'a_511 -> 'a_512 PrimSequence.Slice.t -> 'a_511 = 
	       fn x_933: 'a_511 => 
	       let
		  val x_2797: 'a_512 PrimSequence.Slice.t -> 'a_511 = 
		     fn x_934: 'a_512 PrimSequence.Slice.t => 
		     let
			val x_2798: 'a_511 = 
			   case x_934 of
			   T['a_512] x_2799: word64 * 'a_512 vector * word64 => 
			      let
				 val x_2800: word64 = 
				    #2 x_2799
				 val x_2801: 'a_512 vector = 
				    #1 x_2799
				 val x_2802: word64 = 
				    #0 x_2799
				 val x_2803: word64 = 
				    0x1
				 val x_2804: word64 * word64 = 
				    (x_2802, x_2803)
				 val len: word64 = 
				    -? x_2804
				 val x_2805: word64 * word64 = 
				    (x_2800, len)
				 val max: word64 = 
				    +? x_2805
				 val rec 
				    loop: word64 * 'a_511 -> 'a_511 = 
				       fn x_935: word64 * 'a_511 => 
				       let
					  val b: 'a_511 = 
					     #1 x_935
					  val i: word64 = 
					     #0 x_935
					  val x_2806: word64 * word64 = 
					     (i, max)
					  val x_2807: bool = 
					     > x_2806
					  val x_2808: 'a_511 = 
					     case x_2807 of
					     true => 
						let
						in
						   b
						end
					     false => 
						let
						   val x_2809: word64 = 
						      0x1
						   val x_2810: word64 * word64 = 
						      (i, x_2809)
						   val x_2811: word64 = 
						      +? x_2810
						   val x_2812: word64 * word64 = 
						      (i, x_2800)
						   val x_2813: word64 = 
						      -? x_2812
						   val x_2814: 'a_512 vector
							       * word64 = 
						      (x_2801, i)
						   val x_2815: 'a_512 = 
						      subUnsafe_0 ('a_512) x_2814
						   val x_2816: word64
							       * 'a_512
							       * 'a_511 = 
						      (x_2813, x_2815, b)
						   val x_2817: 'a_511 = 
						      x_932 x_2816
						   val x_2818: word64 * 'a_511 = 
						      (x_2811, x_2817)
						   val x_2819: 'a_511 = 
						      loop x_2818
						in
						   x_2819
						end
				       in
					  x_2808
				       end
				 val x_2820: word64 * 'a_511 = 
				    (x_2800, x_933)
				 val x_2821: 'a_511 = 
				    loop x_2820
			      in
				 x_2821
			      end
		     in
			x_2798
		     end
	       in
		  x_2797
	       end
	 in
	    x_2796
	 end
   val rec ('a_521, 'a_520, 'a_519, 'a_518, 'a_517, 'a_516, 'a_515) 
      make: (('a_521 * 'a_520 * 'a_519 -> 'a_518) -> 'a_516 -> 'a_515 -> 'a_517)
	    -> ('a_520 * 'a_519 -> 'a_518) -> 'a_516 -> 'a_515 -> 'a_517 = 
	 fn x_936: ('a_521 * 'a_520 * 'a_519 -> 'a_518)
		   -> 'a_516 -> 'a_515 -> 'a_517 => 
	 let
	    val x_2822: ('a_520 * 'a_519 -> 'a_518)
			-> 'a_516 -> 'a_515 -> 'a_517 = 
	       fn x_937: 'a_520 * 'a_519 -> 'a_518 => 
	       let
		  val x_2823: 'a_516 -> 'a_515 -> 'a_517 = 
		     fn x_938: 'a_516 => 
		     let
			val x_2824: 'a_515 -> 'a_517 = 
			   fn x_939: 'a_515 => 
			   let
			      val x_2825: 'a_521 * 'a_520 * 'a_519 -> 'a_518 = 
				 fn x_940: 'a_521 * 'a_520 * 'a_519 => 
				 let
				    val x_2826: 'a_519 = 
				       #2 x_940
				    val x_2827: 'a_520 = 
				       #1 x_940
				    val x_2828: 'a_520 * 'a_519 = 
				       (x_2827, x_2826)
				    val x_2829: 'a_518 = 
				       x_937 x_2828
				 in
				    x_2829
				 end
			      val x_2830: 'a_516 -> 'a_515 -> 'a_517 = 
				 x_936 x_2825
			      val x_2831: 'a_515 -> 'a_517 = 
				 x_2830 x_938
			      val x_2832: 'a_517 = 
				 x_2831 x_939
			   in
			      x_2832
			   end
		     in
			x_2824
		     end
	       in
		  x_2823
	       end
	 in
	    x_2822
	 end
   val rec ('a_523, 'a_522) 
      foldl: ('a_523 * 'a_522 -> 'a_522)
	     -> 'a_522 -> 'a_523 PrimSequence.Slice.t -> 'a_522 = 
	 fn x_941: 'a_523 * 'a_522 -> 'a_522 => 
	 let
	    val x_2833: ('a_523 * 'a_522 -> 'a_522)
			-> 'a_522 -> 'a_523 PrimSequence.Slice.t -> 'a_522 = 
	       make (word64,
		     'a_523,
		     'a_522,
		     'a_522,
		     'a_522,
		     'a_522,
		     'a_523 PrimSequence.Slice.t) foldli ('a_523, 'a_522)
	    val x_2834: 'a_522 -> 'a_523 PrimSequence.Slice.t -> 'a_522 = 
	       x_2833 x_941
	 in
	    x_2834
	 end
   val rec ('a_529, 'a_528) 
      mapi: (word64 * 'a_529 -> 'a_528)
	    -> 'a_529 PrimSequence.Slice.t -> 'a_528 vector = 
	 fn x_942: word64 * 'a_529 -> 'a_528 => 
	 let
	    val x_2835: 'a_529 PrimSequence.Slice.t -> 'a_528 vector = 
	       fn x_943: 'a_529 PrimSequence.Slice.t => 
	       let
		  val x_2836: 'a_528 vector = 
		     case x_943 of
		     T['a_529] x_2837: word64 * 'a_529 vector * word64 => 
			let
			   val x_2838: word64 = 
			      #2 x_2837
			   val x_2839: 'a_529 vector = 
			      #1 x_2837
			   val x_2840: word64 = 
			      #0 x_2837
			   val x_2841: word64 -> 'a_528 = 
			      fn x_944: word64 => 
			      let
				 val x_2842: word64 * word64 = 
				    (x_2838, x_944)
				 val x_2843: word64 = 
				    +? x_2842
				 val x_2844: 'a_529 vector * word64 = 
				    (x_2839, x_2843)
				 val x_2845: 'a_529 = 
				    subUnsafe_0 ('a_529) x_2844
				 val x_2846: word64 * 'a_529 = 
				    (x_944, x_2845)
				 val x_2847: 'a_528 = 
				    x_942 x_2846
			      in
				 x_2847
			      end
			   val x_2848: word64 * (word64 -> 'a_528) = 
			      (x_2840, x_2841)
			   val x_2849: 'a_528 vector = 
			      tabulate ('a_528) x_2848
			in
			   x_2849
			end
	       in
		  x_2836
	       end
	 in
	    x_2835
	 end
   val rec ('a_531, 'a_530) 
      map: ('a_530 -> 'a_531) -> 'a_530 PrimSequence.Slice.t -> 'a_531 vector = 
	 fn x_945: 'a_530 -> 'a_531 => 
	 let
	    val x_2850: 'a_530 PrimSequence.Slice.t -> 'a_531 vector = 
	       fn x_946: 'a_530 PrimSequence.Slice.t => 
	       let
		  val x_2851: word64 * 'a_530 -> 'a_530 = 
		     fn x_947: word64 * 'a_530 => 
		     let
			val x_2852: 'a_530 = 
			   #1 x_947
		     in
			x_2852
		     end
		  val x_2853: ('a_530 -> 'a_531) * (word64 * 'a_530 -> 'a_530) = 
		     (x_945, x_2851)
		  val x_2854: word64 * 'a_530 -> 'a_531 = 
		     o ('a_530, 'a_531, word64 * 'a_530) x_2853
		  val x_2855: 'a_530 PrimSequence.Slice.t -> 'a_531 vector = 
		     mapi ('a_530, 'a_531) x_2854
		  val x_2856: 'a_531 vector = 
		     x_2855 x_946
	       in
		  x_2856
	       end
	 in
	    x_2850
	 end
   val rec 'a_532 
      findi: (word64 * 'a_532 -> bool)
	     -> 'a_532 PrimSequence.Slice.t
		-> (word64 * 'a_532) Primitive.Option.t = 
	 fn x_948: word64 * 'a_532 -> bool => 
	 let
	    val x_2857: 'a_532 PrimSequence.Slice.t
			-> (word64 * 'a_532) Primitive.Option.t = 
	       fn x_949: 'a_532 PrimSequence.Slice.t => 
	       let
		  val x_2858: (word64 * 'a_532) Primitive.Option.t = 
		     case x_949 of
		     T['a_532] x_2859: word64 * 'a_532 vector * word64 => 
			let
			   val x_2860: word64 = 
			      #2 x_2859
			   val x_2861: 'a_532 vector = 
			      #1 x_2859
			   val x_2862: word64 = 
			      #0 x_2859
			   val x_2863: word64 = 
			      0x1
			   val x_2864: word64 * word64 = 
			      (x_2862, x_2863)
			   val len: word64 = 
			      -? x_2864
			   val x_2865: word64 * word64 = 
			      (x_2860, len)
			   val max: word64 = 
			      +? x_2865
			   val rec 
			      loop: word64
				    -> (word64 * 'a_532) Primitive.Option.t = 
				 fn x_950: word64 => 
				 let
				    val x_2866: word64 * word64 = 
				       (x_950, max)
				    val x_2867: bool = 
				       > x_2866
				    val x_2868: (word64 * 'a_532) Primitive.Option.t = 
				       case x_2867 of
				       true => 
					  let
					     val x_2880: (word64 * 'a_532) Primitive.Option.t = 
						NONE[word64 * 'a_532]
					  in
					     x_2880
					  end
				       false => 
					  let
					     val x_2869: word64 * word64 = 
						(x_950, x_2860)
					     val x_2870: word64 = 
						-? x_2869
					     val x_2871: 'a_532 vector * word64 = 
						(x_2861, x_950)
					     val x_2872: 'a_532 = 
						subUnsafe_0 ('a_532) x_2871
					     val z: word64 * 'a_532 = 
						(x_2870, x_2872)
					     val x_2873: bool = 
						x_948 z
					     val x_2874: (word64 * 'a_532) Primitive.Option.t = 
						case x_2873 of
						true => 
						   let
						      val x_2879: (word64
								   * 'a_532) Primitive.Option.t = 
							 SOME[word64 * 'a_532] z
						   in
						      x_2879
						   end
						false => 
						   let
						      val x_2875: word64 = 
							 0x1
						      val x_2876: word64
								  * word64 = 
							 (x_950, x_2875)
						      val x_2877: word64 = 
							 +? x_2876
						      val x_2878: (word64
								   * 'a_532) Primitive.Option.t = 
							 loop x_2877
						   in
						      x_2878
						   end
					  in
					     x_2874
					  end
				 in
				    x_2868
				 end
			   val x_2881: (word64 * 'a_532) Primitive.Option.t = 
			      loop x_2860
			in
			   x_2881
			end
	       in
		  x_2858
	       end
	 in
	    x_2857
	 end
   val rec 'a_534 
      existsi: (word64 * 'a_534 -> bool) -> 'a_534 PrimSequence.Slice.t -> bool = 
	 fn x_951: word64 * 'a_534 -> bool => 
	 let
	    val x_2882: 'a_534 PrimSequence.Slice.t -> bool = 
	       fn x_952: 'a_534 PrimSequence.Slice.t => 
	       let
		  val x_2883: 'a_534 PrimSequence.Slice.t
			      -> (word64 * 'a_534) Primitive.Option.t = 
		     findi ('a_534) x_951
		  val x_2884: (word64 * 'a_534) Primitive.Option.t = 
		     x_2883 x_952
		  val x_2885: bool = 
		     case x_2884 of
		     NONE[word64 * 'a_534] => 
			let
			   val x_2888: bool = 
			      false
			in
			   x_2888
			end
		     SOME[word64 * 'a_534] x_2886: word64 * 'a_534 => 
			let
			   val x_2887: bool = 
			      true
			in
			   x_2887
			end
	       in
		  x_2885
	       end
	 in
	    x_2882
	 end
   val rec 'a_535 
      exists: ('a_535 -> bool) -> 'a_535 PrimSequence.Slice.t -> bool = 
	 fn x_953: 'a_535 -> bool => 
	 let
	    val x_2889: 'a_535 PrimSequence.Slice.t -> bool = 
	       fn x_954: 'a_535 PrimSequence.Slice.t => 
	       let
		  val x_2890: word64 * 'a_535 -> 'a_535 = 
		     fn x_955: word64 * 'a_535 => 
		     let
			val x_2891: 'a_535 = 
			   #1 x_955
		     in
			x_2891
		     end
		  val x_2892: ('a_535 -> bool) * (word64 * 'a_535 -> 'a_535) = 
		     (x_953, x_2890)
		  val x_2893: word64 * 'a_535 -> bool = 
		     o ('a_535, bool, word64 * 'a_535) x_2892
		  val x_2894: 'a_535 PrimSequence.Slice.t -> bool = 
		     existsi ('a_535) x_2893
		  val x_2895: bool = 
		     x_2894 x_954
	       in
		  x_2895
	       end
	 in
	    x_2889
	 end
   val rec 'a 
      sequence: 'a PrimSequence.Slice.t -> 'a vector = 
	 fn x_956: 'a PrimSequence.Slice.t => 
	 let
	    val x_2896: 'a vector = 
	       case x_956 of
	       T['a] x_2897: word64 * 'a vector * word64 => 
		  let
		     val x_2898: word64 = 
			#2 x_2897
		     val x_2899: 'a vector = 
			#1 x_2897
		     val x_2900: word64 = 
			#0 x_2897
		     val x_2901: word64 = 
			0x0
		     val x_2902: word64 * word64 = 
			(x_2898, x_2901)
		     val x_2903: bool = 
			<> (word64) x_2902
		     val x_2904: bool = 
			case x_2903 of
			true => 
			   let
			      val x_2908: bool = 
				 true
			   in
			      x_2908
			   end
			false => 
			   let
			      val x_2905: word64 = 
				 length_0 ('a) x_2899
			      val x_2906: word64 * word64 = 
				 (x_2900, x_2905)
			      val x_2907: bool = 
				 <> (word64) x_2906
			   in
			      x_2907
			   end
		     val x_2909: 'a vector = 
			case x_2904 of
			true => 
			   let
			      val x_2910: 'a -> 'a = 
				 fn x_957: 'a => 
				 let
				 in
				    x_957
				 end
			      val x_2911: 'a PrimSequence.Slice.t -> 'a vector = 
				 map ('a, 'a) x_2910
			      val x_2912: 'a vector = 
				 x_2911 x_956
			   in
			      x_2912
			   end
			false => 
			   let
			   in
			      x_2899
			   end
		  in
		     x_2909
		  end
	 in
	    x_2896
	 end
   val rec 'a 
      append: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t -> 'a vector = 
	 fn x_958: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t => 
	 let
	    val sl2: 'a PrimSequence.Slice.t = 
	       #1 x_958
	    val sl1: 'a PrimSequence.Slice.t = 
	       #0 x_958
	    val x_2913: word64 = 
	       length ('a) sl1
	    val x_2914: word64 = 
	       0x0
	    val x_2915: word64 * word64 = 
	       (x_2913, x_2914)
	    val x_2916: bool = 
	       = (word64) x_2915
	    val x_2917: 'a vector = 
	       case x_2916 of
	       true => 
		  let
		     val x_2949: 'a vector = 
			sequence ('a) sl2
		  in
		     x_2949
		  end
	       false => 
		  let
		     val x_2918: word64 = 
			length ('a) sl2
		     val x_2919: word64 = 
			0x0
		     val x_2920: word64 * word64 = 
			(x_2918, x_2919)
		     val x_2921: bool = 
			= (word64) x_2920
		     val x_2922: 'a vector = 
			case x_2921 of
			true => 
			   let
			      val x_2948: 'a vector = 
				 sequence ('a) sl1
			   in
			      x_2948
			   end
			false => 
			   let
			      val l1: word64 = 
				 length ('a) sl1
			      val l2: word64 = 
				 length ('a) sl2
			      val x_2923: word64 * word64 = 
				 (l1, l2)
			      val n: word64 = 
				 +? x_2923
			      val x_2924: word64 = 
				 0x0
			      val x_2925: word64 * 'a PrimSequence.Slice.t = 
				 (x_2924, sl1)
			      val x_2926: word64
					  * (word64 * 'a PrimSequence.Slice.t)
					  -> 'a
					     * (word64 * 'a PrimSequence.Slice.t) = 
				 fn x_961: word64
					   * (word64 * 'a PrimSequence.Slice.t) => 
				 let
				    val x_2927: word64 * 'a PrimSequence.Slice.t = 
				       #1 x_961
				    val sl: 'a PrimSequence.Slice.t = 
				       #1 x_2927
				    val i: word64 = 
				       #0 x_2927
				    val x_2928: word64 = 
				       length ('a) sl
				    val x_2929: word64 * word64 = 
				       (i, x_2928)
				    val x_2930: bool = 
				       < x_2929
				    val x_2931: 'a
						* (word64
						   * 'a PrimSequence.Slice.t) = 
				       case x_2930 of
				       true => 
					  let
					     val x_2938: 'a PrimSequence.Slice.t
							 * word64 = 
						(sl, i)
					     val x_2939: 'a = 
						unsafeSub ('a) x_2938
					     val x_2940: word64 = 
						0x1
					     val x_2941: word64 * word64 = 
						(i, x_2940)
					     val x_2942: word64 = 
						+? x_2941
					     val x_2943: word64
							 * 'a PrimSequence.Slice.t = 
						(x_2942, sl)
					     val x_2944: 'a
							 * (word64
							    * 'a PrimSequence.Slice.t) = 
						(x_2939, x_2943)
					  in
					     x_2944
					  end
				       false => 
					  let
					     val x_2932: word64 = 
						0x0
					     val x_2933: 'a PrimSequence.Slice.t
							 * word64 = 
						(sl2, x_2932)
					     val x_2934: 'a = 
						unsafeSub ('a) x_2933
					     val x_2935: word64 = 
						0x1
					     val x_2936: word64
							 * 'a PrimSequence.Slice.t = 
						(x_2935, sl2)
					     val x_2937: 'a
							 * (word64
							    * 'a PrimSequence.Slice.t) = 
						(x_2934, x_2936)
					  in
					     x_2937
					  end
				 in
				    x_2931
				 end
			      val x_2945: word64
					  * (word64 * 'a PrimSequence.Slice.t)
					  * (word64
					     * (word64 * 'a PrimSequence.Slice.t)
					     -> 'a
						* (word64
						   * 'a PrimSequence.Slice.t)) = 
				 (n, x_2925, x_2926)
			      val x_2946: 'a vector
					  * (word64 * 'a PrimSequence.Slice.t) = 
				 unfoldi (word64 * 'a PrimSequence.Slice.t, 'a) x_2945
			      val x_2947: 'a vector = 
				 #0 x_2946
			   in
			      x_2947
			   end
		  in
		     x_2922
		  end
	 in
	    x_2917
	 end
   val rec 'a_540 
      split: 'a_540 PrimSequence.Slice.t * word64
	     -> 'a_540 PrimSequence.Slice.t * 'a_540 PrimSequence.Slice.t = 
	 fn x_962: 'a_540 PrimSequence.Slice.t * word64 => 
	 let
	    val x_2950: word64 = 
	       #1 x_962
	    val x_2951: 'a_540 PrimSequence.Slice.t = 
	       #0 x_962
	    val x_2952: 'a_540 PrimSequence.Slice.t
			* 'a_540 PrimSequence.Slice.t = 
	       case x_2951 of
	       T['a_540] x_2953: word64 * 'a_540 vector * word64 => 
		  let
		     val x_2954: word64 = 
			#2 x_2953
		     val x_2955: 'a_540 vector = 
			#1 x_2953
		     val x_2956: word64 = 
			#0 x_2953
		     val x_2957: word64 * word64 = 
			(x_2950, x_2954)
		     val x_2958: word64 = 
			-? x_2957
		     val x_2959: word64 Primitive.Option.t = 
			SOME[word64] x_2958
		     val x_2960: 'a_540 vector
				 * word64
				 * word64 Primitive.Option.t = 
			(x_2955, x_2954, x_2959)
		     val x_2961: 'a_540 PrimSequence.Slice.t = 
			unsafeSlice ('a_540) x_2960
		     val x_2962: word64 * word64 = 
			(x_2950, x_2954)
		     val x_2963: word64 = 
			-? x_2962
		     val x_2964: word64 * word64 = 
			(x_2956, x_2963)
		     val x_2965: word64 = 
			-? x_2964
		     val x_2966: word64 Primitive.Option.t = 
			SOME[word64] x_2965
		     val x_2967: 'a_540 vector
				 * word64
				 * word64 Primitive.Option.t = 
			(x_2955, x_2950, x_2966)
		     val x_2968: 'a_540 PrimSequence.Slice.t = 
			unsafeSlice ('a_540) x_2967
		     val x_2969: 'a_540 PrimSequence.Slice.t
				 * 'a_540 PrimSequence.Slice.t = 
			(x_2961, x_2968)
		  in
		     x_2969
		  end
	 in
	    x_2952
	 end
   val rec 'a_541 
      splitl: ('a_541 -> bool)
	      -> 'a_541 PrimSequence.Slice.t
		 -> 'a_541 PrimSequence.Slice.t * 'a_541 PrimSequence.Slice.t = 
	 fn x_963: 'a_541 -> bool => 
	 let
	    val x_2970: 'a_541 PrimSequence.Slice.t
			-> 'a_541 PrimSequence.Slice.t
			   * 'a_541 PrimSequence.Slice.t = 
	       fn x_964: 'a_541 PrimSequence.Slice.t => 
	       let
		  val x_2971: 'a_541 PrimSequence.Slice.t
			      * 'a_541 PrimSequence.Slice.t = 
		     case x_964 of
		     T['a_541] x_2972: word64 * 'a_541 vector * word64 => 
			let
			   val x_2973: word64 = 
			      #2 x_2972
			   val x_2974: 'a_541 vector = 
			      #1 x_2972
			   val x_2975: word64 = 
			      #0 x_2972
			   val x_2976: word64 * word64 = 
			      (x_2973, x_2975)
			   val stop: word64 = 
			      +? x_2976
			   val rec 
			      loop: word64 -> word64 = 
				 fn x_965: word64 => 
				 let
				    val x_2977: word64 * word64 = 
				       (x_965, stop)
				    val x_2978: bool = 
				       >= x_2977
				    val x_2979: word64 = 
				       case x_2978 of
				       true => 
					  let
					  in
					     x_965
					  end
				       false => 
					  let
					     val x_2980: 'a_541 vector * word64 = 
						(x_2974, x_965)
					     val x_2981: 'a_541 = 
						subUnsafe_0 ('a_541) x_2980
					     val x_2982: bool = 
						x_963 x_2981
					     val x_2983: word64 = 
						case x_2982 of
						true => 
						   let
						      val x_2984: word64 = 
							 0x1
						      val x_2985: word64
								  * word64 = 
							 (x_965, x_2984)
						      val x_2986: word64 = 
							 +? x_2985
						      val x_2987: word64 = 
							 loop x_2986
						   in
						      x_2987
						   end
						false => 
						   let
						   in
						      x_965
						   end
					  in
					     x_2983
					  end
				 in
				    x_2979
				 end
			   val x_2988: word64 = 
			      loop x_2973
			   val x_2989: 'a_541 PrimSequence.Slice.t * word64 = 
			      (x_964, x_2988)
			   val x_2990: 'a_541 PrimSequence.Slice.t
				       * 'a_541 PrimSequence.Slice.t = 
			      split ('a_541) x_2989
			in
			   x_2990
			end
	       in
		  x_2971
	       end
	 in
	    x_2970
	 end
   val rec 'a_542 
      splitr: ('a_542 -> bool)
	      -> 'a_542 PrimSequence.Slice.t
		 -> 'a_542 PrimSequence.Slice.t * 'a_542 PrimSequence.Slice.t = 
	 fn x_966: 'a_542 -> bool => 
	 let
	    val x_2991: 'a_542 PrimSequence.Slice.t
			-> 'a_542 PrimSequence.Slice.t
			   * 'a_542 PrimSequence.Slice.t = 
	       fn x_967: 'a_542 PrimSequence.Slice.t => 
	       let
		  val x_2992: 'a_542 PrimSequence.Slice.t
			      * 'a_542 PrimSequence.Slice.t = 
		     case x_967 of
		     T['a_542] x_2993: word64 * 'a_542 vector * word64 => 
			let
			   val x_2994: word64 = 
			      #2 x_2993
			   val x_2995: 'a_542 vector = 
			      #1 x_2993
			   val x_2996: word64 = 
			      #0 x_2993
			   val rec 
			      loop: word64 -> word64 = 
				 fn x_968: word64 => 
				 let
				    val x_2997: word64 * word64 = 
				       (x_968, x_2994)
				    val x_2998: bool = 
				       < x_2997
				    val x_2999: word64 = 
				       case x_2998 of
				       true => 
					  let
					  in
					     x_2994
					  end
				       false => 
					  let
					     val x_3000: 'a_542 vector * word64 = 
						(x_2995, x_968)
					     val x_3001: 'a_542 = 
						subUnsafe_0 ('a_542) x_3000
					     val x_3002: bool = 
						x_966 x_3001
					     val x_3003: word64 = 
						case x_3002 of
						true => 
						   let
						      val x_3007: word64 = 
							 0x1
						      val x_3008: word64
								  * word64 = 
							 (x_968, x_3007)
						      val x_3009: word64 = 
							 -? x_3008
						      val x_3010: word64 = 
							 loop x_3009
						   in
						      x_3010
						   end
						false => 
						   let
						      val x_3004: word64 = 
							 0x1
						      val x_3005: word64
								  * word64 = 
							 (x_968, x_3004)
						      val x_3006: word64 = 
							 +? x_3005
						   in
						      x_3006
						   end
					  in
					     x_3003
					  end
				 in
				    x_2999
				 end
			   val x_3011: word64 * word64 = 
			      (x_2994, x_2996)
			   val x_3012: word64 = 
			      +? x_3011
			   val x_3013: word64 = 
			      0x1
			   val x_3014: word64 * word64 = 
			      (x_3012, x_3013)
			   val x_3015: word64 = 
			      -? x_3014
			   val x_3016: word64 = 
			      loop x_3015
			   val x_3017: 'a_542 PrimSequence.Slice.t * word64 = 
			      (x_967, x_3016)
			   val x_3018: 'a_542 PrimSequence.Slice.t
				       * 'a_542 PrimSequence.Slice.t = 
			      split ('a_542) x_3017
			in
			   x_3018
			end
	       in
		  x_2992
	       end
	 in
	    x_2991
	 end
   val rec 'a_545 
      dropr: ('a_545 -> bool)
	     -> 'a_545 PrimSequence.Slice.t -> 'a_545 PrimSequence.Slice.t = 
	 fn x_969: 'a_545 -> bool => 
	 let
	    val x_3019: 'a_545 PrimSequence.Slice.t
			-> 'a_545 PrimSequence.Slice.t = 
	       fn x_970: 'a_545 PrimSequence.Slice.t => 
	       let
		  val x_3020: 'a_545 PrimSequence.Slice.t
			      -> 'a_545 PrimSequence.Slice.t
				 * 'a_545 PrimSequence.Slice.t = 
		     splitr ('a_545) x_969
		  val x_3021: 'a_545 PrimSequence.Slice.t
			      * 'a_545 PrimSequence.Slice.t = 
		     x_3020 x_970
		  val x_3022: 'a_545 PrimSequence.Slice.t = 
		     #0 x_3021
	       in
		  x_3022
	       end
	 in
	    x_3019
	 end
   val rec 'a_546 
      takel: ('a_546 -> bool)
	     -> 'a_546 PrimSequence.Slice.t -> 'a_546 PrimSequence.Slice.t = 
	 fn x_972: 'a_546 -> bool => 
	 let
	    val x_3023: 'a_546 PrimSequence.Slice.t
			-> 'a_546 PrimSequence.Slice.t = 
	       fn x_973: 'a_546 PrimSequence.Slice.t => 
	       let
		  val x_3024: 'a_546 PrimSequence.Slice.t
			      -> 'a_546 PrimSequence.Slice.t
				 * 'a_546 PrimSequence.Slice.t = 
		     splitl ('a_546) x_972
		  val x_3025: 'a_546 PrimSequence.Slice.t
			      * 'a_546 PrimSequence.Slice.t = 
		     x_3024 x_973
		  val x_3026: 'a_546 PrimSequence.Slice.t = 
		     #0 x_3025
	       in
		  x_3026
	       end
	 in
	    x_3023
	 end
   val rec 'a_547 
      taker: ('a_547 -> bool)
	     -> 'a_547 PrimSequence.Slice.t -> 'a_547 PrimSequence.Slice.t = 
	 fn x_975: 'a_547 -> bool => 
	 let
	    val x_3027: 'a_547 PrimSequence.Slice.t
			-> 'a_547 PrimSequence.Slice.t = 
	       fn x_976: 'a_547 PrimSequence.Slice.t => 
	       let
		  val x_3028: 'a_547 PrimSequence.Slice.t
			      -> 'a_547 PrimSequence.Slice.t
				 * 'a_547 PrimSequence.Slice.t = 
		     splitr ('a_547) x_975
		  val x_3029: 'a_547 PrimSequence.Slice.t
			      * 'a_547 PrimSequence.Slice.t = 
		     x_3028 x_976
		  val x_3030: 'a_547 PrimSequence.Slice.t = 
		     #1 x_3029
	       in
		  x_3030
	       end
	 in
	    x_3027
	 end
   val rec 'a_554 
      unsafeSub: 'a_554 vector * word64 -> 'a_554 = 
	 fn x_978: 'a_554 vector * word64 => 
	 let
	    val i: word64 = 
	       #1 x_978
	    val seq: 'a_554 vector = 
	       #0 x_978
	    val x_3031: 'a_554 PrimSequence.Slice.t = 
	       full ('a_554) seq
	    val x_3032: 'a_554 PrimSequence.Slice.t * word64 = 
	       (x_3031, i)
	    val x_3033: 'a_554 = 
	       unsafeSub ('a_554) x_3032
	 in
	    x_3033
	 end
   val 'a unsafeSub_0: 'a vector * word64 -> 'a = 
      let
      in
	 unsafeSub ('a)
      end
   val ('a, 'b) unfoldi_0: word64 * 'b * (word64 * 'b -> 'a * 'b)
			   -> 'a vector * 'b = 
      let
      in
	 unfoldi ('b, 'a)
      end
   val ('a, 'b) unfold_0: word64 * 'b * ('b -> 'a * 'b) -> 'a vector * 'b = 
      let
      in
	 unfold ('a, 'b)
      end
   val 'a tabulate_0: word64 * (word64 -> 'a) -> 'a vector = 
      let
      in
	 tabulate ('a)
      end
   val 'a unsafeSubslice_0: 'a PrimSequence.Slice.t
			    * word64
			    * word64 Primitive.Option.t
			    -> 'a PrimSequence.Slice.t = 
      let
      in
	 unsafeSubslice ('a)
      end
   val 'a unsafeSub_1: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 unsafeSub ('a)
      end
   val 'a taker_0: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 taker ('a)
      end
   val 'a takel_0: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 takel ('a)
      end
   val 'a subslice_0: 'a PrimSequence.Slice.t
		      * word64
		      * word64 Primitive.Option.t
		      -> 'a PrimSequence.Slice.t = 
      let
      in
	 subslice ('a)
      end
   val 'a sub_0: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a sequence_0: 'a PrimSequence.Slice.t -> 'a vector = 
      let
      in
	 sequence ('a)
      end
   val 'a length_1: 'a PrimSequence.Slice.t -> word64 = 
      let
      in
	 length ('a)
      end
   val 'a full_0: 'a vector -> 'a PrimSequence.Slice.t = 
      let
      in
	 full ('a)
      end
   val ('b, 'a) foldl_0: ('a * 'b -> 'b) -> 'b -> 'a PrimSequence.Slice.t -> 'b = 
      let
      in
	 foldl ('a, 'b)
      end
   val 'a exists_0: ('a -> bool) -> 'a PrimSequence.Slice.t -> bool = 
      let
      in
	 exists ('a)
      end
   val 'a dropr_0: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 dropr ('a)
      end
   val 'a base_0: 'a PrimSequence.Slice.t -> 'a vector * word64 * word64 = 
      let
      in
	 base ('a)
      end
   val 'a append_0: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t
		    -> 'a vector = 
      let
      in
	 append ('a)
      end
   val 'a_597 fromArray: 'a_597 -> 'a_597 = 
      let
	 val x_3034: 'a_597 -> 'a_597 = 
	    fn x_979: 'a_597 => 
	    let
	    in
	       x_979
	    end
      in
	 x_3034
      end
   val isMutable: bool = 
      true
   val 'a_598 length: 'a_598 array -> word64 = 
      let
      in
	 length ('a_598)
      end
   val 'a_599 subUnsafe: 'a_599 array * word64 -> 'a_599 = 
      let
      in
	 subUnsafe ('a_599)
      end
   val 'a subUnsafe_1: 'a array * word64 -> 'a = 
      let
      in
	 subUnsafe ('a)
      end
   val 'a length_2: 'a array -> word64 = 
      let
      in
	 length ('a)
      end
   val 'a fromArray_1: 'a array -> 'a array = 
      let
      in
	 fromArray ('a array)
      end
   val rec ('a_608, 'a_607, 'a_606) 
      o: ('a_608 -> 'a_607) * ('a_606 -> 'a_608) -> 'a_606 -> 'a_607 = 
	 fn x_980: ('a_608 -> 'a_607) * ('a_606 -> 'a_608) => 
	 let
	    val x_3035: 'a_606 -> 'a_607 = 
	       fn x_981: 'a_606 => 
	       let
		  val x_3036: 'a_606 -> 'a_608 = 
		     #1 x_980
		  val x_3037: 'a_608 -> 'a_607 = 
		     #0 x_980
		  val x_3038: 'a_608 = 
		     x_3036 x_981
		  val x_3039: 'a_607 = 
		     x_3037 x_3038
	       in
		  x_3039
	       end
	 in
	    x_3035
	 end
   val rec 
      valOf: word32 Primitive.Option.t -> word32 = 
	 fn x_982: word32 Primitive.Option.t => 
	 let
	    val x_3040: word32 = 
	       case x_982 of
	       SOME[word32] x_3042: word32 => 
		  let
		  in
		     x_3042
		  end
	       NONE[word32] => 
		  let
		     val x_3041: word32 = 
			0x0
		  in
		     x_3041
		  end
	 in
	    x_3040
	 end
   val rec 'a_609 
      doit: word32 * ('a_609 -> word64) * 'a_609 -> word64 = 
	 fn x_983: word32 * ('a_609 -> word64) * 'a_609 => 
	 let
	    val maxInt': 'a_609 = 
	       #2 x_983
	    val fromInt: 'a_609 -> word64 = 
	       #1 x_983
	    val precision: word32 = 
	       #0 x_983
	    val x_3043: word32 = 
	       valOf precision
	    val x_3044: word32 * word32 = 
	       (x_3043, precision)
	    val x_3045: bool = 
	       >= x_3044
	    val x_3046: word64 = 
	       case x_3045 of
	       true => 
		  let
		     val x_3047: word64 = 
			fromInt maxInt'
		  in
		     x_3047
		  end
	       false => 
		  let
		  in
		     maxInt'
		  end
	 in
	    x_3046
	 end
   val x_3048: word32 = 
      valOf precision
   val x_3049: word32 * (word8 -> word64) * word8 = 
      (x_3048, sextdFromInt8ToInt64, maxInt')
   val fInt8: word64 = 
      doit (word8) x_3049
   val x_3050: word32 = 
      valOf precision
   val x_3051: word32 * (word16 -> word64) * word16 = 
      (x_3050, sextdFromInt16ToInt64, maxInt')
   val fInt16: word64 = 
      doit (word16) x_3051
   val x_3052: word32 = 
      valOf precision
   val x_3053: word32 * (word32 -> word64) * word32 = 
      (x_3052, sextdFromInt32ToInt64, maxInt')
   val fInt32: word64 = 
      doit (word32) x_3053
   val x_3054: word32 = 
      valOf precision
   val x_3055: word32 * (word64 -> word64) * word64 = 
      (x_3054, sextdFromInt64ToInt64, maxInt')
   val fInt64: word64 = 
      doit (word64) x_3055
   val rec 'a_613 
      arrayUninit: word64 -> 'a_613 array = 
	 fn x_984: word64 => 
	 let
	    val x_3056: bool = 
	       not isMutable
	    val x_3057: bool = 
	       case x_3056 of
	       true => 
		  let
		     val x_3059: word64 = 
			0x0
		     val x_3060: word64 * word64 = 
			(x_984, x_3059)
		     val x_3061: bool = 
			= (word64) x_3060
		  in
		     x_3061
		  end
	       false => 
		  let
		     val x_3058: bool = 
			false
		  in
		     x_3058
		  end
	    val x_3062: 'a_613 array = 
	       case x_3057 of
	       true => 
		  let
		     val x_3069: unit = 
			()
		     val x_3070: 'a_613 array = 
			array0Const ('a_613) x_3069
		  in
		     x_3070
		  end
	       false => 
		  let
		     val x_3063: word64 * word64 = 
			(x_984, fInt32)
		     val x_3064: bool = 
			> x_3063
		     val x_3065: 'a_613 array = 
			case x_3064 of
			true => 
			   let
			      val x_3067: exn = 
				 Size
			      val x_3068: 'a_613 array = 
				 raise x_3067
			   in
			      x_3068
			   end
			false => 
			   let
			      val x_3066: 'a_613 array = 
				 arrayUnsafe ('a_613) x_984
			   in
			      x_3066
			   end
		  in
		     x_3065
		  end
	 in
	    x_3062
	 end
   val rec 'a_614 
      newUninit: word64 -> 'a_614 array = 
	 fn x_985: word64 => 
	 let
	    val x_3071: 'a_614 array = 
	       arrayUninit ('a_614) x_985
	    val x_3072: 'a_614 array = 
	       fromArray_1 ('a_614) x_3071
	 in
	    x_3072
	 end
   exception GenerateAlreadyGotVector
   exception GenerateVectorNotFull
   val rec ('a_617, 'a_616) 
      unfoldi: word64 * 'a_617 * (word64 * 'a_617 -> 'a_616 * 'a_617)
	       -> 'a_616 array * 'a_617 = 
	 fn x_986: word64 * 'a_617 * (word64 * 'a_617 -> 'a_616 * 'a_617) => 
	 let
	    val f: word64 * 'a_617 -> 'a_616 * 'a_617 = 
	       #2 x_986
	    val b: 'a_617 = 
	       #1 x_986
	    val n: word64 = 
	       #0 x_986
	    val a: 'a_616 array = 
	       arrayUninit ('a_616) n
	    val rec 
	       loop: word64 * 'a_617 -> 'a_617 = 
		  fn x_987: word64 * 'a_617 => 
		  let
		     val b: 'a_617 = 
			#1 x_987
		     val i: word64 = 
			#0 x_987
		     val x_3073: word64 * word64 = 
			(i, n)
		     val x_3074: bool = 
			>= x_3073
		     val x_3075: 'a_617 = 
			case x_3074 of
			true => 
			   let
			   in
			      b
			   end
			false => 
			   let
			      val x_3076: word64 * 'a_617 = 
				 (i, b)
			      val x_3077: 'a_616 * 'a_617 = 
				 f x_3076
			      val b: 'a_617 = 
				 #1 x_3077
			      val x: 'a_616 = 
				 #0 x_3077
			      val x_3078: 'a_616 array * word64 * 'a_616 = 
				 (a, i, x)
			      val x_3079: unit = 
				 updateUnsafe ('a_616) x_3078
			      val x_3080: word64 = 
				 0x1
			      val x_3081: word64 * word64 = 
				 (i, x_3080)
			      val x_3082: word64 = 
				 +? x_3081
			      val x_3083: word64 * 'a_617 = 
				 (x_3082, b)
			      val x_3084: 'a_617 = 
				 loop x_3083
			   in
			      x_3084
			   end
		  in
		     x_3075
		  end
	    val x_3085: word64 = 
	       0x0
	    val x_3086: word64 * 'a_617 = 
	       (x_3085, b)
	    val b: 'a_617 = 
	       loop x_3086
	    val x_3087: 'a_616 array = 
	       fromArray_1 ('a_616) a
	    val x_3088: 'a_616 array * 'a_617 = 
	       (x_3087, b)
	 in
	    x_3088
	 end
   val rec ('a_619, 'a_618) 
      unfold: word64 * 'a_618 * ('a_618 -> 'a_619 * 'a_618)
	      -> 'a_619 array * 'a_618 = 
	 fn x_988: word64 * 'a_618 * ('a_618 -> 'a_619 * 'a_618) => 
	 let
	    val f: 'a_618 -> 'a_619 * 'a_618 = 
	       #2 x_988
	    val b: 'a_618 = 
	       #1 x_988
	    val n: word64 = 
	       #0 x_988
	    val x_3089: word64 * 'a_618 -> 'a_618 = 
	       fn x_989: word64 * 'a_618 => 
	       let
		  val x_3090: 'a_618 = 
		     #1 x_989
	       in
		  x_3090
	       end
	    val x_3091: ('a_618 -> 'a_619 * 'a_618)
			* (word64 * 'a_618 -> 'a_618) = 
	       (f, x_3089)
	    val x_3092: word64 * 'a_618 -> 'a_619 * 'a_618 = 
	       o ('a_618, 'a_619 * 'a_618, word64 * 'a_618) x_3091
	    val x_3093: word64 * 'a_618 * (word64 * 'a_618 -> 'a_619 * 'a_618) = 
	       (n, b, x_3092)
	    val x_3094: 'a_619 array * 'a_618 = 
	       unfoldi ('a_618, 'a_619) x_3093
	 in
	    x_3094
	 end
   val rec 'a_622 
      length: 'a_622 PrimSequence.Slice.t -> word64 = 
	 fn x_990: 'a_622 PrimSequence.Slice.t => 
	 let
	    val x_3095: word64 = 
	       case x_990 of
	       T['a_622] x_3096: word64 * 'a_622 array * word64 => 
		  let
		     val x_3097: word64 = 
			#0 x_3096
		  in
		     x_3097
		  end
	 in
	    x_3095
	 end
   val rec 'a_623 
      unsafeSub: 'a_623 PrimSequence.Slice.t * word64 -> 'a_623 = 
	 fn x_991: 'a_623 PrimSequence.Slice.t * word64 => 
	 let
	    val x_3098: word64 = 
	       #1 x_991
	    val x_3099: 'a_623 PrimSequence.Slice.t = 
	       #0 x_991
	    val x_3100: 'a_623 = 
	       case x_3099 of
	       T['a_623] x_3101: word64 * 'a_623 array * word64 => 
		  let
		     val x_3102: word64 = 
			#2 x_3101
		     val x_3103: 'a_623 array = 
			#1 x_3101
		     val x_3104: word64 * word64 = 
			(x_3102, x_3098)
		     val x_3105: word64 = 
			+? x_3104
		     val x_3106: 'a_623 array * word64 = 
			(x_3103, x_3105)
		     val x_3107: 'a_623 = 
			subUnsafe_1 ('a_623) x_3106
		  in
		     x_3107
		  end
	 in
	    x_3100
	 end
   val rec 'a_624 
      sub: 'a_624 PrimSequence.Slice.t * word64 -> 'a_624 = 
	 fn x_992: 'a_624 PrimSequence.Slice.t * word64 => 
	 let
	    val x_3108: word64 = 
	       #1 x_992
	    val x_3109: 'a_624 PrimSequence.Slice.t = 
	       #0 x_992
	    val x_3110: 'a_624 = 
	       case x_3109 of
	       T['a_624] x_3111: word64 * 'a_624 array * word64 => 
		  let
		     val x_3112: word64 = 
			#0 x_3111
		     val x_3113: word64 * word64 = 
			(x_3108, x_3112)
		     val x_3114: bool = 
			>= x_3113
		     val x_3115: 'a_624 = 
			case x_3114 of
			true => 
			   let
			      val x_3118: exn = 
				 Subscript
			      val x_3119: 'a_624 = 
				 raise x_3118
			   in
			      x_3119
			   end
			false => 
			   let
			      val x_3116: 'a_624 PrimSequence.Slice.t * word64 = 
				 (x_3109, x_3108)
			      val x_3117: 'a_624 = 
				 unsafeSub ('a_624) x_3116
			   in
			      x_3117
			   end
		  in
		     x_3115
		  end
	 in
	    x_3110
	 end
   val rec ('a_627, 'a_626, 'a_625) 
      unsafeUpdateMk: ('a_627 array * word64 * 'a_626 -> 'a_625)
		      -> 'a_627 PrimSequence.Slice.t * word64 * 'a_626 -> 'a_625 = 
	 fn x_993: 'a_627 array * word64 * 'a_626 -> 'a_625 => 
	 let
	    val x_3120: 'a_627 PrimSequence.Slice.t * word64 * 'a_626 -> 'a_625 = 
	       fn x_994: 'a_627 PrimSequence.Slice.t * word64 * 'a_626 => 
	       let
		  val x_3121: 'a_626 = 
		     #2 x_994
		  val x_3122: word64 = 
		     #1 x_994
		  val x_3123: 'a_627 PrimSequence.Slice.t = 
		     #0 x_994
		  val x_3124: 'a_625 = 
		     case x_3123 of
		     T['a_627] x_3125: word64 * 'a_627 array * word64 => 
			let
			   val x_3126: word64 = 
			      #2 x_3125
			   val x_3127: 'a_627 array = 
			      #1 x_3125
			   val x_3128: word64 * word64 = 
			      (x_3126, x_3122)
			   val x_3129: word64 = 
			      +? x_3128
			   val x_3130: 'a_627 array * word64 * 'a_626 = 
			      (x_3127, x_3129, x_3121)
			   val x_3131: 'a_625 = 
			      x_993 x_3130
			in
			   x_3131
			end
	       in
		  x_3124
	       end
	 in
	    x_3120
	 end
   val rec ('a_630, 'a_629, 'a_628) 
      updateMk: ('a_630 array * word64 * 'a_629 -> 'a_628)
		-> 'a_630 PrimSequence.Slice.t * word64 * 'a_629 -> 'a_628 = 
	 fn x_995: 'a_630 array * word64 * 'a_629 -> 'a_628 => 
	 let
	    val x_3132: 'a_630 PrimSequence.Slice.t * word64 * 'a_629 -> 'a_628 = 
	       fn x_996: 'a_630 PrimSequence.Slice.t * word64 * 'a_629 => 
	       let
		  val x_3133: 'a_629 = 
		     #2 x_996
		  val x_3134: word64 = 
		     #1 x_996
		  val x_3135: 'a_630 PrimSequence.Slice.t = 
		     #0 x_996
		  val x_3136: 'a_628 = 
		     case x_3135 of
		     T['a_630] x_3137: word64 * 'a_630 array * word64 => 
			let
			   val x_3138: word64 = 
			      #0 x_3137
			   val x_3139: word64 * word64 = 
			      (x_3134, x_3138)
			   val x_3140: bool = 
			      >= x_3139
			   val x_3141: 'a_628 = 
			      case x_3140 of
			      true => 
				 let
				    val x_3145: exn = 
				       Subscript
				    val x_3146: 'a_628 = 
				       raise x_3145
				 in
				    x_3146
				 end
			      false => 
				 let
				    val x_3142: 'a_630 PrimSequence.Slice.t
						* word64
						* 'a_629
						-> 'a_628 = 
				       unsafeUpdateMk ('a_630, 'a_629, 'a_628) x_995
				    val x_3143: 'a_630 PrimSequence.Slice.t
						* word64
						* 'a_629 = 
				       (x_3135, x_3134, x_3133)
				    val x_3144: 'a_628 = 
				       x_3142 x_3143
				 in
				    x_3144
				 end
			in
			   x_3141
			end
	       in
		  x_3136
	       end
	 in
	    x_3132
	 end
   val rec 'a 
      full: 'a array -> 'a PrimSequence.Slice.t = 
	 fn x_997: 'a array => 
	 let
	    val x_3147: word64 = 
	       0x0
	    val x_3148: word64 = 
	       length_2 ('a) x_997
	    val x_3149: word64 * 'a array * word64 = 
	       (x_3148, x_997, x_3147)
	    val x_3150: 'a PrimSequence.Slice.t = 
	       T['a] x_3149
	 in
	    x_3150
	 end
   val rec 'a_631 
      unsafeSubslice: 'a_631 PrimSequence.Slice.t
		      * word64
		      * word64 Primitive.Option.t
		      -> 'a_631 PrimSequence.Slice.t = 
	 fn x_998: 'a_631 PrimSequence.Slice.t
		   * word64
		   * word64 Primitive.Option.t => 
	 let
	    val x_3151: word64 Primitive.Option.t = 
	       #2 x_998
	    val x_3152: word64 = 
	       #1 x_998
	    val x_3153: 'a_631 PrimSequence.Slice.t = 
	       #0 x_998
	    val x_3154: 'a_631 PrimSequence.Slice.t = 
	       case x_3153 of
	       T['a_631] x_3155: word64 * 'a_631 array * word64 => 
		  let
		     val x_3156: word64 = 
			#2 x_3155
		     val x_3157: 'a_631 array = 
			#1 x_3155
		     val x_3158: word64 = 
			#0 x_3155
		     val x_3159: word64 * word64 = 
			(x_3156, x_3152)
		     val x_3160: word64 = 
			+? x_3159
		     val x_3161: word64 = 
			case x_3151 of
			NONE[word64] => 
			   let
			      val x_3163: word64 * word64 = 
				 (x_3158, x_3152)
			      val x_3164: word64 = 
				 -? x_3163
			   in
			      x_3164
			   end
			SOME[word64] x_3162: word64 => 
			   let
			   in
			      x_3162
			   end
		     val x_3165: word64 * 'a_631 array * word64 = 
			(x_3161, x_3157, x_3160)
		     val x_3166: 'a_631 PrimSequence.Slice.t = 
			T['a_631] x_3165
		  in
		     x_3166
		  end
	 in
	    x_3154
	 end
   val rec 'a_633 
      subslice: 'a_633 PrimSequence.Slice.t * word64 * word64 Primitive.Option.t
		-> 'a_633 PrimSequence.Slice.t = 
	 fn x_999: 'a_633 PrimSequence.Slice.t
		   * word64
		   * word64 Primitive.Option.t => 
	 let
	    val x_3167: word64 Primitive.Option.t = 
	       #2 x_999
	    val x_3168: word64 = 
	       #1 x_999
	    val x_3169: 'a_633 PrimSequence.Slice.t = 
	       #0 x_999
	    val x_3170: 'a_633 PrimSequence.Slice.t = 
	       case x_3169 of
	       T['a_633] x_3171: word64 * 'a_633 array * word64 => 
		  let
		     val x_3172: word64 = 
			#2 x_3171
		     val x_3173: 'a_633 array = 
			#1 x_3171
		     val x_3174: word64 = 
			#0 x_3171
		     val x_3175: 'a_633 PrimSequence.Slice.t = 
			case x_3167 of
			NONE[word64] => 
			   let
			      val x_3192: word64 * word64 = 
				 (x_3168, x_3174)
			      val x_3193: bool = 
				 > x_3192
			      val x_3194: 'a_633 PrimSequence.Slice.t = 
				 case x_3193 of
				 true => 
				    let
				       val x_3201: exn = 
					  Subscript
				       val x_3202: 'a_633 PrimSequence.Slice.t = 
					  raise x_3201
				    in
				       x_3202
				    end
				 false => 
				    let
				       val x_3195: word64 * word64 = 
					  (x_3172, x_3168)
				       val x_3196: word64 = 
					  +? x_3195
				       val x_3197: word64 * word64 = 
					  (x_3174, x_3168)
				       val x_3198: word64 = 
					  -? x_3197
				       val x_3199: word64
						   * 'a_633 array
						   * word64 = 
					  (x_3198, x_3173, x_3196)
				       val x_3200: 'a_633 PrimSequence.Slice.t = 
					  T['a_633] x_3199
				    in
				       x_3200
				    end
			   in
			      x_3194
			   end
			SOME[word64] x_3176: word64 => 
			   let
			      val x_3177: word64 * word64 = 
				 (x_3168, x_3174)
			      val x_3178: bool = 
				 > x_3177
			      val x_3179: bool = 
				 case x_3178 of
				 true => 
				    let
				       val x_3184: bool = 
					  true
				    in
				       x_3184
				    end
				 false => 
				    let
				       val x_3180: word64 * word64 = 
					  (x_3174, x_3168)
				       val x_3181: word64 = 
					  -? x_3180
				       val x_3182: word64 * word64 = 
					  (x_3176, x_3181)
				       val x_3183: bool = 
					  > x_3182
				    in
				       x_3183
				    end
			      val x_3185: 'a_633 PrimSequence.Slice.t = 
				 case x_3179 of
				 true => 
				    let
				       val x_3190: exn = 
					  Subscript
				       val x_3191: 'a_633 PrimSequence.Slice.t = 
					  raise x_3190
				    in
				       x_3191
				    end
				 false => 
				    let
				       val x_3186: word64 * word64 = 
					  (x_3172, x_3168)
				       val x_3187: word64 = 
					  +? x_3186
				       val x_3188: word64
						   * 'a_633 array
						   * word64 = 
					  (x_3176, x_3173, x_3187)
				       val x_3189: 'a_633 PrimSequence.Slice.t = 
					  T['a_633] x_3188
				    in
				       x_3189
				    end
			   in
			      x_3185
			   end
		  in
		     x_3175
		  end
	 in
	    x_3170
	 end
   val rec 'a 
      slice: 'a array * word64 * word64 Primitive.Option.t
	     -> 'a PrimSequence.Slice.t = 
	 fn x_1000: 'a array * word64 * word64 Primitive.Option.t => 
	 let
	    val len: word64 Primitive.Option.t = 
	       #2 x_1000
	    val start: word64 = 
	       #1 x_1000
	    val seq: 'a array = 
	       #0 x_1000
	    val x_3203: 'a PrimSequence.Slice.t = 
	       full ('a) seq
	    val x_3204: 'a PrimSequence.Slice.t
			* word64
			* word64 Primitive.Option.t = 
	       (x_3203, start, len)
	    val x_3205: 'a PrimSequence.Slice.t = 
	       subslice ('a) x_3204
	 in
	    x_3205
	 end
   val rec 'a_634 
      base: 'a_634 PrimSequence.Slice.t -> 'a_634 array * word64 * word64 = 
	 fn x_1001: 'a_634 PrimSequence.Slice.t => 
	 let
	    val x_3206: 'a_634 array * word64 * word64 = 
	       case x_1001 of
	       T['a_634] x_3207: word64 * 'a_634 array * word64 => 
		  let
		     val x_3208: word64 = 
			#2 x_3207
		     val x_3209: 'a_634 array = 
			#1 x_3207
		     val x_3210: word64 = 
			#0 x_3207
		     val x_3211: 'a_634 array * word64 * word64 = 
			(x_3209, x_3208, x_3210)
		  in
		     x_3211
		  end
	 in
	    x_3206
	 end
   val rec ('a_638, 'a_637) 
      foldli: (word64 * 'a_638 * 'a_637 -> 'a_637)
	      -> 'a_637 -> 'a_638 PrimSequence.Slice.t -> 'a_637 = 
	 fn x_1002: word64 * 'a_638 * 'a_637 -> 'a_637 => 
	 let
	    val x_3212: 'a_637 -> 'a_638 PrimSequence.Slice.t -> 'a_637 = 
	       fn x_1003: 'a_637 => 
	       let
		  val x_3213: 'a_638 PrimSequence.Slice.t -> 'a_637 = 
		     fn x_1004: 'a_638 PrimSequence.Slice.t => 
		     let
			val x_3214: 'a_637 = 
			   case x_1004 of
			   T['a_638] x_3215: word64 * 'a_638 array * word64 => 
			      let
				 val x_3216: word64 = 
				    #2 x_3215
				 val x_3217: 'a_638 array = 
				    #1 x_3215
				 val x_3218: word64 = 
				    #0 x_3215
				 val x_3219: word64 = 
				    0x1
				 val x_3220: word64 * word64 = 
				    (x_3218, x_3219)
				 val len: word64 = 
				    -? x_3220
				 val x_3221: word64 * word64 = 
				    (x_3216, len)
				 val max: word64 = 
				    +? x_3221
				 val rec 
				    loop: word64 * 'a_637 -> 'a_637 = 
				       fn x_1005: word64 * 'a_637 => 
				       let
					  val b: 'a_637 = 
					     #1 x_1005
					  val i: word64 = 
					     #0 x_1005
					  val x_3222: word64 * word64 = 
					     (i, max)
					  val x_3223: bool = 
					     > x_3222
					  val x_3224: 'a_637 = 
					     case x_3223 of
					     true => 
						let
						in
						   b
						end
					     false => 
						let
						   val x_3225: word64 = 
						      0x1
						   val x_3226: word64 * word64 = 
						      (i, x_3225)
						   val x_3227: word64 = 
						      +? x_3226
						   val x_3228: word64 * word64 = 
						      (i, x_3216)
						   val x_3229: word64 = 
						      -? x_3228
						   val x_3230: 'a_638 array
							       * word64 = 
						      (x_3217, i)
						   val x_3231: 'a_638 = 
						      subUnsafe_1 ('a_638) x_3230
						   val x_3232: word64
							       * 'a_638
							       * 'a_637 = 
						      (x_3229, x_3231, b)
						   val x_3233: 'a_637 = 
						      x_1002 x_3232
						   val x_3234: word64 * 'a_637 = 
						      (x_3227, x_3233)
						   val x_3235: 'a_637 = 
						      loop x_3234
						in
						   x_3235
						end
				       in
					  x_3224
				       end
				 val x_3236: word64 * 'a_637 = 
				    (x_3216, x_1003)
				 val x_3237: 'a_637 = 
				    loop x_3236
			      in
				 x_3237
			      end
		     in
			x_3214
		     end
	       in
		  x_3213
	       end
	 in
	    x_3212
	 end
   val rec ('a_640, 'a_639) 
      foldri: (word64 * 'a_640 * 'a_639 -> 'a_639)
	      -> 'a_639 -> 'a_640 PrimSequence.Slice.t -> 'a_639 = 
	 fn x_1006: word64 * 'a_640 * 'a_639 -> 'a_639 => 
	 let
	    val x_3238: 'a_639 -> 'a_640 PrimSequence.Slice.t -> 'a_639 = 
	       fn x_1007: 'a_639 => 
	       let
		  val x_3239: 'a_640 PrimSequence.Slice.t -> 'a_639 = 
		     fn x_1008: 'a_640 PrimSequence.Slice.t => 
		     let
			val x_3240: 'a_639 = 
			   case x_1008 of
			   T['a_640] x_3241: word64 * 'a_640 array * word64 => 
			      let
				 val x_3242: word64 = 
				    #2 x_3241
				 val x_3243: 'a_640 array = 
				    #1 x_3241
				 val x_3244: word64 = 
				    #0 x_3241
				 val x_3245: word64 = 
				    0x1
				 val x_3246: word64 * word64 = 
				    (x_3244, x_3245)
				 val len: word64 = 
				    -? x_3246
				 val x_3247: word64 * word64 = 
				    (x_3242, len)
				 val max: word64 = 
				    +? x_3247
				 val rec 
				    loop: word64 * 'a_639 -> 'a_639 = 
				       fn x_1009: word64 * 'a_639 => 
				       let
					  val b: 'a_639 = 
					     #1 x_1009
					  val i: word64 = 
					     #0 x_1009
					  val x_3248: word64 * word64 = 
					     (i, x_3242)
					  val x_3249: bool = 
					     < x_3248
					  val x_3250: 'a_639 = 
					     case x_3249 of
					     true => 
						let
						in
						   b
						end
					     false => 
						let
						   val x_3251: word64 = 
						      0x1
						   val x_3252: word64 * word64 = 
						      (i, x_3251)
						   val x_3253: word64 = 
						      -? x_3252
						   val x_3254: word64 * word64 = 
						      (i, x_3242)
						   val x_3255: word64 = 
						      -? x_3254
						   val x_3256: 'a_640 array
							       * word64 = 
						      (x_3243, i)
						   val x_3257: 'a_640 = 
						      subUnsafe_1 ('a_640) x_3256
						   val x_3258: word64
							       * 'a_640
							       * 'a_639 = 
						      (x_3255, x_3257, b)
						   val x_3259: 'a_639 = 
						      x_1006 x_3258
						   val x_3260: word64 * 'a_639 = 
						      (x_3253, x_3259)
						   val x_3261: 'a_639 = 
						      loop x_3260
						in
						   x_3261
						end
				       in
					  x_3250
				       end
				 val x_3262: word64 * 'a_639 = 
				    (max, x_1007)
				 val x_3263: 'a_639 = 
				    loop x_3262
			      in
				 x_3263
			      end
		     in
			x_3240
		     end
	       in
		  x_3239
	       end
	 in
	    x_3238
	 end
   val ('a, 'b) unfoldi_1: word64 * 'b * (word64 * 'b -> 'a * 'b)
			   -> 'a array * 'b = 
      let
      in
	 unfoldi ('b, 'a)
      end
   val ('a, 'b) unfold_1: word64 * 'b * ('b -> 'a * 'b) -> 'a array * 'b = 
      let
      in
	 unfold ('a, 'b)
      end
   val 'a newUninit_0: word64 -> 'a array = 
      let
      in
	 newUninit ('a)
      end
   val 'a updateMk_0: ('a array * word64 * 'a -> unit)
		      -> 'a PrimSequence.Slice.t * word64 * 'a -> unit = 
      let
      in
	 updateMk ('a, 'a, unit)
      end
   val 'a unsafeUpdateMk_0: ('a array * word64 * 'a -> unit)
			    -> 'a PrimSequence.Slice.t * word64 * 'a -> unit = 
      let
      in
	 unsafeUpdateMk ('a, 'a, unit)
      end
   val 'a unsafeSubslice_1: 'a PrimSequence.Slice.t
			    * word64
			    * word64 Primitive.Option.t
			    -> 'a PrimSequence.Slice.t = 
      let
      in
	 unsafeSubslice ('a)
      end
   val 'a unsafeSub_2: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 unsafeSub ('a)
      end
   val 'a subslice_1: 'a PrimSequence.Slice.t
		      * word64
		      * word64 Primitive.Option.t
		      -> 'a PrimSequence.Slice.t = 
      let
      in
	 subslice ('a)
      end
   val 'a sub_1: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a slice_0: 'a array * word64 * word64 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t = 
      let
      in
	 slice ('a)
      end
   val 'a length_3: 'a PrimSequence.Slice.t -> word64 = 
      let
      in
	 length ('a)
      end
   val 'a full_1: 'a array -> 'a PrimSequence.Slice.t = 
      let
      in
	 full ('a)
      end
   val ('b, 'a) foldri_0: (word64 * 'a * 'b -> 'b)
			  -> 'b -> 'a PrimSequence.Slice.t -> 'b = 
      let
      in
	 foldri ('a, 'b)
      end
   val ('b, 'a) foldli_0: (word64 * 'a * 'b -> 'b)
			  -> 'b -> 'a PrimSequence.Slice.t -> 'b = 
      let
      in
	 foldli ('a, 'b)
      end
   val 'a base_1: 'a PrimSequence.Slice.t -> 'a array * word64 * word64 = 
      let
      in
	 base ('a)
      end
   val rec 'a_723 
      unsafeUpdate: 'a_723 PrimSequence.Slice.t * word64 * 'a_723 -> unit = 
	 fn x_1010: 'a_723 PrimSequence.Slice.t * word64 * 'a_723 => 
	 let
	    val x_3264: 'a_723 PrimSequence.Slice.t * word64 * 'a_723 -> unit = 
	       unsafeUpdateMk_0 ('a_723) updateUnsafe ('a_723)
	    val x_3265: unit = 
	       x_3264 x_1010
	 in
	    x_3265
	 end
   val rec 'a_724 
      vector: 'a_724 PrimSequence.Slice.t -> 'a_724 vector = 
	 fn x_1011: 'a_724 PrimSequence.Slice.t => 
	 let
	    val x_3266: word64 = 
	       length_3 ('a_724) x_1011
	    val x_3267: word64 -> 'a_724 = 
	       fn x_1012: word64 => 
	       let
		  val x_3268: 'a_724 PrimSequence.Slice.t * word64 = 
		     (x_1011, x_1012)
		  val x_3269: 'a_724 = 
		     unsafeSub_2 ('a_724) x_3268
	       in
		  x_3269
	       end
	    val x_3270: word64 * (word64 -> 'a_724) = 
	       (x_3266, x_3267)
	    val x_3271: 'a_724 vector = 
	       tabulate_0 ('a_724) x_3270
	 in
	    x_3271
	 end
   val rec ('a_733, 'a_732, 'a_731, 'a_730, 'a_729) 
      make: ((word64 * 'a_731 * 'a_730 -> unit)
	     -> unit -> 'a_732 PrimSequence.Slice.t -> 'a_729)
	    * ('a_733 -> word64)
	    * ('a_733 * word64 -> 'a_732)
	    -> word64 * 'a_732 array * 'a_733 -> 'a_729 = 
	 fn x_1013: ((word64 * 'a_731 * 'a_730 -> unit)
		     -> unit -> 'a_732 PrimSequence.Slice.t -> 'a_729)
		    * ('a_733 -> word64)
		    * ('a_733 * word64 -> 'a_732) => 
	 let
	    val x_3272: word64 * 'a_732 array * 'a_733 -> 'a_729 = 
	       fn x_1014: word64 * 'a_732 array * 'a_733 => 
	       let
		  val x_3273: 'a_733 * word64 -> 'a_732 = 
		     #2 x_1013
		  val x_3274: 'a_733 -> word64 = 
		     #1 x_1013
		  val x_3275: (word64 * 'a_731 * 'a_730 -> unit)
			      -> unit -> 'a_732 PrimSequence.Slice.t -> 'a_729 = 
		     #0 x_1013
		  val x_3276: 'a_733 = 
		     #2 x_1014
		  val x_3277: 'a_732 array = 
		     #1 x_1014
		  val x_3278: word64 = 
		     #0 x_1014
		  val x_3279: word64 = 
		     x_3274 x_3276
		  val x_3280: word64 Primitive.Option.t = 
		     SOME[word64] x_3279
		  val x_3281: 'a_732 array * word64 * word64 Primitive.Option.t = 
		     (x_3277, x_3278, x_3280)
		  val sl: 'a_732 PrimSequence.Slice.t = 
		     slice_0 ('a_732) x_3281
		  val rec ('a_728, 'a_727) 
		     transfer: word64 * 'a_728 * 'a_727 -> unit = 
			fn x_1015: word64 * 'a_728 * 'a_727 => 
			let
			   val x_3282: word64 = 
			      #0 x_1015
			   val x_3283: 'a_733 * word64 = 
			      (x_3276, x_3282)
			   val x_3284: 'a_732 = 
			      x_3273 x_3283
			   val x_3285: 'a_732 PrimSequence.Slice.t
				       * word64
				       * 'a_732 = 
			      (sl, x_3282, x_3284)
			   val x_3286: unit = 
			      unsafeUpdate ('a_732) x_3285
			in
			   x_3286
			end
		  val x_3287: unit -> 'a_732 PrimSequence.Slice.t -> 'a_729 = 
		     x_3275 transfer ('a_731, 'a_730)
		  val x_3288: unit = 
		     ()
		  val x_3289: 'a_732 PrimSequence.Slice.t -> 'a_729 = 
		     x_3287 x_3288
		  val x_3290: 'a_729 = 
		     x_3289 sl
	       in
		  x_3290
	       end
	 in
	    x_3272
	 end
   val rec 'a_735 
      copyVec: word64 * 'a_735 array * 'a_735 PrimSequence.Slice.t -> unit = 
	 fn x_1016: word64 * 'a_735 array * 'a_735 PrimSequence.Slice.t => 
	 let
	    val x_3291: ((word64 * 'a_735 * unit -> unit)
			 -> unit -> 'a_735 PrimSequence.Slice.t -> unit)
			* ('a_735 PrimSequence.Slice.t -> word64)
			* ('a_735 PrimSequence.Slice.t * word64 -> 'a_735) = 
	       (foldli_0 (unit, 'a_735), length_1 ('a_735), unsafeSub_1 ('a_735))
	    val x_3292: word64 * 'a_735 array * 'a_735 PrimSequence.Slice.t
			-> unit = 
	       make ('a_735 PrimSequence.Slice.t, 'a_735, 'a_735, unit, unit) x_3291
	    val x_3293: unit = 
	       x_3292 x_1016
	 in
	    x_3293
	 end
   val rec 'a_740 
      copyVec: word64 * 'a_740 array * 'a_740 vector -> unit = 
	 fn x_1017: word64 * 'a_740 array * 'a_740 vector => 
	 let
	    val src: 'a_740 vector = 
	       #2 x_1017
	    val dst: 'a_740 array = 
	       #1 x_1017
	    val di: word64 = 
	       #0 x_1017
	    val x_3294: 'a_740 PrimSequence.Slice.t = 
	       full_0 ('a_740) src
	    val x_3295: word64 * 'a_740 array * 'a_740 PrimSequence.Slice.t = 
	       (di, dst, x_3294)
	    val x_3296: unit = 
	       copyVec ('a_740) x_3295
	 in
	    x_3296
	 end
   val zero: intInf = 
      0
   val rec 
      isSmall: intInf -> bool = 
	 fn x_1018: intInf => 
	 let
	    val x_3297: word64 = 
	       0x0
	    val x_3298: word64 = 
	       toWord x_1018
	    val x_3299: word64 = 
	       0x1
	    val x_3300: word64 * word64 = 
	       (x_3298, x_3299)
	    val x_3301: word64 = 
	       andb x_3300
	    val x_3302: word64 * word64 = 
	       (x_3297, x_3301)
	    val x_3303: bool = 
	       <> (word64) x_3302
	 in
	    x_3303
	 end
   val rec 
      areSmall: intInf * intInf -> bool = 
	 fn x_1019: intInf * intInf => 
	 let
	    val i': intInf = 
	       #1 x_1019
	    val i: intInf = 
	       #0 x_1019
	    val x_3304: word64 = 
	       0x0
	    val x_3305: word64 = 
	       toWord i
	    val x_3306: word64 = 
	       toWord i'
	    val x_3307: word64 * word64 = 
	       (x_3305, x_3306)
	    val x_3308: word64 = 
	       andb x_3307
	    val x_3309: word64 = 
	       0x1
	    val x_3310: word64 * word64 = 
	       (x_3308, x_3309)
	    val x_3311: word64 = 
	       andb x_3310
	    val x_3312: word64 * word64 = 
	       (x_3304, x_3311)
	    val x_3313: bool = 
	       <> (word64) x_3312
	 in
	    x_3313
	 end
   val rec 
      numLimbs: intInf -> word64 = 
	 fn x_1021: intInf => 
	 let
	    val x_3314: bool = 
	       isSmall x_1021
	    val x_3315: word64 = 
	       case x_3314 of
	       true => 
		  let
		     val x_3321: word64 = 
			0x1
		  in
		     x_3321
		  end
	       false => 
		  let
		     val x_3316: word64 vector = 
			toVector x_1021
		     val x_3317: word64 = 
			length (word64) x_3316
		     val x_3318: word64 = 
			0x1
		     val x_3319: word64 * word64 = 
			(x_3317, x_3318)
		     val x_3320: word64 = 
			-! x_3319
		  in
		     x_3320
		  end
	 in
	    x_3315
	 end
   val rec 
      dropTagCoerce: intInf -> word64 = 
	 fn x_1023: intInf => 
	 let
	    val x_3322: word64 = 
	       toWord x_1023
	    val x_3323: word32 = 
	       0x1
	    val x_3324: word64 * word32 = 
	       (x_3322, x_3323)
	    val x_3325: word64 = 
	       ~>>? x_3324
	 in
	    x_3325
	 end
   val rec 
      addTag: word64 -> word64 = 
	 fn x_1025: word64 => 
	 let
	    val x_3326: word32 = 
	       0x1
	    val x_3327: word64 * word32 = 
	       (x_1025, x_3326)
	    val x_3328: word64 = 
	       <<? x_3327
	    val x_3329: word64 = 
	       0x1
	    val x_3330: word64 * word64 = 
	       (x_3328, x_3329)
	    val x_3331: word64 = 
	       orb x_3330
	 in
	    x_3331
	 end
   val rec 'a 
      make: (('a * 'a -> bool)
	     * ('a -> bool)
	     * ('a -> 'a)
	     * ('a -> 'a)
	     * ('a * word32 -> 'a)
	     * ('a * word32 -> 'a)
	     * word32
	     * 'a)
	    * ('a -> word64)
	    * ('a -> word64)
	    * ('a -> word64)
	    -> bool * 'a -> intInf = 
	 fn x_1026: (('a * 'a -> bool)
		     * ('a -> bool)
		     * ('a -> 'a)
		     * ('a -> 'a)
		     * ('a * word32 -> 'a)
		     * ('a * word32 -> 'a)
		     * word32
		     * 'a)
		    * ('a -> word64)
		    * ('a -> word64)
		    * ('a -> word64) => 
	 let
	    val x_3332: bool * 'a -> intInf = 
	       fn x_1027: bool * 'a => 
	       let
		  val x_3333: 'a -> word64 = 
		     #3 x_1026
		  val x_3334: 'a -> word64 = 
		     #2 x_1026
		  val x_3335: 'a -> word64 = 
		     #1 x_1026
		  val x_3336: ('a * 'a -> bool)
			      * ('a -> bool)
			      * ('a -> 'a)
			      * ('a -> 'a)
			      * ('a * word32 -> 'a)
			      * ('a * word32 -> 'a)
			      * word32
			      * 'a = 
		     #0 x_1026
		  val x_3337: 'a = 
		     #1 x_1027
		  val x_3338: bool = 
		     #0 x_1027
		  val x_3339: word32 = 
		     #6 x_3336
		  val x_3340: word32 * word32 = 
		     (sizeInBits, x_3339)
		  val x_3341: bool = 
		     > x_3340
		  val x_3342: bool = 
		     case x_3341 of
		     true => 
			let
			   val x_3359: bool = 
			      true
			in
			   x_3359
			end
		     false => 
			let
			   val x_3343: word32 = 
			      0x2
			   val x_3344: word32 * word32 = 
			      (sizeInBitsWord, x_3343)
			   val shift: word32 = 
			      - x_3344
			   val x_3345: 'a * word32 -> 'a = 
			      #4 x_3336
			   val x_3346: 'a * word32 = 
			      (x_3337, shift)
			   val upperBits: 'a = 
			      x_3345 x_3346
			   val x_3347: 'a = 
			      #7 x_3336
			   val x_3348: 'a -> 'a = 
			      #3 x_3336
			   val oneBits: 'a = 
			      x_3348 x_3347
			   val x_3349: 'a * 'a -> bool = 
			      #0 x_3336
			   val x_3350: 'a * 'a = 
			      (upperBits, x_3347)
			   val x_3351: bool = 
			      x_3349 x_3350
			   val x_3352: bool = 
			      case x_3351 of
			      true => 
				 let
				    val x_3358: bool = 
				       true
				 in
				    x_3358
				 end
			      false => 
				 let
				    val x_3353: bool = 
				       case x_3338 of
				       true => 
					  let
					     val x_3355: 'a * 'a -> bool = 
						#0 x_3336
					     val x_3356: 'a * 'a = 
						(upperBits, oneBits)
					     val x_3357: bool = 
						x_3355 x_3356
					  in
					     x_3357
					  end
				       false => 
					  let
					     val x_3354: bool = 
						false
					  in
					     x_3354
					  end
				 in
				    x_3353
				 end
			in
			   x_3352
			end
		  val x_3360: intInf = 
		     case x_3342 of
		     true => 
			let
			   val x_3415: intInf = 
			      case x_3338 of
			      true => 
				 let
				    val x_3419: word64 = 
				       x_3335 x_3337
				    val x_3420: word64 = 
				       addTag x_3419
				    val x_3421: intInf = 
				       fromWord x_3420
				 in
				    x_3421
				 end
			      false => 
				 let
				    val x_3416: word64 = 
				       x_3333 x_3337
				    val x_3417: word64 = 
				       addTag x_3416
				    val x_3418: intInf = 
				       fromWord x_3417
				 in
				    x_3418
				 end
			in
			   x_3415
			end
		     false => 
			let
			   val rec 
			      loop: 'a * word64 * (word64 * word64) list
				    -> word64 * (word64 * word64) list = 
				 fn x_1031: 'a * word64 * (word64 * word64) list => 
				 let
				    val acc: (word64 * word64) list = 
				       #2 x_1031
				    val i: word64 = 
				       #1 x_1031
				    val w: 'a = 
				       #0 x_1031
				    val x_3361: 'a * 'a -> bool = 
				       #0 x_3336
				    val x_3362: 'a = 
				       #7 x_3336
				    val x_3363: 'a * 'a = 
				       (w, x_3362)
				    val x_3364: bool = 
				       x_3361 x_3363
				    val x_3365: word64 * (word64 * word64) list = 
				       case x_3364 of
				       true => 
					  let
					     val x_3376: word64
							 * (word64 * word64) list = 
						(i, acc)
					  in
					     x_3376
					  end
				       false => 
					  let
					     val limb: word64 = 
						x_3334 w
					     val x_3366: 'a * word32 -> 'a = 
						#5 x_3336
					     val x_3367: 'a * word32 = 
						(w, sizeInBitsWord)
					     val w: 'a = 
						x_3366 x_3367
					     val x_3368: word64 = 
						0x1
					     val x_3369: word64 * word64 = 
						(i, x_3368)
					     val x_3370: word64 = 
						+! x_3369
					     val x_3371: word64 * word64 = 
						(i, limb)
					     val x_3372: (word64 * word64)
							 * (word64 * word64) list = 
						(x_3371, acc)
					     val x_3373: (word64 * word64) list = 
						::[word64 * word64] x_3372
					     val x_3374: 'a
							 * word64
							 * (word64 * word64) list = 
						(w, x_3370, x_3373)
					     val x_3375: word64
							 * (word64 * word64) list = 
						loop x_3374
					  in
					     x_3375
					  end
				 in
				    x_3365
				 end
			   val x_3377: bool = 
			      case x_3338 of
			      true => 
				 let
				    val x_3379: 'a -> bool = 
				       #1 x_3336
				    val x_3380: bool = 
				       x_3379 x_3337
				 in
				    x_3380
				 end
			      false => 
				 let
				    val x_3378: bool = 
				       false
				 in
				    x_3378
				 end
			   val x_3381: word64 * (word64 * word64) list = 
			      case x_3377 of
			      true => 
				 let
				    val x_3391: 'a -> 'a = 
				       #2 x_3336
				    val x_3392: 'a = 
				       x_3391 x_3337
				    val x_3393: word64 = 
				       0x1
				    val x_3394: (word64 * word64) list = 
				       nil[word64 * word64]
				    val x_3395: word64 = 
				       0x0
				    val x_3396: word64 = 
				       0x1
				    val x_3397: word64 * word64 = 
				       (x_3395, x_3396)
				    val x_3398: (word64 * word64)
						* (word64 * word64) list = 
				       (x_3397, x_3394)
				    val x_3399: (word64 * word64) list = 
				       ::[word64 * word64] x_3398
				    val x_3400: 'a
						* word64
						* (word64 * word64) list = 
				       (x_3392, x_3393, x_3399)
				    val x_3401: word64 * (word64 * word64) list = 
				       loop x_3400
				 in
				    x_3401
				 end
			      false => 
				 let
				    val x_3382: word64 = 
				       0x1
				    val x_3383: (word64 * word64) list = 
				       nil[word64 * word64]
				    val x_3384: word64 = 
				       0x0
				    val x_3385: word64 = 
				       0x0
				    val x_3386: word64 * word64 = 
				       (x_3384, x_3385)
				    val x_3387: (word64 * word64)
						* (word64 * word64) list = 
				       (x_3386, x_3383)
				    val x_3388: (word64 * word64) list = 
				       ::[word64 * word64] x_3387
				    val x_3389: 'a
						* word64
						* (word64 * word64) list = 
				       (x_3337, x_3382, x_3388)
				    val x_3390: word64 * (word64 * word64) list = 
				       loop x_3389
				 in
				    x_3390
				 end
			   val acc: (word64 * word64) list = 
			      #1 x_3381
			   val n: word64 = 
			      #0 x_3381
			   val a: word64 array = 
			      arrayUnsafe (word64) n
			   val rec 
			      loop: (word64 * word64) list -> unit = 
				 fn x_1028: (word64 * word64) list => 
				 let
				    val x_3402: unit = 
				       case x_1028 of
				       nil[word64 * word64] => 
					  let
					     val x_3411: unit = 
						()
					  in
					     x_3411
					  end
				       ::[word64 * word64] x_3403: (word64
								    * word64)
								   * (word64
								      * word64) list => 
					  let
					     val x_3404: (word64 * word64) list = 
						#1 x_3403
					     val x_3405: word64 * word64 = 
						#0 x_3403
					     val x_3406: word64 = 
						#1 x_3405
					     val x_3407: word64 = 
						#0 x_3405
					     val x_3408: word64 array
							 * word64
							 * word64 = 
						(a, x_3407, x_3406)
					     val x_3409: unit = 
						updateUnsafe (word64) x_3408
					     val x_3410: unit = 
						loop x_3404
					  in
					     x_3410
					  end
				 in
				    x_3402
				 end
			   val x_3412: unit = 
			      loop acc
			   val x_3413: word64 vector = 
			      fromArrayUnsafe (word64) a
			   val x_3414: intInf = 
			      WordVector_toIntInf (x_3413)
			in
			   x_3414
			end
	       in
		  x_3360
	       end
	 in
	    x_3332
	 end
   val rec 
      extdFromWord64: bool * word64 -> intInf = 
	 fn x_1059: bool * word64 => 
	 let
	    val w: word64 = 
	       #1 x_1059
	    val sextd: bool = 
	       #0 x_1059
	    val x_3422: word64 -> bool = 
	       fn x_1060: word64 => 
	       let
		  val x_3423: word64 = 
		     idFromWord64ToInt64 x_1060
		  val x_3424: word64 = 
		     0x0
		  val x_3425: word64 * word64 = 
		     (x_3423, x_3424)
		  val x_3426: bool = 
		     < x_3425
	       in
		  x_3426
	       end
	    val x_3427: (word64 * word64 -> bool)
			* (word64 -> bool)
			* (word64 -> word64)
			* (word64 -> word64)
			* (word64 * word32 -> word64)
			* (word64 * word32 -> word64)
			* word32
			* word64 = 
	       (= (word64), x_3422, ~, notb, ~>>?, >>?, sizeInBits, zero)
	    val x_3428: ((word64 * word64 -> bool)
			 * (word64 -> bool)
			 * (word64 -> word64)
			 * (word64 -> word64)
			 * (word64 * word32 -> word64)
			 * (word64 * word32 -> word64)
			 * word32
			 * word64)
			* (word64 -> word64)
			* (word64 -> word64)
			* (word64 -> word64) = 
	       (x_3427,
		sextdFromWord64ToWord64,
		zextdFromWord64ToWord64,
		zextdFromWord64ToWord64)
	    val x_3429: bool * word64 -> intInf = 
	       make (word64) x_3428
	    val x_3430: bool * word64 = 
	       (sextd, w)
	    val x_3431: intInf = 
	       x_3429 x_3430
	 in
	    x_3431
	 end
   val rec 
      sextdFromInt64: word64 -> intInf = 
	 fn x_1064: word64 => 
	 let
	    val x_3432: word64 = 
	       idFromInt64ToWord64 x_1064
	    val x_3433: bool = 
	       true
	    val x_3434: bool * word64 = 
	       (x_3433, x_3432)
	    val x_3435: intInf = 
	       extdFromWord64 x_3434
	 in
	    x_3435
	 end
   val rec 'a_753 
      zextdFromIntInf: 'a_753 -> 'a_753 = 
	 fn x_1065: 'a_753 => 
	 let
	 in
	    x_1065
	 end
   val rec 'a_754 
      sextdFromIntInf: 'a_754 -> 'a_754 = 
	 fn x_1066: 'a_754 => 
	 let
	 in
	    x_1066
	 end
   val rec 'a_755 
      castFromIntInf: 'a_755 -> 'a_755 = 
	 fn x_1067: 'a_755 => 
	 let
	 in
	    x_1067
	 end
   val rec 'a_756 
      zchckFromIntInf: 'a_756 -> 'a_756 = 
	 fn x_1068: 'a_756 => 
	 let
	 in
	    x_1068
	 end
   val rec 'a_757 
      schckFromIntInf: 'a_757 -> 'a_757 = 
	 fn x_1069: 'a_757 => 
	 let
	 in
	    x_1069
	 end
   val rec 'a 
      make: (('a * word32 -> 'a) * ('a * 'a -> 'a) * word32 * word32 * 'a)
	    * (word64 -> 'a)
	    -> intInf -> 'a Primitive.IntInf.ans = 
	 fn x_1070: (('a * word32 -> 'a)
		     * ('a * 'a -> 'a)
		     * word32
		     * word32
		     * 'a)
		    * (word64 -> 'a) => 
	 let
	    val x_3436: intInf -> 'a Primitive.IntInf.ans = 
	       fn x_1071: intInf => 
	       let
		  val x_3437: word64 -> 'a = 
		     #1 x_1070
		  val x_3438: ('a * word32 -> 'a)
			      * ('a * 'a -> 'a)
			      * word32
			      * word32
			      * 'a = 
		     #0 x_1070
		  val x_3439: bool = 
		     isSmall x_1071
		  val x_3440: 'a Primitive.IntInf.ans = 
		     case x_3439 of
		     true => 
			let
			   val x_3500: word64 = 
			      dropTagCoerce x_1071
			   val x_3501: 'a Primitive.IntInf.ans = 
			      Small['a] x_3500
			in
			   x_3501
			end
		     false => 
			let
			   val v: word64 vector = 
			      toVector x_1071
			   val n: word64 = 
			      length (word64) v
			   val x_3441: word64 = 
			      0x0
			   val x_3442: word64 vector * word64 = 
			      (v, x_3441)
			   val x_3443: word64 = 
			      subUnsafe (word64) x_3442
			   val x_3444: word64 = 
			      0x0
			   val x_3445: word64 * word64 = 
			      (x_3443, x_3444)
			   val isneg: bool = 
			      <> (word64) x_3445
			   val x_3446: word32 = 
			      #2 x_3438
			   val x_3447: word32 * word32 = 
			      (sizeInBits, x_3446)
			   val x_3448: bool = 
			      >= x_3447
			   val x_3449: 'a Primitive.IntInf.ans = 
			      case x_3448 of
			      true => 
				 let
				    val limbsPer: word64 = 
				       0x1
				    val x_3483: word64 = 
				       0x1
				    val x_3484: word64 vector * word64 = 
				       (v, x_3483)
				    val limb: word64 = 
				       subUnsafe (word64) x_3484
				    val x_3485: word64 = 
				       0x1
				    val x_3486: word64 * word64 = 
				       (limbsPer, x_3485)
				    val x_3487: word64 = 
				       +! x_3486
				    val x_3488: word64 * word64 = 
				       (n, x_3487)
				    val x_3489: bool = 
				       > x_3488
				    val x_3490: bool = 
				       case x_3489 of
				       true => 
					  let
					     val x_3497: bool = 
						true
					  in
					     x_3497
					  end
				       false => 
					  let
					     val x_3491: word32 = 
						#3 x_3438
					     val x_3492: word64 * word32 = 
						(limb, x_3491)
					     val x_3493: word64 = 
						>>? x_3492
					     val x_3494: word64 = 
						0x0
					     val x_3495: word64 * word64 = 
						(x_3493, x_3494)
					     val x_3496: bool = 
						<> (word64) x_3495
					  in
					     x_3496
					  end
				    val ans: 'a = 
				       x_3437 limb
				    val x_3498: bool * bool * 'a = 
				       (isneg, x_3490, ans)
				    val x_3499: 'a Primitive.IntInf.ans = 
				       Big['a] x_3498
				 in
				    x_3499
				 end
			      false => 
				 let
				    val x_3450: word32 = 
				       #2 x_3438
				    val x_3451: word32 * word32 = 
				       (x_3450, sizeInBits)
				    val x_3452: word32 = 
				       quot x_3451
				    val limbsPer: word64 = 
				       sextdFromInt32ToInt64 x_3452
				    val x_3453: word64 = 
				       0x1
				    val x_3454: word64 * word64 = 
				       (limbsPer, x_3453)
				    val x_3455: word64 = 
				       +! x_3454
				    val x_3456: word64 * word64 = 
				       (n, x_3455)
				    val extra: bool = 
				       > x_3456
				    val rec 
				       loop: word64 * 'a -> 'a = 
					  fn x_1073: word64 * 'a => 
					  let
					     val ans: 'a = 
						#1 x_1073
					     val i: word64 = 
						#0 x_1073
					     val x_3457: word64 = 
						0x0
					     val x_3458: word64 * word64 = 
						(i, x_3457)
					     val x_3459: bool = 
						> x_3458
					     val x_3460: 'a = 
						case x_3459 of
						true => 
						   let
						      val x_3461: word64 vector
								  * word64 = 
							 (v, i)
						      val limb: word64 = 
							 subUnsafe (word64) x_3461
						      val x_3462: 'a * 'a -> 'a = 
							 #1 x_3438
						      val x_3463: 'a * word32
								  -> 'a = 
							 #0 x_3438
						      val x_3464: 'a * word32 = 
							 (ans, sizeInBitsWord)
						      val x_3465: 'a = 
							 x_3463 x_3464
						      val x_3466: 'a = 
							 x_3437 limb
						      val x_3467: 'a * 'a = 
							 (x_3465, x_3466)
						      val ans: 'a = 
							 x_3462 x_3467
						      val x_3468: word64 = 
							 0x1
						      val x_3469: word64
								  * word64 = 
							 (i, x_3468)
						      val x_3470: word64 = 
							 -! x_3469
						      val x_3471: word64 * 'a = 
							 (x_3470, ans)
						      val x_3472: 'a = 
							 loop x_3471
						   in
						      x_3472
						   end
						false => 
						   let
						   in
						      ans
						   end
					  in
					     x_3460
					  end
				    val x_3473: word64 = 
				       0x1
				    val x_3474: word64 * word64 = 
				       (n, x_3473)
				    val x_3475: word64 = 
				       -! x_3474
				    val x_3476: word64 * word64 = 
				       (x_3475, limbsPer)
				    val x_3477: bool = 
				       < x_3476
				    val x_3478: word64 = 
				       case x_3477 of
				       true => 
					  let
					  in
					     x_3475
					  end
				       false => 
					  let
					  in
					     limbsPer
					  end
				    val x_3479: 'a = 
				       #4 x_3438
				    val x_3480: word64 * 'a = 
				       (x_3478, x_3479)
				    val ans: 'a = 
				       loop x_3480
				    val x_3481: bool * bool * 'a = 
				       (isneg, extra, ans)
				    val x_3482: 'a Primitive.IntInf.ans = 
				       Big['a] x_3481
				 in
				    x_3482
				 end
			in
			   x_3449
			end
	       in
		  x_3440
	       end
	 in
	    x_3436
	 end
   val x_3502: (word8 * word32 -> word8)
	       * (word8 * word8 -> word8)
	       * word32
	       * word32
	       * word8 = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_3503: ((word8 * word32 -> word8)
		* (word8 * word8 -> word8)
		* word32
		* word32
		* word8)
	       * (word64 -> word8) = 
      (x_3502, zextdFromWord64ToWord8)
   val chckToWord8Aux: intInf -> word8 Primitive.IntInf.ans = 
      make (word8) x_3503
   val x_3504: (word16 * word32 -> word16)
	       * (word16 * word16 -> word16)
	       * word32
	       * word32
	       * word16 = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_3505: ((word16 * word32 -> word16)
		* (word16 * word16 -> word16)
		* word32
		* word32
		* word16)
	       * (word64 -> word16) = 
      (x_3504, zextdFromWord64ToWord16)
   val chckToWord16Aux: intInf -> word16 Primitive.IntInf.ans = 
      make (word16) x_3505
   val x_3506: (word32 * word32 -> word32)
	       * (word32 * word32 -> word32)
	       * word32
	       * word32
	       * word32 = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_3507: ((word32 * word32 -> word32)
		* (word32 * word32 -> word32)
		* word32
		* word32
		* word32)
	       * (word64 -> word32) = 
      (x_3506, zextdFromWord64ToWord32)
   val chckToWord32Aux: intInf -> word32 Primitive.IntInf.ans = 
      make (word32) x_3507
   val x_3508: (word64 * word32 -> word64)
	       * (word64 * word64 -> word64)
	       * word32
	       * word32
	       * word64 = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_3509: ((word64 * word32 -> word64)
		* (word64 * word64 -> word64)
		* word32
		* word32
		* word64)
	       * (word64 -> word64) = 
      (x_3508, zextdFromWord64ToWord64)
   val chckToWord64Aux: intInf -> word64 Primitive.IntInf.ans = 
      make (word64) x_3509
   val rec 'a_760 
      zextdToIntInf: 'a_760 -> 'a_760 = 
	 fn x_1107: 'a_760 => 
	 let
	 in
	    x_1107
	 end
   val rec 'a_761 
      sextdToIntInf: 'a_761 -> 'a_761 = 
	 fn x_1108: 'a_761 => 
	 let
	 in
	    x_1108
	 end
   val rec 'a_762 
      castToIntInf: 'a_762 -> 'a_762 = 
	 fn x_1109: 'a_762 => 
	 let
	 in
	    x_1109
	 end
   val rec 'a_763 
      zchckToIntInf: 'a_763 -> 'a_763 = 
	 fn x_1110: 'a_763 => 
	 let
	 in
	    x_1110
	 end
   val rec 'a_764 
      schckToIntInf: 'a_764 -> 'a_764 = 
	 fn x_1111: 'a_764 => 
	 let
	 in
	    x_1111
	 end
   val x_3510: word32 = 
      0x8
   val x_3511: word32 * word32 = 
      (sizeInBits, x_3510)
   val x_3512: word32 = 
      quot x_3511
   val bytesPerMPLimb: word64 = 
      zextdFromInt32ToWord64 x_3512
   val x_3513: word32 = 
      0x8
   val x_3514: word32 * word32 = 
      (sizeInBits, x_3513)
   val x_3515: word32 = 
      quot x_3514
   val bytesPerCounter: word64 = 
      zextdFromInt32ToWord64 x_3515
   val x_3516: word32 = 
      0x8
   val x_3517: word32 * word32 = 
      (sizeInBits, x_3516)
   val x_3518: word32 = 
      quot x_3517
   val bytesPerLength: word64 = 
      zextdFromInt32ToWord64 x_3518
   val x_3519: word32 = 
      0x8
   val x_3520: word32 * word32 = 
      (sizeInBits, x_3519)
   val x_3521: word32 = 
      quot x_3520
   val bytesPerHeader: word64 = 
      zextdFromInt32ToWord64 x_3521
   val x_3522: word64 * word64 = 
      (bytesPerLength, bytesPerHeader)
   val x_3523: word64 = 
      + x_3522
   val x_3524: word64 * word64 = 
      (bytesPerCounter, x_3523)
   val bytesPerArrayHeader: word64 = 
      + x_3524
   val rec 
      reserve: word64 * word64 -> word64 = 
	 fn x_1112: word64 * word64 => 
	 let
	    val extra: word64 = 
	       #1 x_1112
	    val num: word64 = 
	       #0 x_1112
	    val x_3525: word64 = 
	       zextdFromInt64ToWord64 num
	    val x_3526: word64 * word64 = 
	       (bytesPerMPLimb, x_3525)
	    val x_3527: word64 = 
	       * x_3526
	    val x_3528: word64 = 
	       zextdFromInt64ToWord64 extra
	    val x_3529: word64 * word64 = 
	       (bytesPerMPLimb, x_3528)
	    val x_3530: word64 = 
	       * x_3529
	    val x_3531: word64 = 
	       0x7
	    val x_3532: word64 * word64 = 
	       (bytesPerArrayHeader, x_3531)
	    val x_3533: word64 = 
	       + x_3532
	    val x_3534: word64 * word64 = 
	       (bytesPerMPLimb, x_3533)
	    val x_3535: word64 = 
	       + x_3534
	    val x_3536: word64 * word64 = 
	       (x_3530, x_3535)
	    val x_3537: word64 = 
	       + x_3536
	    val x_3538: word64 * word64 = 
	       (x_3527, x_3537)
	    val x_3539: word64 = 
	       + x_3538
	 in
	    x_3539
	 end
   val x_3540: word32 = 
      0x1
   val x_3541: word64 * word32 = 
      (minInt', x_3540)
   val badObjptrInt: word64 = 
      ~>>? x_3541
   val badObjptrWord: word64 = 
      zextdFromInt64ToWord64 badObjptrInt
   val badObjptrWordTagged: word64 = 
      addTag badObjptrWord
   val x_3542: word64 = 
      ~! badObjptrInt
   val negBadIntInf: intInf = 
      sextdFromInt64 x_3542
   val rec 
      make: (word64 * word64 -> word64)
	    * (intInf * intInf * word64 -> intInf)
	    * (word64 * word64 -> word64)
	    * word64
	    -> intInf * intInf -> intInf = 
	 fn x_1114: (word64 * word64 -> word64)
		    * (intInf * intInf * word64 -> intInf)
		    * (word64 * word64 -> word64)
		    * word64 => 
	 let
	    val x_3543: intInf * intInf -> intInf = 
	       fn x_1115: intInf * intInf => 
	       let
		  val x_3544: word64 = 
		     #3 x_1114
		  val x_3545: word64 * word64 -> word64 = 
		     #2 x_1114
		  val x_3546: intInf * intInf * word64 -> intInf = 
		     #1 x_1114
		  val x_3547: word64 * word64 -> word64 = 
		     #0 x_1114
		  val x_3548: intInf = 
		     #1 x_1115
		  val x_3549: intInf = 
		     #0 x_1115
		  val x_3550: intInf * intInf = 
		     (x_3549, x_3548)
		  val x_3551: bool = 
		     areSmall x_3550
		  val x_3552: intInf Primitive.Option.t = 
		     case x_3551 of
		     true => 
			let
			   val x_3554: intInf Primitive.Option.t = 
			      let
				 val lhsw: word64 = 
				    dropTagCoerce x_3549
				 val lhsi: word64 = 
				    zextdFromWord64ToInt64 lhsw
				 val rhsw: word64 = 
				    dropTagCoerce x_3548
				 val rhsi: word64 = 
				    zextdFromWord64ToInt64 rhsw
				 val x_3555: word64 * word64 = 
				    (lhsi, rhsi)
				 val ansi: word64 = 
				    x_3547 x_3555
				 val answ: word64 = 
				    zextdFromInt64ToWord64 ansi
				 val ans: word64 = 
				    addTag answ
				 val x_3556: word64 = 
				    Word64_xorb (ans, answ)
				 val x_3557: word64 = 
				    zextdFromWord64ToInt64 x_3556
				 val x_3558: word64 = 
				    0x0
				 val x_3559: word64 * word64 = 
				    (x_3557, x_3558)
				 val x_3560: bool = 
				    >= x_3559
				 val x_3561: intInf Primitive.Option.t = 
				    case x_3560 of
				    true => 
				       let
					  val x_3563: intInf = 
					     fromWord ans
					  val x_3564: intInf Primitive.Option.t = 
					     SOME[intInf] x_3563
				       in
					  x_3564
				       end
				    false => 
				       let
					  val x_3562: intInf Primitive.Option.t = 
					     NONE[intInf]
				       in
					  x_3562
				       end
			      in
				 x_3561
			      end
			      handle x_1116 => let
						  val x_3565: intInf Primitive.Option.t = 
						     case x_1116 of
						     Overflow => 
							let
							   val x_3566: intInf Primitive.Option.t = 
							      NONE[intInf]
							in
							   x_3566
							end
						       _ => let
							       val x_3567: intInf Primitive.Option.t = 
								  raise x_1116
							    in
							       x_3567
							    end
					       in
						  x_3565
					       end
			in
			   x_3554
			end
		     false => 
			let
			   val x_3553: intInf Primitive.Option.t = 
			      NONE[intInf]
			in
			   x_3553
			end
		  val x_3568: intInf = 
		     case x_3552 of
		     NONE[intInf] => 
			let
			   val x_3570: word64 = 
			      numLimbs x_3549
			   val x_3571: word64 = 
			      numLimbs x_3548
			   val x_3572: word64 * word64 = 
			      (x_3570, x_3571)
			   val x_3573: word64 = 
			      x_3545 x_3572
			   val x_3574: word64 * word64 = 
			      (x_3573, x_3544)
			   val x_3575: word64 = 
			      reserve x_3574
			   val x_3576: intInf * intInf * word64 = 
			      (x_3549, x_3548, x_3575)
			   val x_3577: intInf = 
			      x_3546 x_3576
			in
			   x_3577
			end
		     SOME[intInf] x_3569: intInf => 
			let
			in
			   x_3569
			end
	       in
		  x_3568
	       end
	 in
	    x_3543
	 end
   val x_3578: word64 = 
      0x1
   val x_3579: (word64 * word64 -> word64)
	       * (intInf * intInf * word64 -> intInf)
	       * (word64 * word64 -> word64)
	       * word64 = 
      (+!, +, max, x_3578)
   val bigAdd: intInf * intInf -> intInf = 
      make x_3579
   val x_3580: word64 = 
      0x0
   val x_3581: (word64 * word64 -> word64)
	       * (intInf * intInf * word64 -> intInf)
	       * (word64 * word64 -> word64)
	       * word64 = 
      (*!, *, +!, x_3580)
   val bigMul: intInf * intInf -> intInf = 
      make x_3581
   val rec 
      bigQuot: intInf * intInf -> intInf = 
	 fn x_1118: intInf * intInf => 
	 let
	    val den: intInf = 
	       #1 x_1118
	    val num: intInf = 
	       #0 x_1118
	    val x_3582: intInf * intInf = 
	       (num, den)
	    val x_3583: bool = 
	       areSmall x_3582
	    val x_3584: intInf = 
	       case x_3583 of
	       true => 
		  let
		     val numw: word64 = 
			dropTagCoerce num
		     val numi: word64 = 
			zextdFromWord64ToInt64 numw
		     val denw: word64 = 
			dropTagCoerce den
		     val deni: word64 = 
			zextdFromWord64ToInt64 denw
		     val x_3599: word64 * word64 = 
			(numw, badObjptrWord)
		     val x_3600: bool = 
			= (word64) x_3599
		     val x_3601: bool = 
			case x_3600 of
			true => 
			   let
			      val x_3603: word64 = 
				 0xFFFFFFFFFFFFFFFF
			      val x_3604: word64 * word64 = 
				 (deni, x_3603)
			      val x_3605: bool = 
				 = (word64) x_3604
			   in
			      x_3605
			   end
			false => 
			   let
			      val x_3602: bool = 
				 false
			   in
			      x_3602
			   end
		     val x_3606: intInf = 
			case x_3601 of
			true => 
			   let
			   in
			      negBadIntInf
			   end
			false => 
			   let
			      val x_3607: word64 * word64 = 
				 (numi, deni)
			      val ansi: word64 = 
				 quot x_3607
			      val answ: word64 = 
				 zextdFromInt64ToWord64 ansi
			      val ans: word64 = 
				 addTag answ
			      val x_3608: intInf = 
				 fromWord ans
			   in
			      x_3608
			   end
		  in
		     x_3606
		  end
	       false => 
		  let
		     val nlimbs: word64 = 
			numLimbs num
		     val dlimbs: word64 = 
			numLimbs den
		     val x_3585: word64 * word64 = 
			(nlimbs, dlimbs)
		     val x_3586: bool = 
			< x_3585
		     val x_3587: intInf = 
			case x_3586 of
			true => 
			   let
			   in
			      zero
			   end
			false => 
			   let
			      val x_3588: intInf * intInf = 
				 (den, zero)
			      val x_3589: bool = 
				 = (intInf) x_3588
			      val x_3590: intInf = 
				 case x_3589 of
				 true => 
				    let
				       val x_3597: exn = 
					  Div
				       val x_3598: intInf = 
					  raise x_3597
				    in
				       x_3598
				    end
				 false => 
				    let
				       val x_3591: word64 * word64 = 
					  (nlimbs, dlimbs)
				       val x_3592: word64 = 
					  -! x_3591
				       val x_3593: word64 = 
					  0x2
				       val x_3594: word64 * word64 = 
					  (x_3592, x_3593)
				       val x_3595: word64 = 
					  reserve x_3594
				       val x_3596: intInf = 
					  IntInf_quot (num, den, x_3595)
				    in
				       x_3596
				    end
			   in
			      x_3590
			   end
		  in
		     x_3587
		  end
	 in
	    x_3584
	 end
   val rec 'a 
      make: (word64 * word64 -> 'a) * (word32 * word32 -> 'a)
	    -> intInf * intInf -> 'a = 
	 fn x_1119: (word64 * word64 -> 'a) * (word32 * word32 -> 'a) => 
	 let
	    val x_3609: intInf * intInf -> 'a = 
	       fn x_1120: intInf * intInf => 
	       let
		  val x_3610: word32 * word32 -> 'a = 
		     #1 x_1119
		  val x_3611: word64 * word64 -> 'a = 
		     #0 x_1119
		  val x_3612: intInf = 
		     #1 x_1120
		  val x_3613: intInf = 
		     #0 x_1120
		  val x_3614: intInf * intInf = 
		     (x_3613, x_3612)
		  val x_3615: bool = 
		     areSmall x_3614
		  val x_3616: 'a = 
		     case x_3615 of
		     true => 
			let
			   val x_3621: word64 = 
			      toWord x_3613
			   val x_3622: word64 = 
			      zextdFromWord64ToInt64 x_3621
			   val x_3623: word64 = 
			      toWord x_3612
			   val x_3624: word64 = 
			      zextdFromWord64ToInt64 x_3623
			   val x_3625: word64 * word64 = 
			      (x_3622, x_3624)
			   val x_3626: 'a = 
			      x_3611 x_3625
			in
			   x_3626
			end
		     false => 
			let
			   val x_3617: word32 = 
			      IntInf_compare (x_3613, x_3612)
			   val x_3618: word32 = 
			      0x0
			   val x_3619: word32 * word32 = 
			      (x_3617, x_3618)
			   val x_3620: 'a = 
			      x_3610 x_3619
			in
			   x_3620
			end
	       in
		  x_3616
	       end
	 in
	    x_3609
	 end
   val x_3627: (word64 * word64 -> bool) * (word32 * word32 -> bool) = 
      (<, <)
   val bigLT: intInf * intInf -> bool = 
      make (bool) x_3627
   val rec 
      mkBigCvt: word32 * (word64 -> word8 vector) -> intInf -> word8 vector = 
	 fn x_1121: word32 * (word64 -> word8 vector) => 
	 let
	    val x_3628: intInf -> word8 vector = 
	       fn x_1122: intInf => 
	       let
		  val x_3629: word64 -> word8 vector = 
		     #1 x_1121
		  val x_3630: word32 = 
		     #0 x_1121
		  val x_3631: bool = 
		     isSmall x_1122
		  val x_3632: word8 vector = 
		     case x_3631 of
		     true => 
			let
			   val x_3736: word64 = 
			      dropTagCoerce x_1122
			   val x_3737: word64 = 
			      zextdFromWord64ToInt64 x_3736
			   val x_3738: word8 vector = 
			      x_3629 x_3737
			in
			   x_3738
			end
		     false => 
			let
			   val x_3633: word32 = 
			      idFromInt32ToWord32 x_3630
			   val rec 
			      loop: word32 * word32 * word32 -> word32 = 
				 fn x_888: word32 * word32 * word32 => 
				 let
				    val acc: word32 = 
				       #2 x_888
				    val s: word32 = 
				       #1 x_888
				    val n: word32 = 
				       #0 x_888
				    val x_3634: word32 * word32 = 
				       (n, one)
				    val x_3635: bool = 
				       = (word32) x_3634
				    val x_3636: word32 = 
				       case x_3635 of
				       true => 
					  let
					  in
					     acc
					  end
				       false => 
					  let
					     val x_3637: word32 * word32 = 
						(one, s)
					     val x_3638: word32 = 
						<<? x_3637
					     val x_3639: word32 * word32 = 
						(n, x_3638)
					     val x_3640: bool = 
						>= x_3639
					     val x_3641: word32 * word32 = 
						case x_3640 of
						true => 
						   let
						      val x_3643: word32
								  * word32 = 
							 (n, s)
						      val x_3644: word32 = 
							 >>? x_3643
						      val x_3645: word32 = 
							 Word32_add (acc, s)
						      val x_3646: word32
								  * word32 = 
							 (x_3644, x_3645)
						   in
						      x_3646
						   end
						false => 
						   let
						      val x_3642: word32
								  * word32 = 
							 (n, acc)
						   in
						      x_3642
						   end
					     val acc: word32 = 
						#1 x_3641
					     val n: word32 = 
						#0 x_3641
					     val x_3647: word32 = 
						0x1
					     val x_3648: word32 * word32 = 
						(s, x_3647)
					     val x_3649: word32 = 
						>>? x_3648
					     val x_3650: word32
							 * word32
							 * word32 = 
						(n, x_3649, acc)
					     val x_3651: word32 = 
						loop x_3650
					  in
					     x_3651
					  end
				 in
				    x_3636
				 end
			   val x_3652: word32 * word32 = 
			      (x_3633, zero)
			   val x_3653: bool = 
			      = (word32) x_3652
			   val x_3654: word32 = 
			      case x_3653 of
			      true => 
				 let
				    val x_3661: exn = 
				       Domain
				    val x_3662: word32 = 
				       raise x_3661
				 in
				    x_3662
				 end
			      false => 
				 let
				    val x_3655: word32 = 
				       0x1
				    val x_3656: word32 * word32 = 
				       (sizeInBitsWord, x_3655)
				    val x_3657: word32 = 
				       >>? x_3656
				    val x_3658: word32 = 
				       0x0
				    val x_3659: word32 * word32 * word32 = 
				       (x_3633, x_3657, x_3658)
				    val x_3660: word32 = 
				       loop x_3659
				 in
				    x_3660
				 end
			   val x_3663: word32 = 
			      zextdFromWord32ToInt32 x_3654
			   val x_3664: word32 * word32 = 
			      (sizeInBits, x_3663)
			   val x_3665: word32 = 
			      quot x_3664
			   val x_3666: word32 * word32 = 
			      (sizeInBits, zero)
			   val x_3667: bool = 
			      >= x_3666
			   val x_3668: word32 = 
			      case x_3667 of
			      true => 
				 let
				    val x_3695: word32 * word32 = 
				       (x_3663, zero)
				    val x_3696: bool = 
				       > x_3695
				    val x_3697: word32 = 
				       case x_3696 of
				       true => 
					  let
					     val x_3714: word32 * word32 = 
						(sizeInBits, x_3663)
					     val x_3715: word32 = 
						remUnsafe x_3714
					  in
					     x_3715
					  end
				       false => 
					  let
					     val x_3698: word32 * word32 = 
						(x_3663, zero)
					     val x_3699: bool = 
						< x_3698
					     val x_3700: word32 = 
						case x_3699 of
						true => 
						   let
						      val x_3703: word32
								  * word32 = 
							 (sizeInBits, zero)
						      val x_3704: bool = 
							 = (word32) x_3703
						      val x_3705: word32 = 
							 case x_3704 of
							 true => 
							    let
							    in
							       zero
							    end
							 false => 
							    let
							       val x_3706: word32
									   * word32 = 
								  (sizeInBits,
								   one)
							       val x_3707: word32 = 
								  -? x_3706
							       val x_3708: word32
									   * word32 = 
								  (x_3707,
								   x_3663)
							       val x_3709: word32 = 
								  remUnsafe x_3708
							       val x_3710: word32
									   * word32 = 
								  (x_3663, one)
							       val x_3711: word32 = 
								  +! x_3710
							       val x_3712: word32
									   * word32 = 
								  (x_3709,
								   x_3711)
							       val x_3713: word32 = 
								  +? x_3712
							    in
							       x_3713
							    end
						   in
						      x_3705
						   end
						false => 
						   let
						      val x_3701: exn = 
							 Div
						      val x_3702: word32 = 
							 raise x_3701
						   in
						      x_3702
						   end
					  in
					     x_3700
					  end
				 in
				    x_3697
				 end
			      false => 
				 let
				    val x_3669: word32 * word32 = 
				       (x_3663, zero)
				    val x_3670: bool = 
				       < x_3669
				    val x_3671: word32 = 
				       case x_3670 of
				       true => 
					  let
					     val x_3685: word32 * word32 = 
						(sizeInBits, minInt')
					     val x_3686: bool = 
						= (word32) x_3685
					     val x_3687: bool = 
						case x_3686 of
						true => 
						   let
						      val x_3689: word32 = 
							 ~! one
						      val x_3690: word32
								  * word32 = 
							 (x_3663, x_3689)
						      val x_3691: bool = 
							 = (word32) x_3690
						   in
						      x_3691
						   end
						false => 
						   let
						      val x_3688: bool = 
							 false
						   in
						      x_3688
						   end
					     val x_3692: word32 = 
						case x_3687 of
						true => 
						   let
						   in
						      zero
						   end
						false => 
						   let
						      val x_3693: word32
								  * word32 = 
							 (sizeInBits, x_3663)
						      val x_3694: word32 = 
							 remUnsafe x_3693
						   in
						      x_3694
						   end
					  in
					     x_3692
					  end
				       false => 
					  let
					     val x_3672: word32 * word32 = 
						(x_3663, zero)
					     val x_3673: bool = 
						> x_3672
					     val x_3674: word32 = 
						case x_3673 of
						true => 
						   let
						      val x_3677: word32
								  * word32 = 
							 (sizeInBits, one)
						      val x_3678: word32 = 
							 +? x_3677
						      val x_3679: word32
								  * word32 = 
							 (x_3678, x_3663)
						      val x_3680: word32 = 
							 remUnsafe x_3679
						      val x_3681: word32
								  * word32 = 
							 (x_3663, one)
						      val x_3682: word32 = 
							 -? x_3681
						      val x_3683: word32
								  * word32 = 
							 (x_3680, x_3682)
						      val x_3684: word32 = 
							 +? x_3683
						   in
						      x_3684
						   end
						false => 
						   let
						      val x_3675: exn = 
							 Div
						      val x_3676: word32 = 
							 raise x_3675
						   in
						      x_3676
						   end
					  in
					     x_3674
					  end
				 in
				    x_3671
				 end
			   val x_3716: word32 = 
			      0x0
			   val x_3717: word32 * word32 = 
			      (x_3668, x_3716)
			   val x_3718: bool = 
			      = (word32) x_3717
			   val x_3719: word32 = 
			      case x_3718 of
			      true => 
				 let
				    val x_3721: word32 = 
				       0x0
				 in
				    x_3721
				 end
			      false => 
				 let
				    val x_3720: word32 = 
				       0x1
				 in
				    x_3720
				 end
			   val x_3722: word32 * word32 = 
			      (x_3665, x_3719)
			   val dpl: word32 = 
			      +! x_3722
			   val x_3723: word64 = 
			      0x1
			   val x_3724: word64 = 
			      0x7
			   val x_3725: word64 * word64 = 
			      (x_3723, x_3724)
			   val x_3726: word64 = 
			      + x_3725
			   val x_3727: word64 * word64 = 
			      (bytesPerArrayHeader, x_3726)
			   val x_3728: word64 = 
			      + x_3727
			   val x_3729: word64 = 
			      zextdFromInt32ToWord64 dpl
			   val x_3730: word64 = 
			      numLimbs x_1122
			   val x_3731: word64 = 
			      zextdFromInt64ToWord64 x_3730
			   val x_3732: word64 * word64 = 
			      (x_3729, x_3731)
			   val x_3733: word64 = 
			      * x_3732
			   val x_3734: word64 * word64 = 
			      (x_3728, x_3733)
			   val bytes: word64 = 
			      + x_3734
			   val x_3735: word8 vector = 
			      IntInf_toString (x_1122, x_3630, bytes)
			in
			   x_3735
			end
	       in
		  x_3632
	       end
	 in
	    x_3628
	 end
   val 'a_765 precision: 'a_765 Primitive.Option.t = 
      let
	 val x_3739: 'a_765 Primitive.Option.t = 
	    NONE['a_765]
      in
	 x_3739
      end
   exception Chr
   exception Fail of word8 vector
   val 'a_2059 !: 'a_2059 ref -> 'a_2059 = 
      let
      in
	 deref ('a_2059)
      end
   val 'a_2060 :=: 'a_2060 ref * 'a_2060 -> unit = 
      let
      in
	 assign ('a_2060)
      end
   val rec ('a_2063, 'a_2062, 'a_2061) 
      o: ('a_2063 -> 'a_2062) * ('a_2061 -> 'a_2063) -> 'a_2061 -> 'a_2062 = 
	 fn x_1123: ('a_2063 -> 'a_2062) * ('a_2061 -> 'a_2063) => 
	 let
	    val x_3740: 'a_2061 -> 'a_2062 = 
	       fn x_1124: 'a_2061 => 
	       let
		  val x_3741: 'a_2061 -> 'a_2063 = 
		     #1 x_1123
		  val x_3742: 'a_2063 -> 'a_2062 = 
		     #0 x_1123
		  val x_3743: 'a_2063 = 
		     x_3741 x_1124
		  val x_3744: 'a_2062 = 
		     x_3742 x_3743
	       in
		  x_3744
	       end
	 in
	    x_3740
	 end
   val rec 'a_2064 
      before: 'a_2064 * unit -> 'a_2064 = 
	 fn x_1125: 'a_2064 * unit => 
	 let
	    val x_3745: 'a_2064 = 
	       #0 x_1125
	 in
	    x_3745
	 end
   val rec 'a_2065 
      ignore: 'a_2065 -> unit = 
	 fn x_1126: 'a_2065 => 
	 let
	    val x_3746: unit = 
	       ()
	 in
	    x_3746
	 end
   val x_3747: (exn -> word8 vector Primitive.Option.t) list = 
      nil[exn -> word8 vector Primitive.Option.t]
   val messagers: (exn -> word8 vector Primitive.Option.t) list ref = 
      Ref_ref[(exn -> word8 vector Primitive.Option.t) list] (x_3747)
   val addExnMessager: (exn -> word8 vector Primitive.Option.t) -> unit = 
      fn x_1127: exn -> word8 vector Primitive.Option.t => 
      let
	 val x_3748: (exn -> word8 vector Primitive.Option.t) list = 
	    ! ((exn -> word8 vector Primitive.Option.t) list) messagers
	 val x_3749: (exn -> word8 vector Primitive.Option.t)
		     * (exn -> word8 vector Primitive.Option.t) list = 
	    (x_1127, x_3748)
	 val x_3750: (exn -> word8 vector Primitive.Option.t) list = 
	    ::[exn -> word8 vector Primitive.Option.t] x_3749
	 val x_3751: (exn -> word8 vector Primitive.Option.t) list ref
		     * (exn -> word8 vector Primitive.Option.t) list = 
	    (messagers, x_3750)
	 val x_3752: unit = 
	    := ((exn -> word8 vector Primitive.Option.t) list) x_3751
      in
	 x_3752
      end
   val rec 
      exnMessage: exn -> word8 vector = 
	 fn x_1128: exn => 
	 let
	    val rec 
	       find: (exn -> word8 vector Primitive.Option.t) list
		     -> word8 vector = 
		  fn x_1129: (exn -> word8 vector Primitive.Option.t) list => 
		  let
		     val x_3753: word8 vector = 
			case x_1129 of
			nil[exn -> word8 vector Primitive.Option.t] => 
			   let
			      val x_3761: word8 vector = 
				 name x_1128
			   in
			      x_3761
			   end
			::[exn -> word8 vector Primitive.Option.t] x_3754: (exn
									    -> word8 vector Primitive.Option.t)
									   * (exn
									      -> word8 vector Primitive.Option.t) list => 
			   let
			      val x_3755: (exn
					   -> word8 vector Primitive.Option.t) list = 
				 #1 x_3754
			      val x_3756: exn -> word8 vector Primitive.Option.t = 
				 #0 x_3754
			      val x_3757: word8 vector Primitive.Option.t = 
				 x_3756 x_1128
			      val x_3758: word8 vector = 
				 case x_3757 of
				 NONE[word8 vector] => 
				    let
				       val x_3760: word8 vector = 
					  find x_3755
				    in
				       x_3760
				    end
				 SOME[word8 vector] x_3759: word8 vector => 
				    let
				    in
				       x_3759
				    end
			   in
			      x_3758
			   end
		  in
		     x_3753
		  end
	    val x_3762: (exn -> word8 vector Primitive.Option.t) list = 
	       ! ((exn -> word8 vector Primitive.Option.t) list) messagers
	    val x_3763: word8 vector = 
	       find x_3762
	 in
	    x_3763
	 end
   val ('a, 'c, 'b) o_0: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = 
      let
      in
	 o ('b, 'c, 'a)
      end
   val 'a ignore_0: 'a -> unit = 
      let
      in
	 ignore ('a)
      end
   val 'a before_0: 'a * unit -> 'a = 
      let
      in
	 before ('a)
      end
   val 'a :=_0: 'a ref * 'a -> unit = 
      let
      in
	 := ('a)
      end
   val 'a !_0: 'a ref -> 'a = 
      let
      in
	 ! ('a)
      end
   val ('a, 'c, 'b) o_1: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = 
      let
      in
	 o_0 ('a, 'c, 'b)
      end
   val 'a ignore_1: 'a -> unit = 
      let
      in
	 ignore_0 ('a)
      end
   val 'a before_1: 'a * unit -> 'a = 
      let
      in
	 before_0 ('a)
      end
   val 'a :=_1: 'a ref * 'a -> unit = 
      let
      in
	 :=_0 ('a)
      end
   val 'a !_1: 'a ref -> 'a = 
      let
      in
	 !_0 ('a)
      end
   val rec 'a_2066 
      make: (unit -> 'a_2066) -> 'a_2066 One.t = 
	 fn x_1130: unit -> 'a_2066 => 
	 let
	    val x_3764: unit = 
	       ()
	    val x_3765: 'a_2066 = 
	       x_1130 x_3764
	    val x_3766: bool = 
	       false
	    val x_3767: bool ref = 
	       Ref_ref[bool] (x_3766)
	    val x_3768: (unit -> 'a_2066) * 'a_2066 * bool ref = 
	       (x_1130, x_3765, x_3767)
	    val x_3769: 'a_2066 One.t = 
	       T['a_2066] x_3768
	 in
	    x_3769
	 end
   val rec ('a_2068, 'a_2067) 
      use: 'a_2068 One.t * ('a_2068 -> 'a_2067) -> 'a_2067 = 
	 fn x_1131: 'a_2068 One.t * ('a_2068 -> 'a_2067) => 
	 let
	    val x_3770: 'a_2068 -> 'a_2067 = 
	       #1 x_1131
	    val x_3771: 'a_2068 One.t = 
	       #0 x_1131
	    val x_3772: 'a_2067 = 
	       case x_3771 of
	       T['a_2068] x_3773: (unit -> 'a_2068) * 'a_2068 * bool ref => 
		  let
		     val x_3774: bool ref = 
			#2 x_3773
		     val x_3775: 'a_2068 = 
			#1 x_3773
		     val x_3776: unit -> 'a_2068 = 
			#0 x_3773
		     val x_3777: unit = 
			()
		     val x_3778: unit = 
			atomicBegin x_3777
		     val b: bool = 
			!_1 (bool) x_3774
		     val x_3779: 'a_2068 = 
			case b of
			true => 
			   let
			      val x_3785: unit = 
				 ()
			      val x_3786: unit = 
				 atomicEnd x_3785
			      val x_3787: unit = 
				 ()
			      val x_3788: 'a_2068 = 
				 x_3776 x_3787
			   in
			      x_3788
			   end
			false => 
			   let
			      val x_3780: bool = 
				 true
			      val x_3781: bool ref * bool = 
				 (x_3774, x_3780)
			      val x_3782: unit = 
				 :=_1 (bool) x_3781
			      val x_3783: unit = 
				 ()
			      val x_3784: unit = 
				 atomicEnd x_3783
			   in
			      x_3775
			   end
		     val x_3789: unit -> 'a_2067 = 
			fn x_1133: unit => 
			let
			   val x_3790: 'a_2067 = 
			      x_3770 x_3779
			in
			   x_3790
			end
		     val x_3791: unit -> unit = 
			fn x_1132: unit => 
			let
			   val x_3792: unit = 
			      case b of
			      true => 
				 let
				    val x_3796: unit = 
				       ()
				 in
				    x_3796
				 end
			      false => 
				 let
				    val x_3793: bool = 
				       false
				    val x_3794: bool ref * bool = 
				       (x_3774, x_3793)
				    val x_3795: unit = 
				       :=_1 (bool) x_3794
				 in
				    x_3795
				 end
			in
			   x_3792
			end
		     val x_3797: (unit -> 'a_2067) * (unit -> unit) = 
			(x_3789, x_3791)
		     val x_3798: 'a_2067 = 
			wind_0 ('a_2067) x_3797
		  in
		     x_3798
		  end
	 in
	    x_3772
	 end
   val ('b, 'a) use_0: 'a One.t * ('a -> 'b) -> 'b = 
      let
      in
	 use ('a, 'b)
      end
   val 'a make_0: (unit -> 'a) -> 'a One.t = 
      let
      in
	 make ('a)
      end
   exception Option
   val rec ('a_2073, 'a_2072) 
      map: ('a_2073 -> 'a_2072)
	   -> 'a_2073 Primitive.Option.t -> 'a_2072 Primitive.Option.t = 
	 fn x_1134: 'a_2073 -> 'a_2072 => 
	 let
	    val x_3799: 'a_2073 Primitive.Option.t -> 'a_2072 Primitive.Option.t = 
	       fn x_1135: 'a_2073 Primitive.Option.t => 
	       let
		  val x_3800: 'a_2072 Primitive.Option.t = 
		     case x_1135 of
		     NONE['a_2073] => 
			let
			   val x_3804: 'a_2072 Primitive.Option.t = 
			      NONE['a_2072]
			in
			   x_3804
			end
		     SOME['a_2073] x_3801: 'a_2073 => 
			let
			   val x_3802: 'a_2072 = 
			      x_1134 x_3801
			   val x_3803: 'a_2072 Primitive.Option.t = 
			      SOME['a_2072] x_3802
			in
			   x_3803
			end
	       in
		  x_3800
	       end
	 in
	    x_3799
	 end
   val 'a_2088 valOf: 'a_2088 Primitive.Option.t -> 'a_2088 = 
      let
	 val x_3805: 'a_2088 Primitive.Option.t -> 'a_2088 = 
	    fn x_1136: 'a_2088 Primitive.Option.t => 
	    let
	       val x_3806: 'a_2088 = 
		  case x_1136 of
		  NONE['a_2088] => 
		     let
			val x_3808: exn = 
			   Option
			val x_3809: 'a_2088 = 
			   raise x_3808
		     in
			x_3809
		     end
		  SOME['a_2088] x_3807: 'a_2088 => 
		     let
		     in
			x_3807
		     end
	    in
	       x_3806
	    end
      in
	 x_3805
      end
   val 'a valOf_0: 'a Primitive.Option.t -> 'a = 
      let
      in
	 valOf ('a)
      end
   val ('b, 'a) map_0: ('a -> 'b)
		       -> 'a Primitive.Option.t -> 'b Primitive.Option.t = 
      let
      in
	 map ('a, 'b)
      end
   val 'a valOf_1: 'a Primitive.Option.t -> 'a = 
      let
      in
	 valOf_0 ('a)
      end
   exception Empty
   val rec ('a_2099, 'a_2098) 
      foldl: ('a_2099 * 'a_2098 -> 'a_2098)
	     -> 'a_2098 -> 'a_2099 list -> 'a_2098 = 
	 fn x_1137: 'a_2099 * 'a_2098 -> 'a_2098 => 
	 let
	    val x_3810: 'a_2098 -> 'a_2099 list -> 'a_2098 = 
	       fn x_1138: 'a_2098 => 
	       let
		  val x_3811: 'a_2099 list -> 'a_2098 = 
		     fn x_1139: 'a_2099 list => 
		     let
			val rec 
			   loop: 'a_2099 list * 'a_2098 -> 'a_2098 = 
			      fn x_1140: 'a_2099 list * 'a_2098 => 
			      let
				 val b: 'a_2098 = 
				    #1 x_1140
				 val l: 'a_2099 list = 
				    #0 x_1140
				 val x_3812: 'a_2098 = 
				    case l of
				    nil['a_2099] => 
				       let
				       in
					  b
				       end
				    ::['a_2099] x_3813: 'a_2099 * 'a_2099 list => 
				       let
					  val x_3814: 'a_2099 list = 
					     #1 x_3813
					  val x_3815: 'a_2099 = 
					     #0 x_3813
					  val x_3816: 'a_2099 * 'a_2098 = 
					     (x_3815, b)
					  val x_3817: 'a_2098 = 
					     x_1137 x_3816
					  val x_3818: 'a_2099 list * 'a_2098 = 
					     (x_3814, x_3817)
					  val x_3819: 'a_2098 = 
					     loop x_3818
				       in
					  x_3819
				       end
			      in
				 x_3812
			      end
			val x_3820: 'a_2099 list * 'a_2098 = 
			   (x_1139, x_1138)
			val x_3821: 'a_2098 = 
			   loop x_3820
		     in
			x_3821
		     end
	       in
		  x_3811
	       end
	 in
	    x_3810
	 end
   val rec 'a_2100 
      length: 'a_2100 list -> word32 = 
	 fn x_1141: 'a_2100 list => 
	 let
	    val x_3822: 'a_2100 * word32 -> word32 = 
	       fn x_1142: 'a_2100 * word32 => 
	       let
		  val x_3823: word32 = 
		     #1 x_1142
		  val x_3824: word32 = 
		     0x1
		  val x_3825: word32 * word32 = 
		     (x_3823, x_3824)
		  val x_3826: word32 = 
		     +? x_3825
	       in
		  x_3826
	       end
	    val x_3827: word32 -> 'a_2100 list -> word32 = 
	       foldl ('a_2100, word32) x_3822
	    val x_3828: word32 = 
	       0x0
	    val x_3829: 'a_2100 list -> word32 = 
	       x_3827 x_3828
	    val x_3830: word32 = 
	       x_3829 x_1141
	 in
	    x_3830
	 end
   val rec 'a_2101 
      appendRev: 'a_2101 list * 'a_2101 list -> 'a_2101 list = 
	 fn x_1143: 'a_2101 list * 'a_2101 list => 
	 let
	    val l2: 'a_2101 list = 
	       #1 x_1143
	    val l1: 'a_2101 list = 
	       #0 x_1143
	    val x_3831: 'a_2101 * 'a_2101 list -> 'a_2101 list = 
	       fn x_3832: 'a_2101 * 'a_2101 list => 
	       let
		  val x_3833: 'a_2101 list = 
		     ::['a_2101] x_3832
	       in
		  x_3833
	       end
	    val x_3834: 'a_2101 list -> 'a_2101 list -> 'a_2101 list = 
	       foldl ('a_2101, 'a_2101 list) x_3831
	    val x_3835: 'a_2101 list -> 'a_2101 list = 
	       x_3834 l2
	    val x_3836: 'a_2101 list = 
	       x_3835 l1
	 in
	    x_3836
	 end
   val rec 'a_2103 
      rev: 'a_2103 list -> 'a_2103 list = 
	 fn x_1144: 'a_2103 list => 
	 let
	    val x_3837: 'a_2103 list = 
	       nil['a_2103]
	    val x_3838: 'a_2103 list * 'a_2103 list = 
	       (x_1144, x_3837)
	    val x_3839: 'a_2103 list = 
	       appendRev ('a_2103) x_3838
	 in
	    x_3839
	 end
   val rec 'a_2108 
      app: ('a_2108 -> unit) -> 'a_2108 list -> unit = 
	 fn x_1145: 'a_2108 -> unit => 
	 let
	    val x_3840: 'a_2108 * unit -> 'a_2108 = 
	       fn x_1146: 'a_2108 * unit => 
	       let
		  val x_3841: 'a_2108 = 
		     #0 x_1146
	       in
		  x_3841
	       end
	    val x_3842: ('a_2108 -> unit) * ('a_2108 * unit -> 'a_2108) = 
	       (x_1145, x_3840)
	    val x_3843: 'a_2108 * unit -> unit = 
	       o_1 ('a_2108 * unit, unit, 'a_2108) x_3842
	    val x_3844: unit -> 'a_2108 list -> unit = 
	       foldl ('a_2108, unit) x_3843
	    val x_3845: unit = 
	       ()
	    val x_3846: 'a_2108 list -> unit = 
	       x_3844 x_3845
	 in
	    x_3846
	 end
   val rec ('a_2110, 'a_2109) 
      map: ('a_2110 -> 'a_2109) -> 'a_2110 list -> 'a_2109 list = 
	 fn x_1147: 'a_2110 -> 'a_2109 => 
	 let
	    val x_3847: 'a_2110 list -> 'a_2109 list = 
	       fn x_1148: 'a_2110 list => 
	       let
		  val x_3848: 'a_2110 * 'a_2109 list -> 'a_2109 list = 
		     fn x_1149: 'a_2110 * 'a_2109 list => 
		     let
			val l: 'a_2109 list = 
			   #1 x_1149
			val x: 'a_2110 = 
			   #0 x_1149
			val x_3849: 'a_2109 = 
			   x_1147 x
			val x_3850: 'a_2109 * 'a_2109 list = 
			   (x_3849, l)
			val x_3851: 'a_2109 list = 
			   ::['a_2109] x_3850
		     in
			x_3851
		     end
		  val x_3852: 'a_2109 list -> 'a_2110 list -> 'a_2109 list = 
		     foldl ('a_2110, 'a_2109 list) x_3848
		  val x_3853: 'a_2109 list = 
		     nil['a_2109]
		  val x_3854: 'a_2110 list -> 'a_2109 list = 
		     x_3852 x_3853
		  val x_3855: 'a_2109 list = 
		     x_3854 x_1148
		  val x_3856: 'a_2109 list = 
		     rev ('a_2109) x_3855
	       in
		  x_3856
	       end
	 in
	    x_3847
	 end
   val rec 'a_2115 
      find: ('a_2115 -> bool) -> 'a_2115 list -> 'a_2115 Primitive.Option.t = 
	 fn x_1150: 'a_2115 -> bool => 
	 let
	    val rec 
	       loop: 'a_2115 list -> 'a_2115 Primitive.Option.t = 
		  fn x_1151: 'a_2115 list => 
		  let
		     val x_3857: 'a_2115 Primitive.Option.t = 
			case x_1151 of
			nil['a_2115] => 
			   let
			      val x_3865: 'a_2115 Primitive.Option.t = 
				 NONE['a_2115]
			   in
			      x_3865
			   end
			::['a_2115] x_3858: 'a_2115 * 'a_2115 list => 
			   let
			      val x_3859: 'a_2115 list = 
				 #1 x_3858
			      val x_3860: 'a_2115 = 
				 #0 x_3858
			      val x_3861: bool = 
				 x_1150 x_3860
			      val x_3862: 'a_2115 Primitive.Option.t = 
				 case x_3861 of
				 true => 
				    let
				       val x_3864: 'a_2115 Primitive.Option.t = 
					  SOME['a_2115] x_3860
				    in
				       x_3864
				    end
				 false => 
				    let
				       val x_3863: 'a_2115 Primitive.Option.t = 
					  loop x_3859
				    in
				       x_3863
				    end
			   in
			      x_3862
			   end
		  in
		     x_3857
		  end
	 in
	    loop
	 end
   val 'a rev_0: 'a list -> 'a list = 
      let
      in
	 rev ('a)
      end
   val ('b, 'a) map_1: ('a -> 'b) -> 'a list -> 'b list = 
      let
      in
	 map ('a, 'b)
      end
   val 'a length_4: 'a list -> word32 = 
      let
      in
	 length ('a)
      end
   val ('b, 'a) foldl_1: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b = 
      let
      in
	 foldl ('a, 'b)
      end
   val 'a find_0: ('a -> bool) -> 'a list -> 'a Primitive.Option.t = 
      let
      in
	 find ('a)
      end
   val 'a app_0: ('a -> unit) -> 'a list -> unit = 
      let
      in
	 app ('a)
      end
   val 'a rev_1: 'a list -> 'a list = 
      let
      in
	 rev_0 ('a)
      end
   val ('b, 'a) map_2: ('a -> 'b) -> 'a list -> 'b list = 
      let
      in
	 map_1 ('b, 'a)
      end
   val 'a app_1: ('a -> unit) -> 'a list -> unit = 
      let
      in
	 app_0 ('a)
      end
   exception UnequalLengths
   val 'a unsafeSub_3: 'a vector * word64 -> 'a = 
      let
      in
	 unsafeSub_0 ('a)
      end
   val ('a, 'b) unfoldi_2: word64 * 'b * (word64 * 'b -> 'a * 'b)
			   -> 'a vector * 'b = 
      let
      in
	 unfoldi_0 ('a, 'b)
      end
   val ('a, 'b) unfold_2: word64 * 'b * ('b -> 'a * 'b) -> 'a vector * 'b = 
      let
      in
	 unfold_0 ('a, 'b)
      end
   val 'a length_5: 'a vector -> word64 = 
      let
      in
	 length ('a)
      end
   val 'a unsafeSubslice_2: 'a PrimSequence.Slice.t
			    * word64
			    * word64 Primitive.Option.t
			    -> 'a PrimSequence.Slice.t = 
      let
      in
	 unsafeSubslice_0 ('a)
      end
   val 'a unsafeSub_4: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 unsafeSub_1 ('a)
      end
   val 'a taker_1: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 taker_0 ('a)
      end
   val 'a takel_1: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 takel_0 ('a)
      end
   val 'a subslice_2: 'a PrimSequence.Slice.t
		      * word64
		      * word64 Primitive.Option.t
		      -> 'a PrimSequence.Slice.t = 
      let
      in
	 subslice_0 ('a)
      end
   val 'a sub_2: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 sub_0 ('a)
      end
   val 'a sequence_1: 'a PrimSequence.Slice.t -> 'a vector = 
      let
      in
	 sequence_0 ('a)
      end
   val 'a length_6: 'a PrimSequence.Slice.t -> word64 = 
      let
      in
	 length_1 ('a)
      end
   val 'a full_2: 'a vector -> 'a PrimSequence.Slice.t = 
      let
      in
	 full_0 ('a)
      end
   val ('b, 'a) foldl_2: ('a * 'b -> 'b) -> 'b -> 'a PrimSequence.Slice.t -> 'b = 
      let
      in
	 foldl_0 ('b, 'a)
      end
   val 'a exists_1: ('a -> bool) -> 'a PrimSequence.Slice.t -> bool = 
      let
      in
	 exists_0 ('a)
      end
   val 'a dropr_1: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 dropr_0 ('a)
      end
   val 'a base_2: 'a PrimSequence.Slice.t -> 'a vector * word64 * word64 = 
      let
      in
	 base_0 ('a)
      end
   val 'a append_1: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t
		    -> 'a vector = 
      let
      in
	 append_0 ('a)
      end
   val rec ('a_2331, 'a_2330) 
      wrap2: (word32 * 'a_2331 -> 'a_2330) -> word64 * 'a_2331 -> 'a_2330 = 
	 fn x_1152: word32 * 'a_2331 -> 'a_2330 => 
	 let
	    val x_3866: word64 * 'a_2331 -> 'a_2330 = 
	       fn x_1153: word64 * 'a_2331 => 
	       let
		  val x: 'a_2331 = 
		     #1 x_1153
		  val i: word64 = 
		     #0 x_1153
		  val x_3867: word32 = 
		     sextdFromInt64ToInt32 i
		  val x_3868: word32 * 'a_2331 = 
		     (x_3867, x)
		  val x_3869: 'a_2330 = 
		     x_1152 x_3868
	       in
		  x_3869
	       end
	 in
	    x_3866
	 end
   val rec 
      fromIntForLength: word32 -> word64 = 
	 fn x_1154: word32 => 
	 let
	    val x_3870: word64 = 
	       let
		  val x_3871: word64 = 
		     sextdFromInt32ToInt64 x_1154
	       in
		  x_3871
	       end
	       handle x_1155 => let
				   val x_3872: word64 = 
				      case x_1155 of
				      Overflow => 
					 let
					    val x_3873: exn = 
					       Size
					    val x_3874: word64 = 
					       raise x_3873
					 in
					    x_3874
					 end
					_ => let
						val x_3875: word64 = 
						   raise x_1155
					     in
						x_3875
					     end
				in
				   x_3872
				end
	 in
	    x_3870
	 end
   val rec 'a_2338 
      length: 'a_2338 vector -> word32 = 
	 fn x_1156: 'a_2338 vector => 
	 let
	    val x_3876: word32 = 
	       let
		  val x_3877: word64 = 
		     length_5 ('a_2338) x_1156
		  val x_3878: word32 = 
		     schckFromInt64ToInt32 x_3877
	       in
		  x_3878
	       end
	       handle x_1157 => let
				   val x_3879: word32 = 
				      case x_1157 of
				      Overflow => 
					 let
					    val x_3880: word8 vector = 
					       "Sequence.length"
					    val x_3881: exn = 
					       Fail x_3880
					    val x_3882: word32 = 
					       raise x_3881
					 in
					    x_3882
					 end
					_ => let
						val x_3883: word32 = 
						   raise x_1157
					     in
						x_3883
					     end
				in
				   x_3879
				end
	 in
	    x_3876
	 end
   val rec ('a_2342, 'a_2341) 
      unfoldi: word32 * 'a_2341 * (word32 * 'a_2341 -> 'a_2342 * 'a_2341)
	       -> 'a_2342 vector * 'a_2341 = 
	 fn x_1158: word32 * 'a_2341 * (word32 * 'a_2341 -> 'a_2342 * 'a_2341) => 
	 let
	    val f: word32 * 'a_2341 -> 'a_2342 * 'a_2341 = 
	       #2 x_1158
	    val b: 'a_2341 = 
	       #1 x_1158
	    val n: word32 = 
	       #0 x_1158
	    val x_3884: word64 = 
	       fromIntForLength n
	    val x_3885: word64 * 'a_2341 -> 'a_2342 * 'a_2341 = 
	       wrap2 ('a_2341, 'a_2342 * 'a_2341) f
	    val x_3886: word64
			* 'a_2341
			* (word64 * 'a_2341 -> 'a_2342 * 'a_2341) = 
	       (x_3884, b, x_3885)
	    val x_3887: 'a_2342 vector * 'a_2341 = 
	       unfoldi_2 ('a_2342, 'a_2341) x_3886
	 in
	    x_3887
	 end
   val rec ('a_2344, 'a_2343) 
      unfold: word32 * 'a_2343 * ('a_2343 -> 'a_2344 * 'a_2343)
	      -> 'a_2344 vector * 'a_2343 = 
	 fn x_1159: word32 * 'a_2343 * ('a_2343 -> 'a_2344 * 'a_2343) => 
	 let
	    val f: 'a_2343 -> 'a_2344 * 'a_2343 = 
	       #2 x_1159
	    val b: 'a_2343 = 
	       #1 x_1159
	    val n: word32 = 
	       #0 x_1159
	    val x_3888: word64 = 
	       fromIntForLength n
	    val x_3889: word64 * 'a_2343 * ('a_2343 -> 'a_2344 * 'a_2343) = 
	       (x_3888, b, f)
	    val x_3890: 'a_2344 vector * 'a_2343 = 
	       unfold_2 ('a_2344, 'a_2343) x_3889
	 in
	    x_3890
	 end
   val rec 'a_2345 
      seq0: unit -> 'a_2345 vector = 
	 fn x_1160: unit => 
	 let
	    val x_3891: word32 = 
	       0x0
	    val x_3892: unit = 
	       ()
	    val x_3893: unit -> 'a_2345 * unit = 
	       fn x_1162: unit => 
	       let
		  val x_3894: word8 vector = 
		     "Sequence.seq0"
		  val x_3895: exn = 
		     Fail x_3894
		  val x_3896: 'a_2345 * unit = 
		     raise x_3895
	       in
		  x_3896
	       end
	    val x_3897: word32 * unit * (unit -> 'a_2345 * unit) = 
	       (x_3891, x_3892, x_3893)
	    val x_3898: 'a_2345 vector * unit = 
	       unfold ('a_2345, unit) x_3897
	    val x_3899: 'a_2345 vector = 
	       #0 x_3898
	 in
	    x_3899
	 end
   val rec 'a_2346 
      tabulate: word32 * (word32 -> 'a_2346) -> 'a_2346 vector = 
	 fn x_1163: word32 * (word32 -> 'a_2346) => 
	 let
	    val f: word32 -> 'a_2346 = 
	       #1 x_1163
	    val n: word32 = 
	       #0 x_1163
	    val x_3900: unit = 
	       ()
	    val x_3901: word32 * unit -> 'a_2346 * unit = 
	       fn x_1165: word32 * unit => 
	       let
		  val x_3902: word32 = 
		     #0 x_1165
		  val x_3903: 'a_2346 = 
		     f x_3902
		  val x_3904: unit = 
		     ()
		  val x_3905: 'a_2346 * unit = 
		     (x_3903, x_3904)
	       in
		  x_3905
	       end
	    val x_3906: word32 * unit * (word32 * unit -> 'a_2346 * unit) = 
	       (n, x_3900, x_3901)
	    val x_3907: 'a_2346 vector * unit = 
	       unfoldi ('a_2346, unit) x_3906
	    val x_3908: 'a_2346 vector = 
	       #0 x_3907
	 in
	    x_3908
	 end
   val rec 'a_2347 
      new: word32 * 'a_2347 -> 'a_2347 vector = 
	 fn x_1166: word32 * 'a_2347 => 
	 let
	    val x: 'a_2347 = 
	       #1 x_1166
	    val n: word32 = 
	       #0 x_1166
	    val x_3909: unit = 
	       ()
	    val x_3910: unit -> 'a_2347 * unit = 
	       fn x_1168: unit => 
	       let
		  val x_3911: unit = 
		     ()
		  val x_3912: 'a_2347 * unit = 
		     (x, x_3911)
	       in
		  x_3912
	       end
	    val x_3913: word32 * unit * (unit -> 'a_2347 * unit) = 
	       (n, x_3909, x_3910)
	    val x_3914: 'a_2347 vector * unit = 
	       unfold ('a_2347, unit) x_3913
	    val x_3915: 'a_2347 vector = 
	       #0 x_3914
	 in
	    x_3915
	 end
   val rec 'a_2348 
      fromList: 'a_2348 list -> 'a_2348 vector = 
	 fn x_1169: 'a_2348 list => 
	 let
	    val x_3916: word32 = 
	       length_4 ('a_2348) x_1169
	    val x_3917: 'a_2348 list -> 'a_2348 * 'a_2348 list = 
	       fn x_1171: 'a_2348 list => 
	       let
		  val x_3918: 'a_2348 * 'a_2348 list = 
		     case x_1171 of
		     nil['a_2348] => 
			let
			   val x_3923: word8 vector = 
			      "Sequence.fromList"
			   val x_3924: exn = 
			      Fail x_3923
			   val x_3925: 'a_2348 * 'a_2348 list = 
			      raise x_3924
			in
			   x_3925
			end
		     ::['a_2348] x_3919: 'a_2348 * 'a_2348 list => 
			let
			   val x_3920: 'a_2348 list = 
			      #1 x_3919
			   val x_3921: 'a_2348 = 
			      #0 x_3919
			   val x_3922: 'a_2348 * 'a_2348 list = 
			      (x_3921, x_3920)
			in
			   x_3922
			end
	       in
		  x_3918
	       end
	    val x_3926: word32
			* 'a_2348 list
			* ('a_2348 list -> 'a_2348 * 'a_2348 list) = 
	       (x_3916, x_1169, x_3917)
	    val x_3927: 'a_2348 vector * 'a_2348 list = 
	       unfold ('a_2348, 'a_2348 list) x_3926
	    val x_3928: 'a_2348 vector = 
	       #0 x_3927
	 in
	    x_3928
	 end
   val rec 'a_2349 
      length: 'a_2349 PrimSequence.Slice.t -> word32 = 
	 fn x_1172: 'a_2349 PrimSequence.Slice.t => 
	 let
	    val x_3929: word32 = 
	       let
		  val x_3930: word64 = 
		     length_6 ('a_2349) x_1172
		  val x_3931: word32 = 
		     schckFromInt64ToInt32 x_3930
	       in
		  x_3931
	       end
	       handle x_1173 => let
				   val x_3932: word32 = 
				      case x_1173 of
				      Overflow => 
					 let
					    val x_3933: word8 vector = 
					       "Sequence.Slice.length"
					    val x_3934: exn = 
					       Fail x_3933
					    val x_3935: word32 = 
					       raise x_3934
					 in
					    x_3935
					 end
					_ => let
						val x_3936: word32 = 
						   raise x_1173
					     in
						x_3936
					     end
				in
				   x_3932
				end
	 in
	    x_3929
	 end
   val rec 'a_2350 
      unsafeSub: 'a_2350 PrimSequence.Slice.t * word32 -> 'a_2350 = 
	 fn x_1174: 'a_2350 PrimSequence.Slice.t * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1174
	    val sl: 'a_2350 PrimSequence.Slice.t = 
	       #0 x_1174
	    val x_3937: word64 = 
	       sextdFromInt32ToInt64 i
	    val x_3938: 'a_2350 PrimSequence.Slice.t * word64 = 
	       (sl, x_3937)
	    val x_3939: 'a_2350 = 
	       unsafeSub_4 ('a_2350) x_3938
	 in
	    x_3939
	 end
   val rec 'a_2351 
      sub: 'a_2351 PrimSequence.Slice.t * word32 -> 'a_2351 = 
	 fn x_1175: 'a_2351 PrimSequence.Slice.t * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1175
	    val sl: 'a_2351 PrimSequence.Slice.t = 
	       #0 x_1175
	    val i: word64 = 
	       let
		  val x_3940: word64 = 
		     sextdFromInt32ToInt64 i
	       in
		  x_3940
	       end
	       handle x_1176 => let
				   val x_3941: word64 = 
				      case x_1176 of
				      Overflow => 
					 let
					    val x_3942: exn = 
					       Subscript
					    val x_3943: word64 = 
					       raise x_3942
					 in
					    x_3943
					 end
					_ => let
						val x_3944: word64 = 
						   raise x_1176
					     in
						x_3944
					     end
				in
				   x_3941
				end
	    val x_3945: 'a_2351 PrimSequence.Slice.t * word64 = 
	       (sl, i)
	    val x_3946: 'a_2351 = 
	       sub_2 ('a_2351) x_3945
	 in
	    x_3946
	 end
   val 'a_2354 full: 'a_2354 vector -> 'a_2354 PrimSequence.Slice.t = 
      let
      in
	 full_2 ('a_2354)
      end
   val rec 'a_2355 
      unsafeSubslice: 'a_2355 PrimSequence.Slice.t
		      * word32
		      * word32 Primitive.Option.t
		      -> 'a_2355 PrimSequence.Slice.t = 
	 fn x_1177: 'a_2355 PrimSequence.Slice.t
		    * word32
		    * word32 Primitive.Option.t => 
	 let
	    val len: word32 Primitive.Option.t = 
	       #2 x_1177
	    val start: word32 = 
	       #1 x_1177
	    val sl: 'a_2355 PrimSequence.Slice.t = 
	       #0 x_1177
	    val x_3947: word64 = 
	       sextdFromInt32ToInt64 start
	    val x_3948: word32 Primitive.Option.t -> word64 Primitive.Option.t = 
	       map_0 (word64, word32) sextdFromInt32ToInt64
	    val x_3949: word64 Primitive.Option.t = 
	       x_3948 len
	    val x_3950: 'a_2355 PrimSequence.Slice.t
			* word64
			* word64 Primitive.Option.t = 
	       (sl, x_3947, x_3949)
	    val x_3951: 'a_2355 PrimSequence.Slice.t = 
	       unsafeSubslice_2 ('a_2355) x_3950
	 in
	    x_3951
	 end
   val rec 'a_2357 
      subslice: 'a_2357 PrimSequence.Slice.t
		* word32
		* word32 Primitive.Option.t
		-> 'a_2357 PrimSequence.Slice.t = 
	 fn x_1178: 'a_2357 PrimSequence.Slice.t
		    * word32
		    * word32 Primitive.Option.t => 
	 let
	    val len: word32 Primitive.Option.t = 
	       #2 x_1178
	    val start: word32 = 
	       #1 x_1178
	    val sl: 'a_2357 PrimSequence.Slice.t = 
	       #0 x_1178
	    val x_3952: 'a_2357 PrimSequence.Slice.t = 
	       let
		  val x_3953: word64 = 
		     sextdFromInt32ToInt64 start
		  val x_3954: word32 Primitive.Option.t
			      -> word64 Primitive.Option.t = 
		     map_0 (word64, word32) sextdFromInt32ToInt64
		  val x_3955: word64 Primitive.Option.t = 
		     x_3954 len
		  val x_3956: 'a_2357 PrimSequence.Slice.t
			      * word64
			      * word64 Primitive.Option.t = 
		     (sl, x_3953, x_3955)
		  val x_3957: 'a_2357 PrimSequence.Slice.t = 
		     subslice_2 ('a_2357) x_3956
	       in
		  x_3957
	       end
	       handle x_1179 => let
				   val x_3958: 'a_2357 PrimSequence.Slice.t = 
				      case x_1179 of
				      Overflow => 
					 let
					    val x_3959: exn = 
					       Subscript
					    val x_3960: 'a_2357 PrimSequence.Slice.t = 
					       raise x_3959
					 in
					    x_3960
					 end
					_ => let
						val x_3961: 'a_2357 PrimSequence.Slice.t = 
						   raise x_1179
					     in
						x_3961
					     end
				in
				   x_3958
				end
	 in
	    x_3952
	 end
   val rec 'a 
      slice: 'a vector * word32 * word32 Primitive.Option.t
	     -> 'a PrimSequence.Slice.t = 
	 fn x_1180: 'a vector * word32 * word32 Primitive.Option.t => 
	 let
	    val len: word32 Primitive.Option.t = 
	       #2 x_1180
	    val start: word32 = 
	       #1 x_1180
	    val seq: 'a vector = 
	       #0 x_1180
	    val x_3962: 'a PrimSequence.Slice.t = 
	       full ('a) seq
	    val x_3963: 'a PrimSequence.Slice.t
			* word32
			* word32 Primitive.Option.t = 
	       (x_3962, start, len)
	    val x_3964: 'a PrimSequence.Slice.t = 
	       subslice ('a) x_3963
	 in
	    x_3964
	 end
   val rec 'a_2358 
      base: 'a_2358 PrimSequence.Slice.t -> 'a_2358 vector * word32 * word32 = 
	 fn x_1181: 'a_2358 PrimSequence.Slice.t => 
	 let
	    val x_3965: 'a_2358 vector * word64 * word64 = 
	       base_2 ('a_2358) x_1181
	    val len: word64 = 
	       #2 x_3965
	    val start: word64 = 
	       #1 x_3965
	    val seq: 'a_2358 vector = 
	       #0 x_3965
	    val x_3966: 'a_2358 vector * word32 * word32 = 
	       let
		  val x_3967: word32 = 
		     schckFromInt64ToInt32 start
		  val x_3968: word32 = 
		     schckFromInt64ToInt32 len
		  val x_3969: 'a_2358 vector * word32 * word32 = 
		     (seq, x_3967, x_3968)
	       in
		  x_3969
	       end
	       handle x_1182 => let
				   val x_3970: 'a_2358 vector * word32 * word32 = 
				      case x_1182 of
				      Overflow => 
					 let
					    val x_3971: word8 vector = 
					       "Sequence.Slice.base"
					    val x_3972: exn = 
					       Fail x_3971
					    val x_3973: 'a_2358 vector
							* word32
							* word32 = 
					       raise x_3972
					 in
					    x_3973
					 end
					_ => let
						val x_3974: 'a_2358 vector
							    * word32
							    * word32 = 
						   raise x_1182
					     in
						x_3974
					     end
				in
				   x_3970
				end
	 in
	    x_3966
	 end
   val ('a_2366, 'a_2365) foldl: ('a_2365 * 'a_2366 -> 'a_2366)
				 -> 'a_2366
				    -> 'a_2365 PrimSequence.Slice.t -> 'a_2366 = 
      let
      in
	 foldl_2 ('a_2366, 'a_2365)
      end
   val 'a_2378 exists: ('a_2378 -> bool) -> 'a_2378 PrimSequence.Slice.t -> bool = 
      let
      in
	 exists_1 ('a_2378)
      end
   val 'a_2382 sequence: 'a_2382 PrimSequence.Slice.t -> 'a_2382 vector = 
      let
      in
	 sequence_1 ('a_2382)
      end
   val 'a_2383 append: 'a_2383 PrimSequence.Slice.t
		       * 'a_2383 PrimSequence.Slice.t
		       -> 'a_2383 vector = 
      let
      in
	 append_1 ('a_2383)
      end
   val rec 'a 
      concat: 'a PrimSequence.Slice.t list -> 'a vector = 
	 fn x_1183: 'a PrimSequence.Slice.t list => 
	 let
	    val x_3975: 'a vector = 
	       case x_1183 of
	       nil['a PrimSequence.Slice.t] => 
		  let
		     val x_4019: unit = 
			()
		     val x_4020: 'a vector = 
			seq0 ('a) x_4019
		  in
		     x_4020
		  end
	       ::['a PrimSequence.Slice.t] x_3976: 'a PrimSequence.Slice.t
						   * 'a PrimSequence.Slice.t list => 
		  let
		     val x_3977: 'a PrimSequence.Slice.t list = 
			#1 x_3976
		     val x_3978: 'a PrimSequence.Slice.t = 
			#0 x_3976
		     val x_3979: 'a vector = 
			case x_3977 of
			nil['a PrimSequence.Slice.t] => 
			   let
			      val x_3980: 'a vector = 
				 sequence ('a) x_3978
			   in
			      x_3980
			   end
			  _ => let
				  val x_3981: 'a PrimSequence.Slice.t * word64
					      -> word64 = 
				     fn x_1185: 'a PrimSequence.Slice.t * word64 => 
				     let
					val s: word64 = 
					   #1 x_1185
					val sl: 'a PrimSequence.Slice.t = 
					   #0 x_1185
					val x_3982: word64 = 
					   let
					      val x_3983: word64 = 
						 length_6 ('a) sl
					      val x_3984: word64 * word64 = 
						 (s, x_3983)
					      val x_3985: word64 = 
						 +! x_3984
					   in
					      x_3985
					   end
					   handle x_1186 => let
							       val x_3986: word64 = 
								  case x_1186 of
								  Overflow => 
								     let
									val x_3987: exn = 
									   Size
									val x_3988: word64 = 
									   raise x_3987
								     in
									x_3988
								     end
								    _ => let
									    val x_3989: word64 = 
									       raise x_1186
									 in
									    x_3989
									 end
							    in
							       x_3986
							    end
				     in
					x_3982
				     end
				  val x_3990: word64
					      -> 'a PrimSequence.Slice.t list
						 -> word64 = 
				     foldl_1 (word64, 'a PrimSequence.Slice.t) x_3981
				  val x_3991: word64 = 
				     0x0
				  val x_3992: 'a PrimSequence.Slice.t list
					      -> word64 = 
				     x_3990 x_3991
				  val n: word64 = 
				     x_3992 x_1183
				  val rec 'a_2384 
				     loop: word64
					   * 'a_2384 PrimSequence.Slice.t
					   * 'a_2384 PrimSequence.Slice.t list
					   -> 'a_2384
					      * (word64
						 * 'a_2384 PrimSequence.Slice.t
						 * 'a_2384 PrimSequence.Slice.t list) = 
					fn x_1184: word64
						   * 'a_2384 PrimSequence.Slice.t
						   * 'a_2384 PrimSequence.Slice.t list => 
					let
					   val sls: 'a_2384 PrimSequence.Slice.t list = 
					      #2 x_1184
					   val sl: 'a_2384 PrimSequence.Slice.t = 
					      #1 x_1184
					   val i: word64 = 
					      #0 x_1184
					   val x_3993: word64 = 
					      length_6 ('a_2384) sl
					   val x_3994: word64 * word64 = 
					      (i, x_3993)
					   val x_3995: bool = 
					      < x_3994
					   val x_3996: 'a_2384
						       * (word64
							  * 'a_2384 PrimSequence.Slice.t
							  * 'a_2384 PrimSequence.Slice.t list) = 
					      case x_3995 of
					      true => 
						 let
						    val x_4007: 'a_2384 PrimSequence.Slice.t
								* word64 = 
						       (sl, i)
						    val x_4008: 'a_2384 = 
						       unsafeSub_4 ('a_2384) x_4007
						    val x_4009: word64 = 
						       0x1
						    val x_4010: word64 * word64 = 
						       (i, x_4009)
						    val x_4011: word64 = 
						       +? x_4010
						    val x_4012: word64
								* 'a_2384 PrimSequence.Slice.t
								* 'a_2384 PrimSequence.Slice.t list = 
						       (x_4011, sl, sls)
						    val x_4013: 'a_2384
								* (word64
								   * 'a_2384 PrimSequence.Slice.t
								   * 'a_2384 PrimSequence.Slice.t list) = 
						       (x_4008, x_4012)
						 in
						    x_4013
						 end
					      false => 
						 let
						    val x_3997: 'a_2384
								* (word64
								   * 'a_2384 PrimSequence.Slice.t
								   * 'a_2384 PrimSequence.Slice.t list) = 
						       case sls of
						       nil['a_2384 PrimSequence.Slice.t] => 
							  let
							     val x_4004: word8 vector = 
								"Sequence.Slice.concat"
							     val x_4005: exn = 
								Fail x_4004
							     val x_4006: 'a_2384
									 * (word64
									    * 'a_2384 PrimSequence.Slice.t
									    * 'a_2384 PrimSequence.Slice.t list) = 
								raise x_4005
							  in
							     x_4006
							  end
						       ::['a_2384 PrimSequence.Slice.t] x_3998: 'a_2384 PrimSequence.Slice.t
												* 'a_2384 PrimSequence.Slice.t list => 
							  let
							     val x_3999: 'a_2384 PrimSequence.Slice.t list = 
								#1 x_3998
							     val x_4000: 'a_2384 PrimSequence.Slice.t = 
								#0 x_3998
							     val x_4001: word64 = 
								0x0
							     val x_4002: word64
									 * 'a_2384 PrimSequence.Slice.t
									 * 'a_2384 PrimSequence.Slice.t list = 
								(x_4001,
								 x_4000,
								 x_3999)
							     val x_4003: 'a_2384
									 * (word64
									    * 'a_2384 PrimSequence.Slice.t
									    * 'a_2384 PrimSequence.Slice.t list) = 
								loop ('a_2384) x_4002
							  in
							     x_4003
							  end
						 in
						    x_3997
						 end
					in
					   x_3996
					end
				  val x_4014: word64 = 
				     0x0
				  val x_4015: word64
					      * 'a PrimSequence.Slice.t
					      * 'a PrimSequence.Slice.t list = 
				     (x_4014, x_3978, x_3977)
				  val x_4016: word64
					      * (word64
						 * 'a PrimSequence.Slice.t
						 * 'a PrimSequence.Slice.t list)
					      * (word64
						 * 'a PrimSequence.Slice.t
						 * 'a PrimSequence.Slice.t list
						 -> 'a
						    * (word64
						       * 'a PrimSequence.Slice.t
						       * 'a PrimSequence.Slice.t list)) = 
				     (n, x_4015, loop ('a))
				  val x_4017: 'a vector
					      * (word64
						 * 'a PrimSequence.Slice.t
						 * 'a PrimSequence.Slice.t list) = 
				     unfold_2 ('a,
					       word64
					       * 'a PrimSequence.Slice.t
					       * 'a PrimSequence.Slice.t list) x_4016
				  val x_4018: 'a vector = 
				     #0 x_4017
			       in
				  x_4018
			       end
		  in
		     x_3979
		  end
	 in
	    x_3975
	 end
   val rec 'a 
      isPrefix: ('a * 'a -> bool)
		-> 'a vector -> 'a PrimSequence.Slice.t -> bool = 
	 fn x_1189: 'a * 'a -> bool => 
	 let
	    val x_4021: 'a vector -> 'a PrimSequence.Slice.t -> bool = 
	       fn x_1190: 'a vector => 
	       let
		  val x_4022: 'a PrimSequence.Slice.t -> bool = 
		     fn x_1191: 'a PrimSequence.Slice.t => 
		     let
			val n: word64 = 
			   length_5 ('a) x_1190
			val n': word64 = 
			   length_6 ('a) x_1191
			val x_4023: word64 * word64 = 
			   (n, n')
			val x_4024: bool = 
			   <= x_4023
			val x_4025: bool = 
			   case x_4024 of
			   true => 
			      let
				 val rec 
				    loop: word64 -> bool = 
				       fn x_1192: word64 => 
				       let
					  val x_4027: word64 * word64 = 
					     (x_1192, n)
					  val x_4028: bool = 
					     >= x_4027
					  val x_4029: bool = 
					     case x_4028 of
					     true => 
						let
						   val x_4042: bool = 
						      true
						in
						   x_4042
						end
					     false => 
						let
						   val x_4030: 'a vector
							       * word64 = 
						      (x_1190, x_1192)
						   val x_4031: 'a = 
						      unsafeSub_3 ('a) x_4030
						   val x_4032: 'a PrimSequence.Slice.t
							       * word64 = 
						      (x_1191, x_1192)
						   val x_4033: 'a = 
						      unsafeSub_4 ('a) x_4032
						   val x_4034: 'a * 'a = 
						      (x_4031, x_4033)
						   val x_4035: bool = 
						      x_1189 x_4034
						   val x_4036: bool = 
						      case x_4035 of
						      true => 
							 let
							    val x_4038: word64 = 
							       0x1
							    val x_4039: word64
									* word64 = 
							       (x_1192, x_4038)
							    val x_4040: word64 = 
							       +? x_4039
							    val x_4041: bool = 
							       loop x_4040
							 in
							    x_4041
							 end
						      false => 
							 let
							    val x_4037: bool = 
							       false
							 in
							    x_4037
							 end
						in
						   x_4036
						end
				       in
					  x_4029
				       end
				 val x_4043: word64 = 
				    0x0
				 val x_4044: bool = 
				    loop x_4043
			      in
				 x_4044
			      end
			   false => 
			      let
				 val x_4026: bool = 
				    false
			      in
				 x_4026
			      end
		     in
			x_4025
		     end
	       in
		  x_4022
	       end
	 in
	    x_4021
	 end
   val 'a_2391 dropr: ('a_2391 -> bool)
		      -> 'a_2391 PrimSequence.Slice.t
			 -> 'a_2391 PrimSequence.Slice.t = 
      let
      in
	 dropr_1 ('a_2391)
      end
   val 'a_2392 takel: ('a_2392 -> bool)
		      -> 'a_2392 PrimSequence.Slice.t
			 -> 'a_2392 PrimSequence.Slice.t = 
      let
      in
	 takel_1 ('a_2392)
      end
   val 'a_2393 taker: ('a_2393 -> bool)
		      -> 'a_2393 PrimSequence.Slice.t
			 -> 'a_2393 PrimSequence.Slice.t = 
      let
      in
	 taker_1 ('a_2393)
      end
   val rec ('a_2395, 'a) 
      translate: ('a -> 'a_2395 vector)
		 -> 'a PrimSequence.Slice.t -> 'a_2395 vector = 
	 fn x_1193: 'a -> 'a_2395 vector => 
	 let
	    val x_4045: 'a PrimSequence.Slice.t -> 'a_2395 vector = 
	       fn x_1194: 'a PrimSequence.Slice.t => 
	       let
		  val x_4046: 'a * 'a_2395 PrimSequence.Slice.t list
			      -> 'a_2395 PrimSequence.Slice.t list = 
		     fn x_1195: 'a * 'a_2395 PrimSequence.Slice.t list => 
		     let
			val l: 'a_2395 PrimSequence.Slice.t list = 
			   #1 x_1195
			val c: 'a = 
			   #0 x_1195
			val x_4047: 'a_2395 vector = 
			   x_1193 c
			val x_4048: 'a_2395 PrimSequence.Slice.t = 
			   full ('a_2395) x_4047
			val x_4049: 'a_2395 PrimSequence.Slice.t
				    * 'a_2395 PrimSequence.Slice.t list = 
			   (x_4048, l)
			val x_4050: 'a_2395 PrimSequence.Slice.t list = 
			   ::['a_2395 PrimSequence.Slice.t] x_4049
		     in
			x_4050
		     end
		  val x_4051: 'a_2395 PrimSequence.Slice.t list
			      -> 'a PrimSequence.Slice.t
				 -> 'a_2395 PrimSequence.Slice.t list = 
		     foldl ('a_2395 PrimSequence.Slice.t list, 'a) x_4046
		  val x_4052: 'a_2395 PrimSequence.Slice.t list = 
		     nil['a_2395 PrimSequence.Slice.t]
		  val x_4053: 'a PrimSequence.Slice.t
			      -> 'a_2395 PrimSequence.Slice.t list = 
		     x_4051 x_4052
		  val x_4054: 'a_2395 PrimSequence.Slice.t list = 
		     x_4053 x_1194
		  val x_4055: 'a_2395 PrimSequence.Slice.t list = 
		     rev_0 ('a_2395 PrimSequence.Slice.t) x_4054
		  val x_4056: 'a_2395 vector = 
		     concat ('a_2395) x_4055
	       in
		  x_4056
	       end
	 in
	    x_4045
	 end
   val rec ('a_2401, 'a_2400) 
      make: ('a_2401 PrimSequence.Slice.t -> 'a_2400)
	    -> 'a_2401 vector -> 'a_2400 = 
	 fn x_1196: 'a_2401 PrimSequence.Slice.t -> 'a_2400 => 
	 let
	    val x_4057: 'a_2401 vector -> 'a_2400 = 
	       fn x_1197: 'a_2401 vector => 
	       let
		  val x_4058: 'a_2401 PrimSequence.Slice.t = 
		     full ('a_2401) x_1197
		  val x_4059: 'a_2400 = 
		     x_1196 x_4058
	       in
		  x_4059
	       end
	 in
	    x_4057
	 end
   val rec ('a_2404, 'a_2403, 'a_2402) 
      make2: ('a_2404 PrimSequence.Slice.t * 'a_2403 PrimSequence.Slice.t
	      -> 'a_2402)
	     -> 'a_2404 vector * 'a_2403 vector -> 'a_2402 = 
	 fn x_1198: 'a_2404 PrimSequence.Slice.t * 'a_2403 PrimSequence.Slice.t
		    -> 'a_2402 => 
	 let
	    val x_4060: 'a_2404 vector * 'a_2403 vector -> 'a_2402 = 
	       fn x_1199: 'a_2404 vector * 'a_2403 vector => 
	       let
		  val x_4061: 'a_2403 vector = 
		     #1 x_1199
		  val x_4062: 'a_2404 vector = 
		     #0 x_1199
		  val x_4063: 'a_2404 PrimSequence.Slice.t = 
		     full ('a_2404) x_4062
		  val x_4064: 'a_2403 PrimSequence.Slice.t = 
		     full ('a_2403) x_4061
		  val x_4065: 'a_2404 PrimSequence.Slice.t
			      * 'a_2403 PrimSequence.Slice.t = 
		     (x_4063, x_4064)
		  val x_4066: 'a_2402 = 
		     x_1198 x_4065
	       in
		  x_4066
	       end
	 in
	    x_4060
	 end
   val rec 'a_2405 
      sub: 'a_2405 vector * word32 -> 'a_2405 = 
	 fn x_1200: 'a_2405 vector * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1200
	    val seq: 'a_2405 vector = 
	       #0 x_1200
	    val x_4067: 'a_2405 PrimSequence.Slice.t = 
	       full ('a_2405) seq
	    val x_4068: 'a_2405 PrimSequence.Slice.t * word32 = 
	       (x_4067, i)
	    val x_4069: 'a_2405 = 
	       sub ('a_2405) x_4068
	 in
	    x_4069
	 end
   val rec 'a_2409 
      append: 'a_2409 vector * 'a_2409 vector -> 'a_2409 vector = 
	 fn x_1201: 'a_2409 vector * 'a_2409 vector => 
	 let
	    val x_4070: 'a_2409 vector * 'a_2409 vector -> 'a_2409 vector = 
	       make2 ('a_2409, 'a_2409, 'a_2409 vector) append ('a_2409)
	    val x_4071: 'a_2409 vector = 
	       x_4070 x_1201
	 in
	    x_4071
	 end
   val rec 'a_2410 
      concat: 'a_2410 vector list -> 'a_2410 vector = 
	 fn x_1202: 'a_2410 vector list => 
	 let
	    val x_4072: 'a_2410 vector list -> 'a_2410 PrimSequence.Slice.t list = 
	       map_1 ('a_2410 PrimSequence.Slice.t, 'a_2410 vector) full ('a_2410)
	    val x_4073: 'a_2410 PrimSequence.Slice.t list = 
	       x_4072 x_1202
	    val x_4074: 'a_2410 vector = 
	       concat ('a_2410) x_4073
	 in
	    x_4074
	 end
   val rec 'a_2428 
      exists: ('a_2428 -> bool) -> 'a_2428 vector -> bool = 
	 fn x_1203: 'a_2428 -> bool => 
	 let
	    val x_4075: 'a_2428 PrimSequence.Slice.t -> bool = 
	       exists ('a_2428) x_1203
	    val x_4076: 'a_2428 vector -> bool = 
	       make ('a_2428, bool) x_4075
	 in
	    x_4076
	 end
   val rec 'a_2433 
      isPrefix: ('a_2433 * 'a_2433 -> bool)
		-> 'a_2433 vector -> 'a_2433 vector -> bool = 
	 fn x_1204: 'a_2433 * 'a_2433 -> bool => 
	 let
	    val x_4077: 'a_2433 vector -> 'a_2433 vector -> bool = 
	       fn x_1205: 'a_2433 vector => 
	       let
		  val x_4078: 'a_2433 vector
			      -> 'a_2433 PrimSequence.Slice.t -> bool = 
		     isPrefix ('a_2433) x_1204
		  val x_4079: 'a_2433 PrimSequence.Slice.t -> bool = 
		     x_4078 x_1205
		  val x_4080: 'a_2433 vector -> bool = 
		     make ('a_2433, bool) x_4079
	       in
		  x_4080
	       end
	 in
	    x_4077
	 end
   val rec ('a_2437, 'a_2436) 
      translate: ('a_2436 -> 'a_2437 vector) -> 'a_2436 vector -> 'a_2437 vector = 
	 fn x_1206: 'a_2436 -> 'a_2437 vector => 
	 let
	    val x_4081: 'a_2436 PrimSequence.Slice.t -> 'a_2437 vector = 
	       translate ('a_2437, 'a_2436) x_1206
	    val x_4082: 'a_2436 vector -> 'a_2437 vector = 
	       make ('a_2436, 'a_2437 vector) x_4081
	 in
	    x_4082
	 end
   val ('b, 'a) translate_0: ('a -> 'b vector) -> 'a vector -> 'b vector = 
      let
      in
	 translate ('b, 'a)
      end
   val 'a tabulate_1: word32 * (word32 -> 'a) -> 'a vector = 
      let
      in
	 tabulate ('a)
      end
   val 'a sub_3: 'a vector * word32 -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a new_0: word32 * 'a -> 'a vector = 
      let
      in
	 new ('a)
      end
   val 'a length_7: 'a vector -> word32 = 
      let
      in
	 length ('a)
      end
   val 'a isPrefix_0: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool = 
      let
      in
	 isPrefix ('a)
      end
   val 'a fromList_0: 'a list -> 'a vector = 
      let
      in
	 fromList ('a)
      end
   val 'a exists_2: ('a -> bool) -> 'a vector -> bool = 
      let
      in
	 exists ('a)
      end
   val 'a concat_0: 'a vector list -> 'a vector = 
      let
      in
	 concat ('a)
      end
   val 'a append_2: 'a vector * 'a vector -> 'a vector = 
      let
      in
	 append ('a)
      end
   val 'a taker_2: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 taker ('a)
      end
   val 'a takel_2: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 takel ('a)
      end
   val 'a sub_4: 'a PrimSequence.Slice.t * word32 -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a slice_1: 'a vector * word32 * word32 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t = 
      let
      in
	 slice ('a)
      end
   val 'a sequence_2: 'a PrimSequence.Slice.t -> 'a vector = 
      let
      in
	 sequence ('a)
      end
   val 'a length_8: 'a PrimSequence.Slice.t -> word32 = 
      let
      in
	 length ('a)
      end
   val 'a full_3: 'a vector -> 'a PrimSequence.Slice.t = 
      let
      in
	 full ('a)
      end
   val 'a dropr_2: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 dropr ('a)
      end
   val 'a base_3: 'a PrimSequence.Slice.t -> 'a vector * word32 * word32 = 
      let
      in
	 base ('a)
      end
   val 'a_2453 vector: 'a_2453 PrimSequence.Slice.t -> 'a_2453 vector = 
      let
      in
	 sequence_2 ('a_2453)
      end
   val 'a_2457 unsafeFromArray: 'a_2457 array -> 'a_2457 vector = 
      let
      in
	 fromArrayUnsafe ('a_2457)
      end
   val 'a_2458 vector: word32 * 'a_2458 -> 'a_2458 vector = 
      let
      in
	 new_0 ('a_2458)
      end
   val 'a vector_0: word32 * 'a -> 'a vector = 
      let
      in
	 vector ('a)
      end
   val 'a unsafeFromArray_0: 'a array -> 'a vector = 
      let
      in
	 unsafeFromArray ('a)
      end
   val ('b, 'a) translate_1: ('a -> 'b vector) -> 'a vector -> 'b vector = 
      let
      in
	 translate_0 ('b, 'a)
      end
   val 'a tabulate_2: word32 * (word32 -> 'a) -> 'a vector = 
      let
      in
	 tabulate_1 ('a)
      end
   val 'a sub_5: 'a vector * word32 -> 'a = 
      let
      in
	 sub_3 ('a)
      end
   val 'a length_9: 'a vector -> word32 = 
      let
      in
	 length_7 ('a)
      end
   val 'a isPrefix_1: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool = 
      let
      in
	 isPrefix_0 ('a)
      end
   val 'a fromList_1: 'a list -> 'a vector = 
      let
      in
	 fromList_0 ('a)
      end
   val 'a exists_3: ('a -> bool) -> 'a vector -> bool = 
      let
      in
	 exists_2 ('a)
      end
   val 'a concat_1: 'a vector list -> 'a vector = 
      let
      in
	 concat_0 ('a)
      end
   val 'a append_3: 'a vector * 'a vector -> 'a vector = 
      let
      in
	 append_2 ('a)
      end
   val 'a vector_1: 'a PrimSequence.Slice.t -> 'a vector = 
      let
      in
	 vector ('a)
      end
   val 'a taker_3: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 taker_2 ('a)
      end
   val 'a takel_3: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 takel_2 ('a)
      end
   val 'a sub_6: 'a PrimSequence.Slice.t * word32 -> 'a = 
      let
      in
	 sub_4 ('a)
      end
   val 'a slice_2: 'a vector * word32 * word32 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t = 
      let
      in
	 slice_1 ('a)
      end
   val 'a length_10: 'a PrimSequence.Slice.t -> word32 = 
      let
      in
	 length_8 ('a)
      end
   val 'a full_4: 'a vector -> 'a PrimSequence.Slice.t = 
      let
      in
	 full_3 ('a)
      end
   val 'a dropr_3: ('a -> bool)
		   -> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t = 
      let
      in
	 dropr_2 ('a)
      end
   val 'a base_4: 'a PrimSequence.Slice.t -> 'a vector * word32 * word32 = 
      let
      in
	 base_3 ('a)
      end
   val 'a base_5: 'a PrimSequence.Slice.t -> 'a vector * word32 * word32 = 
      let
      in
	 base_4 ('a)
      end
   val ('a, 'b) unfoldi_3: word64 * 'b * (word64 * 'b -> 'a * 'b)
			   -> 'a array * 'b = 
      let
      in
	 unfoldi_1 ('a, 'b)
      end
   val ('a, 'b) unfold_3: word64 * 'b * ('b -> 'a * 'b) -> 'a array * 'b = 
      let
      in
	 unfold_1 ('a, 'b)
      end
   val 'a newUninit_1: word64 -> 'a array = 
      let
      in
	 newUninit_0 ('a)
      end
   val 'a length_11: 'a array -> word64 = 
      let
      in
	 length ('a)
      end
   val 'a updateMk_1: ('a array * word64 * 'a -> unit)
		      -> 'a PrimSequence.Slice.t * word64 * 'a -> unit = 
      let
      in
	 updateMk_0 ('a)
      end
   val 'a unsafeUpdateMk_1: ('a array * word64 * 'a -> unit)
			    -> 'a PrimSequence.Slice.t * word64 * 'a -> unit = 
      let
      in
	 unsafeUpdateMk_0 ('a)
      end
   val 'a unsafeSubslice_3: 'a PrimSequence.Slice.t
			    * word64
			    * word64 Primitive.Option.t
			    -> 'a PrimSequence.Slice.t = 
      let
      in
	 unsafeSubslice_1 ('a)
      end
   val 'a unsafeSub_5: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 unsafeSub_2 ('a)
      end
   val 'a subslice_3: 'a PrimSequence.Slice.t
		      * word64
		      * word64 Primitive.Option.t
		      -> 'a PrimSequence.Slice.t = 
      let
      in
	 subslice_1 ('a)
      end
   val 'a sub_7: 'a PrimSequence.Slice.t * word64 -> 'a = 
      let
      in
	 sub_1 ('a)
      end
   val 'a full_5: 'a array -> 'a PrimSequence.Slice.t = 
      let
      in
	 full_1 ('a)
      end
   val ('b, 'a) foldri_1: (word64 * 'a * 'b -> 'b)
			  -> 'b -> 'a PrimSequence.Slice.t -> 'b = 
      let
      in
	 foldri_0 ('b, 'a)
      end
   val 'a base_6: 'a PrimSequence.Slice.t -> 'a array * word64 * word64 = 
      let
      in
	 base_1 ('a)
      end
   val rec ('a_2485, 'a_2484) 
      wrap2: (word32 * 'a_2485 -> 'a_2484) -> word64 * 'a_2485 -> 'a_2484 = 
	 fn x_1207: word32 * 'a_2485 -> 'a_2484 => 
	 let
	    val x_4083: word64 * 'a_2485 -> 'a_2484 = 
	       fn x_1208: word64 * 'a_2485 => 
	       let
		  val x: 'a_2485 = 
		     #1 x_1208
		  val i: word64 = 
		     #0 x_1208
		  val x_4084: word32 = 
		     sextdFromInt64ToInt32 i
		  val x_4085: word32 * 'a_2485 = 
		     (x_4084, x)
		  val x_4086: 'a_2484 = 
		     x_1207 x_4085
	       in
		  x_4086
	       end
	 in
	    x_4083
	 end
   val rec ('a_2488, 'a_2487, 'a_2486) 
      wrap3: (word32 * 'a_2488 * 'a_2487 -> 'a_2486)
	     -> word64 * 'a_2488 * 'a_2487 -> 'a_2486 = 
	 fn x_1209: word32 * 'a_2488 * 'a_2487 -> 'a_2486 => 
	 let
	    val x_4087: word64 * 'a_2488 * 'a_2487 -> 'a_2486 = 
	       fn x_1210: word64 * 'a_2488 * 'a_2487 => 
	       let
		  val y: 'a_2487 = 
		     #2 x_1210
		  val x: 'a_2488 = 
		     #1 x_1210
		  val i: word64 = 
		     #0 x_1210
		  val x_4088: word32 = 
		     sextdFromInt64ToInt32 i
		  val x_4089: word32 * 'a_2488 * 'a_2487 = 
		     (x_4088, x, y)
		  val x_4090: 'a_2486 = 
		     x_1209 x_4089
	       in
		  x_4090
	       end
	 in
	    x_4087
	 end
   val rec 
      fromIntForLength: word32 -> word64 = 
	 fn x_1211: word32 => 
	 let
	    val x_4091: word64 = 
	       let
		  val x_4092: word64 = 
		     sextdFromInt32ToInt64 x_1211
	       in
		  x_4092
	       end
	       handle x_1212 => let
				   val x_4093: word64 = 
				      case x_1212 of
				      Overflow => 
					 let
					    val x_4094: exn = 
					       Size
					    val x_4095: word64 = 
					       raise x_4094
					 in
					    x_4095
					 end
					_ => let
						val x_4096: word64 = 
						   raise x_1212
					     in
						x_4096
					     end
				in
				   x_4093
				end
	 in
	    x_4091
	 end
   val rec 'a_2492 
      length: 'a_2492 array -> word32 = 
	 fn x_1213: 'a_2492 array => 
	 let
	    val x_4097: word32 = 
	       let
		  val x_4098: word64 = 
		     length_11 ('a_2492) x_1213
		  val x_4099: word32 = 
		     schckFromInt64ToInt32 x_4098
	       in
		  x_4099
	       end
	       handle x_1214 => let
				   val x_4100: word32 = 
				      case x_1214 of
				      Overflow => 
					 let
					    val x_4101: word8 vector = 
					       "Sequence.length"
					    val x_4102: exn = 
					       Fail x_4101
					    val x_4103: word32 = 
					       raise x_4102
					 in
					    x_4103
					 end
					_ => let
						val x_4104: word32 = 
						   raise x_1214
					     in
						x_4104
					     end
				in
				   x_4100
				end
	 in
	    x_4097
	 end
   val rec 'a_2493 
      newUninit: word32 -> 'a_2493 array = 
	 fn x_1215: word32 => 
	 let
	    val x_4105: word64 = 
	       fromIntForLength x_1215
	    val x_4106: 'a_2493 array = 
	       newUninit_1 ('a_2493) x_4105
	 in
	    x_4106
	 end
   val rec ('a_2496, 'a_2495) 
      unfoldi: word32 * 'a_2495 * (word32 * 'a_2495 -> 'a_2496 * 'a_2495)
	       -> 'a_2496 array * 'a_2495 = 
	 fn x_1216: word32 * 'a_2495 * (word32 * 'a_2495 -> 'a_2496 * 'a_2495) => 
	 let
	    val f: word32 * 'a_2495 -> 'a_2496 * 'a_2495 = 
	       #2 x_1216
	    val b: 'a_2495 = 
	       #1 x_1216
	    val n: word32 = 
	       #0 x_1216
	    val x_4107: word64 = 
	       fromIntForLength n
	    val x_4108: word64 * 'a_2495 -> 'a_2496 * 'a_2495 = 
	       wrap2 ('a_2495, 'a_2496 * 'a_2495) f
	    val x_4109: word64
			* 'a_2495
			* (word64 * 'a_2495 -> 'a_2496 * 'a_2495) = 
	       (x_4107, b, x_4108)
	    val x_4110: 'a_2496 array * 'a_2495 = 
	       unfoldi_3 ('a_2496, 'a_2495) x_4109
	 in
	    x_4110
	 end
   val rec ('a_2498, 'a_2497) 
      unfold: word32 * 'a_2497 * ('a_2497 -> 'a_2498 * 'a_2497)
	      -> 'a_2498 array * 'a_2497 = 
	 fn x_1217: word32 * 'a_2497 * ('a_2497 -> 'a_2498 * 'a_2497) => 
	 let
	    val f: 'a_2497 -> 'a_2498 * 'a_2497 = 
	       #2 x_1217
	    val b: 'a_2497 = 
	       #1 x_1217
	    val n: word32 = 
	       #0 x_1217
	    val x_4111: word64 = 
	       fromIntForLength n
	    val x_4112: word64 * 'a_2497 * ('a_2497 -> 'a_2498 * 'a_2497) = 
	       (x_4111, b, f)
	    val x_4113: 'a_2498 array * 'a_2497 = 
	       unfold_3 ('a_2498, 'a_2497) x_4112
	 in
	    x_4113
	 end
   val rec 'a_2500 
      tabulate: word32 * (word32 -> 'a_2500) -> 'a_2500 array = 
	 fn x_1218: word32 * (word32 -> 'a_2500) => 
	 let
	    val f: word32 -> 'a_2500 = 
	       #1 x_1218
	    val n: word32 = 
	       #0 x_1218
	    val x_4114: unit = 
	       ()
	    val x_4115: word32 * unit -> 'a_2500 * unit = 
	       fn x_1220: word32 * unit => 
	       let
		  val x_4116: word32 = 
		     #0 x_1220
		  val x_4117: 'a_2500 = 
		     f x_4116
		  val x_4118: unit = 
		     ()
		  val x_4119: 'a_2500 * unit = 
		     (x_4117, x_4118)
	       in
		  x_4119
	       end
	    val x_4120: word32 * unit * (word32 * unit -> 'a_2500 * unit) = 
	       (n, x_4114, x_4115)
	    val x_4121: 'a_2500 array * unit = 
	       unfoldi ('a_2500, unit) x_4120
	    val x_4122: 'a_2500 array = 
	       #0 x_4121
	 in
	    x_4122
	 end
   val rec 'a_2501 
      new: word32 * 'a_2501 -> 'a_2501 array = 
	 fn x_1221: word32 * 'a_2501 => 
	 let
	    val x: 'a_2501 = 
	       #1 x_1221
	    val n: word32 = 
	       #0 x_1221
	    val x_4123: unit = 
	       ()
	    val x_4124: unit -> 'a_2501 * unit = 
	       fn x_1223: unit => 
	       let
		  val x_4125: unit = 
		     ()
		  val x_4126: 'a_2501 * unit = 
		     (x, x_4125)
	       in
		  x_4126
	       end
	    val x_4127: word32 * unit * (unit -> 'a_2501 * unit) = 
	       (n, x_4123, x_4124)
	    val x_4128: 'a_2501 array * unit = 
	       unfold ('a_2501, unit) x_4127
	    val x_4129: 'a_2501 array = 
	       #0 x_4128
	 in
	    x_4129
	 end
   val rec 'a_2504 
      unsafeSub: 'a_2504 PrimSequence.Slice.t * word32 -> 'a_2504 = 
	 fn x_1224: 'a_2504 PrimSequence.Slice.t * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1224
	    val sl: 'a_2504 PrimSequence.Slice.t = 
	       #0 x_1224
	    val x_4130: word64 = 
	       sextdFromInt32ToInt64 i
	    val x_4131: 'a_2504 PrimSequence.Slice.t * word64 = 
	       (sl, x_4130)
	    val x_4132: 'a_2504 = 
	       unsafeSub_5 ('a_2504) x_4131
	 in
	    x_4132
	 end
   val rec 'a_2505 
      sub: 'a_2505 PrimSequence.Slice.t * word32 -> 'a_2505 = 
	 fn x_1225: 'a_2505 PrimSequence.Slice.t * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1225
	    val sl: 'a_2505 PrimSequence.Slice.t = 
	       #0 x_1225
	    val i: word64 = 
	       let
		  val x_4133: word64 = 
		     sextdFromInt32ToInt64 i
	       in
		  x_4133
	       end
	       handle x_1226 => let
				   val x_4134: word64 = 
				      case x_1226 of
				      Overflow => 
					 let
					    val x_4135: exn = 
					       Subscript
					    val x_4136: word64 = 
					       raise x_4135
					 in
					    x_4136
					 end
					_ => let
						val x_4137: word64 = 
						   raise x_1226
					     in
						x_4137
					     end
				in
				   x_4134
				end
	    val x_4138: 'a_2505 PrimSequence.Slice.t * word64 = 
	       (sl, i)
	    val x_4139: 'a_2505 = 
	       sub_7 ('a_2505) x_4138
	 in
	    x_4139
	 end
   val rec 'a_2506 
      unsafeUpdateMk: ('a_2506 array * word64 * 'a_2506 -> unit)
		      -> 'a_2506 PrimSequence.Slice.t * word32 * 'a_2506 -> unit = 
	 fn x_1227: 'a_2506 array * word64 * 'a_2506 -> unit => 
	 let
	    val x_4140: 'a_2506 PrimSequence.Slice.t * word32 * 'a_2506 -> unit = 
	       fn x_1228: 'a_2506 PrimSequence.Slice.t * word32 * 'a_2506 => 
	       let
		  val x_4141: 'a_2506 = 
		     #2 x_1228
		  val x_4142: word32 = 
		     #1 x_1228
		  val x_4143: 'a_2506 PrimSequence.Slice.t = 
		     #0 x_1228
		  val x_4144: 'a_2506 PrimSequence.Slice.t * word64 * 'a_2506
			      -> unit = 
		     unsafeUpdateMk_1 ('a_2506) x_1227
		  val x_4145: word64 = 
		     sextdFromInt32ToInt64 x_4142
		  val x_4146: 'a_2506 PrimSequence.Slice.t * word64 * 'a_2506 = 
		     (x_4143, x_4145, x_4141)
		  val x_4147: unit = 
		     x_4144 x_4146
	       in
		  x_4147
	       end
	 in
	    x_4140
	 end
   val rec 'a_2507 
      updateMk: ('a_2507 array * word64 * 'a_2507 -> unit)
		-> 'a_2507 PrimSequence.Slice.t * word32 * 'a_2507 -> unit = 
	 fn x_1229: 'a_2507 array * word64 * 'a_2507 -> unit => 
	 let
	    val x_4148: 'a_2507 PrimSequence.Slice.t * word32 * 'a_2507 -> unit = 
	       fn x_1230: 'a_2507 PrimSequence.Slice.t * word32 * 'a_2507 => 
	       let
		  val x_4149: 'a_2507 = 
		     #2 x_1230
		  val x_4150: word32 = 
		     #1 x_1230
		  val x_4151: 'a_2507 PrimSequence.Slice.t = 
		     #0 x_1230
		  val i: word64 = 
		     let
			val x_4152: word64 = 
			   sextdFromInt32ToInt64 x_4150
		     in
			x_4152
		     end
		     handle x_1231 => let
					 val x_4153: word64 = 
					    case x_1231 of
					    Overflow => 
					       let
						  val x_4154: exn = 
						     Subscript
						  val x_4155: word64 = 
						     raise x_4154
					       in
						  x_4155
					       end
					      _ => let
						      val x_4156: word64 = 
							 raise x_1231
						   in
						      x_4156
						   end
				      in
					 x_4153
				      end
		  val x_4157: 'a_2507 PrimSequence.Slice.t * word64 * 'a_2507
			      -> unit = 
		     updateMk_1 ('a_2507) x_1229
		  val x_4158: 'a_2507 PrimSequence.Slice.t * word64 * 'a_2507 = 
		     (x_4151, i, x_4149)
		  val x_4159: unit = 
		     x_4157 x_4158
	       in
		  x_4159
	       end
	 in
	    x_4148
	 end
   val 'a_2508 full: 'a_2508 array -> 'a_2508 PrimSequence.Slice.t = 
      let
      in
	 full_5 ('a_2508)
      end
   val rec 'a_2509 
      unsafeSubslice: 'a_2509 PrimSequence.Slice.t
		      * word32
		      * word32 Primitive.Option.t
		      -> 'a_2509 PrimSequence.Slice.t = 
	 fn x_1232: 'a_2509 PrimSequence.Slice.t
		    * word32
		    * word32 Primitive.Option.t => 
	 let
	    val len: word32 Primitive.Option.t = 
	       #2 x_1232
	    val start: word32 = 
	       #1 x_1232
	    val sl: 'a_2509 PrimSequence.Slice.t = 
	       #0 x_1232
	    val x_4160: word64 = 
	       sextdFromInt32ToInt64 start
	    val x_4161: word32 Primitive.Option.t -> word64 Primitive.Option.t = 
	       map_0 (word64, word32) sextdFromInt32ToInt64
	    val x_4162: word64 Primitive.Option.t = 
	       x_4161 len
	    val x_4163: 'a_2509 PrimSequence.Slice.t
			* word64
			* word64 Primitive.Option.t = 
	       (sl, x_4160, x_4162)
	    val x_4164: 'a_2509 PrimSequence.Slice.t = 
	       unsafeSubslice_3 ('a_2509) x_4163
	 in
	    x_4164
	 end
   val rec 'a_2511 
      subslice: 'a_2511 PrimSequence.Slice.t
		* word32
		* word32 Primitive.Option.t
		-> 'a_2511 PrimSequence.Slice.t = 
	 fn x_1233: 'a_2511 PrimSequence.Slice.t
		    * word32
		    * word32 Primitive.Option.t => 
	 let
	    val len: word32 Primitive.Option.t = 
	       #2 x_1233
	    val start: word32 = 
	       #1 x_1233
	    val sl: 'a_2511 PrimSequence.Slice.t = 
	       #0 x_1233
	    val x_4165: 'a_2511 PrimSequence.Slice.t = 
	       let
		  val x_4166: word64 = 
		     sextdFromInt32ToInt64 start
		  val x_4167: word32 Primitive.Option.t
			      -> word64 Primitive.Option.t = 
		     map_0 (word64, word32) sextdFromInt32ToInt64
		  val x_4168: word64 Primitive.Option.t = 
		     x_4167 len
		  val x_4169: 'a_2511 PrimSequence.Slice.t
			      * word64
			      * word64 Primitive.Option.t = 
		     (sl, x_4166, x_4168)
		  val x_4170: 'a_2511 PrimSequence.Slice.t = 
		     subslice_3 ('a_2511) x_4169
	       in
		  x_4170
	       end
	       handle x_1234 => let
				   val x_4171: 'a_2511 PrimSequence.Slice.t = 
				      case x_1234 of
				      Overflow => 
					 let
					    val x_4172: exn = 
					       Subscript
					    val x_4173: 'a_2511 PrimSequence.Slice.t = 
					       raise x_4172
					 in
					    x_4173
					 end
					_ => let
						val x_4174: 'a_2511 PrimSequence.Slice.t = 
						   raise x_1234
					     in
						x_4174
					     end
				in
				   x_4171
				end
	 in
	    x_4165
	 end
   val rec 'a 
      slice: 'a array * word32 * word32 Primitive.Option.t
	     -> 'a PrimSequence.Slice.t = 
	 fn x_1235: 'a array * word32 * word32 Primitive.Option.t => 
	 let
	    val len: word32 Primitive.Option.t = 
	       #2 x_1235
	    val start: word32 = 
	       #1 x_1235
	    val seq: 'a array = 
	       #0 x_1235
	    val x_4175: 'a PrimSequence.Slice.t = 
	       full ('a) seq
	    val x_4176: 'a PrimSequence.Slice.t
			* word32
			* word32 Primitive.Option.t = 
	       (x_4175, start, len)
	    val x_4177: 'a PrimSequence.Slice.t = 
	       subslice ('a) x_4176
	 in
	    x_4177
	 end
   val rec 'a_2512 
      base: 'a_2512 PrimSequence.Slice.t -> 'a_2512 array * word32 * word32 = 
	 fn x_1236: 'a_2512 PrimSequence.Slice.t => 
	 let
	    val x_4178: 'a_2512 array * word64 * word64 = 
	       base_6 ('a_2512) x_1236
	    val len: word64 = 
	       #2 x_4178
	    val start: word64 = 
	       #1 x_4178
	    val seq: 'a_2512 array = 
	       #0 x_4178
	    val x_4179: 'a_2512 array * word32 * word32 = 
	       let
		  val x_4180: word32 = 
		     schckFromInt64ToInt32 start
		  val x_4181: word32 = 
		     schckFromInt64ToInt32 len
		  val x_4182: 'a_2512 array * word32 * word32 = 
		     (seq, x_4180, x_4181)
	       in
		  x_4182
	       end
	       handle x_1237 => let
				   val x_4183: 'a_2512 array * word32 * word32 = 
				      case x_1237 of
				      Overflow => 
					 let
					    val x_4184: word8 vector = 
					       "Sequence.Slice.base"
					    val x_4185: exn = 
					       Fail x_4184
					    val x_4186: 'a_2512 array
							* word32
							* word32 = 
					       raise x_4185
					 in
					    x_4186
					 end
					_ => let
						val x_4187: 'a_2512 array
							    * word32
							    * word32 = 
						   raise x_1237
					     in
						x_4187
					     end
				in
				   x_4183
				end
	 in
	    x_4179
	 end
   val rec ('a_2518, 'a_2517) 
      foldri: (word32 * 'a_2518 * 'a_2517 -> 'a_2517)
	      -> 'a_2517 -> 'a_2518 PrimSequence.Slice.t -> 'a_2517 = 
	 fn x_1238: word32 * 'a_2518 * 'a_2517 -> 'a_2517 => 
	 let
	    val x_4188: 'a_2517 -> 'a_2518 PrimSequence.Slice.t -> 'a_2517 = 
	       fn x_1239: 'a_2517 => 
	       let
		  val x_4189: 'a_2518 PrimSequence.Slice.t -> 'a_2517 = 
		     fn x_1240: 'a_2518 PrimSequence.Slice.t => 
		     let
			val x_4190: word64 * 'a_2518 * 'a_2517 -> 'a_2517 = 
			   wrap3 ('a_2518, 'a_2517, 'a_2517) x_1238
			val x_4191: 'a_2517
				    -> 'a_2518 PrimSequence.Slice.t -> 'a_2517 = 
			   foldri_1 ('a_2517, 'a_2518) x_4190
			val x_4192: 'a_2518 PrimSequence.Slice.t -> 'a_2517 = 
			   x_4191 x_1239
			val x_4193: 'a_2517 = 
			   x_4192 x_1240
		     in
			x_4193
		     end
	       in
		  x_4189
	       end
	 in
	    x_4188
	 end
   val rec ('a_2555, 'a_2554) 
      make: ('a_2555 PrimSequence.Slice.t -> 'a_2554)
	    -> 'a_2555 array -> 'a_2554 = 
	 fn x_1241: 'a_2555 PrimSequence.Slice.t -> 'a_2554 => 
	 let
	    val x_4194: 'a_2555 array -> 'a_2554 = 
	       fn x_1242: 'a_2555 array => 
	       let
		  val x_4195: 'a_2555 PrimSequence.Slice.t = 
		     full ('a_2555) x_1242
		  val x_4196: 'a_2554 = 
		     x_1241 x_4195
	       in
		  x_4196
	       end
	 in
	    x_4194
	 end
   val rec 'a_2559 
      sub: 'a_2559 array * word32 -> 'a_2559 = 
	 fn x_1243: 'a_2559 array * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1243
	    val seq: 'a_2559 array = 
	       #0 x_1243
	    val x_4197: 'a_2559 PrimSequence.Slice.t = 
	       full ('a_2559) seq
	    val x_4198: 'a_2559 PrimSequence.Slice.t * word32 = 
	       (x_4197, i)
	    val x_4199: 'a_2559 = 
	       sub ('a_2559) x_4198
	 in
	    x_4199
	 end
   val rec 'a_2561 
      updateMk: ('a_2561 array * word64 * 'a_2561 -> unit)
		-> 'a_2561 array * word32 * 'a_2561 -> unit = 
	 fn x_1244: 'a_2561 array * word64 * 'a_2561 -> unit => 
	 let
	    val x_4200: 'a_2561 array * word32 * 'a_2561 -> unit = 
	       fn x_1245: 'a_2561 array * word32 * 'a_2561 => 
	       let
		  val x_4201: 'a_2561 = 
		     #2 x_1245
		  val x_4202: word32 = 
		     #1 x_1245
		  val x_4203: 'a_2561 array = 
		     #0 x_1245
		  val x_4204: 'a_2561 PrimSequence.Slice.t * word32 * 'a_2561
			      -> unit = 
		     updateMk ('a_2561) x_1244
		  val x_4205: 'a_2561 PrimSequence.Slice.t = 
		     full ('a_2561) x_4203
		  val x_4206: 'a_2561 PrimSequence.Slice.t * word32 * 'a_2561 = 
		     (x_4205, x_4202, x_4201)
		  val x_4207: unit = 
		     x_4204 x_4206
	       in
		  x_4207
	       end
	 in
	    x_4200
	 end
   val rec ('a_2576, 'a_2575) 
      foldri: (word32 * 'a_2576 * 'a_2575 -> 'a_2575)
	      -> 'a_2575 -> 'a_2576 array -> 'a_2575 = 
	 fn x_1246: word32 * 'a_2576 * 'a_2575 -> 'a_2575 => 
	 let
	    val x_4208: 'a_2575 -> 'a_2576 array -> 'a_2575 = 
	       fn x_1247: 'a_2575 => 
	       let
		  val x_4209: 'a_2575 -> 'a_2576 PrimSequence.Slice.t -> 'a_2575 = 
		     foldri ('a_2576, 'a_2575) x_1246
		  val x_4210: 'a_2576 PrimSequence.Slice.t -> 'a_2575 = 
		     x_4209 x_1247
		  val x_4211: 'a_2576 array -> 'a_2575 = 
		     make ('a_2576, 'a_2575) x_4210
	       in
		  x_4211
	       end
	 in
	    x_4208
	 end
   val 'a updateMk_2: ('a array * word64 * 'a -> unit)
		      -> 'a array * word32 * 'a -> unit = 
      let
      in
	 updateMk ('a)
      end
   val ('a, 'b) unfoldi_4: word32 * 'b * (word32 * 'b -> 'a * 'b)
			   -> 'a array * 'b = 
      let
      in
	 unfoldi ('a, 'b)
      end
   val 'a tabulate_3: word32 * (word32 -> 'a) -> 'a array = 
      let
      in
	 tabulate ('a)
      end
   val 'a sub_8: 'a array * word32 -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a newUninit_2: word32 -> 'a array = 
      let
      in
	 newUninit ('a)
      end
   val 'a new_1: word32 * 'a -> 'a array = 
      let
      in
	 new ('a)
      end
   val 'a length_12: 'a array -> word32 = 
      let
      in
	 length ('a)
      end
   val ('b, 'a) foldri_2: (word32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b = 
      let
      in
	 foldri ('a, 'b)
      end
   val 'a slice_3: 'a array * word32 * word32 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t = 
      let
      in
	 slice ('a)
      end
   val 'a full_6: 'a array -> 'a PrimSequence.Slice.t = 
      let
      in
	 full ('a)
      end
   val 'a base_7: 'a PrimSequence.Slice.t -> 'a array * word32 * word32 = 
      let
      in
	 base ('a)
      end
   val rec ('a_2611, 'a_2610, 'a_2609) 
      wrapCopy: (word64 * 'a_2610 * 'a_2611 -> 'a_2609)
		-> word32 * 'a_2610 * 'a_2611 -> 'a_2609 = 
	 fn x_1248: word64 * 'a_2610 * 'a_2611 -> 'a_2609 => 
	 let
	    val x_4212: word32 * 'a_2610 * 'a_2611 -> 'a_2609 = 
	       fn x_1249: word32 * 'a_2610 * 'a_2611 => 
	       let
		  val src: 'a_2611 = 
		     #2 x_1249
		  val dst: 'a_2610 = 
		     #1 x_1249
		  val di: word32 = 
		     #0 x_1249
		  val x_4213: 'a_2609 = 
		     let
			val x_4214: word64 = 
			   sextdFromInt32ToInt64 di
			val x_4215: word64 * 'a_2610 * 'a_2611 = 
			   (x_4214, dst, src)
			val x_4216: 'a_2609 = 
			   x_1248 x_4215
		     in
			x_4216
		     end
		     handle x_1250 => let
					 val x_4217: 'a_2609 = 
					    case x_1250 of
					    Overflow => 
					       let
						  val x_4218: exn = 
						     Subscript
						  val x_4219: 'a_2609 = 
						     raise x_4218
					       in
						  x_4219
					       end
					      _ => let
						      val x_4220: 'a_2609 = 
							 raise x_1250
						   in
						      x_4220
						   end
				      in
					 x_4217
				      end
	       in
		  x_4213
	       end
	 in
	    x_4212
	 end
   val 'a_2612 vector: 'a_2612 PrimSequence.Slice.t -> 'a_2612 vector = 
      let
      in
	 vector ('a_2612)
      end
   val 'a_2618 arrayUninit: word32 -> 'a_2618 array = 
      let
      in
	 newUninit_2 ('a_2618)
      end
   val 'a_2619 array: word32 * 'a_2619 -> 'a_2619 array = 
      let
      in
	 new_1 ('a_2619)
      end
   val rec 'a_2621 
      update: 'a_2621 array * word32 * 'a_2621 -> unit = 
	 fn x_1251: 'a_2621 array * word32 * 'a_2621 => 
	 let
	    val x_4221: 'a_2621 array * word32 * 'a_2621 -> unit = 
	       updateMk_2 ('a_2621) updateUnsafe ('a_2621)
	    val x_4222: unit = 
	       x_4221 x_1251
	 in
	    x_4222
	 end
   val rec 'a_2624 
      copyVec: word32 * 'a_2624 array * 'a_2624 vector -> unit = 
	 fn x_1252: word32 * 'a_2624 array * 'a_2624 vector => 
	 let
	    val x_4223: word32 * 'a_2624 array * 'a_2624 vector -> unit = 
	       wrapCopy ('a_2624 vector, 'a_2624 array, unit) copyVec ('a_2624)
	    val x_4224: unit = 
	       x_4223 x_1252
	 in
	    x_4224
	 end
   val 'a update_0: 'a array * word32 * 'a -> unit = 
      let
      in
	 update ('a)
      end
   val ('a, 'b) unfoldi_5: word32 * 'b * (word32 * 'b -> 'a * 'b)
			   -> 'a array * 'b = 
      let
      in
	 unfoldi_4 ('a, 'b)
      end
   val 'a tabulate_4: word32 * (word32 -> 'a) -> 'a array = 
      let
      in
	 tabulate_3 ('a)
      end
   val 'a sub_9: 'a array * word32 -> 'a = 
      let
      in
	 sub_8 ('a)
      end
   val 'a length_13: 'a array -> word32 = 
      let
      in
	 length_12 ('a)
      end
   val ('b, 'a) foldri_3: (word32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b = 
      let
      in
	 foldri_2 ('b, 'a)
      end
   val 'a copyVec_0: word32 * 'a array * 'a vector -> unit = 
      let
      in
	 copyVec ('a)
      end
   val 'a arrayUninit_0: word32 -> 'a array = 
      let
      in
	 arrayUninit ('a)
      end
   val 'a array_0: word32 * 'a -> 'a array = 
      let
      in
	 array ('a)
      end
   val 'a vector_2: 'a PrimSequence.Slice.t -> 'a vector = 
      let
      in
	 vector ('a)
      end
   val 'a slice_4: 'a array * word32 * word32 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t = 
      let
      in
	 slice_3 ('a)
      end
   val 'a full_7: 'a array -> 'a PrimSequence.Slice.t = 
      let
      in
	 full_6 ('a)
      end
   val 'a base_8: 'a PrimSequence.Slice.t -> 'a array * word32 * word32 = 
      let
      in
	 base_7 ('a)
      end
   val 'a vector_3: 'a PrimSequence.Slice.t -> 'a vector = 
      let
      in
	 vector_2 ('a)
      end
   val 'a slice_5: 'a array * word32 * word32 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t = 
      let
      in
	 slice_4 ('a)
      end
   val 'a base_9: 'a PrimSequence.Slice.t -> 'a array * word32 * word32 = 
      let
      in
	 base_8 ('a)
      end
   val 'a_2767 toPoly: 'a_2767 -> 'a_2767 = 
      let
	 val x_4225: 'a_2767 -> 'a_2767 = 
	    fn x_1253: 'a_2767 => 
	    let
	    in
	       x_1253
	    end
      in
	 x_4225
      end
   val 'a_2768 fromPoly: 'a_2768 -> 'a_2768 = 
      let
	 val x_4226: 'a_2768 -> 'a_2768 = 
	    fn x_1254: 'a_2768 => 
	    let
	    in
	       x_1254
	    end
      in
	 x_4226
      end
   val 'a_2770 toPoly: 'a_2770 -> 'a_2770 = 
      let
	 val x_4227: 'a_2770 -> 'a_2770 = 
	    fn x_1255: 'a_2770 => 
	    let
	    in
	       x_1255
	    end
      in
	 x_4227
      end
   val x_4228: (word8 -> word8) * (word32 -> word8) = 
      (idFromWord8, sextdFromInt32ToWord8)
   val x_4229: word32 -> word8 = 
      o_1 (word32, word8, word8) x_4228
   val x_4230: (word8 -> word32) * (word8 -> word8) = 
      (zextdFromWord8ToInt32, idToWord8)
   val x_4231: word8 -> word32 = 
      o_1 (word8, word32, word8) x_4230
   val x_4232: word32 = 
      0x100
   val x_4233: (word16 -> word16) * (word32 -> word16) = 
      (idFromWord16, sextdFromInt32ToWord16)
   val x_4234: word32 -> word16 = 
      o_1 (word32, word16, word16) x_4233
   val x_4235: (word16 -> word32) * (word16 -> word16) = 
      (zextdFromWord16ToInt32, idToWord16)
   val x_4236: word16 -> word32 = 
      o_1 (word16, word32, word16) x_4235
   val x_4237: (word32 -> word32) * (word32 -> word32) = 
      (idFromWord32, sextdFromInt32ToWord32)
   val x_4238: word32 -> word32 = 
      o_1 (word32, word32, word32) x_4237
   val x_4239: (word32 -> word32) * (word32 -> word32) = 
      (zextdFromWord32ToInt32, idToWord32)
   val x_4240: word32 -> word32 = 
      o_1 (word32, word32, word32) x_4239
   val rec ('b, 'a) 
      readerN: ('b -> ('a * 'b) Primitive.Option.t) * word32
	       -> 'b -> ('a list * 'b) Primitive.Option.t = 
	 fn x_1256: ('b -> ('a * 'b) Primitive.Option.t) * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1256
	    val reader: 'b -> ('a * 'b) Primitive.Option.t = 
	       #0 x_1256
	    val x_4241: 'b -> ('a list * 'b) Primitive.Option.t = 
	       fn x_1257: 'b => 
	       let
		  val rec 
		     loop: word32 * 'b * 'a list
			   -> ('a list * 'b) Primitive.Option.t = 
			fn x_1258: word32 * 'b * 'a list => 
			let
			   val accum: 'a list = 
			      #2 x_1258
			   val state: 'b = 
			      #1 x_1258
			   val n: word32 = 
			      #0 x_1258
			   val x_4242: word32 = 
			      0x0
			   val x_4243: word32 * word32 = 
			      (n, x_4242)
			   val x_4244: bool = 
			      <= x_4243
			   val x_4245: ('a list * 'b) Primitive.Option.t = 
			      case x_4244 of
			      true => 
				 let
				    val x_4259: 'a list = 
				       rev_1 ('a) accum
				    val x_4260: 'a list * 'b = 
				       (x_4259, state)
				    val x_4261: ('a list * 'b) Primitive.Option.t = 
				       SOME['a list * 'b] x_4260
				 in
				    x_4261
				 end
			      false => 
				 let
				    val x_4246: ('a * 'b) Primitive.Option.t = 
				       reader state
				    val x_4247: ('a list * 'b) Primitive.Option.t = 
				       case x_4246 of
				       NONE['a * 'b] => 
					  let
					     val x_4258: ('a list * 'b) Primitive.Option.t = 
						NONE['a list * 'b]
					  in
					     x_4258
					  end
				       SOME['a * 'b] x_4248: 'a * 'b => 
					  let
					     val x_4249: 'b = 
						#1 x_4248
					     val x_4250: 'a = 
						#0 x_4248
					     val x_4251: word32 = 
						0x1
					     val x_4252: word32 * word32 = 
						(n, x_4251)
					     val x_4253: word32 = 
						-! x_4252
					     val x_4254: 'a * 'a list = 
						(x_4250, accum)
					     val x_4255: 'a list = 
						::['a] x_4254
					     val x_4256: word32 * 'b * 'a list = 
						(x_4253, x_4249, x_4255)
					     val x_4257: ('a list * 'b) Primitive.Option.t = 
						loop x_4256
					  in
					     x_4257
					  end
				 in
				    x_4247
				 end
			in
			   x_4245
			end
		  val x_4262: 'a list = 
		     nil['a]
		  val x_4263: word32 * 'b * 'a list = 
		     (n, x_1257, x_4262)
		  val x_4264: ('a list * 'b) Primitive.Option.t = 
		     loop x_4263
	       in
		  x_4264
	       end
	 in
	    x_4241
	 end
   val rec ('a_2826, 'a_2825) 
      ignore: ('a_2826 -> bool)
	      -> ('a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t)
		 -> 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t = 
	 fn x_1259: 'a_2826 -> bool => 
	 let
	    val x_4265: ('a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t)
			-> 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t = 
	       fn x_1260: 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t => 
	       let
		  val rec 
		     loop: 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t = 
			fn x_1261: 'a_2825 => 
			let
			   val x_4266: ('a_2826 * 'a_2825) Primitive.Option.t = 
			      x_1260 x_1261
			   val x_4267: ('a_2826 * 'a_2825) Primitive.Option.t = 
			      case x_4266 of
			      NONE['a_2826 * 'a_2825] => 
				 let
				    val x_4276: ('a_2826 * 'a_2825) Primitive.Option.t = 
				       NONE['a_2826 * 'a_2825]
				 in
				    x_4276
				 end
			      SOME['a_2826 * 'a_2825] x_4268: 'a_2826 * 'a_2825 => 
				 let
				    val x_4269: 'a_2825 = 
				       #1 x_4268
				    val x_4270: 'a_2826 = 
				       #0 x_4268
				    val x_4271: bool = 
				       x_1259 x_4270
				    val x_4272: ('a_2826 * 'a_2825) Primitive.Option.t = 
				       case x_4271 of
				       true => 
					  let
					     val x_4275: ('a_2826 * 'a_2825) Primitive.Option.t = 
						loop x_4269
					  in
					     x_4275
					  end
				       false => 
					  let
					     val x_4273: 'a_2826 * 'a_2825 = 
						(x_4270, x_4269)
					     val x_4274: ('a_2826 * 'a_2825) Primitive.Option.t = 
						SOME['a_2826 * 'a_2825] x_4273
					  in
					     x_4274
					  end
				 in
				    x_4272
				 end
			in
			   x_4267
			end
	       in
		  loop
	       end
	 in
	    x_4265
	 end
   val ('a_2828, 'a_2827) x_4277: ('a_2828 -> bool)
				  -> ('a_2827
				      -> ('a_2828 * 'a_2827) Primitive.Option.t)
				     -> 'a_2827
					-> ('a_2828 * 'a_2827) Primitive.Option.t = 
      let
      in
	 ignore ('a_2828, 'a_2827)
      end
   val rec ('b, 'c, 'a) 
      map: ('a -> 'c)
	   -> ('b -> ('a * 'b) Primitive.Option.t)
	      -> 'b -> ('c * 'b) Primitive.Option.t = 
	 fn x_1262: 'a -> 'c => 
	 let
	    val x_4278: ('b -> ('a * 'b) Primitive.Option.t)
			-> 'b -> ('c * 'b) Primitive.Option.t = 
	       fn x_1263: 'b -> ('a * 'b) Primitive.Option.t => 
	       let
		  val x_4279: 'b -> ('c * 'b) Primitive.Option.t = 
		     fn x_1264: 'b => 
		     let
			val x_4280: ('a * 'b) Primitive.Option.t = 
			   x_1263 x_1264
			val x_4281: ('c * 'b) Primitive.Option.t = 
			   case x_4280 of
			   NONE['a * 'b] => 
			      let
				 val x_4288: ('c * 'b) Primitive.Option.t = 
				    NONE['c * 'b]
			      in
				 x_4288
			      end
			   SOME['a * 'b] x_4282: 'a * 'b => 
			      let
				 val x_4283: 'b = 
				    #1 x_4282
				 val x_4284: 'a = 
				    #0 x_4282
				 val x_4285: 'c = 
				    x_1262 x_4284
				 val x_4286: 'c * 'b = 
				    (x_4285, x_4283)
				 val x_4287: ('c * 'b) Primitive.Option.t = 
				    SOME['c * 'b] x_4286
			      in
				 x_4287
			      end
		     in
			x_4281
		     end
	       in
		  x_4279
	       end
	 in
	    x_4278
	 end
   val rec ('a_2830, 'a_2829) 
      reader2: ('a_2830 -> ('a_2829 * 'a_2830) Primitive.Option.t)
	       -> 'a_2830 -> (('a_2829 * 'a_2829) * 'a_2830) Primitive.Option.t = 
	 fn x_1265: 'a_2830 -> ('a_2829 * 'a_2830) Primitive.Option.t => 
	 let
	    val x_4289: 'a_2829 list -> 'a_2829 * 'a_2829 = 
	       fn x_1266: 'a_2829 list => 
	       let
		  val x_4290: unit -> 'a_2829 * 'a_2829 = 
		     fn x_4291: unit => 
		     let
			val x_4292: word8 vector = 
			   "Reader.reader2"
			val x_4293: exn = 
			   Fail x_4292
			val x_4294: 'a_2829 * 'a_2829 = 
			   raise x_4293
		     in
			x_4294
		     end
		  val x_4295: 'a_2829 * 'a_2829 = 
		     case x_1266 of
		     ::['a_2829] x_4296: 'a_2829 * 'a_2829 list => 
			let
			   val x_4297: 'a_2829 list = 
			      #1 x_4296
			   val x_4298: 'a_2829 = 
			      #0 x_4296
			   val x_4299: 'a_2829 * 'a_2829 = 
			      case x_4297 of
			      ::['a_2829] x_4300: 'a_2829 * 'a_2829 list => 
				 let
				    val x_4301: 'a_2829 list = 
				       #1 x_4300
				    val x_4302: 'a_2829 = 
				       #0 x_4300
				    val x_4303: 'a_2829 * 'a_2829 = 
				       case x_4301 of
				       nil['a_2829] => 
					  let
					     val x_4304: 'a_2829 * 'a_2829 = 
						(x_4298, x_4302)
					  in
					     x_4304
					  end
					 _ => let
						 val x_4305: unit = 
						    ()
						 val x_4306: 'a_2829 * 'a_2829 = 
						    x_4290 x_4305
					      in
						 x_4306
					      end
				 in
				    x_4303
				 end
				_ => let
					val x_4307: unit = 
					   ()
					val x_4308: 'a_2829 * 'a_2829 = 
					   x_4290 x_4307
				     in
					x_4308
				     end
			in
			   x_4299
			end
		       _ => let
			       val x_4309: unit = 
				  ()
			       val x_4310: 'a_2829 * 'a_2829 = 
				  x_4290 x_4309
			    in
			       x_4310
			    end
	       in
		  x_4295
	       end
	    val x_4311: ('a_2830 -> ('a_2829 list * 'a_2830) Primitive.Option.t)
			-> 'a_2830
			   -> (('a_2829 * 'a_2829) * 'a_2830) Primitive.Option.t = 
	       map ('a_2830, 'a_2829 * 'a_2829, 'a_2829 list) x_4289
	    val x_4312: word32 = 
	       0x2
	    val x_4313: ('a_2830 -> ('a_2829 * 'a_2830) Primitive.Option.t)
			* word32 = 
	       (x_1265, x_4312)
	    val x_4314: 'a_2830 -> ('a_2829 list * 'a_2830) Primitive.Option.t = 
	       readerN ('a_2830, 'a_2829) x_4313
	    val x_4315: 'a_2830
			-> (('a_2829 * 'a_2829) * 'a_2830) Primitive.Option.t = 
	       x_4311 x_4314
	 in
	    x_4315
	 end
   val ('a_2832, 'a_2831) x_4316: ('a_2832
				   -> ('a_2831 * 'a_2832) Primitive.Option.t)
				  -> 'a_2832
				     -> (('a_2831 * 'a_2831) * 'a_2832) Primitive.Option.t = 
      let
      in
	 reader2 ('a_2832, 'a_2831)
      end
   val radixToInt: StringCvt.radix -> word32 = 
      fn x_1267: StringCvt.radix => 
      let
	 val x_4317: word32 = 
	    case x_1267 of
	    BIN => 
	       let
		  val x_4321: word32 = 
		     0x2
	       in
		  x_4321
	       end
	    DEC => 
	       let
		  val x_4320: word32 = 
		     0xA
	       in
		  x_4320
	       end
	    HEX => 
	       let
		  val x_4319: word32 = 
		     0x10
	       in
		  x_4319
	       end
	    OCT => 
	       let
		  val x_4318: word32 = 
		     0x8
	       in
		  x_4318
	       end
      in
	 x_4317
      end
   val rec 'a_2839 
      splitl: (word8 -> bool)
	      -> ('a_2839 -> (word8 * 'a_2839) Primitive.Option.t)
		 -> 'a_2839 -> word8 vector * 'a_2839 = 
	 fn x_1268: word8 -> bool => 
	 let
	    val x_4322: ('a_2839 -> (word8 * 'a_2839) Primitive.Option.t)
			-> 'a_2839 -> word8 vector * 'a_2839 = 
	       fn x_1269: 'a_2839 -> (word8 * 'a_2839) Primitive.Option.t => 
	       let
		  val x_4323: 'a_2839 -> word8 vector * 'a_2839 = 
		     fn x_1270: 'a_2839 => 
		     let
			val rec 
			   done: word8 list -> word8 vector = 
			      fn x_1272: word8 list => 
			      let
				 val x_4324: word8 list = 
				    rev_1 (word8) x_1272
				 val x_4325: word8 vector = 
				    fromList_1 (word8) x_4324
			      in
				 x_4325
			      end
			val rec 
			   loop: 'a_2839 * word8 list -> word8 vector * 'a_2839 = 
			      fn x_1271: 'a_2839 * word8 list => 
			      let
				 val chars: word8 list = 
				    #1 x_1271
				 val src: 'a_2839 = 
				    #0 x_1271
				 val x_4326: (word8 * 'a_2839) Primitive.Option.t = 
				    x_1269 src
				 val x_4327: word8 vector * 'a_2839 = 
				    case x_4326 of
				    NONE[word8 * 'a_2839] => 
				       let
					  val x_4339: word8 vector = 
					     done chars
					  val x_4340: word8 vector * 'a_2839 = 
					     (x_4339, src)
				       in
					  x_4340
				       end
				    SOME[word8 * 'a_2839] x_4328: word8
								  * 'a_2839 => 
				       let
					  val x_4329: 'a_2839 = 
					     #1 x_4328
					  val x_4330: word8 = 
					     #0 x_4328
					  val x_4331: bool = 
					     x_1268 x_4330
					  val x_4332: word8 vector * 'a_2839 = 
					     case x_4331 of
					     true => 
						let
						   val x_4335: word8
							       * word8 list = 
						      (x_4330, chars)
						   val x_4336: word8 list = 
						      ::[word8] x_4335
						   val x_4337: 'a_2839
							       * word8 list = 
						      (x_4329, x_4336)
						   val x_4338: word8 vector
							       * 'a_2839 = 
						      loop x_4337
						in
						   x_4338
						end
					     false => 
						let
						   val x_4333: word8 vector = 
						      done chars
						   val x_4334: word8 vector
							       * 'a_2839 = 
						      (x_4333, src)
						in
						   x_4334
						end
				       in
					  x_4332
				       end
			      in
				 x_4327
			      end
			val x_4341: word8 list = 
			   nil[word8]
			val x_4342: 'a_2839 * word8 list = 
			   (x_1270, x_4341)
			val x_4343: word8 vector * 'a_2839 = 
			   loop x_4342
		     in
			x_4343
		     end
	       in
		  x_4323
	       end
	 in
	    x_4322
	 end
   val rec 'a_2841 
      dropl: (word8 -> bool)
	     -> ('a_2841 -> (word8 * 'a_2841) Primitive.Option.t)
		-> 'a_2841 -> 'a_2841 = 
	 fn x_1273: word8 -> bool => 
	 let
	    val x_4344: ('a_2841 -> (word8 * 'a_2841) Primitive.Option.t)
			-> 'a_2841 -> 'a_2841 = 
	       fn x_1274: 'a_2841 -> (word8 * 'a_2841) Primitive.Option.t => 
	       let
		  val x_4345: 'a_2841 -> 'a_2841 = 
		     fn x_1275: 'a_2841 => 
		     let
			val x_4346: ('a_2841
				     -> (word8 * 'a_2841) Primitive.Option.t)
				    -> 'a_2841 -> word8 vector * 'a_2841 = 
			   splitl ('a_2841) x_1273
			val x_4347: 'a_2841 -> word8 vector * 'a_2841 = 
			   x_4346 x_1274
			val x_4348: word8 vector * 'a_2841 = 
			   x_4347 x_1275
			val x_4349: 'a_2841 = 
			   #1 x_4348
		     in
			x_4349
		     end
	       in
		  x_4345
	       end
	 in
	    x_4344
	 end
   val rec 'a 
      scanString: ((word32 -> (word8 * word32) Primitive.Option.t)
		   -> word32 -> ('a * word32) Primitive.Option.t)
		  -> word8 vector -> 'a Primitive.Option.t = 
	 fn x_1279: (word32 -> (word8 * word32) Primitive.Option.t)
		    -> word32 -> ('a * word32) Primitive.Option.t => 
	 let
	    val x_4350: word8 vector -> 'a Primitive.Option.t = 
	       fn x_1280: word8 vector => 
	       let
		  val x_4351: word32 -> (word8 * word32) Primitive.Option.t = 
		     fn x_1278: word32 => 
		     let
			val x_4352: word32 = 
			   length_9 (word8) x_1280
			val x_4353: word32 * word32 = 
			   (x_1278, x_4352)
			val x_4354: bool = 
			   >= x_4353
			val x_4355: (word8 * word32) Primitive.Option.t = 
			   case x_4354 of
			   true => 
			      let
				 val x_4363: (word8 * word32) Primitive.Option.t = 
				    NONE[word8 * word32]
			      in
				 x_4363
			      end
			   false => 
			      let
				 val x_4356: word8 vector * word32 = 
				    (x_1280, x_1278)
				 val x_4357: word8 = 
				    sub_5 (word8) x_4356
				 val x_4358: word32 = 
				    0x1
				 val x_4359: word32 * word32 = 
				    (x_1278, x_4358)
				 val x_4360: word32 = 
				    +! x_4359
				 val x_4361: word8 * word32 = 
				    (x_4357, x_4360)
				 val x_4362: (word8 * word32) Primitive.Option.t = 
				    SOME[word8 * word32] x_4361
			      in
				 x_4362
			      end
		     in
			x_4355
		     end
		  val x_4364: word32 -> ('a * word32) Primitive.Option.t = 
		     x_1279 x_4351
		  val x_4365: word32 = 
		     0x0
		  val x_4366: ('a * word32) Primitive.Option.t = 
		     x_4364 x_4365
		  val x_4367: 'a Primitive.Option.t = 
		     case x_4366 of
		     NONE['a * word32] => 
			let
			   val x_4371: 'a Primitive.Option.t = 
			      NONE['a]
			in
			   x_4371
			end
		     SOME['a * word32] x_4368: 'a * word32 => 
			let
			   val x_4369: 'a = 
			      #0 x_4368
			   val x_4370: 'a Primitive.Option.t = 
			      SOME['a] x_4369
			in
			   x_4370
			end
	       in
		  x_4367
	       end
	 in
	    x_4350
	 end
   val rec 'a 
      memoize: (word8 -> 'a) -> word8 -> 'a = 
	 fn x_1281: word8 -> 'a => 
	 let
	    val x_4372: (word8 -> 'a) * (word32 -> word8) = 
	       (x_1281, x_4229)
	    val x_4373: word32 -> 'a = 
	       o_1 (word32, 'a, word8) x_4372
	    val x_4374: word32 * (word32 -> 'a) = 
	       (x_4232, x_4373)
	    val a: 'a array = 
	       tabulate_4 ('a) x_4374
	    val x_4375: word8 -> 'a = 
	       fn x_1282: word8 => 
	       let
		  val x_4376: word32 = 
		     x_4231 x_1282
		  val x_4377: 'a array * word32 = 
		     (a, x_4376)
		  val x_4378: 'a = 
		     sub_9 ('a) x_4377
	       in
		  x_4378
	       end
	 in
	    x_4375
	 end
   val rec 
      range: word32 * word8 * word8 -> word8 -> word32 Primitive.Option.t = 
	 fn x_1283: word32 * word8 * word8 => 
	 let
	    val cmax: word8 = 
	       #2 x_1283
	    val cmin: word8 = 
	       #1 x_1283
	    val add: word32 = 
	       #0 x_1283
	    val min: word32 = 
	       x_4231 cmin
	    val x_4379: word8 -> word32 Primitive.Option.t = 
	       fn x_1284: word8 => 
	       let
		  val x_4380: word8 * word8 = 
		     (cmin, x_1284)
		  val x_4381: bool = 
		     <= x_4380
		  val x_4382: bool = 
		     case x_4381 of
		     true => 
			let
			   val x_4384: word8 * word8 = 
			      (x_1284, cmax)
			   val x_4385: bool = 
			      <= x_4384
			in
			   x_4385
			end
		     false => 
			let
			   val x_4383: bool = 
			      false
			in
			   x_4383
			end
		  val x_4386: word32 Primitive.Option.t = 
		     case x_4382 of
		     true => 
			let
			   val x_4388: word32 = 
			      x_4231 x_1284
			   val x_4389: word32 * word32 = 
			      (add, x_4388)
			   val x_4390: word32 = 
			      +? x_4389
			   val x_4391: word32 * word32 = 
			      (x_4390, min)
			   val x_4392: word32 = 
			      -? x_4391
			   val x_4393: word32 Primitive.Option.t = 
			      SOME[word32] x_4392
			in
			   x_4393
			end
		     false => 
			let
			   val x_4387: word32 Primitive.Option.t = 
			      NONE[word32]
			in
			   x_4387
			end
	       in
		  x_4386
	       end
	 in
	    x_4379
	 end
   val rec 'a 
      combine: (word8 -> 'a Primitive.Option.t) list
	       -> word8 -> 'a Primitive.Option.t = 
	 fn x_1285: (word8 -> 'a Primitive.Option.t) list => 
	 let
	    val x_4394: word8 -> 'a Primitive.Option.t = 
	       fn x_1286: word8 => 
	       let
		  val rec 'a_2842 
		     loop: (word8 -> 'a_2842 Primitive.Option.t) list
			   -> 'a_2842 Primitive.Option.t = 
			fn x_1287: (word8 -> 'a_2842 Primitive.Option.t) list => 
			let
			   val x_4395: 'a_2842 Primitive.Option.t = 
			      case x_1287 of
			      nil[word8 -> 'a_2842 Primitive.Option.t] => 
				 let
				    val x_4402: 'a_2842 Primitive.Option.t = 
				       NONE['a_2842]
				 in
				    x_4402
				 end
			      ::[word8 -> 'a_2842 Primitive.Option.t] x_4396: (word8
									       -> 'a_2842 Primitive.Option.t)
									      * (word8
										 -> 'a_2842 Primitive.Option.t) list => 
				 let
				    val x_4397: (word8
						 -> 'a_2842 Primitive.Option.t) list = 
				       #1 x_4396
				    val x_4398: word8
						-> 'a_2842 Primitive.Option.t = 
				       #0 x_4396
				    val x_4399: 'a_2842 Primitive.Option.t = 
				       x_4398 x_1286
				    val x_4400: 'a_2842 Primitive.Option.t = 
				       case x_4399 of
				       NONE['a_2842] => 
					  let
					     val x_4401: 'a_2842 Primitive.Option.t = 
						loop ('a_2842) x_4397
					  in
					     x_4401
					  end
					 _ => let
					      in
						 x_4399
					      end
				 in
				    x_4400
				 end
			in
			   x_4395
			end
		  val x_4403: 'a Primitive.Option.t = 
		     loop ('a) x_1285
	       in
		  x_4403
	       end
	    val x_4404: word8 -> 'a Primitive.Option.t = 
	       memoize ('a Primitive.Option.t) x_4394
	 in
	    x_4404
	 end
   val x_4405: word32 = 
      0x0
   val x_4406: word8 = 
      0x30
   val x_4407: word8 = 
      0x31
   val x_4408: word32 * word8 * word8 = 
      (x_4405, x_4406, x_4407)
   val x_4409: word8 -> word32 Primitive.Option.t = 
      range x_4408
   val bin: word8 -> word32 Primitive.Option.t = 
      memoize (word32 Primitive.Option.t) x_4409
   val x_4410: word32 = 
      0x0
   val x_4411: word8 = 
      0x30
   val x_4412: word8 = 
      0x37
   val x_4413: word32 * word8 * word8 = 
      (x_4410, x_4411, x_4412)
   val x_4414: word8 -> word32 Primitive.Option.t = 
      range x_4413
   val oct: word8 -> word32 Primitive.Option.t = 
      memoize (word32 Primitive.Option.t) x_4414
   val x_4415: word32 = 
      0x0
   val x_4416: word8 = 
      0x30
   val x_4417: word8 = 
      0x39
   val x_4418: word32 * word8 * word8 = 
      (x_4415, x_4416, x_4417)
   val x_4419: word8 -> word32 Primitive.Option.t = 
      range x_4418
   val dec: word8 -> word32 Primitive.Option.t = 
      memoize (word32 Primitive.Option.t) x_4419
   val x_4420: word32 = 
      0x0
   val x_4421: word8 = 
      0x30
   val x_4422: word8 = 
      0x39
   val x_4423: word32 * word8 * word8 = 
      (x_4420, x_4421, x_4422)
   val x_4424: word8 -> word32 Primitive.Option.t = 
      range x_4423
   val x_4425: word32 = 
      0xA
   val x_4426: word8 = 
      0x61
   val x_4427: word8 = 
      0x66
   val x_4428: word32 * word8 * word8 = 
      (x_4425, x_4426, x_4427)
   val x_4429: word8 -> word32 Primitive.Option.t = 
      range x_4428
   val x_4430: word32 = 
      0xA
   val x_4431: word8 = 
      0x41
   val x_4432: word8 = 
      0x46
   val x_4433: word32 * word8 * word8 = 
      (x_4430, x_4431, x_4432)
   val x_4434: word8 -> word32 Primitive.Option.t = 
      range x_4433
   val x_4435: (word8 -> word32 Primitive.Option.t) list = 
      nil[word8 -> word32 Primitive.Option.t]
   val x_4436: (word8 -> word32 Primitive.Option.t)
	       * (word8 -> word32 Primitive.Option.t) list = 
      (x_4434, x_4435)
   val x_4437: (word8 -> word32 Primitive.Option.t) list = 
      ::[word8 -> word32 Primitive.Option.t] x_4436
   val x_4438: (word8 -> word32 Primitive.Option.t)
	       * (word8 -> word32 Primitive.Option.t) list = 
      (x_4429, x_4437)
   val x_4439: (word8 -> word32 Primitive.Option.t) list = 
      ::[word8 -> word32 Primitive.Option.t] x_4438
   val x_4440: (word8 -> word32 Primitive.Option.t)
	       * (word8 -> word32 Primitive.Option.t) list = 
      (x_4424, x_4439)
   val x_4441: (word8 -> word32 Primitive.Option.t) list = 
      ::[word8 -> word32 Primitive.Option.t] x_4440
   val hex: word8 -> word32 Primitive.Option.t = 
      combine (word32) x_4441
   val rec 
      isSpace: word8 -> bool = 
	 fn x_1288: word8 => 
	 let
	    val x_4442: word8 = 
	       0x20
	    val x_4443: word8 * word8 = 
	       (x_1288, x_4442)
	    val x_4444: bool = 
	       = (word8) x_4443
	    val x_4445: bool = 
	       case x_4444 of
	       true => 
		  let
		     val x_4449: bool = 
			true
		  in
		     x_4449
		  end
	       false => 
		  let
		     val x_4446: word8 = 
			0x9
		     val x_4447: word8 * word8 = 
			(x_1288, x_4446)
		     val x_4448: bool = 
			= (word8) x_4447
		  in
		     x_4448
		  end
	    val x_4450: bool = 
	       case x_4445 of
	       true => 
		  let
		     val x_4454: bool = 
			true
		  in
		     x_4454
		  end
	       false => 
		  let
		     val x_4451: word8 = 
			0xD
		     val x_4452: word8 * word8 = 
			(x_1288, x_4451)
		     val x_4453: bool = 
			= (word8) x_4452
		  in
		     x_4453
		  end
	    val x_4455: bool = 
	       case x_4450 of
	       true => 
		  let
		     val x_4459: bool = 
			true
		  in
		     x_4459
		  end
	       false => 
		  let
		     val x_4456: word8 = 
			0xA
		     val x_4457: word8 * word8 = 
			(x_1288, x_4456)
		     val x_4458: bool = 
			= (word8) x_4457
		  in
		     x_4458
		  end
	    val x_4460: bool = 
	       case x_4455 of
	       true => 
		  let
		     val x_4464: bool = 
			true
		  in
		     x_4464
		  end
	       false => 
		  let
		     val x_4461: word8 = 
			0xB
		     val x_4462: word8 * word8 = 
			(x_1288, x_4461)
		     val x_4463: bool = 
			= (word8) x_4462
		  in
		     x_4463
		  end
	    val x_4465: bool = 
	       case x_4460 of
	       true => 
		  let
		     val x_4469: bool = 
			true
		  in
		     x_4469
		  end
	       false => 
		  let
		     val x_4466: word8 = 
			0xC
		     val x_4467: word8 * word8 = 
			(x_1288, x_4466)
		     val x_4468: bool = 
			= (word8) x_4467
		  in
		     x_4468
		  end
	 in
	    x_4465
	 end
   val isSpace: word8 -> bool = 
      memoize (bool) isSpace
   val rec 'a_2843 
      skipWS: ('a_2843 -> (word8 * 'a_2843) Primitive.Option.t)
	      -> 'a_2843 -> 'a_2843 = 
	 fn x_1289: 'a_2843 -> (word8 * 'a_2843) Primitive.Option.t => 
	 let
	    val x_4470: ('a_2843 -> (word8 * 'a_2843) Primitive.Option.t)
			-> 'a_2843 -> 'a_2843 = 
	       dropl ('a_2843) isSpace
	    val x_4471: 'a_2843 -> 'a_2843 = 
	       x_4470 x_1289
	 in
	    x_4471
	 end
   val rec 
      digitToChar: word32 -> word8 = 
	 fn x_1291: word32 => 
	 let
	    val x_4472: word8 vector = 
	       "0123456789ABCDEF"
	    val x_4473: word8 vector * word32 = 
	       (x_4472, x_1291)
	    val x_4474: word8 = 
	       sub_5 (word8) x_4473
	 in
	    x_4474
	 end
   val 'a skipWS_0: ('a -> (word8 * 'a) Primitive.Option.t) -> 'a -> 'a = 
      let
      in
	 skipWS ('a)
      end
   val 'a scanString_0: ((word32 -> (word8 * word32) Primitive.Option.t)
			 -> word32 -> ('a * word32) Primitive.Option.t)
			-> word8 vector -> 'a Primitive.Option.t = 
      let
      in
	 scanString ('a)
      end
   val precision': word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word8 * word32 -> word8 = 
	 fn x_1292: word8 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1292
	    val i: word8 = 
	       #0 x_1292
	    val x_4475: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4476: bool = 
	       >= x_4475
	    val x_4477: word8 = 
	       case x_4476 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4478: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4479: word8 * word32 = 
			(i, x_4478)
		     val x_4480: word8 = 
			<<? x_4479
		  in
		     x_4480
		  end
	 in
	    x_4477
	 end
   val rec 
      >>: word8 * word32 -> word8 = 
	 fn x_1293: word8 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1293
	    val i: word8 = 
	       #0 x_1293
	    val x_4481: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4482: bool = 
	       >= x_4481
	    val x_4483: word8 = 
	       case x_4482 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4484: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4485: word8 * word32 = 
			(i, x_4484)
		     val x_4486: word8 = 
			>>? x_4485
		  in
		     x_4486
		  end
	 in
	    x_4483
	 end
   val precision': word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word16 * word32 -> word16 = 
	 fn x_1294: word16 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1294
	    val i: word16 = 
	       #0 x_1294
	    val x_4487: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4488: bool = 
	       >= x_4487
	    val x_4489: word16 = 
	       case x_4488 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4490: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4491: word16 * word32 = 
			(i, x_4490)
		     val x_4492: word16 = 
			<<? x_4491
		  in
		     x_4492
		  end
	 in
	    x_4489
	 end
   val rec 
      >>: word16 * word32 -> word16 = 
	 fn x_1295: word16 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1295
	    val i: word16 = 
	       #0 x_1295
	    val x_4493: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4494: bool = 
	       >= x_4493
	    val x_4495: word16 = 
	       case x_4494 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4496: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4497: word16 * word32 = 
			(i, x_4496)
		     val x_4498: word16 = 
			>>? x_4497
		  in
		     x_4498
		  end
	 in
	    x_4495
	 end
   val precision': word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word32 * word32 -> word32 = 
	 fn x_1296: word32 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1296
	    val i: word32 = 
	       #0 x_1296
	    val x_4499: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4500: bool = 
	       >= x_4499
	    val x_4501: word32 = 
	       case x_4500 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4502: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4503: word32 * word32 = 
			(i, x_4502)
		     val x_4504: word32 = 
			<<? x_4503
		  in
		     x_4504
		  end
	 in
	    x_4501
	 end
   val rec 
      >>: word32 * word32 -> word32 = 
	 fn x_1297: word32 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1297
	    val i: word32 = 
	       #0 x_1297
	    val x_4505: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4506: bool = 
	       >= x_4505
	    val x_4507: word32 = 
	       case x_4506 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4508: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4509: word32 * word32 = 
			(i, x_4508)
		     val x_4510: word32 = 
			>>? x_4509
		  in
		     x_4510
		  end
	 in
	    x_4507
	 end
   val x_4511: word32 = 
      0x1
   val x_4512: word32 * word32 = 
      (precision', x_4511)
   val maxNumDigits: word32 = 
      +! x_4512
   val x_4513: unit -> word8 array = 
      fn x_1298: unit => 
      let
	 val x_4514: word8 = 
	    0x0
	 val x_4515: word32 * word8 = 
	    (maxNumDigits, x_4514)
	 val x_4516: word8 array = 
	    array_0 (word8) x_4515
      in
	 x_4516
      end
   val oneBuf: word8 array One.t = 
      make_0 (word8 array) x_4513
   val x_4517: StringCvt.radix = 
      DEC
   val rec 'a_2855 
      scan: StringCvt.radix
	    -> ('a_2855 -> (word8 * 'a_2855) Primitive.Option.t)
	       -> 'a_2855 -> (word32 * 'a_2855) Primitive.Option.t = 
	 fn x_1303: StringCvt.radix => 
	 let
	    val x_4518: ('a_2855 -> (word8 * 'a_2855) Primitive.Option.t)
			-> 'a_2855 -> (word32 * 'a_2855) Primitive.Option.t = 
	       fn x_1304: 'a_2855 -> (word8 * 'a_2855) Primitive.Option.t => 
	       let
		  val x_4519: 'a_2855 -> (word32 * 'a_2855) Primitive.Option.t = 
		     fn x_1305: 'a_2855 => 
		     let
			val x_4520: 'a_2855 -> 'a_2855 = 
			   skipWS_0 ('a_2855) x_1304
			val s: 'a_2855 = 
			   x_4520 x_1305
			val rec 
			   charToDigit: word8 -> word32 Primitive.Option.t = 
			      fn x_1309: word8 => 
			      let
				 val x_4521: word8 -> word32 Primitive.Option.t = 
				    case x_1303 of
				    BIN => 
				       let
				       in
					  bin
				       end
				    DEC => 
				       let
				       in
					  dec
				       end
				    HEX => 
				       let
				       in
					  hex
				       end
				    OCT => 
				       let
				       in
					  oct
				       end
				 val x_4522: word32 Primitive.Option.t = 
				    x_4521 x_1309
				 val x_4523: word32 Primitive.Option.t = 
				    case x_4522 of
				    NONE[word32] => 
				       let
					  val x_4527: word32 Primitive.Option.t = 
					     NONE[word32]
				       in
					  x_4527
				       end
				    SOME[word32] x_4524: word32 => 
				       let
					  val x_4525: word32 = 
					     sextdFromInt32ToInt32 x_4524
					  val x_4526: word32 Primitive.Option.t = 
					     SOME[word32] x_4525
				       in
					  x_4526
				       end
			      in
				 x_4523
			      end
			val x_4528: word32 = 
			   radixToInt x_1303
			val radixInt: word32 = 
			   sextdFromInt32ToInt32 x_4528
			val rec 
			   finishNum: 'a_2855 * word32
				      -> (word32 * 'a_2855) Primitive.Option.t = 
			      fn x_1308: 'a_2855 * word32 => 
			      let
				 val n: word32 = 
				    #1 x_1308
				 val s: 'a_2855 = 
				    #0 x_1308
				 val x_4529: (word8 * 'a_2855) Primitive.Option.t = 
				    x_1304 s
				 val x_4530: (word32 * 'a_2855) Primitive.Option.t = 
				    case x_4529 of
				    NONE[word8 * 'a_2855] => 
				       let
					  val x_4545: word32 * 'a_2855 = 
					     (n, s)
					  val x_4546: (word32 * 'a_2855) Primitive.Option.t = 
					     SOME[word32 * 'a_2855] x_4545
				       in
					  x_4546
				       end
				    SOME[word8 * 'a_2855] x_4531: word8
								  * 'a_2855 => 
				       let
					  val x_4532: 'a_2855 = 
					     #1 x_4531
					  val x_4533: word8 = 
					     #0 x_4531
					  val x_4534: word32 Primitive.Option.t = 
					     charToDigit x_4533
					  val x_4535: (word32 * 'a_2855) Primitive.Option.t = 
					     case x_4534 of
					     NONE[word32] => 
						let
						   val x_4543: word32 * 'a_2855 = 
						      (n, s)
						   val x_4544: (word32 * 'a_2855) Primitive.Option.t = 
						      SOME[word32 * 'a_2855] x_4543
						in
						   x_4544
						end
					     SOME[word32] x_4536: word32 => 
						let
						   val x_4537: word32 * word32 = 
						      (n, radixInt)
						   val x_4538: word32 = 
						      *! x_4537
						   val x_4539: word32 * word32 = 
						      (x_4538, x_4536)
						   val x_4540: word32 = 
						      -! x_4539
						   val x_4541: 'a_2855 * word32 = 
						      (x_4532, x_4540)
						   val x_4542: (word32 * 'a_2855) Primitive.Option.t = 
						      finishNum x_4541
						in
						   x_4542
						end
				       in
					  x_4535
				       end
			      in
				 x_4530
			      end
			val rec 
			   num: 'a_2855 -> (word32 * 'a_2855) Primitive.Option.t = 
			      fn x_1307: 'a_2855 => 
			      let
				 val x_4547: (word8 * 'a_2855) Primitive.Option.t = 
				    x_1304 x_1307
				 val x_4548: 'a_2855 * word8
					     -> (word32 * 'a_2855) Primitive.Option.t = 
				    fn x_4549: 'a_2855 * word8 => 
				    let
				       val c: word8 = 
					  #1 x_4549
				       val s: 'a_2855 = 
					  #0 x_4549
				       val x_4550: word32 Primitive.Option.t = 
					  charToDigit c
				       val x_4551: (word32 * 'a_2855) Primitive.Option.t = 
					  case x_4550 of
					  NONE[word32] => 
					     let
						val x_4556: (word32 * 'a_2855) Primitive.Option.t = 
						   NONE[word32 * 'a_2855]
					     in
						x_4556
					     end
					  SOME[word32] x_4552: word32 => 
					     let
						val x_4553: word32 = 
						   ~? x_4552
						val x_4554: 'a_2855 * word32 = 
						   (s, x_4553)
						val x_4555: (word32 * 'a_2855) Primitive.Option.t = 
						   finishNum x_4554
					     in
						x_4555
					     end
				    in
				       x_4551
				    end
				 val x_4557: (word32 * 'a_2855) Primitive.Option.t = 
				    case x_4547 of
				    NONE[word8 * 'a_2855] => 
				       let
					  val x_4606: (word32 * 'a_2855) Primitive.Option.t = 
					     NONE[word32 * 'a_2855]
				       in
					  x_4606
				       end
				    SOME[word8 * 'a_2855] x_4558: word8
								  * 'a_2855 => 
				       let
					  val x_4559: 'a_2855 = 
					     #1 x_4558
					  val x_4560: word8 = 
					     #0 x_4558
					  val x_4561: (word32 * 'a_2855) Primitive.Option.t = 
					     case x_4560 of
					     0x30 => 
						let
						   val x_4562: (word32 * 'a_2855) Primitive.Option.t = 
						      case x_1303 of
						      HEX => 
							 let
							    val x_4563: (word8
									 * 'a_2855) Primitive.Option.t = 
							       x_1304 x_4559
							    val x_4564: (word32
									 * 'a_2855) Primitive.Option.t = 
							       case x_4563 of
							       NONE[word8
								    * 'a_2855] => 
								  let
								     val x_4600: word32
										 * 'a_2855 = 
									(zero,
									 x_4559)
								     val x_4601: (word32
										  * 'a_2855) Primitive.Option.t = 
									SOME[word32
									     * 'a_2855] x_4600
								  in
								     x_4601
								  end
							       SOME[word8
								    * 'a_2855] x_4565: word8
										       * 'a_2855 => 
								  let
								     val x_4566: 'a_2855 = 
									#1 x_4565
								     val x_4567: word8 = 
									#0 x_4565
								     val x_4568: word8 = 
									0x78
								     val x_4569: word8
										 * word8 = 
									(x_4567,
									 x_4568)
								     val x_4570: bool = 
									= (word8) x_4569
								     val x_4571: bool = 
									case x_4570 of
									true => 
									   let
									      val x_4575: bool = 
										 true
									   in
									      x_4575
									   end
									false => 
									   let
									      val x_4572: word8 = 
										 0x58
									      val x_4573: word8
											  * word8 = 
										 (x_4567,
										  x_4572)
									      val x_4574: bool = 
										 = (word8) x_4573
									   in
									      x_4574
									   end
								     val x_4576: (word32
										  * 'a_2855) Primitive.Option.t = 
									case x_4571 of
									true => 
									   let
									      val x_4585: (word8
											   * 'a_2855) Primitive.Option.t = 
										 x_1304 x_4566
									      val x_4586: (word32
											   * 'a_2855) Primitive.Option.t = 
										 case x_4585 of
										 NONE[word8
										      * 'a_2855] => 
										    let
										       val x_4598: word32
												   * 'a_2855 = 
											  (zero,
											   x_4559)
										       val x_4599: (word32
												    * 'a_2855) Primitive.Option.t = 
											  SOME[word32
											       * 'a_2855] x_4598
										    in
										       x_4599
										    end
										 SOME[word8
										      * 'a_2855] x_4587: word8
													 * 'a_2855 => 
										    let
										       val x_4588: 'a_2855 = 
											  #1 x_4587
										       val x_4589: word8 = 
											  #0 x_4587
										       val x_4590: word32 Primitive.Option.t = 
											  charToDigit x_4589
										       val x_4591: (word32
												    * 'a_2855) Primitive.Option.t = 
											  case x_4590 of
											  NONE[word32] => 
											     let
												val x_4596: word32
													    * 'a_2855 = 
												   (zero,
												    x_4559)
												val x_4597: (word32
													     * 'a_2855) Primitive.Option.t = 
												   SOME[word32
													* 'a_2855] x_4596
											     in
												x_4597
											     end
											  SOME[word32] x_4592: word32 => 
											     let
												val x_4593: word32 = 
												   ~? x_4592
												val x_4594: 'a_2855
													    * word32 = 
												   (x_4588,
												    x_4593)
												val x_4595: (word32
													     * 'a_2855) Primitive.Option.t = 
												   finishNum x_4594
											     in
												x_4595
											     end
										    in
										       x_4591
										    end
									   in
									      x_4586
									   end
									false => 
									   let
									      val x_4577: word32 Primitive.Option.t = 
										 charToDigit x_4567
									      val x_4578: (word32
											   * 'a_2855) Primitive.Option.t = 
										 case x_4577 of
										 NONE[word32] => 
										    let
										       val x_4583: word32
												   * 'a_2855 = 
											  (zero,
											   x_4559)
										       val x_4584: (word32
												    * 'a_2855) Primitive.Option.t = 
											  SOME[word32
											       * 'a_2855] x_4583
										    in
										       x_4584
										    end
										 SOME[word32] x_4579: word32 => 
										    let
										       val x_4580: word32 = 
											  ~? x_4579
										       val x_4581: 'a_2855
												   * word32 = 
											  (x_4566,
											   x_4580)
										       val x_4582: (word32
												    * 'a_2855) Primitive.Option.t = 
											  finishNum x_4581
										    in
										       x_4582
										    end
									   in
									      x_4578
									   end
								  in
								     x_4576
								  end
							 in
							    x_4564
							 end
							_ => let
								val x_4602: 'a_2855
									    * word8 = 
								   (x_4559,
								    x_4560)
								val x_4603: (word32
									     * 'a_2855) Primitive.Option.t = 
								   x_4548 x_4602
							     in
								x_4603
							     end
						in
						   x_4562
						end
					       _ => let
						       val x_4604: 'a_2855
								   * word8 = 
							  (x_4559, x_4560)
						       val x_4605: (word32
								    * 'a_2855) Primitive.Option.t = 
							  x_4548 x_4604
						    in
						       x_4605
						    end
				       in
					  x_4561
				       end
			      in
				 x_4557
			      end
			val rec 
			   negate: 'a_2855
				   -> (word32 * 'a_2855) Primitive.Option.t = 
			      fn x_1306: 'a_2855 => 
			      let
				 val x_4607: (word32 * 'a_2855) Primitive.Option.t = 
				    num x_1306
				 val x_4608: (word32 * 'a_2855) Primitive.Option.t = 
				    case x_4607 of
				    NONE[word32 * 'a_2855] => 
				       let
					  val x_4615: (word32 * 'a_2855) Primitive.Option.t = 
					     NONE[word32 * 'a_2855]
				       in
					  x_4615
				       end
				    SOME[word32 * 'a_2855] x_4609: word32
								   * 'a_2855 => 
				       let
					  val x_4610: 'a_2855 = 
					     #1 x_4609
					  val x_4611: word32 = 
					     #0 x_4609
					  val x_4612: word32 = 
					     ~! x_4611
					  val x_4613: word32 * 'a_2855 = 
					     (x_4612, x_4610)
					  val x_4614: (word32 * 'a_2855) Primitive.Option.t = 
					     SOME[word32 * 'a_2855] x_4613
				       in
					  x_4614
				       end
			      in
				 x_4608
			      end
			val x_4616: (word8 * 'a_2855) Primitive.Option.t = 
			   x_1304 s
			val x_4617: (word32 * 'a_2855) Primitive.Option.t = 
			   case x_4616 of
			   NONE[word8 * 'a_2855] => 
			      let
				 val x_4626: (word32 * 'a_2855) Primitive.Option.t = 
				    NONE[word32 * 'a_2855]
			      in
				 x_4626
			      end
			   SOME[word8 * 'a_2855] x_4618: word8 * 'a_2855 => 
			      let
				 val x_4619: 'a_2855 = 
				    #1 x_4618
				 val x_4620: word8 = 
				    #0 x_4618
				 val x_4621: (word32 * 'a_2855) Primitive.Option.t = 
				    case x_4620 of
				    0x7E => 
				       let
					  val x_4624: (word32 * 'a_2855) Primitive.Option.t = 
					     num x_4619
				       in
					  x_4624
				       end
				    0x2B => 
				       let
					  val x_4623: (word32 * 'a_2855) Primitive.Option.t = 
					     negate x_4619
				       in
					  x_4623
				       end
				    0x2D => 
				       let
					  val x_4622: (word32 * 'a_2855) Primitive.Option.t = 
					     num x_4619
				       in
					  x_4622
				       end
				      _ => let
					      val x_4625: (word32 * 'a_2855) Primitive.Option.t = 
						 negate s
					   in
					      x_4625
					   end
			      in
				 x_4621
			      end
		     in
			x_4617
		     end
	       in
		  x_4519
	       end
	 in
	    x_4518
	 end
   val x_4627: StringCvt.radix = 
      DEC
   val x_4628: (word32 -> (word8 * word32) Primitive.Option.t)
	       -> word32 -> (word32 * word32) Primitive.Option.t = 
      scan (word32) x_4627
   val fromString: word8 vector -> word32 Primitive.Option.t = 
      scanString_0 (word32) x_4628
   val precision': word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word64 * word32 -> word64 = 
	 fn x_1310: word64 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1310
	    val i: word64 = 
	       #0 x_1310
	    val x_4629: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4630: bool = 
	       >= x_4629
	    val x_4631: word64 = 
	       case x_4630 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4632: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4633: word64 * word32 = 
			(i, x_4632)
		     val x_4634: word64 = 
			<<? x_4633
		  in
		     x_4634
		  end
	 in
	    x_4631
	 end
   val rec 
      >>: word64 * word32 -> word64 = 
	 fn x_1311: word64 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1311
	    val i: word64 = 
	       #0 x_1311
	    val x_4635: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4636: bool = 
	       >= x_4635
	    val x_4637: word64 = 
	       case x_4636 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4638: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4639: word64 * word32 = 
			(i, x_4638)
		     val x_4640: word64 = 
			>>? x_4639
		  in
		     x_4640
		  end
	 in
	    x_4637
	 end
   val x_4641: word32 = 
      0x1
   val x_4642: word32 * word32 = 
      (precision', x_4641)
   val maxNumDigits: word32 = 
      +! x_4642
   val x_4643: unit -> word8 array = 
      fn x_1312: unit => 
      let
	 val x_4644: word8 = 
	    0x0
	 val x_4645: word32 * word8 = 
	    (maxNumDigits, x_4644)
	 val x_4646: word8 array = 
	    array_0 (word8) x_4645
      in
	 x_4646
      end
   val oneBuf: word8 array One.t = 
      make_0 (word8 array) x_4643
   val rec 
      fmt: StringCvt.radix -> word64 -> word8 vector = 
	 fn x_1313: StringCvt.radix => 
	 let
	    val x_4647: word64 -> word8 vector = 
	       fn x_1314: word64 => 
	       let
		  val x_4648: word8 array -> word8 vector = 
		     fn x_1315: word8 array => 
		     let
			val x_4649: word32 = 
			   radixToInt x_1313
			val radix: word64 = 
			   sextdFromInt32ToInt64 x_4649
			val rec 
			   loop: word64 * word32 -> word8 vector = 
			      fn x_1316: word64 * word32 => 
			      let
				 val i: word32 = 
				    #1 x_1316
				 val q: word64 = 
				    #0 x_1316
				 val x_4650: word64 * word64 = 
				    (radix, zero)
				 val x_4651: bool = 
				    = (word64) x_4650
				 val x_4652: word64 = 
				    case x_4651 of
				    true => 
				       let
					  val x_4662: exn = 
					     Div
					  val x_4663: word64 = 
					     raise x_4662
				       in
					  x_4663
				       end
				    false => 
				       let
					  val x_4653: word64 * word64 = 
					     (q, minInt')
					  val x_4654: bool = 
					     = (word64) x_4653
					  val x_4655: bool = 
					     case x_4654 of
					     true => 
						let
						   val x_4657: word64 = 
						      ~! one
						   val x_4658: word64 * word64 = 
						      (radix, x_4657)
						   val x_4659: bool = 
						      = (word64) x_4658
						in
						   x_4659
						end
					     false => 
						let
						   val x_4656: bool = 
						      false
						in
						   x_4656
						end
					  val x_4660: word64 = 
					     case x_4655 of
					     true => 
						let
						in
						   zero
						end
					     false => 
						let
						   val x_4661: word64 = 
						      WordS64_rem (q, radix)
						in
						   x_4661
						end
				       in
					  x_4660
				       end
				 val x_4664: word64 = 
				    ~? x_4652
				 val x_4665: word32 = 
				    schckFromInt64ToInt32 x_4664
				 val x_4666: word8 = 
				    digitToChar x_4665
				 val x_4667: word8 array * word32 * word8 = 
				    (x_1315, i, x_4666)
				 val x_4668: unit = 
				    update_0 (word8) x_4667
				 val x_4669: word64 * word64 = 
				    (q, radix)
				 val q: word64 = 
				    quot x_4669
				 val x_4670: word64 * word64 = 
				    (q, zero)
				 val x_4671: bool = 
				    = (word64) x_4670
				 val x_4672: word8 vector = 
				    case x_4671 of
				    true => 
				       let
					  val x_4678: word64 * word64 = 
					     (x_1314, zero)
					  val x_4679: bool = 
					     < x_4678
					  val x_4680: word32 = 
					     case x_4679 of
					     true => 
						let
						   val x_4681: word32 = 
						      0x1
						   val x_4682: word32 * word32 = 
						      (i, x_4681)
						   val i: word32 = 
						      -! x_4682
						   val x_4683: word8 = 
						      0x7E
						   val x_4684: word8 array
							       * word32
							       * word8 = 
						      (x_1315, i, x_4683)
						   val x_4685: unit = 
						      update_0 (word8) x_4684
						in
						   i
						end
					     false => 
						let
						in
						   i
						end
					  val x_4686: word32 Primitive.Option.t = 
					     NONE[word32]
					  val x_4687: word8 array
						      * word32
						      * word32 Primitive.Option.t = 
					     (x_1315, x_4680, x_4686)
					  val x_4688: word8 PrimSequence.Slice.t = 
					     slice_4 (word8) x_4687
					  val x_4689: word8 vector = 
					     vector_2 (word8) x_4688
				       in
					  x_4689
				       end
				    false => 
				       let
					  val x_4673: word32 = 
					     0x1
					  val x_4674: word32 * word32 = 
					     (i, x_4673)
					  val x_4675: word32 = 
					     -! x_4674
					  val x_4676: word64 * word32 = 
					     (q, x_4675)
					  val x_4677: word8 vector = 
					     loop x_4676
				       in
					  x_4677
				       end
			      in
				 x_4672
			      end
			val x_4690: word64 * word64 = 
			   (x_1314, zero)
			val x_4691: bool = 
			   < x_4690
			val x_4692: word64 = 
			   case x_4691 of
			   true => 
			      let
			      in
				 x_1314
			      end
			   false => 
			      let
				 val x_4693: word64 = 
				    ~? x_1314
			      in
				 x_4693
			      end
			val x_4694: word32 = 
			   0x1
			val x_4695: word32 * word32 = 
			   (maxNumDigits, x_4694)
			val x_4696: word32 = 
			   -! x_4695
			val x_4697: word64 * word32 = 
			   (x_4692, x_4696)
			val x_4698: word8 vector = 
			   loop x_4697
		     in
			x_4698
		     end
		  val x_4699: word8 array One.t * (word8 array -> word8 vector) = 
		     (oneBuf, x_4648)
		  val x_4700: word8 vector = 
		     use_0 (word8 vector, word8 array) x_4699
	       in
		  x_4700
	       end
	 in
	    x_4647
	 end
   val wordSize: word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word8 * word32 -> word8 = 
	 fn x_1317: word8 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1317
	    val i: word8 = 
	       #0 x_1317
	    val x_4701: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4702: bool = 
	       >= x_4701
	    val x_4703: word8 = 
	       case x_4702 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4704: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4705: word8 * word32 = 
			(i, x_4704)
		     val x_4706: word8 = 
			<<? x_4705
		  in
		     x_4706
		  end
	 in
	    x_4703
	 end
   val rec 
      >>: word8 * word32 -> word8 = 
	 fn x_1318: word8 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1318
	    val i: word8 = 
	       #0 x_1318
	    val x_4707: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4708: bool = 
	       >= x_4707
	    val x_4709: word8 = 
	       case x_4708 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4710: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4711: word8 * word32 = 
			(i, x_4710)
		     val x_4712: word8 = 
			>>? x_4711
		  in
		     x_4712
		  end
	 in
	    x_4709
	 end
   val wordSize: word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word16 * word32 -> word16 = 
	 fn x_1319: word16 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1319
	    val i: word16 = 
	       #0 x_1319
	    val x_4713: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4714: bool = 
	       >= x_4713
	    val x_4715: word16 = 
	       case x_4714 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4716: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4717: word16 * word32 = 
			(i, x_4716)
		     val x_4718: word16 = 
			<<? x_4717
		  in
		     x_4718
		  end
	 in
	    x_4715
	 end
   val rec 
      >>: word16 * word32 -> word16 = 
	 fn x_1320: word16 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1320
	    val i: word16 = 
	       #0 x_1320
	    val x_4719: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4720: bool = 
	       >= x_4719
	    val x_4721: word16 = 
	       case x_4720 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4722: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4723: word16 * word32 = 
			(i, x_4722)
		     val x_4724: word16 = 
			>>? x_4723
		  in
		     x_4724
		  end
	 in
	    x_4721
	 end
   val wordSize: word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word32 * word32 -> word32 = 
	 fn x_1321: word32 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1321
	    val i: word32 = 
	       #0 x_1321
	    val x_4725: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4726: bool = 
	       >= x_4725
	    val x_4727: word32 = 
	       case x_4726 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4728: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4729: word32 * word32 = 
			(i, x_4728)
		     val x_4730: word32 = 
			<<? x_4729
		  in
		     x_4730
		  end
	 in
	    x_4727
	 end
   val rec 
      >>: word32 * word32 -> word32 = 
	 fn x_1322: word32 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1322
	    val i: word32 = 
	       #0 x_1322
	    val x_4731: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4732: bool = 
	       >= x_4731
	    val x_4733: word32 = 
	       case x_4732 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4734: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4735: word32 * word32 = 
			(i, x_4734)
		     val x_4736: word32 = 
			>>? x_4735
		  in
		     x_4736
		  end
	 in
	    x_4733
	 end
   val rec 
      st: word32 * word32 * word32 -> word32 * word32 * word32 = 
	 fn x_1323: word32 * word32 * word32 => 
	 let
	    val sft: word32 = 
	       #2 x_1323
	    val msk: word32 = 
	       #1 x_1323
	    val w: word32 = 
	       #0 x_1323
	    val x_4737: word32 * word32 = 
	       (w, msk)
	    val odd: word32 = 
	       andb x_4737
	    val x_4738: word32 * word32 = 
	       (w, odd)
	    val evn: word32 = 
	       xorb x_4738
	    val x_4739: word32 * word32 = 
	       (odd, sft)
	    val x_4740: word32 = 
	       <<? x_4739
	    val x_4741: word32 * word32 = 
	       (evn, sft)
	    val x_4742: word32 = 
	       >>? x_4741
	    val x_4743: word32 * word32 = 
	       (x_4740, x_4742)
	    val x_4744: word32 = 
	       xorb x_4743
	    val x_4745: word32 = 
	       0x1
	    val x_4746: word32 * word32 = 
	       (sft, x_4745)
	    val x_4747: word32 = 
	       >>? x_4746
	    val x_4748: word32 * word32 = 
	       (msk, x_4747)
	    val x_4749: word32 = 
	       <<? x_4748
	    val x_4750: word32 * word32 = 
	       (msk, x_4749)
	    val x_4751: word32 = 
	       xorb x_4750
	    val x_4752: word32 = 
	       0x1
	    val x_4753: word32 * word32 = 
	       (sft, x_4752)
	    val x_4754: word32 = 
	       >>? x_4753
	    val x_4755: word32 * word32 * word32 = 
	       (x_4744, x_4751, x_4754)
	 in
	    x_4755
	 end
   val x_4756: (word32 * word32 * word32 -> word32 * word32 * word32) * word32 = 
      case sizeInBitsWord of
      0x8 => 
	 let
	    val x_4769: word32 * word32 * word32 -> word32 * word32 * word32 = 
	       fn x_1324: word32 * word32 * word32 => 
	       let
	       in
		  x_1324
	       end
	    val x_4770: word32 = 
	       0x4
	    val x_4771: (word32 * word32 * word32 -> word32 * word32 * word32)
			* word32 = 
	       (x_4769, x_4770)
	 in
	    x_4771
	 end
      0x20 => 
	 let
	    val x_4765: (word32 * word32 * word32 -> word32 * word32 * word32)
			* (word32 * word32 * word32 -> word32 * word32 * word32) = 
	       (st, st)
	    val x_4766: word32 * word32 * word32 -> word32 * word32 * word32 = 
	       o_1 (word32 * word32 * word32,
		    word32 * word32 * word32,
		    word32 * word32 * word32) x_4765
	    val x_4767: word32 = 
	       0x10
	    val x_4768: (word32 * word32 * word32 -> word32 * word32 * word32)
			* word32 = 
	       (x_4766, x_4767)
	 in
	    x_4768
	 end
      0x40 => 
	 let
	    val x_4759: (word32 * word32 * word32 -> word32 * word32 * word32)
			* (word32 * word32 * word32 -> word32 * word32 * word32) = 
	       (st, st)
	    val x_4760: word32 * word32 * word32 -> word32 * word32 * word32 = 
	       o_1 (word32 * word32 * word32,
		    word32 * word32 * word32,
		    word32 * word32 * word32) x_4759
	    val x_4761: (word32 * word32 * word32 -> word32 * word32 * word32)
			* (word32 * word32 * word32 -> word32 * word32 * word32) = 
	       (x_4760, st)
	    val x_4762: word32 * word32 * word32 -> word32 * word32 * word32 = 
	       o_1 (word32 * word32 * word32,
		    word32 * word32 * word32,
		    word32 * word32 * word32) x_4761
	    val x_4763: word32 = 
	       0x20
	    val x_4764: (word32 * word32 * word32 -> word32 * word32 * word32)
			* word32 = 
	       (x_4762, x_4763)
	 in
	    x_4764
	 end
      0x10 => 
	 let
	    val x_4757: word32 = 
	       0x8
	    val x_4758: (word32 * word32 * word32 -> word32 * word32 * word32)
			* word32 = 
	       (st, x_4757)
	 in
	    x_4758
	 end
	_ => let
		val x_4772: word8 vector = 
		   "Word.bswap"
		val x_4773: exn = 
		   Fail x_4772
		val x_4774: (word32 * word32 * word32
			     -> word32 * word32 * word32)
			    * word32 = 
		   raise x_4773
	     in
		x_4774
	     end
   val sft: word32 = 
      #1 x_4756
   val f: word32 * word32 * word32 -> word32 * word32 * word32 = 
      #0 x_4756
   val rec 
      bswap: word32 -> word32 = 
	 fn x_1325: word32 => 
	 let
	    val x_4775: word32 * word32 = 
	       (one, sft)
	    val x_4776: word32 = 
	       <<? x_4775
	    val x_4777: word32 * word32 = 
	       (x_4776, one)
	    val x_4778: word32 = 
	       - x_4777
	    val x_4779: word32 * word32 * word32 = 
	       (x_1325, x_4778, sft)
	    val x_4780: word32 * word32 * word32 = 
	       f x_4779
	    val x_4781: word32 = 
	       #0 x_4780
	 in
	    x_4781
	 end
   val wordSize: word32 = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word32 = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word64 * word32 -> word64 = 
	 fn x_1328: word64 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1328
	    val i: word64 = 
	       #0 x_1328
	    val x_4782: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4783: bool = 
	       >= x_4782
	    val x_4784: word64 = 
	       case x_4783 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4785: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4786: word64 * word32 = 
			(i, x_4785)
		     val x_4787: word64 = 
			<<? x_4786
		  in
		     x_4787
		  end
	 in
	    x_4784
	 end
   val rec 
      >>: word64 * word32 -> word64 = 
	 fn x_1329: word64 * word32 => 
	 let
	    val n: word32 = 
	       #1 x_1329
	    val i: word64 = 
	       #0 x_1329
	    val x_4788: word32 * word32 = 
	       (n, sizeInBitsWord)
	    val x_4789: bool = 
	       >= x_4788
	    val x_4790: word64 = 
	       case x_4789 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_4791: word32 = 
			zextdFromWord32ToWord32 n
		     val x_4792: word64 * word32 = 
			(i, x_4791)
		     val x_4793: word64 = 
			>>? x_4792
		  in
		     x_4793
		  end
	 in
	    x_4790
	 end
   val rec 
      toLargeInt: word64 -> intInf = 
	 fn x_1331: word64 => 
	 let
	    val x_4794: bool = 
	       false
	    val x_4795: bool * word64 = 
	       (x_4794, x_1331)
	    val x_4796: intInf = 
	       extdFromWord64 x_4795
	    val x_4797: bool = 
	       case precision (word32) of
	       NONE[word32] => 
		  let
		     val x_4801: bool = 
			false
		  in
		     x_4801
		  end
	       SOME[word32] x_4798: word32 => 
		  let
		     val x_4799: word32 * word32 = 
			(x_4798, sizeInBits)
		     val x_4800: bool = 
			<= x_4799
		  in
		     x_4800
		  end
	    val x_4802: bool = 
	       case x_4797 of
	       true => 
		  let
		     val x_4804: intInf = 
			0
		     val x_4805: intInf * intInf = 
			(x_4796, x_4804)
		     val x_4806: bool = 
			bigLT x_4805
		  in
		     x_4806
		  end
	       false => 
		  let
		     val x_4803: bool = 
			false
		  in
		     x_4803
		  end
	    val x_4807: intInf = 
	       case x_4802 of
	       true => 
		  let
		     val x_4808: exn = 
			Overflow
		     val x_4809: intInf = 
			raise x_4808
		  in
		     x_4809
		  end
	       false => 
		  let
		  in
		     x_4796
		  end
	 in
	    x_4807
	 end
   val x_4810: word32 = 
      0x2
   val x_4811: StringCvt.radix = 
      BIN
   val x_4812: word64 -> word8 vector = 
      fmt x_4811
   val x_4813: word32 * (word64 -> word8 vector) = 
      (x_4810, x_4812)
   val binCvt: intInf -> word8 vector = 
      mkBigCvt x_4813
   val x_4814: word32 = 
      0x8
   val x_4815: StringCvt.radix = 
      OCT
   val x_4816: word64 -> word8 vector = 
      fmt x_4815
   val x_4817: word32 * (word64 -> word8 vector) = 
      (x_4814, x_4816)
   val octCvt: intInf -> word8 vector = 
      mkBigCvt x_4817
   val x_4818: word32 = 
      0xA
   val x_4819: StringCvt.radix = 
      DEC
   val x_4820: word64 -> word8 vector = 
      fmt x_4819
   val x_4821: word32 * (word64 -> word8 vector) = 
      (x_4818, x_4820)
   val decCvt: intInf -> word8 vector = 
      mkBigCvt x_4821
   val x_4822: word32 = 
      0x10
   val x_4823: StringCvt.radix = 
      HEX
   val x_4824: word64 -> word8 vector = 
      fmt x_4823
   val x_4825: word32 * (word64 -> word8 vector) = 
      (x_4822, x_4824)
   val hexCvt: intInf -> word8 vector = 
      mkBigCvt x_4825
   val rec 
      binDig: word8 -> word64 Primitive.Option.t = 
	 fn x_1333: word8 => 
	 let
	    val x_4826: word64 Primitive.Option.t = 
	       case x_1333 of
	       0x30 => 
		  let
		     val x_4829: word64 = 
			0x0
		     val x_4830: word64 Primitive.Option.t = 
			SOME[word64] x_4829
		  in
		     x_4830
		  end
	       0x31 => 
		  let
		     val x_4827: word64 = 
			0x1
		     val x_4828: word64 Primitive.Option.t = 
			SOME[word64] x_4827
		  in
		     x_4828
		  end
		 _ => let
			 val x_4831: word64 Primitive.Option.t = 
			    NONE[word64]
		      in
			 x_4831
		      end
	 in
	    x_4826
	 end
   val rec 
      octDig: word8 -> word64 Primitive.Option.t = 
	 fn x_1334: word8 => 
	 let
	    val x_4832: word8 = 
	       0x30
	    val x_4833: word8 * word8 = 
	       (x_4832, x_1334)
	    val x_4834: bool = 
	       <= x_4833
	    val x_4835: bool = 
	       case x_4834 of
	       true => 
		  let
		     val x_4837: word8 = 
			0x37
		     val x_4838: word8 * word8 = 
			(x_1334, x_4837)
		     val x_4839: bool = 
			<= x_4838
		  in
		     x_4839
		  end
	       false => 
		  let
		     val x_4836: bool = 
			false
		  in
		     x_4836
		  end
	    val x_4840: word64 Primitive.Option.t = 
	       case x_4835 of
	       true => 
		  let
		     val x_4842: word32 = 
			x_4231 x_1334
		     val x_4843: word8 = 
			0x30
		     val x_4844: word32 = 
			x_4231 x_4843
		     val x_4845: word32 * word32 = 
			(x_4842, x_4844)
		     val x_4846: word32 = 
			-! x_4845
		     val x_4847: word64 = 
			sextdFromInt32ToWord64 x_4846
		     val x_4848: word64 Primitive.Option.t = 
			SOME[word64] x_4847
		  in
		     x_4848
		  end
	       false => 
		  let
		     val x_4841: word64 Primitive.Option.t = 
			NONE[word64]
		  in
		     x_4841
		  end
	 in
	    x_4840
	 end
   val rec 
      decDig: word8 -> word64 Primitive.Option.t = 
	 fn x_1335: word8 => 
	 let
	    val x_4849: word8 = 
	       0x30
	    val x_4850: word8 * word8 = 
	       (x_4849, x_1335)
	    val x_4851: bool = 
	       <= x_4850
	    val x_4852: bool = 
	       case x_4851 of
	       true => 
		  let
		     val x_4854: word8 = 
			0x39
		     val x_4855: word8 * word8 = 
			(x_1335, x_4854)
		     val x_4856: bool = 
			<= x_4855
		  in
		     x_4856
		  end
	       false => 
		  let
		     val x_4853: bool = 
			false
		  in
		     x_4853
		  end
	    val x_4857: word64 Primitive.Option.t = 
	       case x_4852 of
	       true => 
		  let
		     val x_4859: word32 = 
			x_4231 x_1335
		     val x_4860: word8 = 
			0x30
		     val x_4861: word32 = 
			x_4231 x_4860
		     val x_4862: word32 * word32 = 
			(x_4859, x_4861)
		     val x_4863: word32 = 
			-! x_4862
		     val x_4864: word64 = 
			sextdFromInt32ToWord64 x_4863
		     val x_4865: word64 Primitive.Option.t = 
			SOME[word64] x_4864
		  in
		     x_4865
		  end
	       false => 
		  let
		     val x_4858: word64 Primitive.Option.t = 
			NONE[word64]
		  in
		     x_4858
		  end
	 in
	    x_4857
	 end
   val rec 
      hexDig: word8 -> word64 Primitive.Option.t = 
	 fn x_1336: word8 => 
	 let
	    val x_4866: word8 = 
	       0x30
	    val x_4867: word8 * word8 = 
	       (x_4866, x_1336)
	    val x_4868: bool = 
	       <= x_4867
	    val x_4869: bool = 
	       case x_4868 of
	       true => 
		  let
		     val x_4871: word8 = 
			0x39
		     val x_4872: word8 * word8 = 
			(x_1336, x_4871)
		     val x_4873: bool = 
			<= x_4872
		  in
		     x_4873
		  end
	       false => 
		  let
		     val x_4870: bool = 
			false
		  in
		     x_4870
		  end
	    val x_4874: word64 Primitive.Option.t = 
	       case x_4869 of
	       true => 
		  let
		     val x_4914: word32 = 
			x_4231 x_1336
		     val x_4915: word8 = 
			0x30
		     val x_4916: word32 = 
			x_4231 x_4915
		     val x_4917: word32 * word32 = 
			(x_4914, x_4916)
		     val x_4918: word32 = 
			-! x_4917
		     val x_4919: word64 = 
			sextdFromInt32ToWord64 x_4918
		     val x_4920: word64 Primitive.Option.t = 
			SOME[word64] x_4919
		  in
		     x_4920
		  end
	       false => 
		  let
		     val x_4875: word8 = 
			0x61
		     val x_4876: word8 * word8 = 
			(x_4875, x_1336)
		     val x_4877: bool = 
			<= x_4876
		     val x_4878: bool = 
			case x_4877 of
			true => 
			   let
			      val x_4880: word8 = 
				 0x66
			      val x_4881: word8 * word8 = 
				 (x_1336, x_4880)
			      val x_4882: bool = 
				 <= x_4881
			   in
			      x_4882
			   end
			false => 
			   let
			      val x_4879: bool = 
				 false
			   in
			      x_4879
			   end
		     val x_4883: word64 Primitive.Option.t = 
			case x_4878 of
			true => 
			   let
			      val x_4904: word32 = 
				 x_4231 x_1336
			      val x_4905: word8 = 
				 0x61
			      val x_4906: word32 = 
				 x_4231 x_4905
			      val x_4907: word32 = 
				 0xA
			      val x_4908: word32 * word32 = 
				 (x_4906, x_4907)
			      val x_4909: word32 = 
				 -! x_4908
			      val x_4910: word32 * word32 = 
				 (x_4904, x_4909)
			      val x_4911: word32 = 
				 -! x_4910
			      val x_4912: word64 = 
				 sextdFromInt32ToWord64 x_4911
			      val x_4913: word64 Primitive.Option.t = 
				 SOME[word64] x_4912
			   in
			      x_4913
			   end
			false => 
			   let
			      val x_4884: word8 = 
				 0x41
			      val x_4885: word8 * word8 = 
				 (x_4884, x_1336)
			      val x_4886: bool = 
				 <= x_4885
			      val x_4887: bool = 
				 case x_4886 of
				 true => 
				    let
				       val x_4889: word8 = 
					  0x46
				       val x_4890: word8 * word8 = 
					  (x_1336, x_4889)
				       val x_4891: bool = 
					  <= x_4890
				    in
				       x_4891
				    end
				 false => 
				    let
				       val x_4888: bool = 
					  false
				    in
				       x_4888
				    end
			      val x_4892: word64 Primitive.Option.t = 
				 case x_4887 of
				 true => 
				    let
				       val x_4894: word32 = 
					  x_4231 x_1336
				       val x_4895: word8 = 
					  0x41
				       val x_4896: word32 = 
					  x_4231 x_4895
				       val x_4897: word32 = 
					  0xA
				       val x_4898: word32 * word32 = 
					  (x_4896, x_4897)
				       val x_4899: word32 = 
					  -! x_4898
				       val x_4900: word32 * word32 = 
					  (x_4894, x_4899)
				       val x_4901: word32 = 
					  -! x_4900
				       val x_4902: word64 = 
					  sextdFromInt32ToWord64 x_4901
				       val x_4903: word64 Primitive.Option.t = 
					  SOME[word64] x_4902
				    in
				       x_4903
				    end
				 false => 
				    let
				       val x_4893: word64 Primitive.Option.t = 
					  NONE[word64]
				    in
				       x_4893
				    end
			   in
			      x_4892
			   end
		  in
		     x_4883
		  end
	 in
	    x_4874
	 end
   val rec 'a 
      toDigR: (word8 -> word64 Primitive.Option.t)
	      * ('a -> (word8 * 'a) Primitive.Option.t)
	      -> 'a -> (word64 * 'a) Primitive.Option.t = 
	 fn x_1337: (word8 -> word64 Primitive.Option.t)
		    * ('a -> (word8 * 'a) Primitive.Option.t) => 
	 let
	    val x_4921: 'a -> (word64 * 'a) Primitive.Option.t = 
	       fn x_1338: 'a => 
	       let
		  val x_4922: 'a -> (word8 * 'a) Primitive.Option.t = 
		     #1 x_1337
		  val x_4923: word8 -> word64 Primitive.Option.t = 
		     #0 x_1337
		  val x_4924: (word8 * 'a) Primitive.Option.t = 
		     x_4922 x_1338
		  val x_4925: (word64 * 'a) Primitive.Option.t = 
		     case x_4924 of
		     NONE[word8 * 'a] => 
			let
			   val x_4935: (word64 * 'a) Primitive.Option.t = 
			      NONE[word64 * 'a]
			in
			   x_4935
			end
		     SOME[word8 * 'a] x_4926: word8 * 'a => 
			let
			   val x_4927: 'a = 
			      #1 x_4926
			   val x_4928: word8 = 
			      #0 x_4926
			   val x_4929: word64 Primitive.Option.t = 
			      x_4923 x_4928
			   val x_4930: (word64 * 'a) Primitive.Option.t = 
			      case x_4929 of
			      NONE[word64] => 
				 let
				    val x_4934: (word64 * 'a) Primitive.Option.t = 
				       NONE[word64 * 'a]
				 in
				    x_4934
				 end
			      SOME[word64] x_4931: word64 => 
				 let
				    val x_4932: word64 * 'a = 
				       (x_4931, x_4927)
				    val x_4933: (word64 * 'a) Primitive.Option.t = 
				       SOME[word64 * 'a] x_4932
				 in
				    x_4933
				 end
			in
			   x_4930
			end
	       in
		  x_4925
	       end
	 in
	    x_4921
	 end
   val rec 'a 
      toChunkR: word64 * ('a -> (word64 * 'a) Primitive.Option.t)
		-> 'a -> ((word64 * bool * word64) * 'a) Primitive.Option.t = 
	 fn x_1339: word64 * ('a -> (word64 * 'a) Primitive.Option.t) => 
	 let
	    val dread: 'a -> (word64 * 'a) Primitive.Option.t = 
	       #1 x_1339
	    val base: word64 = 
	       #0 x_1339
	    val rec 
	       loop: word64 * word32 * 'a * word64
		     -> (word64 * bool * word64) * 'a = 
		  fn x_1341: word64 * word32 * 'a * word64 => 
		  let
		     val shift: word64 = 
			#3 x_1341
		     val s: 'a = 
			#2 x_1341
		     val left: word32 = 
			#1 x_1341
		     val chunk: word64 = 
			#0 x_1341
		     val x_4936: word32 = 
			0x0
		     val x_4937: word32 * word32 = 
			(left, x_4936)
		     val x_4938: bool = 
			<= x_4937
		     val x_4939: (word64 * bool * word64) * 'a = 
			case x_4938 of
			true => 
			   let
			      val x_4959: bool = 
				 true
			      val x_4960: word64 * bool * word64 = 
				 (chunk, x_4959, shift)
			      val x_4961: (word64 * bool * word64) * 'a = 
				 (x_4960, s)
			   in
			      x_4961
			   end
			false => 
			   let
			      val x_4940: (word64 * 'a) Primitive.Option.t = 
				 dread s
			      val x_4941: (word64 * bool * word64) * 'a = 
				 case x_4940 of
				 NONE[word64 * 'a] => 
				    let
				       val x_4956: bool = 
					  false
				       val x_4957: word64 * bool * word64 = 
					  (chunk, x_4956, shift)
				       val x_4958: (word64 * bool * word64) * 'a = 
					  (x_4957, s)
				    in
				       x_4958
				    end
				 SOME[word64 * 'a] x_4942: word64 * 'a => 
				    let
				       val x_4943: 'a = 
					  #1 x_4942
				       val x_4944: word64 = 
					  #0 x_4942
				       val x_4945: word32 = 
					  0x1
				       val x_4946: word32 * word32 = 
					  (left, x_4945)
				       val x_4947: word32 = 
					  -! x_4946
				       val x_4948: word64 * word64 = 
					  (base, shift)
				       val x_4949: word64 = 
					  * x_4948
				       val x_4950: word64 * word64 = 
					  (base, chunk)
				       val x_4951: word64 = 
					  * x_4950
				       val x_4952: word64 * word64 = 
					  (x_4951, x_4944)
				       val x_4953: word64 = 
					  + x_4952
				       val x_4954: word64 * word32 * 'a * word64 = 
					  (x_4953, x_4947, x_4943, x_4949)
				       val x_4955: (word64 * bool * word64) * 'a = 
					  loop x_4954
				    in
				       x_4955
				    end
			   in
			      x_4941
			   end
		  in
		     x_4939
		  end
	    val x_4962: unit -> word32 = 
	       fn x_4963: unit => 
	       let
		  val x_4964: word8 vector = 
		     "IntInf.scan:digitsPerChunk"
		  val x_4965: exn = 
		     Fail x_4964
		  val x_4966: word32 = 
		     raise x_4965
	       in
		  x_4966
	       end
	    val x_4967: word32 = 
	       case wordSize of
	       0x40 => 
		  let
		     val x_4986: word64 = 
			0xA
		     val x_4987: bool = 
			MLton_equal[word64] (base, x_4986)
		     val x_4988: word32 = 
			case x_4987 of
			true => 
			   let
			      val x_5003: word32 = 
				 0x12
			   in
			      x_5003
			   end
			false => 
			   let
			      val x_4989: word64 = 
				 0x2
			      val x_4990: bool = 
				 MLton_equal[word64] (base, x_4989)
			      val x_4991: word32 = 
				 case x_4990 of
				 true => 
				    let
				       val x_5002: word32 = 
					  0x3D
				    in
				       x_5002
				    end
				 false => 
				    let
				       val x_4992: word64 = 
					  0x8
				       val x_4993: bool = 
					  MLton_equal[word64] (base, x_4992)
				       val x_4994: word32 = 
					  case x_4993 of
					  true => 
					     let
						val x_5001: word32 = 
						   0x14
					     in
						x_5001
					     end
					  false => 
					     let
						val x_4995: word64 = 
						   0x10
						val x_4996: bool = 
						   MLton_equal[word64] (base,
									x_4995)
						val x_4997: word32 = 
						   case x_4996 of
						   true => 
						      let
							 val x_5000: word32 = 
							    0xF
						      in
							 x_5000
						      end
						   false => 
						      let
							 val x_4998: unit = 
							    ()
							 val x_4999: word32 = 
							    x_4962 x_4998
						      in
							 x_4999
						      end
					     in
						x_4997
					     end
				    in
				       x_4994
				    end
			   in
			      x_4991
			   end
		  in
		     x_4988
		  end
	       0x20 => 
		  let
		     val x_4968: word64 = 
			0xA
		     val x_4969: bool = 
			MLton_equal[word64] (base, x_4968)
		     val x_4970: word32 = 
			case x_4969 of
			true => 
			   let
			      val x_4985: word32 = 
				 0x8
			   in
			      x_4985
			   end
			false => 
			   let
			      val x_4971: word64 = 
				 0x2
			      val x_4972: bool = 
				 MLton_equal[word64] (base, x_4971)
			      val x_4973: word32 = 
				 case x_4972 of
				 true => 
				    let
				       val x_4984: word32 = 
					  0x1D
				    in
				       x_4984
				    end
				 false => 
				    let
				       val x_4974: word64 = 
					  0x8
				       val x_4975: bool = 
					  MLton_equal[word64] (base, x_4974)
				       val x_4976: word32 = 
					  case x_4975 of
					  true => 
					     let
						val x_4983: word32 = 
						   0x9
					     in
						x_4983
					     end
					  false => 
					     let
						val x_4977: word64 = 
						   0x10
						val x_4978: bool = 
						   MLton_equal[word64] (base,
									x_4977)
						val x_4979: word32 = 
						   case x_4978 of
						   true => 
						      let
							 val x_4982: word32 = 
							    0x7
						      in
							 x_4982
						      end
						   false => 
						      let
							 val x_4980: unit = 
							    ()
							 val x_4981: word32 = 
							    x_4962 x_4980
						      in
							 x_4981
						      end
					     in
						x_4979
					     end
				    in
				       x_4976
				    end
			   in
			      x_4973
			   end
		  in
		     x_4970
		  end
		 _ => let
			 val x_5004: unit = 
			    ()
			 val x_5005: word32 = 
			    x_4962 x_5004
		      in
			 x_5005
		      end
	    val rec 
	       reader: 'a -> ((word64 * bool * word64) * 'a) Primitive.Option.t = 
		  fn x_1340: 'a => 
		  let
		     val x_5006: (word64 * 'a) Primitive.Option.t = 
			dread x_1340
		     val x_5007: ((word64 * bool * word64) * 'a) Primitive.Option.t = 
			case x_5006 of
			NONE[word64 * 'a] => 
			   let
			      val x_5017: ((word64 * bool * word64) * 'a) Primitive.Option.t = 
				 NONE[(word64 * bool * word64) * 'a]
			   in
			      x_5017
			   end
			SOME[word64 * 'a] x_5008: word64 * 'a => 
			   let
			      val x_5009: 'a = 
				 #1 x_5008
			      val x_5010: word64 = 
				 #0 x_5008
			      val x_5011: word32 = 
				 0x1
			      val x_5012: word32 * word32 = 
				 (x_4967, x_5011)
			      val x_5013: word32 = 
				 -! x_5012
			      val x_5014: word64 * word32 * 'a * word64 = 
				 (x_5010, x_5013, x_5009, base)
			      val x_5015: (word64 * bool * word64) * 'a = 
				 loop x_5014
			      val x_5016: ((word64 * bool * word64) * 'a) Primitive.Option.t = 
				 SOME[(word64 * bool * word64) * 'a] x_5015
			   in
			      x_5016
			   end
		  in
		     x_5007
		  end
	 in
	    reader
	 end
   val rec 'a 
      toUnsR: ('a -> ((word64 * bool * word64) * 'a) Primitive.Option.t)
	      -> 'a -> (intInf * 'a) Primitive.Option.t = 
	 fn x_1342: 'a -> ((word64 * bool * word64) * 'a) Primitive.Option.t => 
	 let
	    val rec 
	       loop: bool * intInf * 'a -> intInf * 'a = 
		  fn x_1344: bool * intInf * 'a => 
		  let
		     val s: 'a = 
			#2 x_1344
		     val acc: intInf = 
			#1 x_1344
		     val more: bool = 
			#0 x_1344
		     val x_5018: intInf * 'a = 
			case more of
			true => 
			   let
			      val x_5020: ((word64 * bool * word64) * 'a) Primitive.Option.t = 
				 x_1342 s
			      val x_5021: intInf * 'a = 
				 case x_5020 of
				 NONE[(word64 * bool * word64) * 'a] => 
				    let
				       val x_5036: intInf * 'a = 
					  (acc, s)
				    in
				       x_5036
				    end
				 SOME[(word64 * bool * word64) * 'a] x_5022: (word64
									      * bool
									      * word64)
									     * 'a => 
				    let
				       val x_5023: 'a = 
					  #1 x_5022
				       val x_5024: word64 * bool * word64 = 
					  #0 x_5022
				       val x_5025: word64 = 
					  #2 x_5024
				       val x_5026: bool = 
					  #1 x_5024
				       val x_5027: word64 = 
					  #0 x_5024
				       val x_5028: intInf = 
					  toLargeInt x_5025
				       val x_5029: intInf * intInf = 
					  (x_5028, acc)
				       val x_5030: intInf = 
					  bigMul x_5029
				       val x_5031: intInf = 
					  toLargeInt x_5027
				       val x_5032: intInf * intInf = 
					  (x_5030, x_5031)
				       val x_5033: intInf = 
					  bigAdd x_5032
				       val x_5034: bool * intInf * 'a = 
					  (x_5026, x_5033, x_5023)
				       val x_5035: intInf * 'a = 
					  loop x_5034
				    in
				       x_5035
				    end
			   in
			      x_5021
			   end
			false => 
			   let
			      val x_5019: intInf * 'a = 
				 (acc, s)
			   in
			      x_5019
			   end
		  in
		     x_5018
		  end
	    val rec 
	       reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		  fn x_1343: 'a => 
		  let
		     val x_5037: ((word64 * bool * word64) * 'a) Primitive.Option.t = 
			x_1342 x_1343
		     val x_5038: (intInf * 'a) Primitive.Option.t = 
			case x_5037 of
			NONE[(word64 * bool * word64) * 'a] => 
			   let
			      val x_5048: (intInf * 'a) Primitive.Option.t = 
				 NONE[intInf * 'a]
			   in
			      x_5048
			   end
			SOME[(word64 * bool * word64) * 'a] x_5039: (word64
								     * bool
								     * word64)
								    * 'a => 
			   let
			      val x_5040: 'a = 
				 #1 x_5039
			      val x_5041: word64 * bool * word64 = 
				 #0 x_5039
			      val x_5042: bool = 
				 #1 x_5041
			      val x_5043: word64 = 
				 #0 x_5041
			      val x_5044: intInf = 
				 toLargeInt x_5043
			      val x_5045: bool * intInf * 'a = 
				 (x_5042, x_5044, x_5040)
			      val x_5046: intInf * 'a = 
				 loop x_5045
			      val x_5047: (intInf * 'a) Primitive.Option.t = 
				 SOME[intInf * 'a] x_5046
			   in
			      x_5047
			   end
		  in
		     x_5038
		  end
	 in
	    reader
	 end
   val rec 'a 
      toHexR: ('a -> (word8 * 'a) Primitive.Option.t)
	      * ('a -> (intInf * 'a) Primitive.Option.t)
	      -> 'a -> (intInf * 'a) Primitive.Option.t = 
	 fn x_1345: ('a -> (word8 * 'a) Primitive.Option.t)
		    * ('a -> (intInf * 'a) Primitive.Option.t) => 
	 let
	    val x_5049: 'a -> (intInf * 'a) Primitive.Option.t = 
	       fn x_1346: 'a => 
	       let
		  val x_5050: 'a -> (intInf * 'a) Primitive.Option.t = 
		     #1 x_1345
		  val x_5051: 'a -> (word8 * 'a) Primitive.Option.t = 
		     #0 x_1345
		  val x_5052: (word8 * 'a) Primitive.Option.t = 
		     x_5051 x_1346
		  val x_5053: (intInf * 'a) Primitive.Option.t = 
		     case x_5052 of
		     NONE[word8 * 'a] => 
			let
			   val x_5085: (intInf * 'a) Primitive.Option.t = 
			      NONE[intInf * 'a]
			in
			   x_5085
			end
		     SOME[word8 * 'a] x_5054: word8 * 'a => 
			let
			   val x_5055: 'a = 
			      #1 x_5054
			   val x_5056: word8 = 
			      #0 x_5054
			   val x_5057: word8 = 
			      0x30
			   val x_5058: word8 * word8 = 
			      (x_5056, x_5057)
			   val x_5059: bool = 
			      = (word8) x_5058
			   val x_5060: (intInf * 'a) Primitive.Option.t = 
			      case x_5059 of
			      true => 
				 let
				    val x_5062: (word8 * 'a) Primitive.Option.t = 
				       x_5051 x_5055
				    val x_5063: (intInf * 'a) Primitive.Option.t = 
				       case x_5062 of
				       NONE[word8 * 'a] => 
					  let
					     val x_5083: intInf * 'a = 
						(zero, x_5055)
					     val x_5084: (intInf * 'a) Primitive.Option.t = 
						SOME[intInf * 'a] x_5083
					  in
					     x_5084
					  end
				       SOME[word8 * 'a] x_5064: word8 * 'a => 
					  let
					     val x_5065: 'a = 
						#1 x_5064
					     val x_5066: word8 = 
						#0 x_5064
					     val x_5067: word8 = 
						0x78
					     val x_5068: word8 * word8 = 
						(x_5066, x_5067)
					     val x_5069: bool = 
						= (word8) x_5068
					     val x_5070: bool = 
						case x_5069 of
						true => 
						   let
						      val x_5074: bool = 
							 true
						   in
						      x_5074
						   end
						false => 
						   let
						      val x_5071: word8 = 
							 0x58
						      val x_5072: word8 * word8 = 
							 (x_5066, x_5071)
						      val x_5073: bool = 
							 = (word8) x_5072
						   in
						      x_5073
						   end
					     val x_5075: (intInf * 'a) Primitive.Option.t = 
						case x_5070 of
						true => 
						   let
						      val x_5077: (intInf * 'a) Primitive.Option.t = 
							 x_5050 x_5065
						      val x_5078: (intInf * 'a) Primitive.Option.t = 
							 case x_5077 of
							 NONE[intInf * 'a] => 
							    let
							       val x_5081: intInf
									   * 'a = 
								  (zero, x_5055)
							       val x_5082: (intInf
									    * 'a) Primitive.Option.t = 
								  SOME[intInf
								       * 'a] x_5081
							    in
							       x_5082
							    end
							 SOME[intInf * 'a] x_5079: intInf
										   * 'a => 
							    let
							       val x_5080: (intInf
									    * 'a) Primitive.Option.t = 
								  SOME[intInf
								       * 'a] x_5079
							    in
							       x_5080
							    end
						   in
						      x_5078
						   end
						false => 
						   let
						      val x_5076: (intInf * 'a) Primitive.Option.t = 
							 x_5050 x_1346
						   in
						      x_5076
						   end
					  in
					     x_5075
					  end
				 in
				    x_5063
				 end
			      false => 
				 let
				    val x_5061: (intInf * 'a) Primitive.Option.t = 
				       x_5050 x_1346
				 in
				    x_5061
				 end
			in
			   x_5060
			end
	       in
		  x_5053
	       end
	 in
	    x_5049
	 end
   val rec 'a 
      toSign: ('a -> (word8 * 'a) Primitive.Option.t)
	      * ('a -> (intInf * 'a) Primitive.Option.t)
	      -> 'a -> (intInf * 'a) Primitive.Option.t = 
	 fn x_1347: ('a -> (word8 * 'a) Primitive.Option.t)
		    * ('a -> (intInf * 'a) Primitive.Option.t) => 
	 let
	    val uread: 'a -> (intInf * 'a) Primitive.Option.t = 
	       #1 x_1347
	    val cread: 'a -> (word8 * 'a) Primitive.Option.t = 
	       #0 x_1347
	    val rec 
	       reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		  fn x_1348: 'a => 
		  let
		     val x_5086: 'a -> 'a = 
			skipWS_0 ('a) cread
		     val s: 'a = 
			x_5086 x_1348
		     val x_5087: (word8 * 'a) Primitive.Option.t = 
			cread s
		     val x_5088: (intInf * 'a) Primitive.Option.t = 
			case x_5087 of
			NONE[word8 * 'a] => 
			   let
			      val x_5125: (intInf * 'a) Primitive.Option.t = 
				 NONE[intInf * 'a]
			   in
			      x_5125
			   end
			SOME[word8 * 'a] x_5089: word8 * 'a => 
			   let
			      val x_5090: 'a = 
				 #1 x_5089
			      val x_5091: word8 = 
				 #0 x_5089
			      val x_5092: bool * 'a = 
				 case x_5091 of
				 0x2B => 
				    let
				       val x_5097: bool = 
					  false
				       val x_5098: bool * 'a = 
					  (x_5097, x_5090)
				    in
				       x_5098
				    end
				 0x7E => 
				    let
				       val x_5095: bool = 
					  true
				       val x_5096: bool * 'a = 
					  (x_5095, x_5090)
				    in
				       x_5096
				    end
				 0x2D => 
				    let
				       val x_5093: bool = 
					  true
				       val x_5094: bool * 'a = 
					  (x_5093, x_5090)
				    in
				       x_5094
				    end
				   _ => let
					   val x_5099: bool = 
					      false
					   val x_5100: bool * 'a = 
					      (x_5099, s)
					in
					   x_5100
					end
			      val s'': 'a = 
				 #1 x_5092
			      val isNeg: bool = 
				 #0 x_5092
			      val x_5101: (intInf * 'a) Primitive.Option.t = 
				 case isNeg of
				 true => 
				    let
				       val x_5103: (intInf * 'a) Primitive.Option.t = 
					  uread s''
				       val x_5104: (intInf * 'a) Primitive.Option.t = 
					  case x_5103 of
					  NONE[intInf * 'a] => 
					     let
						val x_5124: (intInf * 'a) Primitive.Option.t = 
						   NONE[intInf * 'a]
					     in
						x_5124
					     end
					  SOME[intInf * 'a] x_5105: intInf * 'a => 
					     let
						val x_5106: 'a = 
						   #1 x_5105
						val x_5107: intInf = 
						   #0 x_5105
						val x_5108: bool = 
						   isSmall x_5107
						val x_5109: intInf = 
						   case x_5108 of
						   true => 
						      let
							 val argw: word64 = 
							    toWord x_5107
							 val x_5115: word64
								     * word64 = 
							    (argw,
							     badObjptrWordTagged)
							 val x_5116: bool = 
							    = (word64) x_5115
							 val x_5117: intInf = 
							    case x_5116 of
							    true => 
							       let
							       in
								  negBadIntInf
							       end
							    false => 
							       let
								  val x_5118: word64 = 
								     0x2
								  val x_5119: word64
									      * word64 = 
								     (x_5118,
								      argw)
								  val x_5120: word64 = 
								     - x_5119
								  val x_5121: intInf = 
								     fromWord x_5120
							       in
								  x_5121
							       end
						      in
							 x_5117
						      end
						   false => 
						      let
							 val x_5110: word64 = 
							    numLimbs x_5107
							 val x_5111: word64 = 
							    0x1
							 val x_5112: word64
								     * word64 = 
							    (x_5110, x_5111)
							 val x_5113: word64 = 
							    reserve x_5112
							 val x_5114: intInf = 
							    IntInf_neg (x_5107,
									x_5113)
						      in
							 x_5114
						      end
						val x_5122: intInf * 'a = 
						   (x_5109, x_5106)
						val x_5123: (intInf * 'a) Primitive.Option.t = 
						   SOME[intInf * 'a] x_5122
					     in
						x_5123
					     end
				    in
				       x_5104
				    end
				 false => 
				    let
				       val x_5102: (intInf * 'a) Primitive.Option.t = 
					  uread s''
				    in
				       x_5102
				    end
			   in
			      x_5101
			   end
		  in
		     x_5088
		  end
	 in
	    reader
	 end
   val rec 'a 
      reader: word64 * (word8 -> word64 Primitive.Option.t)
	      -> ('a -> (word8 * 'a) Primitive.Option.t)
		 -> 'a -> (intInf * 'a) Primitive.Option.t = 
	 fn x_1349: word64 * (word8 -> word64 Primitive.Option.t) => 
	 let
	    val x_5126: ('a -> (word8 * 'a) Primitive.Option.t)
			-> 'a -> (intInf * 'a) Primitive.Option.t = 
	       fn x_1350: 'a -> (word8 * 'a) Primitive.Option.t => 
	       let
		  val x_5127: word8 -> word64 Primitive.Option.t = 
		     #1 x_1349
		  val x_5128: word64 = 
		     #0 x_1349
		  val x_5129: (word8 -> word64 Primitive.Option.t)
			      * ('a -> (word8 * 'a) Primitive.Option.t) = 
		     (x_5127, x_1350)
		  val dread: 'a -> (word64 * 'a) Primitive.Option.t = 
		     toDigR ('a) x_5129
		  val x_5130: word64 * ('a -> (word64 * 'a) Primitive.Option.t) = 
		     (x_5128, dread)
		  val ckread: 'a
			      -> ((word64 * bool * word64) * 'a) Primitive.Option.t = 
		     toChunkR ('a) x_5130
		  val uread: 'a -> (intInf * 'a) Primitive.Option.t = 
		     toUnsR ('a) ckread
		  val x_5131: word64 = 
		     0x10
		  val x_5132: word64 * word64 = 
		     (x_5128, x_5131)
		  val x_5133: bool = 
		     = (word64) x_5132
		  val x_5134: 'a -> (intInf * 'a) Primitive.Option.t = 
		     case x_5133 of
		     true => 
			let
			   val x_5135: ('a -> (word8 * 'a) Primitive.Option.t)
				       * ('a -> (intInf * 'a) Primitive.Option.t) = 
			      (x_1350, uread)
			   val x_5136: 'a -> (intInf * 'a) Primitive.Option.t = 
			      toHexR ('a) x_5135
			in
			   x_5136
			end
		     false => 
			let
			in
			   uread
			end
		  val x_5137: ('a -> (word8 * 'a) Primitive.Option.t)
			      * ('a -> (intInf * 'a) Primitive.Option.t) = 
		     (x_1350, x_5134)
		  val reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		     toSign ('a) x_5137
	       in
		  reader
	       end
	 in
	    x_5126
	 end
   val rec 'a_3028 
      binReader: ('a_3028 -> (word8 * 'a_3028) Primitive.Option.t)
		 -> 'a_3028 -> (intInf * 'a_3028) Primitive.Option.t = 
	 fn x_1351: 'a_3028 -> (word8 * 'a_3028) Primitive.Option.t => 
	 let
	    val x_5138: word64 = 
	       0x2
	    val x_5139: word64 * (word8 -> word64 Primitive.Option.t) = 
	       (x_5138, binDig)
	    val x_5140: ('a_3028 -> (word8 * 'a_3028) Primitive.Option.t)
			-> 'a_3028 -> (intInf * 'a_3028) Primitive.Option.t = 
	       reader ('a_3028) x_5139
	    val x_5141: 'a_3028 -> (intInf * 'a_3028) Primitive.Option.t = 
	       x_5140 x_1351
	 in
	    x_5141
	 end
   val rec 'a_3029 
      octReader: ('a_3029 -> (word8 * 'a_3029) Primitive.Option.t)
		 -> 'a_3029 -> (intInf * 'a_3029) Primitive.Option.t = 
	 fn x_1352: 'a_3029 -> (word8 * 'a_3029) Primitive.Option.t => 
	 let
	    val x_5142: word64 = 
	       0x8
	    val x_5143: word64 * (word8 -> word64 Primitive.Option.t) = 
	       (x_5142, octDig)
	    val x_5144: ('a_3029 -> (word8 * 'a_3029) Primitive.Option.t)
			-> 'a_3029 -> (intInf * 'a_3029) Primitive.Option.t = 
	       reader ('a_3029) x_5143
	    val x_5145: 'a_3029 -> (intInf * 'a_3029) Primitive.Option.t = 
	       x_5144 x_1352
	 in
	    x_5145
	 end
   val rec 'a_3030 
      decReader: ('a_3030 -> (word8 * 'a_3030) Primitive.Option.t)
		 -> 'a_3030 -> (intInf * 'a_3030) Primitive.Option.t = 
	 fn x_1353: 'a_3030 -> (word8 * 'a_3030) Primitive.Option.t => 
	 let
	    val x_5146: word64 = 
	       0xA
	    val x_5147: word64 * (word8 -> word64 Primitive.Option.t) = 
	       (x_5146, decDig)
	    val x_5148: ('a_3030 -> (word8 * 'a_3030) Primitive.Option.t)
			-> 'a_3030 -> (intInf * 'a_3030) Primitive.Option.t = 
	       reader ('a_3030) x_5147
	    val x_5149: 'a_3030 -> (intInf * 'a_3030) Primitive.Option.t = 
	       x_5148 x_1353
	 in
	    x_5149
	 end
   val rec 'a_3031 
      hexReader: ('a_3031 -> (word8 * 'a_3031) Primitive.Option.t)
		 -> 'a_3031 -> (intInf * 'a_3031) Primitive.Option.t = 
	 fn x_1354: 'a_3031 -> (word8 * 'a_3031) Primitive.Option.t => 
	 let
	    val x_5150: word64 = 
	       0x10
	    val x_5151: word64 * (word8 -> word64 Primitive.Option.t) = 
	       (x_5150, hexDig)
	    val x_5152: ('a_3031 -> (word8 * 'a_3031) Primitive.Option.t)
			-> 'a_3031 -> (intInf * 'a_3031) Primitive.Option.t = 
	       reader ('a_3031) x_5151
	    val x_5153: 'a_3031 -> (intInf * 'a_3031) Primitive.Option.t = 
	       x_5152 x_1354
	 in
	    x_5153
	 end
   val rec 'a_3032 
      scan: StringCvt.radix
	    -> ('a_3032 -> (word8 * 'a_3032) Primitive.Option.t)
	       -> 'a_3032 -> (intInf * 'a_3032) Primitive.Option.t = 
	 fn x_1355: StringCvt.radix => 
	 let
	    val x_5154: ('a_3032 -> (word8 * 'a_3032) Primitive.Option.t)
			-> 'a_3032 -> (intInf * 'a_3032) Primitive.Option.t = 
	       case x_1355 of
	       BIN => 
		  let
		  in
		     binReader ('a_3032)
		  end
	       DEC => 
		  let
		  in
		     decReader ('a_3032)
		  end
	       HEX => 
		  let
		  in
		     hexReader ('a_3032)
		  end
	       OCT => 
		  let
		  in
		     octReader ('a_3032)
		  end
	 in
	    x_5154
	 end
   val x_5155: StringCvt.radix = 
      DEC
   val x_5156: (word32 -> (word8 * word32) Primitive.Option.t)
	       -> word32 -> (intInf * word32) Primitive.Option.t = 
      scan (word32) x_5155
   val fromString: word8 vector -> intInf Primitive.Option.t = 
      scanString_0 (intInf) x_5156
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5157: word32 * word32 = 
      (precision', precision')
   val x_5158: bool = 
      < x_5157
   val x_5159: unit = 
      case x_5158 of
      true => 
	 let
	    val x_5163: unit = 
	       ()
	 in
	    x_5163
	 end
      false => 
	 let
	    val x_5160: word8 vector = 
	       "EmbedWord"
	    val x_5161: exn = 
	       Fail x_5160
	    val x_5162: unit = 
	       raise x_5161
	 in
	    x_5162
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5164: word32 * word32 = 
      (precision', precision')
   val x_5165: bool = 
      < x_5164
   val x_5166: unit = 
      case x_5165 of
      true => 
	 let
	    val x_5170: unit = 
	       ()
	 in
	    x_5170
	 end
      false => 
	 let
	    val x_5167: word8 vector = 
	       "EmbedWord"
	    val x_5168: exn = 
	       Fail x_5167
	    val x_5169: unit = 
	       raise x_5168
	 in
	    x_5169
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5171: word32 * word32 = 
      (precision', precision')
   val x_5172: bool = 
      < x_5171
   val x_5173: unit = 
      case x_5172 of
      true => 
	 let
	    val x_5177: unit = 
	       ()
	 in
	    x_5177
	 end
      false => 
	 let
	    val x_5174: word8 vector = 
	       "EmbedWord"
	    val x_5175: exn = 
	       Fail x_5174
	    val x_5176: unit = 
	       raise x_5175
	 in
	    x_5176
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5178: word32 * word32 = 
      (precision', precision')
   val x_5179: bool = 
      < x_5178
   val x_5180: unit = 
      case x_5179 of
      true => 
	 let
	    val x_5184: unit = 
	       ()
	 in
	    x_5184
	 end
      false => 
	 let
	    val x_5181: word8 vector = 
	       "EmbedWord"
	    val x_5182: exn = 
	       Fail x_5181
	    val x_5183: unit = 
	       raise x_5182
	 in
	    x_5183
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5185: word32 * word32 = 
      (precision', precision')
   val x_5186: bool = 
      < x_5185
   val x_5187: unit = 
      case x_5186 of
      true => 
	 let
	    val x_5191: unit = 
	       ()
	 in
	    x_5191
	 end
      false => 
	 let
	    val x_5188: word8 vector = 
	       "EmbedWord"
	    val x_5189: exn = 
	       Fail x_5188
	    val x_5190: unit = 
	       raise x_5189
	 in
	    x_5190
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5192: word32 * word32 = 
      (precision', precision')
   val x_5193: bool = 
      < x_5192
   val x_5194: unit = 
      case x_5193 of
      true => 
	 let
	    val x_5198: unit = 
	       ()
	 in
	    x_5198
	 end
      false => 
	 let
	    val x_5195: word8 vector = 
	       "EmbedWord"
	    val x_5196: exn = 
	       Fail x_5195
	    val x_5197: unit = 
	       raise x_5196
	 in
	    x_5197
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5199: word32 * word32 = 
      (precision', precision')
   val x_5200: bool = 
      < x_5199
   val x_5201: unit = 
      case x_5200 of
      true => 
	 let
	    val x_5205: unit = 
	       ()
	 in
	    x_5205
	 end
      false => 
	 let
	    val x_5202: word8 vector = 
	       "EmbedWord"
	    val x_5203: exn = 
	       Fail x_5202
	    val x_5204: unit = 
	       raise x_5203
	 in
	    x_5204
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5206: word32 * word32 = 
      (precision', precision')
   val x_5207: bool = 
      < x_5206
   val x_5208: unit = 
      case x_5207 of
      true => 
	 let
	    val x_5212: unit = 
	       ()
	 in
	    x_5212
	 end
      false => 
	 let
	    val x_5209: word8 vector = 
	       "EmbedWord"
	    val x_5210: exn = 
	       Fail x_5209
	    val x_5211: unit = 
	       raise x_5210
	 in
	    x_5211
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5213: word32 * word32 = 
      (precision', precision')
   val x_5214: bool = 
      < x_5213
   val x_5215: unit = 
      case x_5214 of
      true => 
	 let
	    val x_5219: unit = 
	       ()
	 in
	    x_5219
	 end
      false => 
	 let
	    val x_5216: word8 vector = 
	       "EmbedWord"
	    val x_5217: exn = 
	       Fail x_5216
	    val x_5218: unit = 
	       raise x_5217
	 in
	    x_5218
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5220: word32 * word32 = 
      (precision', precision')
   val x_5221: bool = 
      < x_5220
   val x_5222: unit = 
      case x_5221 of
      true => 
	 let
	    val x_5226: unit = 
	       ()
	 in
	    x_5226
	 end
      false => 
	 let
	    val x_5223: word8 vector = 
	       "EmbedWord"
	    val x_5224: exn = 
	       Fail x_5223
	    val x_5225: unit = 
	       raise x_5224
	 in
	    x_5225
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5227: word32 * word32 = 
      (precision', precision')
   val x_5228: bool = 
      < x_5227
   val x_5229: unit = 
      case x_5228 of
      true => 
	 let
	    val x_5233: unit = 
	       ()
	 in
	    x_5233
	 end
      false => 
	 let
	    val x_5230: word8 vector = 
	       "EmbedWord"
	    val x_5231: exn = 
	       Fail x_5230
	    val x_5232: unit = 
	       raise x_5231
	 in
	    x_5232
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5234: word32 * word32 = 
      (precision', precision')
   val x_5235: bool = 
      < x_5234
   val x_5236: unit = 
      case x_5235 of
      true => 
	 let
	    val x_5240: unit = 
	       ()
	 in
	    x_5240
	 end
      false => 
	 let
	    val x_5237: word8 vector = 
	       "EmbedWord"
	    val x_5238: exn = 
	       Fail x_5237
	    val x_5239: unit = 
	       raise x_5238
	 in
	    x_5239
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5241: word32 * word32 = 
      (precision', precision')
   val x_5242: bool = 
      < x_5241
   val x_5243: unit = 
      case x_5242 of
      true => 
	 let
	    val x_5247: unit = 
	       ()
	 in
	    x_5247
	 end
      false => 
	 let
	    val x_5244: word8 vector = 
	       "EmbedWord"
	    val x_5245: exn = 
	       Fail x_5244
	    val x_5246: unit = 
	       raise x_5245
	 in
	    x_5246
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5248: word32 * word32 = 
      (precision', precision')
   val x_5249: bool = 
      < x_5248
   val x_5250: unit = 
      case x_5249 of
      true => 
	 let
	    val x_5254: unit = 
	       ()
	 in
	    x_5254
	 end
      false => 
	 let
	    val x_5251: word8 vector = 
	       "EmbedWord"
	    val x_5252: exn = 
	       Fail x_5251
	    val x_5253: unit = 
	       raise x_5252
	 in
	    x_5253
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5255: word32 * word32 = 
      (precision', precision')
   val x_5256: bool = 
      < x_5255
   val x_5257: unit = 
      case x_5256 of
      true => 
	 let
	    val x_5261: unit = 
	       ()
	 in
	    x_5261
	 end
      false => 
	 let
	    val x_5258: word8 vector = 
	       "EmbedWord"
	    val x_5259: exn = 
	       Fail x_5258
	    val x_5260: unit = 
	       raise x_5259
	 in
	    x_5260
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5262: word32 * word32 = 
      (precision', precision')
   val x_5263: bool = 
      < x_5262
   val x_5264: unit = 
      case x_5263 of
      true => 
	 let
	    val x_5268: unit = 
	       ()
	 in
	    x_5268
	 end
      false => 
	 let
	    val x_5265: word8 vector = 
	       "EmbedWord"
	    val x_5266: exn = 
	       Fail x_5265
	    val x_5267: unit = 
	       raise x_5266
	 in
	    x_5267
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5269: word32 * word32 = 
      (precision', precision')
   val x_5270: bool = 
      < x_5269
   val x_5271: unit = 
      case x_5270 of
      true => 
	 let
	    val x_5275: unit = 
	       ()
	 in
	    x_5275
	 end
      false => 
	 let
	    val x_5272: word8 vector = 
	       "EmbedWord"
	    val x_5273: exn = 
	       Fail x_5272
	    val x_5274: unit = 
	       raise x_5273
	 in
	    x_5274
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5276: word32 * word32 = 
      (precision', precision')
   val x_5277: bool = 
      < x_5276
   val x_5278: unit = 
      case x_5277 of
      true => 
	 let
	    val x_5282: unit = 
	       ()
	 in
	    x_5282
	 end
      false => 
	 let
	    val x_5279: word8 vector = 
	       "EmbedWord"
	    val x_5280: exn = 
	       Fail x_5279
	    val x_5281: unit = 
	       raise x_5280
	 in
	    x_5281
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5283: word32 * word32 = 
      (precision', precision')
   val x_5284: bool = 
      < x_5283
   val x_5285: unit = 
      case x_5284 of
      true => 
	 let
	    val x_5289: unit = 
	       ()
	 in
	    x_5289
	 end
      false => 
	 let
	    val x_5286: word8 vector = 
	       "EmbedWord"
	    val x_5287: exn = 
	       Fail x_5286
	    val x_5288: unit = 
	       raise x_5287
	 in
	    x_5288
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5290: word32 * word32 = 
      (precision', precision')
   val x_5291: bool = 
      < x_5290
   val x_5292: unit = 
      case x_5291 of
      true => 
	 let
	    val x_5296: unit = 
	       ()
	 in
	    x_5296
	 end
      false => 
	 let
	    val x_5293: word8 vector = 
	       "EmbedWord"
	    val x_5294: exn = 
	       Fail x_5293
	    val x_5295: unit = 
	       raise x_5294
	 in
	    x_5295
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5297: word32 * word32 = 
      (precision', precision')
   val x_5298: bool = 
      < x_5297
   val x_5299: unit = 
      case x_5298 of
      true => 
	 let
	    val x_5303: unit = 
	       ()
	 in
	    x_5303
	 end
      false => 
	 let
	    val x_5300: word8 vector = 
	       "EmbedWord"
	    val x_5301: exn = 
	       Fail x_5300
	    val x_5302: unit = 
	       raise x_5301
	 in
	    x_5302
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5304: word32 * word32 = 
      (precision', precision')
   val x_5305: bool = 
      < x_5304
   val x_5306: unit = 
      case x_5305 of
      true => 
	 let
	    val x_5310: unit = 
	       ()
	 in
	    x_5310
	 end
      false => 
	 let
	    val x_5307: word8 vector = 
	       "EmbedWord"
	    val x_5308: exn = 
	       Fail x_5307
	    val x_5309: unit = 
	       raise x_5308
	 in
	    x_5309
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5311: word32 * word32 = 
      (precision', precision')
   val x_5312: bool = 
      < x_5311
   val x_5313: unit = 
      case x_5312 of
      true => 
	 let
	    val x_5317: unit = 
	       ()
	 in
	    x_5317
	 end
      false => 
	 let
	    val x_5314: word8 vector = 
	       "EmbedWord"
	    val x_5315: exn = 
	       Fail x_5314
	    val x_5316: unit = 
	       raise x_5315
	 in
	    x_5316
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5318: word32 * word32 = 
      (precision', precision')
   val x_5319: bool = 
      < x_5318
   val x_5320: unit = 
      case x_5319 of
      true => 
	 let
	    val x_5324: unit = 
	       ()
	 in
	    x_5324
	 end
      false => 
	 let
	    val x_5321: word8 vector = 
	       "EmbedWord"
	    val x_5322: exn = 
	       Fail x_5321
	    val x_5323: unit = 
	       raise x_5322
	 in
	    x_5323
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5325: word32 * word32 = 
      (precision', precision')
   val x_5326: bool = 
      < x_5325
   val x_5327: unit = 
      case x_5326 of
      true => 
	 let
	    val x_5331: unit = 
	       ()
	 in
	    x_5331
	 end
      false => 
	 let
	    val x_5328: word8 vector = 
	       "EmbedWord"
	    val x_5329: exn = 
	       Fail x_5328
	    val x_5330: unit = 
	       raise x_5329
	 in
	    x_5330
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5332: word32 * word32 = 
      (precision', precision')
   val x_5333: bool = 
      < x_5332
   val x_5334: unit = 
      case x_5333 of
      true => 
	 let
	    val x_5338: unit = 
	       ()
	 in
	    x_5338
	 end
      false => 
	 let
	    val x_5335: word8 vector = 
	       "EmbedWord"
	    val x_5336: exn = 
	       Fail x_5335
	    val x_5337: unit = 
	       raise x_5336
	 in
	    x_5337
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5339: word32 * word32 = 
      (precision', precision')
   val x_5340: bool = 
      < x_5339
   val x_5341: unit = 
      case x_5340 of
      true => 
	 let
	    val x_5345: unit = 
	       ()
	 in
	    x_5345
	 end
      false => 
	 let
	    val x_5342: word8 vector = 
	       "EmbedWord"
	    val x_5343: exn = 
	       Fail x_5342
	    val x_5344: unit = 
	       raise x_5343
	 in
	    x_5344
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5346: word32 * word32 = 
      (precision', precision')
   val x_5347: bool = 
      < x_5346
   val x_5348: unit = 
      case x_5347 of
      true => 
	 let
	    val x_5352: unit = 
	       ()
	 in
	    x_5352
	 end
      false => 
	 let
	    val x_5349: word8 vector = 
	       "EmbedWord"
	    val x_5350: exn = 
	       Fail x_5349
	    val x_5351: unit = 
	       raise x_5350
	 in
	    x_5351
	 end
   val precision': word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5353: word32 * word32 = 
      (precision', precision')
   val x_5354: bool = 
      < x_5353
   val x_5355: unit = 
      case x_5354 of
      true => 
	 let
	    val x_5359: unit = 
	       ()
	 in
	    x_5359
	 end
      false => 
	 let
	    val x_5356: word8 vector = 
	       "EmbedWord"
	    val x_5357: exn = 
	       Fail x_5356
	    val x_5358: unit = 
	       raise x_5357
	 in
	    x_5358
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5360: word32 * word32 = 
      (wordSize, wordSize)
   val x_5361: bool = 
      < x_5360
   val x_5362: unit = 
      case x_5361 of
      true => 
	 let
	    val x_5366: unit = 
	       ()
	 in
	    x_5366
	 end
      false => 
	 let
	    val x_5363: word8 vector = 
	       "EmbedWord"
	    val x_5364: exn = 
	       Fail x_5363
	    val x_5365: unit = 
	       raise x_5364
	 in
	    x_5365
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5367: word32 * word32 = 
      (wordSize, wordSize)
   val x_5368: bool = 
      < x_5367
   val x_5369: unit = 
      case x_5368 of
      true => 
	 let
	    val x_5373: unit = 
	       ()
	 in
	    x_5373
	 end
      false => 
	 let
	    val x_5370: word8 vector = 
	       "EmbedWord"
	    val x_5371: exn = 
	       Fail x_5370
	    val x_5372: unit = 
	       raise x_5371
	 in
	    x_5372
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5374: word32 * word32 = 
      (wordSize, wordSize)
   val x_5375: bool = 
      < x_5374
   val x_5376: unit = 
      case x_5375 of
      true => 
	 let
	    val x_5380: unit = 
	       ()
	 in
	    x_5380
	 end
      false => 
	 let
	    val x_5377: word8 vector = 
	       "EmbedWord"
	    val x_5378: exn = 
	       Fail x_5377
	    val x_5379: unit = 
	       raise x_5378
	 in
	    x_5379
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5381: word32 * word32 = 
      (wordSize, wordSize)
   val x_5382: bool = 
      < x_5381
   val x_5383: unit = 
      case x_5382 of
      true => 
	 let
	    val x_5387: unit = 
	       ()
	 in
	    x_5387
	 end
      false => 
	 let
	    val x_5384: word8 vector = 
	       "EmbedWord"
	    val x_5385: exn = 
	       Fail x_5384
	    val x_5386: unit = 
	       raise x_5385
	 in
	    x_5386
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5388: word32 * word32 = 
      (wordSize, wordSize)
   val x_5389: bool = 
      < x_5388
   val x_5390: unit = 
      case x_5389 of
      true => 
	 let
	    val x_5394: unit = 
	       ()
	 in
	    x_5394
	 end
      false => 
	 let
	    val x_5391: word8 vector = 
	       "EmbedWord"
	    val x_5392: exn = 
	       Fail x_5391
	    val x_5393: unit = 
	       raise x_5392
	 in
	    x_5393
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5395: word32 * word32 = 
      (wordSize, wordSize)
   val x_5396: bool = 
      < x_5395
   val x_5397: unit = 
      case x_5396 of
      true => 
	 let
	    val x_5401: unit = 
	       ()
	 in
	    x_5401
	 end
      false => 
	 let
	    val x_5398: word8 vector = 
	       "EmbedWord"
	    val x_5399: exn = 
	       Fail x_5398
	    val x_5400: unit = 
	       raise x_5399
	 in
	    x_5400
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5402: word32 * word32 = 
      (wordSize, wordSize)
   val x_5403: bool = 
      < x_5402
   val x_5404: unit = 
      case x_5403 of
      true => 
	 let
	    val x_5408: unit = 
	       ()
	 in
	    x_5408
	 end
      false => 
	 let
	    val x_5405: word8 vector = 
	       "EmbedWord"
	    val x_5406: exn = 
	       Fail x_5405
	    val x_5407: unit = 
	       raise x_5406
	 in
	    x_5407
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5409: word32 * word32 = 
      (wordSize, wordSize)
   val x_5410: bool = 
      < x_5409
   val x_5411: unit = 
      case x_5410 of
      true => 
	 let
	    val x_5415: unit = 
	       ()
	 in
	    x_5415
	 end
      false => 
	 let
	    val x_5412: word8 vector = 
	       "EmbedWord"
	    val x_5413: exn = 
	       Fail x_5412
	    val x_5414: unit = 
	       raise x_5413
	 in
	    x_5414
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5416: word32 * word32 = 
      (wordSize, wordSize)
   val x_5417: bool = 
      < x_5416
   val x_5418: unit = 
      case x_5417 of
      true => 
	 let
	    val x_5422: unit = 
	       ()
	 in
	    x_5422
	 end
      false => 
	 let
	    val x_5419: word8 vector = 
	       "EmbedWord"
	    val x_5420: exn = 
	       Fail x_5419
	    val x_5421: unit = 
	       raise x_5420
	 in
	    x_5421
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5423: word32 * word32 = 
      (wordSize, wordSize)
   val x_5424: bool = 
      < x_5423
   val x_5425: unit = 
      case x_5424 of
      true => 
	 let
	    val x_5429: unit = 
	       ()
	 in
	    x_5429
	 end
      false => 
	 let
	    val x_5426: word8 vector = 
	       "EmbedWord"
	    val x_5427: exn = 
	       Fail x_5426
	    val x_5428: unit = 
	       raise x_5427
	 in
	    x_5428
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5430: word32 * word32 = 
      (wordSize, wordSize)
   val x_5431: bool = 
      < x_5430
   val x_5432: unit = 
      case x_5431 of
      true => 
	 let
	    val x_5436: unit = 
	       ()
	 in
	    x_5436
	 end
      false => 
	 let
	    val x_5433: word8 vector = 
	       "EmbedWord"
	    val x_5434: exn = 
	       Fail x_5433
	    val x_5435: unit = 
	       raise x_5434
	 in
	    x_5435
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5437: word32 * word32 = 
      (wordSize, wordSize)
   val x_5438: bool = 
      < x_5437
   val x_5439: unit = 
      case x_5438 of
      true => 
	 let
	    val x_5443: unit = 
	       ()
	 in
	    x_5443
	 end
      false => 
	 let
	    val x_5440: word8 vector = 
	       "EmbedWord"
	    val x_5441: exn = 
	       Fail x_5440
	    val x_5442: unit = 
	       raise x_5441
	 in
	    x_5442
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5444: word32 * word32 = 
      (wordSize, wordSize)
   val x_5445: bool = 
      < x_5444
   val x_5446: unit = 
      case x_5445 of
      true => 
	 let
	    val x_5450: unit = 
	       ()
	 in
	    x_5450
	 end
      false => 
	 let
	    val x_5447: word8 vector = 
	       "EmbedWord"
	    val x_5448: exn = 
	       Fail x_5447
	    val x_5449: unit = 
	       raise x_5448
	 in
	    x_5449
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5451: word32 * word32 = 
      (wordSize, wordSize)
   val x_5452: bool = 
      < x_5451
   val x_5453: unit = 
      case x_5452 of
      true => 
	 let
	    val x_5457: unit = 
	       ()
	 in
	    x_5457
	 end
      false => 
	 let
	    val x_5454: word8 vector = 
	       "EmbedWord"
	    val x_5455: exn = 
	       Fail x_5454
	    val x_5456: unit = 
	       raise x_5455
	 in
	    x_5456
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5458: word32 * word32 = 
      (wordSize, wordSize)
   val x_5459: bool = 
      < x_5458
   val x_5460: unit = 
      case x_5459 of
      true => 
	 let
	    val x_5464: unit = 
	       ()
	 in
	    x_5464
	 end
      false => 
	 let
	    val x_5461: word8 vector = 
	       "EmbedWord"
	    val x_5462: exn = 
	       Fail x_5461
	    val x_5463: unit = 
	       raise x_5462
	 in
	    x_5463
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5465: word32 * word32 = 
      (wordSize, wordSize)
   val x_5466: bool = 
      < x_5465
   val x_5467: unit = 
      case x_5466 of
      true => 
	 let
	    val x_5471: unit = 
	       ()
	 in
	    x_5471
	 end
      false => 
	 let
	    val x_5468: word8 vector = 
	       "EmbedWord"
	    val x_5469: exn = 
	       Fail x_5468
	    val x_5470: unit = 
	       raise x_5469
	 in
	    x_5470
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5472: word32 * word32 = 
      (wordSize, wordSize)
   val x_5473: bool = 
      < x_5472
   val x_5474: unit = 
      case x_5473 of
      true => 
	 let
	    val x_5478: unit = 
	       ()
	 in
	    x_5478
	 end
      false => 
	 let
	    val x_5475: word8 vector = 
	       "EmbedWord"
	    val x_5476: exn = 
	       Fail x_5475
	    val x_5477: unit = 
	       raise x_5476
	 in
	    x_5477
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5479: word32 * word32 = 
      (wordSize, wordSize)
   val x_5480: bool = 
      < x_5479
   val x_5481: unit = 
      case x_5480 of
      true => 
	 let
	    val x_5485: unit = 
	       ()
	 in
	    x_5485
	 end
      false => 
	 let
	    val x_5482: word8 vector = 
	       "EmbedWord"
	    val x_5483: exn = 
	       Fail x_5482
	    val x_5484: unit = 
	       raise x_5483
	 in
	    x_5484
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5486: word32 * word32 = 
      (wordSize, wordSize)
   val x_5487: bool = 
      < x_5486
   val x_5488: unit = 
      case x_5487 of
      true => 
	 let
	    val x_5492: unit = 
	       ()
	 in
	    x_5492
	 end
      false => 
	 let
	    val x_5489: word8 vector = 
	       "EmbedWord"
	    val x_5490: exn = 
	       Fail x_5489
	    val x_5491: unit = 
	       raise x_5490
	 in
	    x_5491
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5493: word32 * word32 = 
      (wordSize, wordSize)
   val x_5494: bool = 
      < x_5493
   val x_5495: unit = 
      case x_5494 of
      true => 
	 let
	    val x_5499: unit = 
	       ()
	 in
	    x_5499
	 end
      false => 
	 let
	    val x_5496: word8 vector = 
	       "EmbedWord"
	    val x_5497: exn = 
	       Fail x_5496
	    val x_5498: unit = 
	       raise x_5497
	 in
	    x_5498
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5500: word32 * word32 = 
      (wordSize, wordSize)
   val x_5501: bool = 
      < x_5500
   val x_5502: unit = 
      case x_5501 of
      true => 
	 let
	    val x_5506: unit = 
	       ()
	 in
	    x_5506
	 end
      false => 
	 let
	    val x_5503: word8 vector = 
	       "EmbedWord"
	    val x_5504: exn = 
	       Fail x_5503
	    val x_5505: unit = 
	       raise x_5504
	 in
	    x_5505
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5507: word32 * word32 = 
      (wordSize, wordSize)
   val x_5508: bool = 
      < x_5507
   val x_5509: unit = 
      case x_5508 of
      true => 
	 let
	    val x_5513: unit = 
	       ()
	 in
	    x_5513
	 end
      false => 
	 let
	    val x_5510: word8 vector = 
	       "EmbedWord"
	    val x_5511: exn = 
	       Fail x_5510
	    val x_5512: unit = 
	       raise x_5511
	 in
	    x_5512
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5514: word32 * word32 = 
      (wordSize, wordSize)
   val x_5515: bool = 
      < x_5514
   val x_5516: unit = 
      case x_5515 of
      true => 
	 let
	    val x_5520: unit = 
	       ()
	 in
	    x_5520
	 end
      false => 
	 let
	    val x_5517: word8 vector = 
	       "EmbedWord"
	    val x_5518: exn = 
	       Fail x_5517
	    val x_5519: unit = 
	       raise x_5518
	 in
	    x_5519
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5521: word32 * word32 = 
      (wordSize, wordSize)
   val x_5522: bool = 
      < x_5521
   val x_5523: unit = 
      case x_5522 of
      true => 
	 let
	    val x_5527: unit = 
	       ()
	 in
	    x_5527
	 end
      false => 
	 let
	    val x_5524: word8 vector = 
	       "EmbedWord"
	    val x_5525: exn = 
	       Fail x_5524
	    val x_5526: unit = 
	       raise x_5525
	 in
	    x_5526
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5528: word32 * word32 = 
      (wordSize, wordSize)
   val x_5529: bool = 
      < x_5528
   val x_5530: unit = 
      case x_5529 of
      true => 
	 let
	    val x_5534: unit = 
	       ()
	 in
	    x_5534
	 end
      false => 
	 let
	    val x_5531: word8 vector = 
	       "EmbedWord"
	    val x_5532: exn = 
	       Fail x_5531
	    val x_5533: unit = 
	       raise x_5532
	 in
	    x_5533
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5535: word32 * word32 = 
      (wordSize, wordSize)
   val x_5536: bool = 
      < x_5535
   val x_5537: unit = 
      case x_5536 of
      true => 
	 let
	    val x_5541: unit = 
	       ()
	 in
	    x_5541
	 end
      false => 
	 let
	    val x_5538: word8 vector = 
	       "EmbedWord"
	    val x_5539: exn = 
	       Fail x_5538
	    val x_5540: unit = 
	       raise x_5539
	 in
	    x_5540
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5542: word32 * word32 = 
      (wordSize, wordSize)
   val x_5543: bool = 
      < x_5542
   val x_5544: unit = 
      case x_5543 of
      true => 
	 let
	    val x_5548: unit = 
	       ()
	 in
	    x_5548
	 end
      false => 
	 let
	    val x_5545: word8 vector = 
	       "EmbedWord"
	    val x_5546: exn = 
	       Fail x_5545
	    val x_5547: unit = 
	       raise x_5546
	 in
	    x_5547
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5549: word32 * word32 = 
      (wordSize, wordSize)
   val x_5550: bool = 
      < x_5549
   val x_5551: unit = 
      case x_5550 of
      true => 
	 let
	    val x_5555: unit = 
	       ()
	 in
	    x_5555
	 end
      false => 
	 let
	    val x_5552: word8 vector = 
	       "EmbedWord"
	    val x_5553: exn = 
	       Fail x_5552
	    val x_5554: unit = 
	       raise x_5553
	 in
	    x_5554
	 end
   val wordSize: word32 = 
      sextdFromInt32ToInt32 sizeInBits
   val x_5556: word32 * word32 = 
      (wordSize, wordSize)
   val x_5557: bool = 
      < x_5556
   val x_5558: unit = 
      case x_5557 of
      true => 
	 let
	    val x_5562: unit = 
	       ()
	 in
	    x_5562
	 end
      false => 
	 let
	    val x_5559: word8 vector = 
	       "EmbedWord"
	    val x_5560: exn = 
	       Fail x_5559
	    val x_5561: unit = 
	       raise x_5560
	 in
	    x_5561
	 end
   val x_5563: word32 = 
      0x1
   val x_5564: word32 * word32 = 
      (x_4232, x_5563)
   val maxOrd: word32 = 
      -! x_5564
   val rec 'a_3438 
      make: ((word8 * word8 -> bool) -> 'a_3438) -> 'a_3438 = 
	 fn x_1361: (word8 * word8 -> bool) -> 'a_3438 => 
	 let
	    val x_5565: 'a_3438 = 
	       x_1361 = (word8)
	 in
	    x_5565
	 end
   val isPrefix: word8 vector -> word8 vector -> bool = 
      make (word8 vector -> word8 vector -> bool) isPrefix_1 (word8)
   val x_5566: word32 = 
      0x0
   val x_5567: word32 = 
      idFromInt32ToWord32 maxOrd
   val x_5568: word32 = 
      idFromInt32ToWord32 x_5566
   val x_5569: word32 * word32 = 
      (x_5567, x_5568)
   val x_5570: bool = 
      < x_5569
   val x_5571: word8 Primitive.Option.t = 
      case x_5570 of
      true => 
	 let
	    val x_5574: word8 Primitive.Option.t = 
	       NONE[word8]
	 in
	    x_5574
	 end
      false => 
	 let
	    val x_5572: word8 = 
	       x_4229 x_5566
	    val x_5573: word8 Primitive.Option.t = 
	       SOME[word8] x_5572
	 in
	    x_5573
	 end
   val x_5575: word8 = 
      case x_5571 of
      NONE[word8] => 
	 let
	    val x_5577: exn = 
	       Chr
	    val x_5578: word8 = 
	       raise x_5577
	 in
	    x_5578
	 end
      SOME[word8] x_5576: word8 => 
	 let
	 in
	    x_5576
	 end
   val x_5579: word32 = 
      0x1
   val x_5580: word32 * word8 = 
      (x_5579, x_5575)
   val x_5581: word8 vector = 
      vector_0 (word8) x_5580
   val rec 
      nullTerm: word8 vector -> word8 vector = 
	 fn x_1362: word8 vector => 
	 let
	    val x_5582: word8 vector * word8 vector = 
	       (x_1362, x_5581)
	    val x_5583: word8 vector = 
	       append_3 (word8) x_5582
	 in
	    x_5583
	 end
   val x_5584: exn -> word8 vector Primitive.Option.t = 
      fn x_1363: exn => 
      let
	 val x_5585: word8 vector Primitive.Option.t = 
	    case x_1363 of
	    Fail x_5586: word8 vector => 
	       let
		  val x_5587: word8 vector list = 
		     nil[word8 vector]
		  val x_5588: word8 vector * word8 vector list = 
		     (x_5586, x_5587)
		  val x_5589: word8 vector list = 
		     ::[word8 vector] x_5588
		  val x_5590: word8 vector = 
		     "Fail: "
		  val x_5591: word8 vector * word8 vector list = 
		     (x_5590, x_5589)
		  val x_5592: word8 vector list = 
		     ::[word8 vector] x_5591
		  val x_5593: word8 vector = 
		     concat_1 (word8) x_5592
		  val x_5594: word8 vector Primitive.Option.t = 
		     SOME[word8 vector] x_5593
	       in
		  x_5594
	       end
	      _ => let
		      val x_5595: word8 vector Primitive.Option.t = 
			 NONE[word8 vector]
		   in
		      x_5595
		   end
      in
	 x_5585
      end
   val x_5596: unit = 
      addExnMessager x_5584
   val x_5597: (word8 vector -> word8 vector) * (word8 vector -> word8 vector) = 
      (fromString, nullTerm)
   val nullTerm: word8 vector -> word8 vector = 
      o_1 (word8 vector, word8 vector, word8 vector) x_5597
   val rec ('a_3451, 'a_3450) 
      makeLength: ('a_3450 * word32 -> 'a_3451) * ('a_3451 -> bool)
		  -> 'a_3450 -> word32 = 
	 fn x_1364: ('a_3450 * word32 -> 'a_3451) * ('a_3451 -> bool) => 
	 let
	    val x_5598: 'a_3450 -> word32 = 
	       fn x_1365: 'a_3450 => 
	       let
		  val x_5599: 'a_3451 -> bool = 
		     #1 x_1364
		  val x_5600: 'a_3450 * word32 -> 'a_3451 = 
		     #0 x_1364
		  val rec 
		     loop: word32 -> word32 = 
			fn x_1366: word32 => 
			let
			   val x_5601: 'a_3450 * word32 = 
			      (x_1365, x_1366)
			   val x_5602: 'a_3451 = 
			      x_5600 x_5601
			   val x_5603: bool = 
			      x_5599 x_5602
			   val x_5604: word32 = 
			      case x_5603 of
			      true => 
				 let
				 in
				    x_1366
				 end
			      false => 
				 let
				    val x_5605: word32 = 
				       0x1
				    val x_5606: word32 * word32 = 
				       (x_1366, x_5605)
				    val x_5607: word32 = 
				       +? x_5606
				    val x_5608: word32 = 
				       loop x_5607
				 in
				    x_5608
				 end
			in
			   x_5604
			end
		  val x_5609: word32 = 
		     0x0
		  val x_5610: word32 = 
		     loop x_5609
	       in
		  x_5610
	       end
	 in
	    x_5598
	 end
   val rec ('b, 'a) 
      toArrayOfLength: 'a * ('a * word32 -> 'b) * word32 -> 'b array = 
	 fn x_1367: 'a * ('a * word32 -> 'b) * word32 => 
	 let
	    val n: word32 = 
	       #2 x_1367
	    val sub: 'a * word32 -> 'b = 
	       #1 x_1367
	    val s: 'a = 
	       #0 x_1367
	    val x_5611: unit = 
	       ()
	    val x_5612: word32 * unit -> 'b * unit = 
	       fn x_1368: word32 * unit => 
	       let
		  val x_5613: word32 = 
		     #0 x_1368
		  val x_5614: 'a * word32 = 
		     (s, x_5613)
		  val x_5615: 'b = 
		     sub x_5614
		  val x_5616: unit = 
		     ()
		  val x_5617: 'b * unit = 
		     (x_5615, x_5616)
	       in
		  x_5617
	       end
	    val x_5618: word32 * unit * (word32 * unit -> 'b * unit) = 
	       (n, x_5611, x_5612)
	    val x_5619: 'b array * unit = 
	       unfoldi_5 ('b, unit) x_5618
	    val x_5620: 'b array = 
	       #0 x_5619
	 in
	    x_5620
	 end
   val rec 
      sub: word64 * word32 -> word8 = 
	 fn x_1369: word64 * word32 => 
	 let
	    val i: word32 = 
	       #1 x_1369
	    val cs: word64 = 
	       #0 x_1369
	    val x_5621: cpointer = 
	       fromWord cs
	    val x_5622: word64 = 
	       sextdFromInt32ToInt64 i
	    val x_5623: word8 = 
	       CPointer_getWord8 (x_5621, x_5622)
	    val x_5624: word8 = 
	       idFromWord8 x_5623
	 in
	    x_5624
	 end
   val x_5625: word8 -> bool = 
      fn x_1370: word8 => 
      let
	 val x_5626: bool = 
	    case x_1370 of
	    0x0 => 
	       let
		  val x_5627: bool = 
		     true
	       in
		  x_5627
	       end
	      _ => let
		      val x_5628: bool = 
			 false
		   in
		      x_5628
		   end
      in
	 x_5626
      end
   val x_5629: (word64 * word32 -> word8) * (word8 -> bool) = 
      (sub, x_5625)
   val length: word64 -> word32 = 
      makeLength (word8, word64) x_5629
   val rec 
      new: unit -> (unit -> unit) list ref = 
	 fn x_1374: unit => 
	 let
	    val x_5630: (unit -> unit) list = 
	       nil[unit -> unit]
	    val x_5631: (unit -> unit) list ref = 
	       Ref_ref[(unit -> unit) list] (x_5630)
	 in
	    x_5631
	 end
   val rec 'a_3452 
      addNew: 'a_3452 list ref * 'a_3452 -> unit = 
	 fn x_1375: 'a_3452 list ref * 'a_3452 => 
	 let
	    val f: 'a_3452 = 
	       #1 x_1375
	    val cs: 'a_3452 list ref = 
	       #0 x_1375
	    val x_5632: 'a_3452 list = 
	       !_1 ('a_3452 list) cs
	    val x_5633: 'a_3452 * 'a_3452 list = 
	       (f, x_5632)
	    val x_5634: 'a_3452 list = 
	       ::['a_3452] x_5633
	    val x_5635: 'a_3452 list ref * 'a_3452 list = 
	       (cs, x_5634)
	    val x_5636: unit = 
	       :=_1 ('a_3452 list) x_5635
	 in
	    x_5636
	 end
   val x_5637: unit = 
      ()
   val atExit: (unit -> unit) list ref = 
      new x_5637
   val x_5638: unit = 
      ()
   val atLoadWorld: (unit -> unit) list ref = 
      new x_5638
   val fromRep: word32 -> word32 = 
      fn x_1379: word32 => 
      let
      in
	 x_1379
      end
   val toRep: word32 -> word32 = 
      fn x_1380: word32 => 
      let
      in
	 x_1380
      end
   val fromRep: word32 -> word32 = 
      fn x_1381: word32 => 
      let
      in
	 x_1381
      end
   val fromRep: word32 -> word32 = 
      fn x_1382: word32 => 
      let
      in
	 x_1382
      end
   val toRep: word32 -> word32 = 
      fn x_1383: word32 => 
      let
      in
	 x_1383
      end
   val fromRep: word32 -> word32 = 
      fn x_1385: word32 => 
      let
      in
	 x_1385
      end
   val acces: word32 = 
      fromRep EACCES
   val addrinuse: word32 = 
      fromRep EADDRINUSE
   val addrnotavail: word32 = 
      fromRep EADDRNOTAVAIL
   val afnosupport: word32 = 
      fromRep EAFNOSUPPORT
   val again: word32 = 
      fromRep EAGAIN
   val already: word32 = 
      fromRep EALREADY
   val badf: word32 = 
      fromRep EBADF
   val badmsg: word32 = 
      fromRep EBADMSG
   val busy: word32 = 
      fromRep EBUSY
   val canceled: word32 = 
      fromRep ECANCELED
   val child: word32 = 
      fromRep ECHILD
   val connaborted: word32 = 
      fromRep ECONNABORTED
   val connrefused: word32 = 
      fromRep ECONNREFUSED
   val connreset: word32 = 
      fromRep ECONNRESET
   val deadlk: word32 = 
      fromRep EDEADLK
   val destaddrreq: word32 = 
      fromRep EDESTADDRREQ
   val dom: word32 = 
      fromRep EDOM
   val dquot: word32 = 
      fromRep EDQUOT
   val exist: word32 = 
      fromRep EEXIST
   val fault: word32 = 
      fromRep EFAULT
   val fbig: word32 = 
      fromRep EFBIG
   val hostunreach: word32 = 
      fromRep EHOSTUNREACH
   val idrm: word32 = 
      fromRep EIDRM
   val ilseq: word32 = 
      fromRep EILSEQ
   val inprogress: word32 = 
      fromRep EINPROGRESS
   val intr: word32 = 
      fromRep EINTR
   val inval: word32 = 
      fromRep EINVAL
   val io: word32 = 
      fromRep EIO
   val isconn: word32 = 
      fromRep EISCONN
   val isdir: word32 = 
      fromRep EISDIR
   val loop: word32 = 
      fromRep ELOOP
   val mfile: word32 = 
      fromRep EMFILE
   val mlink: word32 = 
      fromRep EMLINK
   val msgsize: word32 = 
      fromRep EMSGSIZE
   val multihop: word32 = 
      fromRep EMULTIHOP
   val nametoolong: word32 = 
      fromRep ENAMETOOLONG
   val netdown: word32 = 
      fromRep ENETDOWN
   val netreset: word32 = 
      fromRep ENETRESET
   val netunreach: word32 = 
      fromRep ENETUNREACH
   val nfile: word32 = 
      fromRep ENFILE
   val nobufs: word32 = 
      fromRep ENOBUFS
   val nodata: word32 = 
      fromRep ENODATA
   val nodev: word32 = 
      fromRep ENODEV
   val noent: word32 = 
      fromRep ENOENT
   val noexec: word32 = 
      fromRep ENOEXEC
   val nolck: word32 = 
      fromRep ENOLCK
   val nolink: word32 = 
      fromRep ENOLINK
   val nomem: word32 = 
      fromRep ENOMEM
   val nomsg: word32 = 
      fromRep ENOMSG
   val noprotoopt: word32 = 
      fromRep ENOPROTOOPT
   val nospc: word32 = 
      fromRep ENOSPC
   val nosr: word32 = 
      fromRep ENOSR
   val nostr: word32 = 
      fromRep ENOSTR
   val nosys: word32 = 
      fromRep ENOSYS
   val notconn: word32 = 
      fromRep ENOTCONN
   val notdir: word32 = 
      fromRep ENOTDIR
   val notempty: word32 = 
      fromRep ENOTEMPTY
   val notsock: word32 = 
      fromRep ENOTSOCK
   val notsup: word32 = 
      fromRep ENOTSUP
   val notty: word32 = 
      fromRep ENOTTY
   val nxio: word32 = 
      fromRep ENXIO
   val opnotsupp: word32 = 
      fromRep EOPNOTSUPP
   val overflow: word32 = 
      fromRep EOVERFLOW
   val perm: word32 = 
      fromRep EPERM
   val pipe: word32 = 
      fromRep EPIPE
   val proto: word32 = 
      fromRep EPROTO
   val protonosupport: word32 = 
      fromRep EPROTONOSUPPORT
   val prototype: word32 = 
      fromRep EPROTOTYPE
   val range: word32 = 
      fromRep ERANGE
   val rofs: word32 = 
      fromRep EROFS
   val spipe: word32 = 
      fromRep ESPIPE
   val srch: word32 = 
      fromRep ESRCH
   val stale: word32 = 
      fromRep ESTALE
   val time: word32 = 
      fromRep ETIME
   val timedout: word32 = 
      fromRep ETIMEDOUT
   val toobig: word32 = 
      fromRep E2BIG
   val txtbsy: word32 = 
      fromRep ETXTBSY
   val wouldblock: word32 = 
      fromRep EWOULDBLOCK
   val xdev: word32 = 
      fromRep EXDEV
   val rec 'a_3453 
      ::?: (word32 * 'a_3453) * (word32 * 'a_3453) list
	   -> (word32 * 'a_3453) list = 
	 fn x_1388: (word32 * 'a_3453) * (word32 * 'a_3453) list => 
	 let
	    val x_5639: (word32 * 'a_3453) list = 
	       #1 x_1388
	    val x_5640: word32 * 'a_3453 = 
	       #0 x_1388
	    val x_5641: 'a_3453 = 
	       #1 x_5640
	    val x_5642: word32 = 
	       #0 x_5640
	    val x_5643: word32 = 
	       0xFFFFFFFF
	    val x_5644: word32 = 
	       fromRep x_5643
	    val x_5645: word32 * word32 = 
	       (x_5642, x_5644)
	    val x_5646: bool = 
	       = (word32) x_5645
	    val x_5647: (word32 * 'a_3453) list = 
	       case x_5646 of
	       true => 
		  let
		  in
		     x_5639
		  end
	       false => 
		  let
		     val x_5648: word32 * 'a_3453 = 
			(x_5642, x_5641)
		     val x_5649: (word32 * 'a_3453) * (word32 * 'a_3453) list = 
			(x_5648, x_5639)
		     val x_5650: (word32 * 'a_3453) list = 
			::[word32 * 'a_3453] x_5649
		  in
		     x_5650
		  end
	 in
	    x_5647
	 end
   val x_5651: word8 vector = 
      "acces"
   val x_5652: word32 * word8 vector = 
      (acces, x_5651)
   val x_5653: word8 vector = 
      "addrinuse"
   val x_5654: word32 * word8 vector = 
      (addrinuse, x_5653)
   val x_5655: word8 vector = 
      "addrnotavail"
   val x_5656: word32 * word8 vector = 
      (addrnotavail, x_5655)
   val x_5657: word8 vector = 
      "afnosupport"
   val x_5658: word32 * word8 vector = 
      (afnosupport, x_5657)
   val x_5659: word8 vector = 
      "again"
   val x_5660: word32 * word8 vector = 
      (again, x_5659)
   val x_5661: word8 vector = 
      "already"
   val x_5662: word32 * word8 vector = 
      (already, x_5661)
   val x_5663: word8 vector = 
      "badf"
   val x_5664: word32 * word8 vector = 
      (badf, x_5663)
   val x_5665: word8 vector = 
      "badmsg"
   val x_5666: word32 * word8 vector = 
      (badmsg, x_5665)
   val x_5667: word8 vector = 
      "busy"
   val x_5668: word32 * word8 vector = 
      (busy, x_5667)
   val x_5669: word8 vector = 
      "canceled"
   val x_5670: word32 * word8 vector = 
      (canceled, x_5669)
   val x_5671: word8 vector = 
      "child"
   val x_5672: word32 * word8 vector = 
      (child, x_5671)
   val x_5673: word8 vector = 
      "connaborted"
   val x_5674: word32 * word8 vector = 
      (connaborted, x_5673)
   val x_5675: word8 vector = 
      "connrefused"
   val x_5676: word32 * word8 vector = 
      (connrefused, x_5675)
   val x_5677: word8 vector = 
      "connreset"
   val x_5678: word32 * word8 vector = 
      (connreset, x_5677)
   val x_5679: word8 vector = 
      "deadlk"
   val x_5680: word32 * word8 vector = 
      (deadlk, x_5679)
   val x_5681: word8 vector = 
      "destaddrreq"
   val x_5682: word32 * word8 vector = 
      (destaddrreq, x_5681)
   val x_5683: word8 vector = 
      "dom"
   val x_5684: word32 * word8 vector = 
      (dom, x_5683)
   val x_5685: word8 vector = 
      "dquot"
   val x_5686: word32 * word8 vector = 
      (dquot, x_5685)
   val x_5687: word8 vector = 
      "exist"
   val x_5688: word32 * word8 vector = 
      (exist, x_5687)
   val x_5689: word8 vector = 
      "fault"
   val x_5690: word32 * word8 vector = 
      (fault, x_5689)
   val x_5691: word8 vector = 
      "fbig"
   val x_5692: word32 * word8 vector = 
      (fbig, x_5691)
   val x_5693: word8 vector = 
      "hostunreach"
   val x_5694: word32 * word8 vector = 
      (hostunreach, x_5693)
   val x_5695: word8 vector = 
      "idrm"
   val x_5696: word32 * word8 vector = 
      (idrm, x_5695)
   val x_5697: word8 vector = 
      "ilseq"
   val x_5698: word32 * word8 vector = 
      (ilseq, x_5697)
   val x_5699: word8 vector = 
      "inprogress"
   val x_5700: word32 * word8 vector = 
      (inprogress, x_5699)
   val x_5701: word8 vector = 
      "intr"
   val x_5702: word32 * word8 vector = 
      (intr, x_5701)
   val x_5703: word8 vector = 
      "inval"
   val x_5704: word32 * word8 vector = 
      (inval, x_5703)
   val x_5705: word8 vector = 
      "io"
   val x_5706: word32 * word8 vector = 
      (io, x_5705)
   val x_5707: word8 vector = 
      "isconn"
   val x_5708: word32 * word8 vector = 
      (isconn, x_5707)
   val x_5709: word8 vector = 
      "isdir"
   val x_5710: word32 * word8 vector = 
      (isdir, x_5709)
   val x_5711: word8 vector = 
      "loop"
   val x_5712: word32 * word8 vector = 
      (loop, x_5711)
   val x_5713: word8 vector = 
      "mfile"
   val x_5714: word32 * word8 vector = 
      (mfile, x_5713)
   val x_5715: word8 vector = 
      "mlink"
   val x_5716: word32 * word8 vector = 
      (mlink, x_5715)
   val x_5717: word8 vector = 
      "msgsize"
   val x_5718: word32 * word8 vector = 
      (msgsize, x_5717)
   val x_5719: word8 vector = 
      "multihop"
   val x_5720: word32 * word8 vector = 
      (multihop, x_5719)
   val x_5721: word8 vector = 
      "nametoolong"
   val x_5722: word32 * word8 vector = 
      (nametoolong, x_5721)
   val x_5723: word8 vector = 
      "netdown"
   val x_5724: word32 * word8 vector = 
      (netdown, x_5723)
   val x_5725: word8 vector = 
      "netreset"
   val x_5726: word32 * word8 vector = 
      (netreset, x_5725)
   val x_5727: word8 vector = 
      "netunreach"
   val x_5728: word32 * word8 vector = 
      (netunreach, x_5727)
   val x_5729: word8 vector = 
      "nfile"
   val x_5730: word32 * word8 vector = 
      (nfile, x_5729)
   val x_5731: word8 vector = 
      "nobufs"
   val x_5732: word32 * word8 vector = 
      (nobufs, x_5731)
   val x_5733: word8 vector = 
      "nodata"
   val x_5734: word32 * word8 vector = 
      (nodata, x_5733)
   val x_5735: word8 vector = 
      "nodev"
   val x_5736: word32 * word8 vector = 
      (nodev, x_5735)
   val x_5737: word8 vector = 
      "noent"
   val x_5738: word32 * word8 vector = 
      (noent, x_5737)
   val x_5739: word8 vector = 
      "noexec"
   val x_5740: word32 * word8 vector = 
      (noexec, x_5739)
   val x_5741: word8 vector = 
      "nolck"
   val x_5742: word32 * word8 vector = 
      (nolck, x_5741)
   val x_5743: word8 vector = 
      "nolink"
   val x_5744: word32 * word8 vector = 
      (nolink, x_5743)
   val x_5745: word8 vector = 
      "nomem"
   val x_5746: word32 * word8 vector = 
      (nomem, x_5745)
   val x_5747: word8 vector = 
      "nomsg"
   val x_5748: word32 * word8 vector = 
      (nomsg, x_5747)
   val x_5749: word8 vector = 
      "noprotoopt"
   val x_5750: word32 * word8 vector = 
      (noprotoopt, x_5749)
   val x_5751: word8 vector = 
      "nospc"
   val x_5752: word32 * word8 vector = 
      (nospc, x_5751)
   val x_5753: word8 vector = 
      "nosr"
   val x_5754: word32 * word8 vector = 
      (nosr, x_5753)
   val x_5755: word8 vector = 
      "nostr"
   val x_5756: word32 * word8 vector = 
      (nostr, x_5755)
   val x_5757: word8 vector = 
      "nosys"
   val x_5758: word32 * word8 vector = 
      (nosys, x_5757)
   val x_5759: word8 vector = 
      "notconn"
   val x_5760: word32 * word8 vector = 
      (notconn, x_5759)
   val x_5761: word8 vector = 
      "notdir"
   val x_5762: word32 * word8 vector = 
      (notdir, x_5761)
   val x_5763: word8 vector = 
      "notempty"
   val x_5764: word32 * word8 vector = 
      (notempty, x_5763)
   val x_5765: word8 vector = 
      "notsock"
   val x_5766: word32 * word8 vector = 
      (notsock, x_5765)
   val x_5767: word8 vector = 
      "notsup"
   val x_5768: word32 * word8 vector = 
      (notsup, x_5767)
   val x_5769: word8 vector = 
      "notty"
   val x_5770: word32 * word8 vector = 
      (notty, x_5769)
   val x_5771: word8 vector = 
      "nxio"
   val x_5772: word32 * word8 vector = 
      (nxio, x_5771)
   val x_5773: word8 vector = 
      "opnotsupp"
   val x_5774: word32 * word8 vector = 
      (opnotsupp, x_5773)
   val x_5775: word8 vector = 
      "overflow"
   val x_5776: word32 * word8 vector = 
      (overflow, x_5775)
   val x_5777: word8 vector = 
      "perm"
   val x_5778: word32 * word8 vector = 
      (perm, x_5777)
   val x_5779: word8 vector = 
      "pipe"
   val x_5780: word32 * word8 vector = 
      (pipe, x_5779)
   val x_5781: word8 vector = 
      "proto"
   val x_5782: word32 * word8 vector = 
      (proto, x_5781)
   val x_5783: word8 vector = 
      "protonosupport"
   val x_5784: word32 * word8 vector = 
      (protonosupport, x_5783)
   val x_5785: word8 vector = 
      "prototype"
   val x_5786: word32 * word8 vector = 
      (prototype, x_5785)
   val x_5787: word8 vector = 
      "range"
   val x_5788: word32 * word8 vector = 
      (range, x_5787)
   val x_5789: word8 vector = 
      "rofs"
   val x_5790: word32 * word8 vector = 
      (rofs, x_5789)
   val x_5791: word8 vector = 
      "spipe"
   val x_5792: word32 * word8 vector = 
      (spipe, x_5791)
   val x_5793: word8 vector = 
      "srch"
   val x_5794: word32 * word8 vector = 
      (srch, x_5793)
   val x_5795: word8 vector = 
      "stale"
   val x_5796: word32 * word8 vector = 
      (stale, x_5795)
   val x_5797: word8 vector = 
      "time"
   val x_5798: word32 * word8 vector = 
      (time, x_5797)
   val x_5799: word8 vector = 
      "timedout"
   val x_5800: word32 * word8 vector = 
      (timedout, x_5799)
   val x_5801: word8 vector = 
      "toobig"
   val x_5802: word32 * word8 vector = 
      (toobig, x_5801)
   val x_5803: word8 vector = 
      "txtbsy"
   val x_5804: word32 * word8 vector = 
      (txtbsy, x_5803)
   val x_5805: word8 vector = 
      "wouldblock"
   val x_5806: word32 * word8 vector = 
      (wouldblock, x_5805)
   val x_5807: word8 vector = 
      "xdev"
   val x_5808: word32 * word8 vector = 
      (xdev, x_5807)
   val x_5809: (word32 * word8 vector) list = 
      nil[word32 * word8 vector]
   val x_5810: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5808, x_5809)
   val x_5811: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5810
   val x_5812: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5806, x_5811)
   val x_5813: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5812
   val x_5814: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5804, x_5813)
   val x_5815: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5814
   val x_5816: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5802, x_5815)
   val x_5817: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5816
   val x_5818: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5800, x_5817)
   val x_5819: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5818
   val x_5820: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5798, x_5819)
   val x_5821: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5820
   val x_5822: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5796, x_5821)
   val x_5823: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5822
   val x_5824: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5794, x_5823)
   val x_5825: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5824
   val x_5826: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5792, x_5825)
   val x_5827: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5826
   val x_5828: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5790, x_5827)
   val x_5829: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5828
   val x_5830: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5788, x_5829)
   val x_5831: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5830
   val x_5832: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5786, x_5831)
   val x_5833: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5832
   val x_5834: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5784, x_5833)
   val x_5835: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5834
   val x_5836: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5782, x_5835)
   val x_5837: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5836
   val x_5838: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5780, x_5837)
   val x_5839: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5838
   val x_5840: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5778, x_5839)
   val x_5841: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5840
   val x_5842: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5776, x_5841)
   val x_5843: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5842
   val x_5844: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5774, x_5843)
   val x_5845: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5844
   val x_5846: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5772, x_5845)
   val x_5847: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5846
   val x_5848: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5770, x_5847)
   val x_5849: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5848
   val x_5850: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5768, x_5849)
   val x_5851: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5850
   val x_5852: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5766, x_5851)
   val x_5853: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5852
   val x_5854: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5764, x_5853)
   val x_5855: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5854
   val x_5856: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5762, x_5855)
   val x_5857: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5856
   val x_5858: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5760, x_5857)
   val x_5859: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5858
   val x_5860: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5758, x_5859)
   val x_5861: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5860
   val x_5862: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5756, x_5861)
   val x_5863: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5862
   val x_5864: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5754, x_5863)
   val x_5865: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5864
   val x_5866: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5752, x_5865)
   val x_5867: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5866
   val x_5868: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5750, x_5867)
   val x_5869: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5868
   val x_5870: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5748, x_5869)
   val x_5871: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5870
   val x_5872: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5746, x_5871)
   val x_5873: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5872
   val x_5874: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5744, x_5873)
   val x_5875: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5874
   val x_5876: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5742, x_5875)
   val x_5877: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5876
   val x_5878: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5740, x_5877)
   val x_5879: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5878
   val x_5880: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5738, x_5879)
   val x_5881: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5880
   val x_5882: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5736, x_5881)
   val x_5883: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5882
   val x_5884: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5734, x_5883)
   val x_5885: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5884
   val x_5886: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5732, x_5885)
   val x_5887: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5886
   val x_5888: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5730, x_5887)
   val x_5889: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5888
   val x_5890: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5728, x_5889)
   val x_5891: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5890
   val x_5892: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5726, x_5891)
   val x_5893: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5892
   val x_5894: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5724, x_5893)
   val x_5895: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5894
   val x_5896: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5722, x_5895)
   val x_5897: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5896
   val x_5898: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5720, x_5897)
   val x_5899: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5898
   val x_5900: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5718, x_5899)
   val x_5901: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5900
   val x_5902: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5716, x_5901)
   val x_5903: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5902
   val x_5904: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5714, x_5903)
   val x_5905: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5904
   val x_5906: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5712, x_5905)
   val x_5907: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5906
   val x_5908: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5710, x_5907)
   val x_5909: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5908
   val x_5910: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5708, x_5909)
   val x_5911: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5910
   val x_5912: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5706, x_5911)
   val x_5913: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5912
   val x_5914: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5704, x_5913)
   val x_5915: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5914
   val x_5916: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5702, x_5915)
   val x_5917: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5916
   val x_5918: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5700, x_5917)
   val x_5919: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5918
   val x_5920: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5698, x_5919)
   val x_5921: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5920
   val x_5922: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5696, x_5921)
   val x_5923: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5922
   val x_5924: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5694, x_5923)
   val x_5925: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5924
   val x_5926: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5692, x_5925)
   val x_5927: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5926
   val x_5928: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5690, x_5927)
   val x_5929: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5928
   val x_5930: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5688, x_5929)
   val x_5931: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5930
   val x_5932: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5686, x_5931)
   val x_5933: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5932
   val x_5934: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5684, x_5933)
   val x_5935: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5934
   val x_5936: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5682, x_5935)
   val x_5937: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5936
   val x_5938: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5680, x_5937)
   val x_5939: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5938
   val x_5940: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5678, x_5939)
   val x_5941: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5940
   val x_5942: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5676, x_5941)
   val x_5943: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5942
   val x_5944: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5674, x_5943)
   val x_5945: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5944
   val x_5946: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5672, x_5945)
   val x_5947: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5946
   val x_5948: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5670, x_5947)
   val x_5949: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5948
   val x_5950: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5668, x_5949)
   val x_5951: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5950
   val x_5952: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5666, x_5951)
   val x_5953: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5952
   val x_5954: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5664, x_5953)
   val x_5955: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5954
   val x_5956: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5662, x_5955)
   val x_5957: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5956
   val x_5958: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5660, x_5957)
   val x_5959: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5958
   val x_5960: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5658, x_5959)
   val x_5961: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5960
   val x_5962: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5656, x_5961)
   val x_5963: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5962
   val x_5964: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5654, x_5963)
   val x_5965: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5964
   val x_5966: (word32 * word8 vector) * (word32 * word8 vector) list = 
      (x_5652, x_5965)
   val errorNames: (word32 * word8 vector) list = 
      ::? (word8 vector) x_5966
   exception SysErr of word8 vector * word32 Primitive.Option.t
   val x_5967: exn -> word8 vector Primitive.Option.t = 
      fn x_1391: exn => 
      let
	 val x_5968: word8 vector Primitive.Option.t = 
	    case x_1391 of
	    SysErr x_5969: word8 vector * word32 Primitive.Option.t => 
	       let
		  val x_5970: word32 Primitive.Option.t = 
		     #1 x_5969
		  val x_5971: word8 vector = 
		     #0 x_5969
		  val x_5972: word8 vector list = 
		     nil[word8 vector]
		  val x_5973: word8 vector = 
		     case x_5970 of
		     NONE[word32] => 
			let
			   val x_5995: word8 vector = 
			      ""
			in
			   x_5995
			end
		     SOME[word32] x_5974: word32 => 
			let
			   val x_5975: word8 vector list = 
			      nil[word8 vector]
			   val x_5976: word8 vector = 
			      "]"
			   val x_5977: word8 vector * word8 vector list = 
			      (x_5976, x_5975)
			   val x_5978: word8 vector list = 
			      ::[word8 vector] x_5977
			   val x_5979: word32 * word8 vector -> bool = 
			      fn x_1390: word32 * word8 vector => 
			      let
				 val x_5980: word32 = 
				    #0 x_1390
				 val x_5981: word32 * word32 = 
				    (x_5974, x_5980)
				 val x_5982: bool = 
				    = (word32) x_5981
			      in
				 x_5982
			      end
			   val x_5983: (word32 * word8 vector) list
				       -> (word32 * word8 vector) Primitive.Option.t = 
			      find_0 (word32 * word8 vector) x_5979
			   val x_5984: (word32 * word8 vector) Primitive.Option.t = 
			      x_5983 errorNames
			   val x_5985: word8 vector = 
			      case x_5984 of
			      NONE[word32 * word8 vector] => 
				 let
				    val x_5988: word8 vector = 
				       "<UNKNOWN>"
				 in
				    x_5988
				 end
			      SOME[word32 * word8 vector] x_5986: word32
								  * word8 vector => 
				 let
				    val x_5987: word8 vector = 
				       #1 x_5986
				 in
				    x_5987
				 end
			   val x_5989: word8 vector * word8 vector list = 
			      (x_5985, x_5978)
			   val x_5990: word8 vector list = 
			      ::[word8 vector] x_5989
			   val x_5991: word8 vector = 
			      " ["
			   val x_5992: word8 vector * word8 vector list = 
			      (x_5991, x_5990)
			   val x_5993: word8 vector list = 
			      ::[word8 vector] x_5992
			   val x_5994: word8 vector = 
			      concat_1 (word8) x_5993
			in
			   x_5994
			end
		  val x_5996: word8 vector * word8 vector list = 
		     (x_5973, x_5972)
		  val x_5997: word8 vector list = 
		     ::[word8 vector] x_5996
		  val x_5998: word8 vector * word8 vector list = 
		     (x_5971, x_5997)
		  val x_5999: word8 vector list = 
		     ::[word8 vector] x_5998
		  val x_6000: word8 vector = 
		     "SysErr: "
		  val x_6001: word8 vector * word8 vector list = 
		     (x_6000, x_5999)
		  val x_6002: word8 vector list = 
		     ::[word8 vector] x_6001
		  val x_6003: word8 vector = 
		     concat_1 (word8) x_6002
		  val x_6004: word8 vector Primitive.Option.t = 
		     SOME[word8 vector] x_6003
	       in
		  x_6004
	       end
	      _ => let
		      val x_6005: word8 vector Primitive.Option.t = 
			 NONE[word8 vector]
		   in
		      x_6005
		   end
      in
	 x_5968
      end
   val x_6006: unit = 
      addExnMessager x_5967
   val rec 
      errorMsg: word32 -> word8 vector = 
	 fn x_1392: word32 => 
	 let
	    val x_6007: word64 = 
	       Posix_Error_strError (x_1392)
	    val x_6008: cpointer = 
	       fromWord x_6007
	    val x_6009: cpointer * cpointer = 
	       (x_6008, null)
	    val x_6010: bool = 
	       = (cpointer) x_6009
	    val x_6011: word8 vector = 
	       case x_6010 of
	       true => 
		  let
		     val x_6017: word8 vector = 
			"Unknown error"
		  in
		     x_6017
		  end
	       false => 
		  let
		     val x_6012: word32 = 
			length x_6007
		     val x_6013: word64 * (word64 * word32 -> word8) * word32 = 
			(x_6007, sub, x_6012)
		     val x_6014: word8 array = 
			toArrayOfLength (word8, word64) x_6013
		     val x_6015: word8 array = 
			fromPoly (word8 array) x_6014
		     val x_6016: word8 vector = 
			unsafeFromArray_0 (word8) x_6015
		  in
		     x_6016
		  end
	 in
	    x_6011
	 end
   val rec 'a_3454 
      raiseSys: word32 -> 'a_3454 = 
	 fn x_1393: word32 => 
	 let
	    val x_6018: word8 vector = 
	       errorMsg x_1393
	    val x_6019: word32 Primitive.Option.t = 
	       SOME[word32] x_1393
	    val x_6020: word8 vector * word32 Primitive.Option.t = 
	       (x_6018, x_6019)
	    val x_6021: exn = 
	       SysErr x_6020
	    val x_6022: 'a_3454 = 
	       raise x_6021
	 in
	    x_6022
	 end
   val rec 'a_3455 
      raiseSysWithMsg: word32 * word8 vector -> 'a_3455 = 
	 fn x_1394: word32 * word8 vector => 
	 let
	    val msg: word8 vector = 
	       #1 x_1394
	    val n: word32 = 
	       #0 x_1394
	    val x_6023: word8 vector = 
	       errorMsg n
	    val x_6024: word8 vector = 
	       ": "
	    val x_6025: word8 vector * word8 vector = 
	       (x_6023, x_6024)
	    val x_6026: word8 vector = 
	       append_3 (word8) x_6025
	    val x_6027: word8 vector * word8 vector = 
	       (x_6026, msg)
	    val x_6028: word8 vector = 
	       append_3 (word8) x_6027
	    val x_6029: word32 Primitive.Option.t = 
	       SOME[word32] n
	    val x_6030: word8 vector * word32 Primitive.Option.t = 
	       (x_6028, x_6029)
	    val x_6031: exn = 
	       SysErr x_6030
	    val x_6032: 'a_3455 = 
	       raise x_6031
	 in
	    x_6032
	 end
   val x_6033: unit -> unit -> unit = 
      fn x_1395: unit => 
      let
	 val x_6034: unit -> unit = 
	    fn x_1396: unit => 
	    let
	       val x_6035: unit = 
		  ()
	    in
	       x_6035
	    end
      in
	 x_6034
      end
   val blocker: (unit -> unit -> unit) ref = 
      Ref_ref[unit -> unit -> unit] (x_6033)
   val x_6036: bool = 
      true
   val restartFlag: bool ref = 
      Ref_ref[bool] (x_6036)
   val ('b, ''a) syscallErr: (bool * ''a * bool)
			     * (unit
				-> (word32 * (unit -> 'b)) list
				   * (''a -> 'b)
				   * ''a)
			     -> 'b = 
      let
	 val x_6037: (bool * ''a * bool)
		     * (unit -> (word32 * (unit -> 'b)) list * (''a -> 'b) * ''a)
		     -> 'b = 
	    fn x_1397: (bool * ''a * bool)
		       * (unit
			  -> (word32 * (unit -> 'b)) list * (''a -> 'b) * ''a) => 
	    let
	       val x_6038: unit
			   -> (word32 * (unit -> 'b)) list * (''a -> 'b) * ''a = 
		  #1 x_1397
	       val x_6039: bool * ''a * bool = 
		  #0 x_1397
	       val x_6040: bool = 
		  #2 x_6039
	       val x_6041: ''a = 
		  #1 x_6039
	       val x_6042: bool = 
		  #0 x_6039
	       val rec 
		  call: (word32 * (word32 * (unit -> 'b)) list -> 'b) -> 'b = 
		     fn x_1405: word32 * (word32 * (unit -> 'b)) list -> 'b => 
		     let
			val x_6043: unit = 
			   ()
			val x_6044: unit = 
			   atomicBegin x_6043
			val x_6045: unit = 
			   case x_6042 of
			   true => 
			      let
				 val x_6047: unit = 
				    Posix_Error_clearErrno ()
			      in
				 x_6047
			      end
			   false => 
			      let
				 val x_6046: unit = 
				    ()
			      in
				 x_6046
			      end
			val x_6048: (word32 * (unit -> 'b)) list
				    * (''a -> 'b)
				    * ''a = 
			   let
			      val x_6049: unit = 
				 ()
			      val x_6050: (word32 * (unit -> 'b)) list
					  * (''a -> 'b)
					  * ''a = 
				 x_6038 x_6049
			   in
			      x_6050
			   end
			   handle x_1406 => let
					       val x_6051: unit = 
						  ()
					       val x_6052: unit = 
						  atomicEnd x_6051
					       val x_6053: (word32
							    * (unit -> 'b)) list
							   * (''a -> 'b)
							   * ''a = 
						  raise x_1406
					    in
					       x_6053
					    end
			val return: ''a = 
			   #2 x_6048
			val post: ''a -> 'b = 
			   #1 x_6048
			val handlers: (word32 * (unit -> 'b)) list = 
			   #0 x_6048
			val return: ''a = 
			   check_0 (''a) return
			val x_6054: ''a * ''a = 
			   (x_6041, return)
			val x_6055: bool = 
			   = (''a) x_6054
			val x_6056: 'b = 
			   case x_6055 of
			   true => 
			      let
				 val x_6061: word32 = 
				    Posix_Error_getErrno ()
				 val e: word32 = 
				    fromRep x_6061
				 val x_6062: unit = 
				    ()
				 val x_6063: unit = 
				    atomicEnd x_6062
				 val x_6064: word32
					     * (word32 * (unit -> 'b)) list = 
				    (e, handlers)
				 val x_6065: 'b = 
				    x_1405 x_6064
			      in
				 x_6065
			      end
			   false => 
			      let
				 val x_6057: unit -> 'b = 
				    fn x_1407: unit => 
				    let
				       val x_6058: 'b = 
					  post return
				    in
				       x_6058
				    end
				 val x_6059: (unit -> 'b) * (unit -> unit) = 
				    (x_6057, atomicEnd)
				 val x_6060: 'b = 
				    wind_0 ('b) x_6059
			      in
				 x_6060
			      end
		     in
			x_6056
		     end
	       val rec 
		  err: (unit -> 'b) * word32 * (word32 * (unit -> 'b)) list
		       -> 'b = 
		     fn x_1403: (unit -> 'b)
				* word32
				* (word32 * (unit -> 'b)) list => 
		     let
			val handlers: (word32 * (unit -> 'b)) list = 
			   #2 x_1403
			val errno: word32 = 
			   #1 x_1403
			val default: unit -> 'b = 
			   #0 x_1403
			val x_6066: word32 * (unit -> 'b) -> bool = 
			   fn x_1404: word32 * (unit -> 'b) => 
			   let
			      val x_6067: word32 = 
				 #0 x_1404
			      val x_6068: word32 * word32 = 
				 (errno, x_6067)
			      val x_6069: bool = 
				 = (word32) x_6068
			   in
			      x_6069
			   end
			val x_6070: (word32 * (unit -> 'b)) list
				    -> (word32 * (unit -> 'b)) Primitive.Option.t = 
			   find_0 (word32 * (unit -> 'b)) x_6066
			val x_6071: (word32 * (unit -> 'b)) Primitive.Option.t = 
			   x_6070 handlers
			val x_6072: 'b = 
			   case x_6071 of
			   NONE[word32 * (unit -> 'b)] => 
			      let
				 val x_6077: unit = 
				    ()
				 val x_6078: 'b = 
				    default x_6077
			      in
				 x_6078
			      end
			   SOME[word32 * (unit -> 'b)] x_6073: word32
							       * (unit -> 'b) => 
			      let
				 val x_6074: unit -> 'b = 
				    #1 x_6073
				 val x_6075: unit = 
				    ()
				 val x_6076: 'b = 
				    x_6074 x_6075
			      in
				 x_6076
			      end
		     in
			x_6072
		     end
	       val rec 
		  errBlocked: word32 * (word32 * (unit -> 'b)) list -> 'b = 
		     fn x_1401: word32 * (word32 * (unit -> 'b)) list => 
		     let
			val handlers: (word32 * (unit -> 'b)) list = 
			   #1 x_1401
			val errno: word32 = 
			   #0 x_1401
			val x_6079: unit -> 'b = 
			   fn x_1402: unit => 
			   let
			      val x_6080: 'b = 
				 raiseSys ('b) errno
			   in
			      x_6080
			   end
			val x_6081: (unit -> 'b)
				    * word32
				    * (word32 * (unit -> 'b)) list = 
			   (x_6079, errno, handlers)
			val x_6082: 'b = 
			   err x_6081
		     in
			x_6082
		     end
	       val rec 
		  errUnblocked: word32 * (word32 * (unit -> 'b)) list -> 'b = 
		     fn x_1398: word32 * (word32 * (unit -> 'b)) list => 
		     let
			val handlers: (word32 * (unit -> 'b)) list = 
			   #1 x_1398
			val errno: word32 = 
			   #0 x_1398
			val x_6083: unit -> 'b = 
			   fn x_1399: unit => 
			   let
			      val x_6084: bool = 
				 case x_6040 of
				 true => 
				    let
				       val x_6086: word32 * word32 = 
					  (errno, intr)
				       val x_6087: bool = 
					  = (word32) x_6086
				    in
				       x_6087
				    end
				 false => 
				    let
				       val x_6085: bool = 
					  false
				    in
				       x_6085
				    end
			      val x_6088: bool = 
				 case x_6084 of
				 true => 
				    let
				       val x_6090: bool = 
					  !_1 (bool) restartFlag
				    in
				       x_6090
				    end
				 false => 
				    let
				       val x_6089: bool = 
					  false
				    in
				       x_6089
				    end
			      val x_6091: 'b = 
				 case x_6088 of
				 true => 
				    let
				       val x_6093: unit = 
					  ()
				       val x_6094: word32 = 
					  atomicState x_6093
				       val x_6095: word32 = 
					  0x0
				       val x_6096: word32 * word32 = 
					  (x_6094, x_6095)
				       val x_6097: bool = 
					  = (word32) x_6096
				       val x_6098: 'b = 
					  case x_6097 of
					  true => 
					     let
						val x_6105: 'b = 
						   call errUnblocked
					     in
						x_6105
					     end
					  false => 
					     let
						val x_6099: unit -> unit -> unit = 
						   !_1 (unit -> unit -> unit) blocker
						val x_6100: unit = 
						   ()
						val finish: unit -> unit = 
						   x_6099 x_6100
						val x_6101: unit -> 'b = 
						   fn x_1400: unit => 
						   let
						      val x_6102: 'b = 
							 call errBlocked
						   in
						      x_6102
						   end
						val x_6103: (unit -> 'b)
							    * (unit -> unit) = 
						   (x_6101, finish)
						val x_6104: 'b = 
						   wind_0 ('b) x_6103
					     in
						x_6104
					     end
				    in
				       x_6098
				    end
				 false => 
				    let
				       val x_6092: 'b = 
					  raiseSys ('b) errno
				    in
				       x_6092
				    end
			   in
			      x_6091
			   end
			val x_6106: (unit -> 'b)
				    * word32
				    * (word32 * (unit -> 'b)) list = 
			   (x_6083, errno, handlers)
			val x_6107: 'b = 
			   err x_6106
		     in
			x_6107
		     end
	       val x_6108: 'b = 
		  call errUnblocked
	    in
	       x_6108
	    end
      in
	 x_6037
      end
   val ''a_3456 simpleResultAux: (''a_3456 * bool) * (unit -> ''a_3456)
				 -> ''a_3456 = 
      let
	 val x_6109: (''a_3456 * bool) * (unit -> ''a_3456) -> ''a_3456 = 
	    fn x_1408: (''a_3456 * bool) * (unit -> ''a_3456) => 
	    let
	       val x_6110: unit -> ''a_3456 = 
		  #1 x_1408
	       val x_6111: ''a_3456 * bool = 
		  #0 x_1408
	       val x_6112: bool = 
		  #1 x_6111
	       val x_6113: ''a_3456 = 
		  #0 x_6111
	       val x_6114: bool = 
		  false
	       val x_6115: bool * ''a_3456 * bool = 
		  (x_6114, x_6113, x_6112)
	       val x_6116: unit
			   -> (word32 * (unit -> ''a_3456)) list
			      * (''a_3456 -> ''a_3456)
			      * ''a_3456 = 
		  fn x_1409: unit => 
		  let
		     val x_6117: unit = 
			()
		     val return: ''a_3456 = 
			x_6110 x_6117
		     val x_6118: ''a_3456 -> ''a_3456 = 
			fn x_1410: ''a_3456 => 
			let
			in
			   x_1410
			end
		     val x_6119: (word32 * (unit -> ''a_3456)) list = 
			nil[word32 * (unit -> ''a_3456)]
		     val x_6120: (word32 * (unit -> ''a_3456)) list
				 * (''a_3456 -> ''a_3456)
				 * ''a_3456 = 
			(x_6119, x_6118, return)
		  in
		     x_6120
		  end
	       val x_6121: (bool * ''a_3456 * bool)
			   * (unit
			      -> (word32 * (unit -> ''a_3456)) list
				 * (''a_3456 -> ''a_3456)
				 * ''a_3456) = 
		  (x_6115, x_6116)
	       val x_6122: ''a_3456 = 
		  syscallErr (''a_3456, ''a_3456) x_6121
	    in
	       x_6122
	    end
      in
	 x_6109
      end
   val simpleResultRestart: (unit -> word32) -> word32 = 
      fn x_1411: unit -> word32 => 
      let
	 val x_6123: bool = 
	    true
	 val x_6124: word32 = 
	    0xFFFFFFFF
	 val x_6125: word32 = 
	    sextdFromInt32ToInt32 x_6124
	 val x_6126: word32 * bool = 
	    (x_6125, x_6123)
	 val x_6127: (word32 * bool) * (unit -> word32) = 
	    (x_6126, x_1411)
	 val x_6128: word32 = 
	    simpleResultAux (word32) x_6127
      in
	 x_6128
      end
   val ''a_3457 simpleResultRestart': ''a_3457 * (unit -> ''a_3457) -> ''a_3457 = 
      let
	 val x_6129: ''a_3457 * (unit -> ''a_3457) -> ''a_3457 = 
	    fn x_1412: ''a_3457 * (unit -> ''a_3457) => 
	    let
	       val f: unit -> ''a_3457 = 
		  #1 x_1412
	       val errVal: ''a_3457 = 
		  #0 x_1412
	       val x_6130: bool = 
		  true
	       val x_6131: ''a_3457 * bool = 
		  (errVal, x_6130)
	       val x_6132: (''a_3457 * bool) * (unit -> ''a_3457) = 
		  (x_6131, f)
	       val x_6133: ''a_3457 = 
		  simpleResultAux (''a_3457) x_6132
	    in
	       x_6133
	    end
      in
	 x_6129
      end
   val ''a_3458 simpleResult': ''a_3458 * (unit -> ''a_3458) -> ''a_3458 = 
      let
	 val x_6134: ''a_3458 * (unit -> ''a_3458) -> ''a_3458 = 
	    fn x_1413: ''a_3458 * (unit -> ''a_3458) => 
	    let
	       val f: unit -> ''a_3458 = 
		  #1 x_1413
	       val errVal: ''a_3458 = 
		  #0 x_1413
	       val x_6135: bool = 
		  false
	       val x_6136: ''a_3458 * bool = 
		  (errVal, x_6135)
	       val x_6137: (''a_3458 * bool) * (unit -> ''a_3458) = 
		  (x_6136, f)
	       val x_6138: ''a_3458 = 
		  simpleResultAux (''a_3458) x_6137
	    in
	       x_6138
	    end
      in
	 x_6134
      end
   val x_6139: (word32 -> unit) * ((unit -> word32) -> word32) = 
      (ignore_1 (word32), simpleResultRestart)
   val simpleRestart: (unit -> word32) -> unit = 
      o_1 (unit -> word32, unit, word32) x_6139
   val ('a_3464, ''a_3463) syscall': ''a_3463
				     * (unit -> ''a_3463 * (''a_3463 -> 'a_3464))
				     -> 'a_3464 = 
      let
	 val x_6140: ''a_3463 * (unit -> ''a_3463 * (''a_3463 -> 'a_3464))
		     -> 'a_3464 = 
	    fn x_1414: ''a_3463 * (unit -> ''a_3463 * (''a_3463 -> 'a_3464)) => 
	    let
	       val f: unit -> ''a_3463 * (''a_3463 -> 'a_3464) = 
		  #1 x_1414
	       val errVal: ''a_3463 = 
		  #0 x_1414
	       val x_6141: bool = 
		  false
	       val x_6142: bool = 
		  false
	       val x_6143: bool * ''a_3463 * bool = 
		  (x_6141, errVal, x_6142)
	       val x_6144: unit
			   -> (word32 * (unit -> 'a_3464)) list
			      * (''a_3463 -> 'a_3464)
			      * ''a_3463 = 
		  fn x_1415: unit => 
		  let
		     val x_6145: unit = 
			()
		     val x_6146: ''a_3463 * (''a_3463 -> 'a_3464) = 
			f x_6145
		     val post: ''a_3463 -> 'a_3464 = 
			#1 x_6146
		     val return: ''a_3463 = 
			#0 x_6146
		     val x_6147: (word32 * (unit -> 'a_3464)) list = 
			nil[word32 * (unit -> 'a_3464)]
		     val x_6148: (word32 * (unit -> 'a_3464)) list
				 * (''a_3463 -> 'a_3464)
				 * ''a_3463 = 
			(x_6147, post, return)
		  in
		     x_6148
		  end
	       val x_6149: (bool * ''a_3463 * bool)
			   * (unit
			      -> (word32 * (unit -> 'a_3464)) list
				 * (''a_3463 -> 'a_3464)
				 * ''a_3463) = 
		  (x_6143, x_6144)
	       val x_6150: 'a_3464 = 
		  syscallErr ('a_3464, ''a_3463) x_6149
	    in
	       x_6150
	    end
      in
	 x_6140
      end
   val 'a_3466 syscall: (unit -> word32 * (word32 -> 'a_3466)) -> 'a_3466 = 
      let
	 val x_6151: (unit -> word32 * (word32 -> 'a_3466)) -> 'a_3466 = 
	    fn x_1416: unit -> word32 * (word32 -> 'a_3466) => 
	    let
	       val x_6152: word32 = 
		  0xFFFFFFFF
	       val x_6153: word32 = 
		  sextdFromInt32ToInt32 x_6152
	       val x_6154: word32 * (unit -> word32 * (word32 -> 'a_3466)) = 
		  (x_6153, x_1416)
	       val x_6155: 'a_3466 = 
		  syscall' ('a_3466, word32) x_6154
	    in
	       x_6155
	    end
      in
	 x_6151
      end
   val 'a raiseSysWithMsg_0: word32 * word8 vector -> 'a = 
      let
      in
	 raiseSysWithMsg ('a)
      end
   val 'a raiseSys_0: word32 -> 'a = 
      let
      in
	 raiseSys ('a)
      end
   val 'a syscall_0: (unit -> word32 * (word32 -> 'a)) -> 'a = 
      let
      in
	 syscall ('a)
      end
   val ''a simpleResultRestart'_0: ''a * (unit -> ''a) -> ''a = 
      let
      in
	 simpleResultRestart' (''a)
      end
   val ''a simpleResult'_0: ''a * (unit -> ''a) -> ''a = 
      let
      in
	 simpleResult' (''a)
      end
   exception Unordered
   val rec 
      fromInt: word32 -> IEEEReal.RoundingMode.t = 
	 fn x_1417: word32 => 
	 let
	    val x_6156: word32 * word32 = 
	       (x_1417, FE_TONEAREST)
	    val x_6157: bool = 
	       = (word32) x_6156
	    val x_6158: IEEEReal.RoundingMode.t = 
	       case x_6157 of
	       true => 
		  let
		     val x_6174: IEEEReal.RoundingMode.t = 
			TO_NEAREST
		  in
		     x_6174
		  end
	       false => 
		  let
		     val x_6159: word32 * word32 = 
			(x_1417, FE_DOWNWARD)
		     val x_6160: bool = 
			= (word32) x_6159
		     val x_6161: IEEEReal.RoundingMode.t = 
			case x_6160 of
			true => 
			   let
			      val x_6173: IEEEReal.RoundingMode.t = 
				 TO_NEGINF
			   in
			      x_6173
			   end
			false => 
			   let
			      val x_6162: word32 * word32 = 
				 (x_1417, FE_UPWARD)
			      val x_6163: bool = 
				 = (word32) x_6162
			      val x_6164: IEEEReal.RoundingMode.t = 
				 case x_6163 of
				 true => 
				    let
				       val x_6172: IEEEReal.RoundingMode.t = 
					  TO_POSINF
				    in
				       x_6172
				    end
				 false => 
				    let
				       val x_6165: word32 * word32 = 
					  (x_1417, FE_TOWARDZERO)
				       val x_6166: bool = 
					  = (word32) x_6165
				       val x_6167: IEEEReal.RoundingMode.t = 
					  case x_6166 of
					  true => 
					     let
						val x_6171: IEEEReal.RoundingMode.t = 
						   TO_ZERO
					     in
						x_6171
					     end
					  false => 
					     let
						val x_6168: word8 vector = 
						   "IEEEReal.RoundingMode.fromInt"
						val x_6169: exn = 
						   Fail x_6168
						val x_6170: IEEEReal.RoundingMode.t = 
						   raise x_6169
					     in
						x_6170
					     end
				    in
				       x_6167
				    end
			   in
			      x_6164
			   end
		  in
		     x_6161
		  end
	 in
	    x_6158
	 end
   val rec 
      setRoundingMode: IEEEReal.RoundingMode.t -> unit = 
	 fn x_1419: IEEEReal.RoundingMode.t => 
	 let
	    val x_6175: word32 = 
	       case x_1419 of
	       TO_NEAREST => 
		  let
		  in
		     FE_TONEAREST
		  end
	       TO_POSINF => 
		  let
		  in
		     FE_UPWARD
		  end
	       TO_ZERO => 
		  let
		  in
		     FE_TOWARDZERO
		  end
	       TO_NEGINF => 
		  let
		  in
		     FE_DOWNWARD
		  end
	    val x_6176: word32 * word32 = 
	       (x_6175, FE_NOSUPPORT)
	    val x_6177: bool = 
	       = (word32) x_6176
	    val x_6178: word32 = 
	       case x_6177 of
	       true => 
		  let
		     val x_6179: word8 vector = 
			"IEEEReal rounding mode not supported"
		     val x_6180: exn = 
			Fail x_6179
		     val x_6181: word32 = 
			raise x_6180
		  in
		     x_6181
		  end
	       false => 
		  let
		  in
		     x_6175
		  end
	    val x_6182: word32 = 
	       IEEEReal_setRoundingMode (x_6178)
	    val x_6183: word32 = 
	       0x0
	    val x_6184: word32 * word32 = 
	       (x_6182, x_6183)
	    val x_6185: bool = 
	       = (word32) x_6184
	    val x_6186: unit = 
	       case x_6185 of
	       true => 
		  let
		     val x_6189: unit = 
			()
		  in
		     x_6189
		  end
	       false => 
		  let
		     val x_6187: exn = 
			raiseSys_0 (exn) inval
		     val x_6188: unit = 
			raise x_6187
		  in
		     x_6188
		  end
	 in
	    x_6186
	 end
   val x_6190: (word32 -> IEEEReal.RoundingMode.t) * (unit -> word32) = 
      (fromInt, getRoundingMode)
   val getRoundingMode: unit -> IEEEReal.RoundingMode.t = 
      o_1 (unit, IEEEReal.RoundingMode.t, word32) x_6190
   val rec 'a 
      withRoundingMode: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a = 
	 fn x_1420: IEEEReal.RoundingMode.t * (unit -> 'a) => 
	 let
	    val th: unit -> 'a = 
	       #1 x_1420
	    val m: IEEEReal.RoundingMode.t = 
	       #0 x_1420
	    val x_6191: unit = 
	       ()
	    val m': IEEEReal.RoundingMode.t = 
	       getRoundingMode x_6191
	    val x_6192: unit = 
	       setRoundingMode m
	    val x_6193: unit = 
	       ()
	    val res: 'a = 
	       th x_6193
	    val x_6194: unit = 
	       setRoundingMode m'
	 in
	    res
	 end
   val 'a withRoundingMode_0: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a = 
      let
      in
	 withRoundingMode ('a)
      end
   val realSize: word32 = 
      sextdFromInt32ToInt32 realSize
   val exponentBias: word32 = 
      sextdFromInt32ToInt32 exponentBias
   val precision: word32 = 
      sextdFromInt32ToInt32 precision
   val x_6195: word32 = 
      sextdFromInt32ToWord32 realSize
   val x_6196: word32 * word32 = 
      (x_6195, one)
   val exponentSignificandBits: word32 = 
      - x_6196
   val x_6197: word32 = 
      sextdFromInt32ToWord32 precision
   val x_6198: word32 * word32 = 
      (x_6197, one)
   val significandBits: word32 = 
      - x_6198
   val x_6199: word32 * word32 = 
      (exponentSignificandBits, significandBits)
   val exponentBits: word32 = 
      - x_6199
   val mkMask: word32 -> word32 = 
      fn x_1424: word32 => 
      let
	 val x_6200: word32 = 
	    notb zero
	 val x_6201: word32 * word32 = 
	    (x_6200, x_1424)
	 val x_6202: word32 = 
	    << x_6201
	 val x_6203: word32 = 
	    notb x_6202
      in
	 x_6203
      end
   val x_6204: word32 = 
      mkMask one
   val x_6205: word32 * word32 = 
      (x_6204, exponentSignificandBits)
   val signMask: word32 = 
      << x_6205
   val x_6206: word32 = 
      mkMask exponentBits
   val x_6207: word32 * word32 = 
      (x_6206, significandBits)
   val exponentMask: word32 = 
      << x_6207
   val significandMask: word32 = 
      mkMask significandBits
   val class: real32 -> IEEEReal.float_class = 
      fn x_1425: real32 => 
      let
	 val w: word32 = 
	    castToWord x_1425
	 val x_6208: word32 * word32 = 
	    (w, exponentMask)
	 val x_6209: word32 = 
	    andb x_6208
	 val x_6210: word32 * word32 = 
	    (x_6209, exponentMask)
	 val x_6211: bool = 
	    = (word32) x_6210
	 val x_6212: IEEEReal.float_class = 
	    case x_6211 of
	    true => 
	       let
		  val x_6226: word32 * word32 = 
		     (w, significandMask)
		  val x_6227: word32 = 
		     andb x_6226
		  val x_6228: word32 * word32 = 
		     (x_6227, zero)
		  val x_6229: bool = 
		     = (word32) x_6228
		  val x_6230: IEEEReal.float_class = 
		     case x_6229 of
		     true => 
			let
			   val x_6232: IEEEReal.float_class = 
			      INF
			in
			   x_6232
			end
		     false => 
			let
			   val x_6231: IEEEReal.float_class = 
			      NAN
			in
			   x_6231
			end
	       in
		  x_6230
	       end
	    false => 
	       let
		  val x_6213: word32 * word32 = 
		     (w, exponentMask)
		  val x_6214: word32 = 
		     andb x_6213
		  val x_6215: word32 * word32 = 
		     (x_6214, zero)
		  val x_6216: bool = 
		     = (word32) x_6215
		  val x_6217: IEEEReal.float_class = 
		     case x_6216 of
		     true => 
			let
			   val x_6219: word32 * word32 = 
			      (w, significandMask)
			   val x_6220: word32 = 
			      andb x_6219
			   val x_6221: word32 * word32 = 
			      (x_6220, zero)
			   val x_6222: bool = 
			      = (word32) x_6221
			   val x_6223: IEEEReal.float_class = 
			      case x_6222 of
			      true => 
				 let
				    val x_6225: IEEEReal.float_class = 
				       ZERO
				 in
				    x_6225
				 end
			      false => 
				 let
				    val x_6224: IEEEReal.float_class = 
				       SUBNORMAL
				 in
				    x_6224
				 end
			in
			   x_6223
			end
		     false => 
			let
			   val x_6218: IEEEReal.float_class = 
			      NORMAL
			in
			   x_6218
			end
	       in
		  x_6217
	       end
      in
	 x_6212
      end
   val toBits: real32 -> word32 * bool * word32 = 
      fn x_1426: real32 => 
      let
	 val w: word32 = 
	    castToWord x_1426
	 val x_6233: word32 * word32 = 
	    (w, significandMask)
	 val significand: word32 = 
	    andb x_6233
	 val x_6234: word32 * word32 = 
	    (w, exponentMask)
	 val x_6235: word32 = 
	    andb x_6234
	 val x_6236: word32 * word32 = 
	    (x_6235, significandBits)
	 val exponent: word32 = 
	    >> x_6236
	 val x_6237: word32 * word32 = 
	    (w, signMask)
	 val x_6238: word32 = 
	    andb x_6237
	 val x_6239: word32 * word32 = 
	    (x_6238, signMask)
	 val sign: bool = 
	    = (word32) x_6239
	 val x_6240: word32 * bool * word32 = 
	    (exponent, sign, significand)
      in
	 x_6240
      end
   val rec 'a 
      make: ('a -> real32) * word32 * (real32 -> 'a)
	    -> (IEEEReal.RoundingMode.t -> 'a -> real32) * (real32 -> 'a) = 
	 fn x_1427: ('a -> real32) * word32 * (real32 -> 'a) => 
	 let
	    val toRealUnsafe: real32 -> 'a = 
	       #2 x_1427
	    val other: word32 = 
	       #1 x_1427
	    val fromRealUnsafe: 'a -> real32 = 
	       #0 x_1427
	    val x_6241: word32 * word32 = 
	       (precision, other)
	    val x_6242: bool = 
	       = (word32) x_6241
	    val x_6243: (IEEEReal.RoundingMode.t -> 'a -> real32)
			* (real32 -> 'a) = 
	       case x_6242 of
	       true => 
		  let
		     val x_6251: IEEEReal.RoundingMode.t -> 'a -> real32 = 
			fn x_1428: IEEEReal.RoundingMode.t => 
			let
			in
			   fromRealUnsafe
			end
		     val x_6252: (IEEEReal.RoundingMode.t -> 'a -> real32)
				 * (real32 -> 'a) = 
			(x_6251, toRealUnsafe)
		  in
		     x_6252
		  end
	       false => 
		  let
		     val x_6244: IEEEReal.RoundingMode.t -> 'a -> real32 = 
			fn x_1429: IEEEReal.RoundingMode.t => 
			let
			   val x_6245: 'a -> real32 = 
			      fn x_1430: 'a => 
			      let
				 val x_6246: unit -> real32 = 
				    fn x_1431: unit => 
				    let
				       val x_6247: real32 = 
					  fromRealUnsafe x_1430
				    in
				       x_6247
				    end
				 val x_6248: IEEEReal.RoundingMode.t
					     * (unit -> real32) = 
				    (x_1429, x_6246)
				 val x_6249: real32 = 
				    withRoundingMode_0 (real32) x_6248
			      in
				 x_6249
			      end
			in
			   x_6245
			end
		     val x_6250: (IEEEReal.RoundingMode.t -> 'a -> real32)
				 * (real32 -> 'a) = 
			(x_6244, toRealUnsafe)
		  in
		     x_6250
		  end
	 in
	    x_6243
	 end
   val x_6253: (real32 -> real32) * word32 * (real32 -> real32) = 
      (fromReal32Unsafe, precision, toReal32Unsafe)
   val x_6254: (IEEEReal.RoundingMode.t -> real32 -> real32)
	       * (real32 -> real32) = 
      make (real32) x_6253
   val zero: real32 = 
      castFromWord zero
   val x_6255: word32 = 
      sextdFromInt32ToWord32 exponentBias
   val x_6256: word32 * word32 = 
      (x_6255, one)
   val x_6257: word32 = 
      - x_6256
   val x_6258: word32 * word32 = 
      (x_6257, significandBits)
   val x_6259: word32 = 
      << x_6258
   val half: real32 = 
      castFromWord x_6259
   val x_6260: word32 = 
      sextdFromInt32ToWord32 exponentBias
   val x_6261: word32 * word32 = 
      (x_6260, significandBits)
   val x_6262: word32 = 
      << x_6261
   val one: real32 = 
      castFromWord x_6262
   val x_6263: word32 * bool * word32 -> bool = 
      fn x_1433: word32 * bool * word32 => 
      let
	 val x_6264: bool = 
	    #1 x_1433
      in
	 x_6264
      end
   val x_6265: (word32 * bool * word32 -> bool)
	       * (real32 -> word32 * bool * word32) = 
      (x_6263, toBits)
   val signBit: real32 -> bool = 
      o_1 (real32, bool, word32 * bool * word32) x_6265
   exception Bad
   val x_6266: unit -> word32 ref = 
      fn x_1437: unit => 
      let
	 val x_6267: word32 = 
	    0x0
	 val x_6268: word32 ref = 
	    Ref_ref[word32] (x_6267)
      in
	 x_6268
      end
   val one: word32 ref One.t = 
      make_0 (word32 ref) x_6266
   val rec 'a_3490 
      safeConvert: IEEEReal.RoundingMode.t * (real32 -> 'a_3490) * real32
		   -> 'a_3490 = 
	 fn x_1461: IEEEReal.RoundingMode.t * (real32 -> 'a_3490) * real32 => 
	 let
	    val x: real32 = 
	       #2 x_1461
	    val cvt: real32 -> 'a_3490 = 
	       #1 x_1461
	    val m: IEEEReal.RoundingMode.t = 
	       #0 x_1461
	    val x_6269: 'a_3490 = 
	       case m of
	       TO_POSINF => 
		  let
		     val x_6280: real32 = 
			Real32_realCeil (x)
		     val x_6281: 'a_3490 = 
			cvt x_6280
		  in
		     x_6281
		  end
	       TO_NEAREST => 
		  let
		     val x_6274: IEEEReal.RoundingMode.t = 
			TO_NEAREST
		     val x_6275: unit -> real32 = 
			fn x_1435: unit => 
			let
			   val x_6276: real32 = 
			      round x
			in
			   x_6276
			end
		     val x_6277: IEEEReal.RoundingMode.t * (unit -> real32) = 
			(x_6274, x_6275)
		     val x_6278: real32 = 
			withRoundingMode_0 (real32) x_6277
		     val x_6279: 'a_3490 = 
			cvt x_6278
		  in
		     x_6279
		  end
	       TO_ZERO => 
		  let
		     val x_6272: real32 = 
			Real32_realTrunc (x)
		     val x_6273: 'a_3490 = 
			cvt x_6272
		  in
		     x_6273
		  end
	       TO_NEGINF => 
		  let
		     val x_6270: real32 = 
			Real32_realFloor (x)
		     val x_6271: 'a_3490 = 
			cvt x_6270
		  in
		     x_6271
		  end
	 in
	    x_6269
	 end
   val rec 'a 
      make: ('a -> real32) * ((word32 -> 'a) * 'a * word32) * (real32 -> 'a)
	    -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
	 fn x_1462: ('a -> real32)
		    * ((word32 -> 'a) * 'a * word32)
		    * (real32 -> 'a) => 
	 let
	    val toIntUnsafe: real32 -> 'a = 
	       #2 x_1462
	    val other: (word32 -> 'a) * 'a * word32 = 
	       #1 x_1462
	    val fromIntUnsafe: 'a -> real32 = 
	       #0 x_1462
	    val x_6282: word32 = 
	       #2 other
	    val x_6283: word32 * word32 = 
	       (precision, x_6282)
	    val x_6284: bool = 
	       < x_6283
	    val x_6285: IEEEReal.RoundingMode.t -> real32 -> 'a = 
	       case x_6284 of
	       true => 
		  let
		     val x_6339: word32 = 
			#2 other
		     val x_6340: word32 * word32 = 
			(x_6339, precision)
		     val x_6341: word32 = 
			-! x_6340
		     val x_6342: word32 = 
			0x1
		     val x_6343: word32 * word32 = 
			(x_6341, x_6342)
		     val trim: word32 = 
			-! x_6343
		     val x_6344: word32 -> 'a = 
			#0 other
		     val x_6345: word32 = 
			sextdFromInt32ToWord32 trim
		     val maxInt': 'a = 
			x_6344 x_6345
		     val x_6346: 'a = 
			#1 other
		     val maxInt: real32 = 
			fromIntUnsafe maxInt'
		     val minInt: real32 = 
			fromIntUnsafe x_6346
		     val x_6347: IEEEReal.RoundingMode.t -> real32 -> 'a = 
			fn x_1466: IEEEReal.RoundingMode.t => 
			let
			   val x_6348: real32 -> 'a = 
			      fn x_1467: real32 => 
			      let
				 val x_6349: real32 * real32 = 
				    (minInt, x_1467)
				 val x_6350: bool = 
				    <= x_6349
				 val x_6351: 'a = 
				    case x_6350 of
				    true => 
				       let
					  val x_6359: real32 * real32 = 
					     (x_1467, maxInt)
					  val x_6360: bool = 
					     <= x_6359
					  val x_6361: 'a = 
					     case x_6360 of
					     true => 
						let
						   val x_6364: IEEEReal.RoundingMode.t
							       * (real32 -> 'a)
							       * real32 = 
						      (x_1466,
						       toIntUnsafe,
						       x_1467)
						   val x_6365: 'a = 
						      safeConvert ('a) x_6364
						in
						   x_6365
						end
					     false => 
						let
						   val x_6362: exn = 
						      Overflow
						   val x_6363: 'a = 
						      raise x_6362
						in
						   x_6363
						end
				       in
					  x_6361
				       end
				    false => 
				       let
					  val x_6352: real32 * real32 = 
					     (x_1467, minInt)
					  val x_6353: bool = 
					     < x_6352
					  val x_6354: 'a = 
					     case x_6353 of
					     true => 
						let
						   val x_6357: exn = 
						      Overflow
						   val x_6358: 'a = 
						      raise x_6357
						in
						   x_6358
						end
					     false => 
						let
						   val x_6355: exn = 
						      Domain
						   val x_6356: 'a = 
						      raise x_6355
						in
						   x_6356
						end
				       in
					  x_6354
				       end
			      in
				 x_6351
			      end
			in
			   x_6348
			end
		  in
		     x_6347
		  end
	       false => 
		  let
		     val x_6286: word32 -> 'a = 
			#0 other
		     val x_6287: word32 = 
			0x0
		     val maxInt': 'a = 
			x_6286 x_6287
		     val x_6288: 'a = 
			#1 other
		     val maxInt: real32 = 
			fromIntUnsafe maxInt'
		     val minInt: real32 = 
			fromIntUnsafe x_6288
		     val x_6289: IEEEReal.RoundingMode.t -> real32 -> 'a = 
			fn x_1470: IEEEReal.RoundingMode.t => 
			let
			   val x_6290: real32 -> 'a = 
			      fn x_1471: real32 => 
			      let
				 val x_6291: real32 * real32 = 
				    (minInt, x_1471)
				 val x_6292: bool = 
				    <= x_6291
				 val x_6293: 'a = 
				    case x_6292 of
				    true => 
				       let
					  val x_6317: real32 * real32 = 
					     (x_1471, maxInt)
					  val x_6318: bool = 
					     <= x_6317
					  val x_6319: 'a = 
					     case x_6318 of
					     true => 
						let
						   val x_6337: IEEEReal.RoundingMode.t
							       * (real32 -> 'a)
							       * real32 = 
						      (x_1470,
						       toIntUnsafe,
						       x_1471)
						   val x_6338: 'a = 
						      safeConvert ('a) x_6337
						in
						   x_6338
						end
					     false => 
						let
						   val x_6320: real32 * real32 = 
						      (maxInt, one)
						   val x_6321: real32 = 
						      + x_6320
						   val x_6322: real32 * real32 = 
						      (x_1471, x_6321)
						   val x_6323: bool = 
						      < x_6322
						   val x_6324: 'a = 
						      case x_6323 of
						      true => 
							 let
							    val x_6327: 'a = 
							       case x_1470 of
							       TO_NEGINF => 
								  let
								  in
								     maxInt'
								  end
							       TO_ZERO => 
								  let
								  in
								     maxInt'
								  end
							       TO_NEAREST => 
								  let
								     val x_6330: real32
										 * real32 = 
									(x_1471,
									 maxInt)
								     val x_6331: real32 = 
									- x_6330
								     val x_6332: real32
										 * real32 = 
									(x_6331,
									 half)
								     val x_6333: bool = 
									>= x_6332
								     val x_6334: 'a = 
									case x_6333 of
									true => 
									   let
									      val x_6335: exn = 
										 Overflow
									      val x_6336: 'a = 
										 raise x_6335
									   in
									      x_6336
									   end
									false => 
									   let
									   in
									      maxInt'
									   end
								  in
								     x_6334
								  end
							       TO_POSINF => 
								  let
								     val x_6328: exn = 
									Overflow
								     val x_6329: 'a = 
									raise x_6328
								  in
								     x_6329
								  end
							 in
							    x_6327
							 end
						      false => 
							 let
							    val x_6325: exn = 
							       Overflow
							    val x_6326: 'a = 
							       raise x_6325
							 in
							    x_6326
							 end
						in
						   x_6324
						end
				       in
					  x_6319
				       end
				    false => 
				       let
					  val x_6294: real32 * real32 = 
					     (x_1471, minInt)
					  val x_6295: bool = 
					     < x_6294
					  val x_6296: 'a = 
					     case x_6295 of
					     true => 
						let
						   val x_6299: real32 * real32 = 
						      (minInt, one)
						   val x_6300: real32 = 
						      - x_6299
						   val x_6301: real32 * real32 = 
						      (x_6300, x_1471)
						   val x_6302: bool = 
						      < x_6301
						   val x_6303: 'a = 
						      case x_6302 of
						      true => 
							 let
							    val x_6306: 'a = 
							       case x_1470 of
							       TO_NEGINF => 
								  let
								     val x_6315: exn = 
									Overflow
								     val x_6316: 'a = 
									raise x_6315
								  in
								     x_6316
								  end
							       TO_ZERO => 
								  let
								  in
								     x_6288
								  end
							       TO_NEAREST => 
								  let
								     val x_6307: real32
										 * real32 = 
									(x_1471,
									 minInt)
								     val x_6308: real32 = 
									- x_6307
								     val x_6309: real32 = 
									~ half
								     val x_6310: real32
										 * real32 = 
									(x_6308,
									 x_6309)
								     val x_6311: bool = 
									< x_6310
								     val x_6312: 'a = 
									case x_6311 of
									true => 
									   let
									      val x_6313: exn = 
										 Overflow
									      val x_6314: 'a = 
										 raise x_6313
									   in
									      x_6314
									   end
									false => 
									   let
									   in
									      x_6288
									   end
								  in
								     x_6312
								  end
							       TO_POSINF => 
								  let
								  in
								     x_6288
								  end
							 in
							    x_6306
							 end
						      false => 
							 let
							    val x_6304: exn = 
							       Overflow
							    val x_6305: 'a = 
							       raise x_6304
							 in
							    x_6305
							 end
						in
						   x_6303
						end
					     false => 
						let
						   val x_6297: exn = 
						      Domain
						   val x_6298: 'a = 
						      raise x_6297
						in
						   x_6298
						end
				       in
					  x_6296
				       end
			      in
				 x_6293
			      end
			in
			   x_6290
			end
		  in
		     x_6289
		  end
	    val x_6366: ('a -> real32)
			* (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
	       (fromIntUnsafe, x_6285)
	 in
	    x_6366
	 end
   val x_6367: word32 -> word8 = 
      fn x_1473: word32 => 
      let
	 val x_6368: word8 * word32 = 
	    (maxInt', x_1473)
	 val x_6369: word8 = 
	    >> x_6368
	 val x_6370: word8 * word32 = 
	    (x_6369, x_1473)
	 val x_6371: word8 = 
	    << x_6370
      in
	 x_6371
      end
   val x_6372: (word32 -> word8) * word8 * word32 = 
      (x_6367, minInt', precision')
   val x_6373: (word8 -> real32)
	       * ((word32 -> word8) * word8 * word32)
	       * (real32 -> word8) = 
      (fromInt8Unsafe, x_6372, toInt8Unsafe)
   val x_6374: (word8 -> real32) * (IEEEReal.RoundingMode.t -> real32 -> word8) = 
      make (word8) x_6373
   val x_6375: word32 -> word16 = 
      fn x_1474: word32 => 
      let
	 val x_6376: word16 * word32 = 
	    (maxInt', x_1474)
	 val x_6377: word16 = 
	    >> x_6376
	 val x_6378: word16 * word32 = 
	    (x_6377, x_1474)
	 val x_6379: word16 = 
	    << x_6378
      in
	 x_6379
      end
   val x_6380: (word32 -> word16) * word16 * word32 = 
      (x_6375, minInt', precision')
   val x_6381: (word16 -> real32)
	       * ((word32 -> word16) * word16 * word32)
	       * (real32 -> word16) = 
      (fromInt16Unsafe, x_6380, toInt16Unsafe)
   val x_6382: (word16 -> real32)
	       * (IEEEReal.RoundingMode.t -> real32 -> word16) = 
      make (word16) x_6381
   val x_6383: word32 -> word32 = 
      fn x_1475: word32 => 
      let
	 val x_6384: word32 * word32 = 
	    (maxInt', x_1475)
	 val x_6385: word32 = 
	    >> x_6384
	 val x_6386: word32 * word32 = 
	    (x_6385, x_1475)
	 val x_6387: word32 = 
	    << x_6386
      in
	 x_6387
      end
   val x_6388: (word32 -> word32) * word32 * word32 = 
      (x_6383, minInt', precision')
   val x_6389: (word32 -> real32)
	       * ((word32 -> word32) * word32 * word32)
	       * (real32 -> word32) = 
      (fromInt32Unsafe, x_6388, toInt32Unsafe)
   val x_6390: (word32 -> real32)
	       * (IEEEReal.RoundingMode.t -> real32 -> word32) = 
      make (word32) x_6389
   val x_6391: word32 -> word64 = 
      fn x_1476: word32 => 
      let
	 val x_6392: word64 * word32 = 
	    (maxInt', x_1476)
	 val x_6393: word64 = 
	    >> x_6392
	 val x_6394: word64 * word32 = 
	    (x_6393, x_1476)
	 val x_6395: word64 = 
	    << x_6394
      in
	 x_6395
      end
   val x_6396: (word32 -> word64) * word64 * word32 = 
      (x_6391, minInt', precision')
   val x_6397: (word64 -> real32)
	       * ((word32 -> word64) * word64 * word32)
	       * (real32 -> word64) = 
      (fromInt64Unsafe, x_6396, toInt64Unsafe)
   val x_6398: (word64 -> real32)
	       * (IEEEReal.RoundingMode.t -> real32 -> word64) = 
      make (word64) x_6397
   val rec 'a 
      make: ('a -> real32) * ((word32 -> 'a) * word32 * 'a) * (real32 -> 'a)
	    -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
	 fn x_1480: ('a -> real32)
		    * ((word32 -> 'a) * word32 * 'a)
		    * (real32 -> 'a) => 
	 let
	    val toWordUnsafe: real32 -> 'a = 
	       #2 x_1480
	    val other: (word32 -> 'a) * word32 * 'a = 
	       #1 x_1480
	    val fromWordUnsafe: 'a -> real32 = 
	       #0 x_1480
	    val x_6399: word32 = 
	       #1 other
	    val x_6400: word32 * word32 = 
	       (precision, x_6399)
	    val x_6401: bool = 
	       <= x_6400
	    val x_6402: IEEEReal.RoundingMode.t -> real32 -> 'a = 
	       case x_6401 of
	       true => 
		  let
		     val x_6454: word32 = 
			#1 other
		     val x_6455: word32 * word32 = 
			(x_6454, precision)
		     val trim: word32 = 
			-! x_6455
		     val x_6456: word32 -> 'a = 
			#0 other
		     val x_6457: word32 = 
			sextdFromInt32ToWord32 trim
		     val maxWord': 'a = 
			x_6456 x_6457
		     val maxWord: real32 = 
			fromWordUnsafe maxWord'
		     val x_6458: 'a = 
			#2 other
		     val x_6459: IEEEReal.RoundingMode.t -> real32 -> 'a = 
			fn x_1484: IEEEReal.RoundingMode.t => 
			let
			   val x_6460: real32 -> 'a = 
			      fn x_1485: real32 => 
			      let
				 val x_6461: IEEEReal.float_class = 
				    class x_1485
				 val x_6462: 'a = 
				    case x_6461 of
				    INF => 
				       let
					  val x_6465: exn = 
					     Overflow
					  val x_6466: 'a = 
					     raise x_6465
				       in
					  x_6466
				       end
				    NAN => 
				       let
					  val x_6463: exn = 
					     Domain
					  val x_6464: 'a = 
					     raise x_6463
				       in
					  x_6464
				       end
				      _ => let
					      val x_6467: real32 * real32 = 
						 (zero, x_1485)
					      val x_6468: bool = 
						 <= x_6467
					      val x_6469: 'a = 
						 case x_6468 of
						 true => 
						    let
						       val x_6485: real32
								   * real32 = 
							  (x_1485, maxWord)
						       val x_6486: bool = 
							  <= x_6485
						       val x_6487: 'a = 
							  case x_6486 of
							  true => 
							     let
								val x_6490: IEEEReal.RoundingMode.t
									    * (real32
									       -> 'a)
									    * real32 = 
								   (x_1484,
								    toWordUnsafe,
								    x_1485)
								val x_6491: 'a = 
								   safeConvert ('a) x_6490
							     in
								x_6491
							     end
							  false => 
							     let
								val x_6488: exn = 
								   Overflow
								val x_6489: 'a = 
								   raise x_6488
							     in
								x_6489
							     end
						    in
						       x_6487
						    end
						 false => 
						    let
						       val x_6470: real32 = 
							  ~ one
						       val x_6471: real32
								   * real32 = 
							  (x_1485, x_6470)
						       val x_6472: bool = 
							  > x_6471
						       val x_6473: 'a = 
							  case x_6472 of
							  true => 
							     let
								val x_6476: 'a = 
								   case x_1484 of
								   TO_NEGINF => 
								      let
									 val x_6483: exn = 
									    Overflow
									 val x_6484: 'a = 
									    raise x_6483
								      in
									 x_6484
								      end
								   TO_ZERO => 
								      let
								      in
									 x_6458
								      end
								   TO_NEAREST => 
								      let
									 val x_6477: real32 = 
									    ~ half
									 val x_6478: real32
										     * real32 = 
									    (x_1485,
									     x_6477)
									 val x_6479: bool = 
									    < x_6478
									 val x_6480: 'a = 
									    case x_6479 of
									    true => 
									       let
										  val x_6481: exn = 
										     Overflow
										  val x_6482: 'a = 
										     raise x_6481
									       in
										  x_6482
									       end
									    false => 
									       let
									       in
										  x_6458
									       end
								      in
									 x_6480
								      end
								   TO_POSINF => 
								      let
								      in
									 x_6458
								      end
							     in
								x_6476
							     end
							  false => 
							     let
								val x_6474: exn = 
								   Overflow
								val x_6475: 'a = 
								   raise x_6474
							     in
								x_6475
							     end
						    in
						       x_6473
						    end
					   in
					      x_6469
					   end
			      in
				 x_6462
			      end
			in
			   x_6460
			end
		  in
		     x_6459
		  end
	       false => 
		  let
		     val x_6403: word32 -> 'a = 
			#0 other
		     val x_6404: word32 = 
			0x0
		     val maxWord': 'a = 
			x_6403 x_6404
		     val maxWord: real32 = 
			fromWordUnsafe maxWord'
		     val x_6405: 'a = 
			#2 other
		     val x_6406: IEEEReal.RoundingMode.t -> real32 -> 'a = 
			fn x_1488: IEEEReal.RoundingMode.t => 
			let
			   val x_6407: real32 -> 'a = 
			      fn x_1489: real32 => 
			      let
				 val x_6408: IEEEReal.float_class = 
				    class x_1489
				 val x_6409: 'a = 
				    case x_6408 of
				    INF => 
				       let
					  val x_6412: exn = 
					     Overflow
					  val x_6413: 'a = 
					     raise x_6412
				       in
					  x_6413
				       end
				    NAN => 
				       let
					  val x_6410: exn = 
					     Domain
					  val x_6411: 'a = 
					     raise x_6410
				       in
					  x_6411
				       end
				      _ => let
					      val x_6414: real32 * real32 = 
						 (zero, x_1489)
					      val x_6415: bool = 
						 <= x_6414
					      val x_6416: 'a = 
						 case x_6415 of
						 true => 
						    let
						       val x_6432: real32
								   * real32 = 
							  (x_1489, maxWord)
						       val x_6433: bool = 
							  <= x_6432
						       val x_6434: 'a = 
							  case x_6433 of
							  true => 
							     let
								val x_6452: IEEEReal.RoundingMode.t
									    * (real32
									       -> 'a)
									    * real32 = 
								   (x_1488,
								    toWordUnsafe,
								    x_1489)
								val x_6453: 'a = 
								   safeConvert ('a) x_6452
							     in
								x_6453
							     end
							  false => 
							     let
								val x_6435: real32
									    * real32 = 
								   (maxWord, one)
								val x_6436: real32 = 
								   + x_6435
								val x_6437: real32
									    * real32 = 
								   (x_1489,
								    x_6436)
								val x_6438: bool = 
								   < x_6437
								val x_6439: 'a = 
								   case x_6438 of
								   true => 
								      let
									 val x_6442: 'a = 
									    case x_1488 of
									    TO_NEGINF => 
									       let
									       in
										  maxWord'
									       end
									    TO_ZERO => 
									       let
									       in
										  maxWord'
									       end
									    TO_NEAREST => 
									       let
										  val x_6445: real32
											      * real32 = 
										     (x_1489,
										      maxWord)
										  val x_6446: real32 = 
										     - x_6445
										  val x_6447: real32
											      * real32 = 
										     (x_6446,
										      half)
										  val x_6448: bool = 
										     >= x_6447
										  val x_6449: 'a = 
										     case x_6448 of
										     true => 
											let
											   val x_6450: exn = 
											      Overflow
											   val x_6451: 'a = 
											      raise x_6450
											in
											   x_6451
											end
										     false => 
											let
											in
											   maxWord'
											end
									       in
										  x_6449
									       end
									    TO_POSINF => 
									       let
										  val x_6443: exn = 
										     Overflow
										  val x_6444: 'a = 
										     raise x_6443
									       in
										  x_6444
									       end
								      in
									 x_6442
								      end
								   false => 
								      let
									 val x_6440: exn = 
									    Overflow
									 val x_6441: 'a = 
									    raise x_6440
								      in
									 x_6441
								      end
							     in
								x_6439
							     end
						    in
						       x_6434
						    end
						 false => 
						    let
						       val x_6417: real32 = 
							  ~ one
						       val x_6418: real32
								   * real32 = 
							  (x_1489, x_6417)
						       val x_6419: bool = 
							  > x_6418
						       val x_6420: 'a = 
							  case x_6419 of
							  true => 
							     let
								val x_6423: 'a = 
								   case x_1488 of
								   TO_NEGINF => 
								      let
									 val x_6430: exn = 
									    Overflow
									 val x_6431: 'a = 
									    raise x_6430
								      in
									 x_6431
								      end
								   TO_ZERO => 
								      let
								      in
									 x_6405
								      end
								   TO_NEAREST => 
								      let
									 val x_6424: real32 = 
									    ~ half
									 val x_6425: real32
										     * real32 = 
									    (x_1489,
									     x_6424)
									 val x_6426: bool = 
									    < x_6425
									 val x_6427: 'a = 
									    case x_6426 of
									    true => 
									       let
										  val x_6428: exn = 
										     Overflow
										  val x_6429: 'a = 
										     raise x_6428
									       in
										  x_6429
									       end
									    false => 
									       let
									       in
										  x_6405
									       end
								      in
									 x_6427
								      end
								   TO_POSINF => 
								      let
								      in
									 x_6405
								      end
							     in
								x_6423
							     end
							  false => 
							     let
								val x_6421: exn = 
								   Overflow
								val x_6422: 'a = 
								   raise x_6421
							     in
								x_6422
							     end
						    in
						       x_6420
						    end
					   in
					      x_6416
					   end
			      in
				 x_6409
			      end
			in
			   x_6407
			end
		  in
		     x_6406
		  end
	    val x_6492: ('a -> real32)
			* (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
	       (fromWordUnsafe, x_6402)
	 in
	    x_6492
	 end
   val x_6493: word32 -> word8 = 
      fn x_1491: word32 => 
      let
	 val x_6494: word8 * word32 = 
	    (maxWord', x_1491)
	 val x_6495: word8 = 
	    >> x_6494
	 val x_6496: word8 * word32 = 
	    (x_6495, x_1491)
	 val x_6497: word8 = 
	    << x_6496
      in
	 x_6497
      end
   val x_6498: (word32 -> word8) * word32 * word8 = 
      (x_6493, wordSize, zero)
   val x_6499: (word8 -> real32)
	       * ((word32 -> word8) * word32 * word8)
	       * (real32 -> word8) = 
      (fromWord8Unsafe, x_6498, toWord8Unsafe)
   val x_6500: (word8 -> real32) * (IEEEReal.RoundingMode.t -> real32 -> word8) = 
      make (word8) x_6499
   val x_6501: word32 -> word16 = 
      fn x_1492: word32 => 
      let
	 val x_6502: word16 * word32 = 
	    (maxWord', x_1492)
	 val x_6503: word16 = 
	    >> x_6502
	 val x_6504: word16 * word32 = 
	    (x_6503, x_1492)
	 val x_6505: word16 = 
	    << x_6504
      in
	 x_6505
      end
   val x_6506: (word32 -> word16) * word32 * word16 = 
      (x_6501, wordSize, zero)
   val x_6507: (word16 -> real32)
	       * ((word32 -> word16) * word32 * word16)
	       * (real32 -> word16) = 
      (fromWord16Unsafe, x_6506, toWord16Unsafe)
   val x_6508: (word16 -> real32)
	       * (IEEEReal.RoundingMode.t -> real32 -> word16) = 
      make (word16) x_6507
   val x_6509: word32 -> word32 = 
      fn x_1493: word32 => 
      let
	 val x_6510: word32 * word32 = 
	    (maxWord', x_1493)
	 val x_6511: word32 = 
	    >> x_6510
	 val x_6512: word32 * word32 = 
	    (x_6511, x_1493)
	 val x_6513: word32 = 
	    << x_6512
      in
	 x_6513
      end
   val x_6514: (word32 -> word32) * word32 * word32 = 
      (x_6509, wordSize, zero)
   val x_6515: (word32 -> real32)
	       * ((word32 -> word32) * word32 * word32)
	       * (real32 -> word32) = 
      (fromWord32Unsafe, x_6514, toWord32Unsafe)
   val x_6516: (word32 -> real32)
	       * (IEEEReal.RoundingMode.t -> real32 -> word32) = 
      make (word32) x_6515
   val x_6517: word32 -> word64 = 
      fn x_1494: word32 => 
      let
	 val x_6518: word64 * word32 = 
	    (maxWord', x_1494)
	 val x_6519: word64 = 
	    >> x_6518
	 val x_6520: word64 * word32 = 
	    (x_6519, x_1494)
	 val x_6521: word64 = 
	    << x_6520
      in
	 x_6521
      end
   val x_6522: (word32 -> word64) * word32 * word64 = 
      (x_6517, wordSize, zero)
   val x_6523: (word64 -> real32)
	       * ((word32 -> word64) * word32 * word64)
	       * (real32 -> word64) = 
      (fromWord64Unsafe, x_6522, toWord64Unsafe)
   val x_6524: (word64 -> real32)
	       * (IEEEReal.RoundingMode.t -> real32 -> word64) = 
      make (word64) x_6523
   val realSize: word32 = 
      sextdFromInt32ToInt32 realSize
   val exponentBias: word32 = 
      sextdFromInt32ToInt32 exponentBias
   val precision: word32 = 
      sextdFromInt32ToInt32 precision
   val x_6525: word32 = 
      sextdFromInt32ToWord32 realSize
   val x_6526: word32 * word32 = 
      (x_6525, one)
   val exponentSignificandBits: word32 = 
      - x_6526
   val x_6527: word32 = 
      sextdFromInt32ToWord32 precision
   val x_6528: word32 * word32 = 
      (x_6527, one)
   val significandBits: word32 = 
      - x_6528
   val x_6529: word32 * word32 = 
      (exponentSignificandBits, significandBits)
   val exponentBits: word32 = 
      - x_6529
   val mkMask: word32 -> word64 = 
      fn x_1495: word32 => 
      let
	 val x_6530: word64 = 
	    notb zero
	 val x_6531: word64 * word32 = 
	    (x_6530, x_1495)
	 val x_6532: word64 = 
	    << x_6531
	 val x_6533: word64 = 
	    notb x_6532
      in
	 x_6533
      end
   val x_6534: word64 = 
      mkMask one
   val x_6535: word64 * word32 = 
      (x_6534, exponentSignificandBits)
   val signMask: word64 = 
      << x_6535
   val x_6536: word64 = 
      mkMask exponentBits
   val x_6537: word64 * word32 = 
      (x_6536, significandBits)
   val exponentMask: word64 = 
      << x_6537
   val significandMask: word64 = 
      mkMask significandBits
   val class: real64 -> IEEEReal.float_class = 
      fn x_1496: real64 => 
      let
	 val w: word64 = 
	    castToWord x_1496
	 val x_6538: word64 * word64 = 
	    (w, exponentMask)
	 val x_6539: word64 = 
	    andb x_6538
	 val x_6540: word64 * word64 = 
	    (x_6539, exponentMask)
	 val x_6541: bool = 
	    = (word64) x_6540
	 val x_6542: IEEEReal.float_class = 
	    case x_6541 of
	    true => 
	       let
		  val x_6556: word64 * word64 = 
		     (w, significandMask)
		  val x_6557: word64 = 
		     andb x_6556
		  val x_6558: word64 * word64 = 
		     (x_6557, zero)
		  val x_6559: bool = 
		     = (word64) x_6558
		  val x_6560: IEEEReal.float_class = 
		     case x_6559 of
		     true => 
			let
			   val x_6562: IEEEReal.float_class = 
			      INF
			in
			   x_6562
			end
		     false => 
			let
			   val x_6561: IEEEReal.float_class = 
			      NAN
			in
			   x_6561
			end
	       in
		  x_6560
	       end
	    false => 
	       let
		  val x_6543: word64 * word64 = 
		     (w, exponentMask)
		  val x_6544: word64 = 
		     andb x_6543
		  val x_6545: word64 * word64 = 
		     (x_6544, zero)
		  val x_6546: bool = 
		     = (word64) x_6545
		  val x_6547: IEEEReal.float_class = 
		     case x_6546 of
		     true => 
			let
			   val x_6549: word64 * word64 = 
			      (w, significandMask)
			   val x_6550: word64 = 
			      andb x_6549
			   val x_6551: word64 * word64 = 
			      (x_6550, zero)
			   val x_6552: bool = 
			      = (word64) x_6551
			   val x_6553: IEEEReal.float_class = 
			      case x_6552 of
			      true => 
				 let
				    val x_6555: IEEEReal.float_class = 
				       ZERO
				 in
				    x_6555
				 end
			      false => 
				 let
				    val x_6554: IEEEReal.float_class = 
				       SUBNORMAL
				 in
				    x_6554
				 end
			in
			   x_6553
			end
		     false => 
			let
			   val x_6548: IEEEReal.float_class = 
			      NORMAL
			in
			   x_6548
			end
	       in
		  x_6547
	       end
      in
	 x_6542
      end
   val toBits: real64 -> word64 * bool * word64 = 
      fn x_1497: real64 => 
      let
	 val w: word64 = 
	    castToWord x_1497
	 val x_6563: word64 * word64 = 
	    (w, significandMask)
	 val significand: word64 = 
	    andb x_6563
	 val x_6564: word64 * word64 = 
	    (w, exponentMask)
	 val x_6565: word64 = 
	    andb x_6564
	 val x_6566: word64 * word32 = 
	    (x_6565, significandBits)
	 val exponent: word64 = 
	    >> x_6566
	 val x_6567: word64 * word64 = 
	    (w, signMask)
	 val x_6568: word64 = 
	    andb x_6567
	 val x_6569: word64 * word64 = 
	    (x_6568, signMask)
	 val sign: bool = 
	    = (word64) x_6569
	 val x_6570: word64 * bool * word64 = 
	    (exponent, sign, significand)
      in
	 x_6570
      end
   val rec 'a 
      make: ('a -> real64) * word32 * (real64 -> 'a)
	    -> (IEEEReal.RoundingMode.t -> 'a -> real64) * (real64 -> 'a) = 
	 fn x_1498: ('a -> real64) * word32 * (real64 -> 'a) => 
	 let
	    val toRealUnsafe: real64 -> 'a = 
	       #2 x_1498
	    val other: word32 = 
	       #1 x_1498
	    val fromRealUnsafe: 'a -> real64 = 
	       #0 x_1498
	    val x_6571: word32 * word32 = 
	       (precision, other)
	    val x_6572: bool = 
	       = (word32) x_6571
	    val x_6573: (IEEEReal.RoundingMode.t -> 'a -> real64)
			* (real64 -> 'a) = 
	       case x_6572 of
	       true => 
		  let
		     val x_6581: IEEEReal.RoundingMode.t -> 'a -> real64 = 
			fn x_1499: IEEEReal.RoundingMode.t => 
			let
			in
			   fromRealUnsafe
			end
		     val x_6582: (IEEEReal.RoundingMode.t -> 'a -> real64)
				 * (real64 -> 'a) = 
			(x_6581, toRealUnsafe)
		  in
		     x_6582
		  end
	       false => 
		  let
		     val x_6574: IEEEReal.RoundingMode.t -> 'a -> real64 = 
			fn x_1500: IEEEReal.RoundingMode.t => 
			let
			   val x_6575: 'a -> real64 = 
			      fn x_1501: 'a => 
			      let
				 val x_6576: unit -> real64 = 
				    fn x_1502: unit => 
				    let
				       val x_6577: real64 = 
					  fromRealUnsafe x_1501
				    in
				       x_6577
				    end
				 val x_6578: IEEEReal.RoundingMode.t
					     * (unit -> real64) = 
				    (x_1500, x_6576)
				 val x_6579: real64 = 
				    withRoundingMode_0 (real64) x_6578
			      in
				 x_6579
			      end
			in
			   x_6575
			end
		     val x_6580: (IEEEReal.RoundingMode.t -> 'a -> real64)
				 * (real64 -> 'a) = 
			(x_6574, toRealUnsafe)
		  in
		     x_6580
		  end
	 in
	    x_6573
	 end
   val x_6583: (real32 -> real64) * word32 * (real64 -> real32) = 
      (fromReal32Unsafe, precision, toReal32Unsafe)
   val x_6584: (IEEEReal.RoundingMode.t -> real32 -> real64)
	       * (real64 -> real32) = 
      make (real32) x_6583
   val zero: real64 = 
      castFromWord zero
   val x_6585: word64 = 
      sextdFromInt32ToWord64 exponentBias
   val x_6586: word64 * word64 = 
      (x_6585, one)
   val x_6587: word64 = 
      - x_6586
   val x_6588: word64 * word32 = 
      (x_6587, significandBits)
   val x_6589: word64 = 
      << x_6588
   val half: real64 = 
      castFromWord x_6589
   val x_6590: word64 = 
      sextdFromInt32ToWord64 exponentBias
   val x_6591: word64 * word32 = 
      (x_6590, significandBits)
   val x_6592: word64 = 
      << x_6591
   val one: real64 = 
      castFromWord x_6592
   val x_6593: word64 * bool * word64 -> bool = 
      fn x_1504: word64 * bool * word64 => 
      let
	 val x_6594: bool = 
	    #1 x_1504
      in
	 x_6594
      end
   val x_6595: (word64 * bool * word64 -> bool)
	       * (real64 -> word64 * bool * word64) = 
      (x_6593, toBits)
   val signBit: real64 -> bool = 
      o_1 (real64, bool, word64 * bool * word64) x_6595
   exception Bad
   val x_6596: unit -> word32 ref = 
      fn x_1508: unit => 
      let
	 val x_6597: word32 = 
	    0x0
	 val x_6598: word32 ref = 
	    Ref_ref[word32] (x_6597)
      in
	 x_6598
      end
   val one: word32 ref One.t = 
      make_0 (word32 ref) x_6596
   val rec 'a_3512 
      safeConvert: IEEEReal.RoundingMode.t * (real64 -> 'a_3512) * real64
		   -> 'a_3512 = 
	 fn x_1532: IEEEReal.RoundingMode.t * (real64 -> 'a_3512) * real64 => 
	 let
	    val x: real64 = 
	       #2 x_1532
	    val cvt: real64 -> 'a_3512 = 
	       #1 x_1532
	    val m: IEEEReal.RoundingMode.t = 
	       #0 x_1532
	    val x_6599: 'a_3512 = 
	       case m of
	       TO_POSINF => 
		  let
		     val x_6610: real64 = 
			Real64_realCeil (x)
		     val x_6611: 'a_3512 = 
			cvt x_6610
		  in
		     x_6611
		  end
	       TO_NEAREST => 
		  let
		     val x_6604: IEEEReal.RoundingMode.t = 
			TO_NEAREST
		     val x_6605: unit -> real64 = 
			fn x_1506: unit => 
			let
			   val x_6606: real64 = 
			      round x
			in
			   x_6606
			end
		     val x_6607: IEEEReal.RoundingMode.t * (unit -> real64) = 
			(x_6604, x_6605)
		     val x_6608: real64 = 
			withRoundingMode_0 (real64) x_6607
		     val x_6609: 'a_3512 = 
			cvt x_6608
		  in
		     x_6609
		  end
	       TO_ZERO => 
		  let
		     val x_6602: real64 = 
			Real64_realTrunc (x)
		     val x_6603: 'a_3512 = 
			cvt x_6602
		  in
		     x_6603
		  end
	       TO_NEGINF => 
		  let
		     val x_6600: real64 = 
			Real64_realFloor (x)
		     val x_6601: 'a_3512 = 
			cvt x_6600
		  in
		     x_6601
		  end
	 in
	    x_6599
	 end
   val rec 'a 
      make: ('a -> real64) * ((word32 -> 'a) * 'a * word32) * (real64 -> 'a)
	    -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
	 fn x_1533: ('a -> real64)
		    * ((word32 -> 'a) * 'a * word32)
		    * (real64 -> 'a) => 
	 let
	    val toIntUnsafe: real64 -> 'a = 
	       #2 x_1533
	    val other: (word32 -> 'a) * 'a * word32 = 
	       #1 x_1533
	    val fromIntUnsafe: 'a -> real64 = 
	       #0 x_1533
	    val x_6612: word32 = 
	       #2 other
	    val x_6613: word32 * word32 = 
	       (precision, x_6612)
	    val x_6614: bool = 
	       < x_6613
	    val x_6615: IEEEReal.RoundingMode.t -> real64 -> 'a = 
	       case x_6614 of
	       true => 
		  let
		     val x_6669: word32 = 
			#2 other
		     val x_6670: word32 * word32 = 
			(x_6669, precision)
		     val x_6671: word32 = 
			-! x_6670
		     val x_6672: word32 = 
			0x1
		     val x_6673: word32 * word32 = 
			(x_6671, x_6672)
		     val trim: word32 = 
			-! x_6673
		     val x_6674: word32 -> 'a = 
			#0 other
		     val x_6675: word32 = 
			sextdFromInt32ToWord32 trim
		     val maxInt': 'a = 
			x_6674 x_6675
		     val x_6676: 'a = 
			#1 other
		     val maxInt: real64 = 
			fromIntUnsafe maxInt'
		     val minInt: real64 = 
			fromIntUnsafe x_6676
		     val x_6677: IEEEReal.RoundingMode.t -> real64 -> 'a = 
			fn x_1537: IEEEReal.RoundingMode.t => 
			let
			   val x_6678: real64 -> 'a = 
			      fn x_1538: real64 => 
			      let
				 val x_6679: real64 * real64 = 
				    (minInt, x_1538)
				 val x_6680: bool = 
				    <= x_6679
				 val x_6681: 'a = 
				    case x_6680 of
				    true => 
				       let
					  val x_6689: real64 * real64 = 
					     (x_1538, maxInt)
					  val x_6690: bool = 
					     <= x_6689
					  val x_6691: 'a = 
					     case x_6690 of
					     true => 
						let
						   val x_6694: IEEEReal.RoundingMode.t
							       * (real64 -> 'a)
							       * real64 = 
						      (x_1537,
						       toIntUnsafe,
						       x_1538)
						   val x_6695: 'a = 
						      safeConvert ('a) x_6694
						in
						   x_6695
						end
					     false => 
						let
						   val x_6692: exn = 
						      Overflow
						   val x_6693: 'a = 
						      raise x_6692
						in
						   x_6693
						end
				       in
					  x_6691
				       end
				    false => 
				       let
					  val x_6682: real64 * real64 = 
					     (x_1538, minInt)
					  val x_6683: bool = 
					     < x_6682
					  val x_6684: 'a = 
					     case x_6683 of
					     true => 
						let
						   val x_6687: exn = 
						      Overflow
						   val x_6688: 'a = 
						      raise x_6687
						in
						   x_6688
						end
					     false => 
						let
						   val x_6685: exn = 
						      Domain
						   val x_6686: 'a = 
						      raise x_6685
						in
						   x_6686
						end
				       in
					  x_6684
				       end
			      in
				 x_6681
			      end
			in
			   x_6678
			end
		  in
		     x_6677
		  end
	       false => 
		  let
		     val x_6616: word32 -> 'a = 
			#0 other
		     val x_6617: word32 = 
			0x0
		     val maxInt': 'a = 
			x_6616 x_6617
		     val x_6618: 'a = 
			#1 other
		     val maxInt: real64 = 
			fromIntUnsafe maxInt'
		     val minInt: real64 = 
			fromIntUnsafe x_6618
		     val x_6619: IEEEReal.RoundingMode.t -> real64 -> 'a = 
			fn x_1541: IEEEReal.RoundingMode.t => 
			let
			   val x_6620: real64 -> 'a = 
			      fn x_1542: real64 => 
			      let
				 val x_6621: real64 * real64 = 
				    (minInt, x_1542)
				 val x_6622: bool = 
				    <= x_6621
				 val x_6623: 'a = 
				    case x_6622 of
				    true => 
				       let
					  val x_6647: real64 * real64 = 
					     (x_1542, maxInt)
					  val x_6648: bool = 
					     <= x_6647
					  val x_6649: 'a = 
					     case x_6648 of
					     true => 
						let
						   val x_6667: IEEEReal.RoundingMode.t
							       * (real64 -> 'a)
							       * real64 = 
						      (x_1541,
						       toIntUnsafe,
						       x_1542)
						   val x_6668: 'a = 
						      safeConvert ('a) x_6667
						in
						   x_6668
						end
					     false => 
						let
						   val x_6650: real64 * real64 = 
						      (maxInt, one)
						   val x_6651: real64 = 
						      + x_6650
						   val x_6652: real64 * real64 = 
						      (x_1542, x_6651)
						   val x_6653: bool = 
						      < x_6652
						   val x_6654: 'a = 
						      case x_6653 of
						      true => 
							 let
							    val x_6657: 'a = 
							       case x_1541 of
							       TO_NEGINF => 
								  let
								  in
								     maxInt'
								  end
							       TO_ZERO => 
								  let
								  in
								     maxInt'
								  end
							       TO_NEAREST => 
								  let
								     val x_6660: real64
										 * real64 = 
									(x_1542,
									 maxInt)
								     val x_6661: real64 = 
									- x_6660
								     val x_6662: real64
										 * real64 = 
									(x_6661,
									 half)
								     val x_6663: bool = 
									>= x_6662
								     val x_6664: 'a = 
									case x_6663 of
									true => 
									   let
									      val x_6665: exn = 
										 Overflow
									      val x_6666: 'a = 
										 raise x_6665
									   in
									      x_6666
									   end
									false => 
									   let
									   in
									      maxInt'
									   end
								  in
								     x_6664
								  end
							       TO_POSINF => 
								  let
								     val x_6658: exn = 
									Overflow
								     val x_6659: 'a = 
									raise x_6658
								  in
								     x_6659
								  end
							 in
							    x_6657
							 end
						      false => 
							 let
							    val x_6655: exn = 
							       Overflow
							    val x_6656: 'a = 
							       raise x_6655
							 in
							    x_6656
							 end
						in
						   x_6654
						end
				       in
					  x_6649
				       end
				    false => 
				       let
					  val x_6624: real64 * real64 = 
					     (x_1542, minInt)
					  val x_6625: bool = 
					     < x_6624
					  val x_6626: 'a = 
					     case x_6625 of
					     true => 
						let
						   val x_6629: real64 * real64 = 
						      (minInt, one)
						   val x_6630: real64 = 
						      - x_6629
						   val x_6631: real64 * real64 = 
						      (x_6630, x_1542)
						   val x_6632: bool = 
						      < x_6631
						   val x_6633: 'a = 
						      case x_6632 of
						      true => 
							 let
							    val x_6636: 'a = 
							       case x_1541 of
							       TO_NEGINF => 
								  let
								     val x_6645: exn = 
									Overflow
								     val x_6646: 'a = 
									raise x_6645
								  in
								     x_6646
								  end
							       TO_ZERO => 
								  let
								  in
								     x_6618
								  end
							       TO_NEAREST => 
								  let
								     val x_6637: real64
										 * real64 = 
									(x_1542,
									 minInt)
								     val x_6638: real64 = 
									- x_6637
								     val x_6639: real64 = 
									~ half
								     val x_6640: real64
										 * real64 = 
									(x_6638,
									 x_6639)
								     val x_6641: bool = 
									< x_6640
								     val x_6642: 'a = 
									case x_6641 of
									true => 
									   let
									      val x_6643: exn = 
										 Overflow
									      val x_6644: 'a = 
										 raise x_6643
									   in
									      x_6644
									   end
									false => 
									   let
									   in
									      x_6618
									   end
								  in
								     x_6642
								  end
							       TO_POSINF => 
								  let
								  in
								     x_6618
								  end
							 in
							    x_6636
							 end
						      false => 
							 let
							    val x_6634: exn = 
							       Overflow
							    val x_6635: 'a = 
							       raise x_6634
							 in
							    x_6635
							 end
						in
						   x_6633
						end
					     false => 
						let
						   val x_6627: exn = 
						      Domain
						   val x_6628: 'a = 
						      raise x_6627
						in
						   x_6628
						end
				       in
					  x_6626
				       end
			      in
				 x_6623
			      end
			in
			   x_6620
			end
		  in
		     x_6619
		  end
	    val x_6696: ('a -> real64)
			* (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
	       (fromIntUnsafe, x_6615)
	 in
	    x_6696
	 end
   val x_6697: word32 -> word8 = 
      fn x_1544: word32 => 
      let
	 val x_6698: word8 * word32 = 
	    (maxInt', x_1544)
	 val x_6699: word8 = 
	    >> x_6698
	 val x_6700: word8 * word32 = 
	    (x_6699, x_1544)
	 val x_6701: word8 = 
	    << x_6700
      in
	 x_6701
      end
   val x_6702: (word32 -> word8) * word8 * word32 = 
      (x_6697, minInt', precision')
   val x_6703: (word8 -> real64)
	       * ((word32 -> word8) * word8 * word32)
	       * (real64 -> word8) = 
      (fromInt8Unsafe, x_6702, toInt8Unsafe)
   val x_6704: (word8 -> real64) * (IEEEReal.RoundingMode.t -> real64 -> word8) = 
      make (word8) x_6703
   val x_6705: word32 -> word16 = 
      fn x_1545: word32 => 
      let
	 val x_6706: word16 * word32 = 
	    (maxInt', x_1545)
	 val x_6707: word16 = 
	    >> x_6706
	 val x_6708: word16 * word32 = 
	    (x_6707, x_1545)
	 val x_6709: word16 = 
	    << x_6708
      in
	 x_6709
      end
   val x_6710: (word32 -> word16) * word16 * word32 = 
      (x_6705, minInt', precision')
   val x_6711: (word16 -> real64)
	       * ((word32 -> word16) * word16 * word32)
	       * (real64 -> word16) = 
      (fromInt16Unsafe, x_6710, toInt16Unsafe)
   val x_6712: (word16 -> real64)
	       * (IEEEReal.RoundingMode.t -> real64 -> word16) = 
      make (word16) x_6711
   val x_6713: word32 -> word32 = 
      fn x_1546: word32 => 
      let
	 val x_6714: word32 * word32 = 
	    (maxInt', x_1546)
	 val x_6715: word32 = 
	    >> x_6714
	 val x_6716: word32 * word32 = 
	    (x_6715, x_1546)
	 val x_6717: word32 = 
	    << x_6716
      in
	 x_6717
      end
   val x_6718: (word32 -> word32) * word32 * word32 = 
      (x_6713, minInt', precision')
   val x_6719: (word32 -> real64)
	       * ((word32 -> word32) * word32 * word32)
	       * (real64 -> word32) = 
      (fromInt32Unsafe, x_6718, toInt32Unsafe)
   val x_6720: (word32 -> real64)
	       * (IEEEReal.RoundingMode.t -> real64 -> word32) = 
      make (word32) x_6719
   val x_6721: word32 -> word64 = 
      fn x_1547: word32 => 
      let
	 val x_6722: word64 * word32 = 
	    (maxInt', x_1547)
	 val x_6723: word64 = 
	    >> x_6722
	 val x_6724: word64 * word32 = 
	    (x_6723, x_1547)
	 val x_6725: word64 = 
	    << x_6724
      in
	 x_6725
      end
   val x_6726: (word32 -> word64) * word64 * word32 = 
      (x_6721, minInt', precision')
   val x_6727: (word64 -> real64)
	       * ((word32 -> word64) * word64 * word32)
	       * (real64 -> word64) = 
      (fromInt64Unsafe, x_6726, toInt64Unsafe)
   val x_6728: (word64 -> real64)
	       * (IEEEReal.RoundingMode.t -> real64 -> word64) = 
      make (word64) x_6727
   val rec 'a 
      make: ('a -> real64) * ((word32 -> 'a) * word32 * 'a) * (real64 -> 'a)
	    -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
	 fn x_1551: ('a -> real64)
		    * ((word32 -> 'a) * word32 * 'a)
		    * (real64 -> 'a) => 
	 let
	    val toWordUnsafe: real64 -> 'a = 
	       #2 x_1551
	    val other: (word32 -> 'a) * word32 * 'a = 
	       #1 x_1551
	    val fromWordUnsafe: 'a -> real64 = 
	       #0 x_1551
	    val x_6729: word32 = 
	       #1 other
	    val x_6730: word32 * word32 = 
	       (precision, x_6729)
	    val x_6731: bool = 
	       <= x_6730
	    val x_6732: IEEEReal.RoundingMode.t -> real64 -> 'a = 
	       case x_6731 of
	       true => 
		  let
		     val x_6784: word32 = 
			#1 other
		     val x_6785: word32 * word32 = 
			(x_6784, precision)
		     val trim: word32 = 
			-! x_6785
		     val x_6786: word32 -> 'a = 
			#0 other
		     val x_6787: word32 = 
			sextdFromInt32ToWord32 trim
		     val maxWord': 'a = 
			x_6786 x_6787
		     val maxWord: real64 = 
			fromWordUnsafe maxWord'
		     val x_6788: 'a = 
			#2 other
		     val x_6789: IEEEReal.RoundingMode.t -> real64 -> 'a = 
			fn x_1555: IEEEReal.RoundingMode.t => 
			let
			   val x_6790: real64 -> 'a = 
			      fn x_1556: real64 => 
			      let
				 val x_6791: IEEEReal.float_class = 
				    class x_1556
				 val x_6792: 'a = 
				    case x_6791 of
				    INF => 
				       let
					  val x_6795: exn = 
					     Overflow
					  val x_6796: 'a = 
					     raise x_6795
				       in
					  x_6796
				       end
				    NAN => 
				       let
					  val x_6793: exn = 
					     Domain
					  val x_6794: 'a = 
					     raise x_6793
				       in
					  x_6794
				       end
				      _ => let
					      val x_6797: real64 * real64 = 
						 (zero, x_1556)
					      val x_6798: bool = 
						 <= x_6797
					      val x_6799: 'a = 
						 case x_6798 of
						 true => 
						    let
						       val x_6815: real64
								   * real64 = 
							  (x_1556, maxWord)
						       val x_6816: bool = 
							  <= x_6815
						       val x_6817: 'a = 
							  case x_6816 of
							  true => 
							     let
								val x_6820: IEEEReal.RoundingMode.t
									    * (real64
									       -> 'a)
									    * real64 = 
								   (x_1555,
								    toWordUnsafe,
								    x_1556)
								val x_6821: 'a = 
								   safeConvert ('a) x_6820
							     in
								x_6821
							     end
							  false => 
							     let
								val x_6818: exn = 
								   Overflow
								val x_6819: 'a = 
								   raise x_6818
							     in
								x_6819
							     end
						    in
						       x_6817
						    end
						 false => 
						    let
						       val x_6800: real64 = 
							  ~ one
						       val x_6801: real64
								   * real64 = 
							  (x_1556, x_6800)
						       val x_6802: bool = 
							  > x_6801
						       val x_6803: 'a = 
							  case x_6802 of
							  true => 
							     let
								val x_6806: 'a = 
								   case x_1555 of
								   TO_NEGINF => 
								      let
									 val x_6813: exn = 
									    Overflow
									 val x_6814: 'a = 
									    raise x_6813
								      in
									 x_6814
								      end
								   TO_ZERO => 
								      let
								      in
									 x_6788
								      end
								   TO_NEAREST => 
								      let
									 val x_6807: real64 = 
									    ~ half
									 val x_6808: real64
										     * real64 = 
									    (x_1556,
									     x_6807)
									 val x_6809: bool = 
									    < x_6808
									 val x_6810: 'a = 
									    case x_6809 of
									    true => 
									       let
										  val x_6811: exn = 
										     Overflow
										  val x_6812: 'a = 
										     raise x_6811
									       in
										  x_6812
									       end
									    false => 
									       let
									       in
										  x_6788
									       end
								      in
									 x_6810
								      end
								   TO_POSINF => 
								      let
								      in
									 x_6788
								      end
							     in
								x_6806
							     end
							  false => 
							     let
								val x_6804: exn = 
								   Overflow
								val x_6805: 'a = 
								   raise x_6804
							     in
								x_6805
							     end
						    in
						       x_6803
						    end
					   in
					      x_6799
					   end
			      in
				 x_6792
			      end
			in
			   x_6790
			end
		  in
		     x_6789
		  end
	       false => 
		  let
		     val x_6733: word32 -> 'a = 
			#0 other
		     val x_6734: word32 = 
			0x0
		     val maxWord': 'a = 
			x_6733 x_6734
		     val maxWord: real64 = 
			fromWordUnsafe maxWord'
		     val x_6735: 'a = 
			#2 other
		     val x_6736: IEEEReal.RoundingMode.t -> real64 -> 'a = 
			fn x_1559: IEEEReal.RoundingMode.t => 
			let
			   val x_6737: real64 -> 'a = 
			      fn x_1560: real64 => 
			      let
				 val x_6738: IEEEReal.float_class = 
				    class x_1560
				 val x_6739: 'a = 
				    case x_6738 of
				    INF => 
				       let
					  val x_6742: exn = 
					     Overflow
					  val x_6743: 'a = 
					     raise x_6742
				       in
					  x_6743
				       end
				    NAN => 
				       let
					  val x_6740: exn = 
					     Domain
					  val x_6741: 'a = 
					     raise x_6740
				       in
					  x_6741
				       end
				      _ => let
					      val x_6744: real64 * real64 = 
						 (zero, x_1560)
					      val x_6745: bool = 
						 <= x_6744
					      val x_6746: 'a = 
						 case x_6745 of
						 true => 
						    let
						       val x_6762: real64
								   * real64 = 
							  (x_1560, maxWord)
						       val x_6763: bool = 
							  <= x_6762
						       val x_6764: 'a = 
							  case x_6763 of
							  true => 
							     let
								val x_6782: IEEEReal.RoundingMode.t
									    * (real64
									       -> 'a)
									    * real64 = 
								   (x_1559,
								    toWordUnsafe,
								    x_1560)
								val x_6783: 'a = 
								   safeConvert ('a) x_6782
							     in
								x_6783
							     end
							  false => 
							     let
								val x_6765: real64
									    * real64 = 
								   (maxWord, one)
								val x_6766: real64 = 
								   + x_6765
								val x_6767: real64
									    * real64 = 
								   (x_1560,
								    x_6766)
								val x_6768: bool = 
								   < x_6767
								val x_6769: 'a = 
								   case x_6768 of
								   true => 
								      let
									 val x_6772: 'a = 
									    case x_1559 of
									    TO_NEGINF => 
									       let
									       in
										  maxWord'
									       end
									    TO_ZERO => 
									       let
									       in
										  maxWord'
									       end
									    TO_NEAREST => 
									       let
										  val x_6775: real64
											      * real64 = 
										     (x_1560,
										      maxWord)
										  val x_6776: real64 = 
										     - x_6775
										  val x_6777: real64
											      * real64 = 
										     (x_6776,
										      half)
										  val x_6778: bool = 
										     >= x_6777
										  val x_6779: 'a = 
										     case x_6778 of
										     true => 
											let
											   val x_6780: exn = 
											      Overflow
											   val x_6781: 'a = 
											      raise x_6780
											in
											   x_6781
											end
										     false => 
											let
											in
											   maxWord'
											end
									       in
										  x_6779
									       end
									    TO_POSINF => 
									       let
										  val x_6773: exn = 
										     Overflow
										  val x_6774: 'a = 
										     raise x_6773
									       in
										  x_6774
									       end
								      in
									 x_6772
								      end
								   false => 
								      let
									 val x_6770: exn = 
									    Overflow
									 val x_6771: 'a = 
									    raise x_6770
								      in
									 x_6771
								      end
							     in
								x_6769
							     end
						    in
						       x_6764
						    end
						 false => 
						    let
						       val x_6747: real64 = 
							  ~ one
						       val x_6748: real64
								   * real64 = 
							  (x_1560, x_6747)
						       val x_6749: bool = 
							  > x_6748
						       val x_6750: 'a = 
							  case x_6749 of
							  true => 
							     let
								val x_6753: 'a = 
								   case x_1559 of
								   TO_NEGINF => 
								      let
									 val x_6760: exn = 
									    Overflow
									 val x_6761: 'a = 
									    raise x_6760
								      in
									 x_6761
								      end
								   TO_ZERO => 
								      let
								      in
									 x_6735
								      end
								   TO_NEAREST => 
								      let
									 val x_6754: real64 = 
									    ~ half
									 val x_6755: real64
										     * real64 = 
									    (x_1560,
									     x_6754)
									 val x_6756: bool = 
									    < x_6755
									 val x_6757: 'a = 
									    case x_6756 of
									    true => 
									       let
										  val x_6758: exn = 
										     Overflow
										  val x_6759: 'a = 
										     raise x_6758
									       in
										  x_6759
									       end
									    false => 
									       let
									       in
										  x_6735
									       end
								      in
									 x_6757
								      end
								   TO_POSINF => 
								      let
								      in
									 x_6735
								      end
							     in
								x_6753
							     end
							  false => 
							     let
								val x_6751: exn = 
								   Overflow
								val x_6752: 'a = 
								   raise x_6751
							     in
								x_6752
							     end
						    in
						       x_6750
						    end
					   in
					      x_6746
					   end
			      in
				 x_6739
			      end
			in
			   x_6737
			end
		  in
		     x_6736
		  end
	    val x_6822: ('a -> real64)
			* (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
	       (fromWordUnsafe, x_6732)
	 in
	    x_6822
	 end
   val x_6823: word32 -> word8 = 
      fn x_1562: word32 => 
      let
	 val x_6824: word8 * word32 = 
	    (maxWord', x_1562)
	 val x_6825: word8 = 
	    >> x_6824
	 val x_6826: word8 * word32 = 
	    (x_6825, x_1562)
	 val x_6827: word8 = 
	    << x_6826
      in
	 x_6827
      end
   val x_6828: (word32 -> word8) * word32 * word8 = 
      (x_6823, wordSize, zero)
   val x_6829: (word8 -> real64)
	       * ((word32 -> word8) * word32 * word8)
	       * (real64 -> word8) = 
      (fromWord8Unsafe, x_6828, toWord8Unsafe)
   val x_6830: (word8 -> real64) * (IEEEReal.RoundingMode.t -> real64 -> word8) = 
      make (word8) x_6829
   val x_6831: word32 -> word16 = 
      fn x_1563: word32 => 
      let
	 val x_6832: word16 * word32 = 
	    (maxWord', x_1563)
	 val x_6833: word16 = 
	    >> x_6832
	 val x_6834: word16 * word32 = 
	    (x_6833, x_1563)
	 val x_6835: word16 = 
	    << x_6834
      in
	 x_6835
      end
   val x_6836: (word32 -> word16) * word32 * word16 = 
      (x_6831, wordSize, zero)
   val x_6837: (word16 -> real64)
	       * ((word32 -> word16) * word32 * word16)
	       * (real64 -> word16) = 
      (fromWord16Unsafe, x_6836, toWord16Unsafe)
   val x_6838: (word16 -> real64)
	       * (IEEEReal.RoundingMode.t -> real64 -> word16) = 
      make (word16) x_6837
   val x_6839: word32 -> word32 = 
      fn x_1564: word32 => 
      let
	 val x_6840: word32 * word32 = 
	    (maxWord', x_1564)
	 val x_6841: word32 = 
	    >> x_6840
	 val x_6842: word32 * word32 = 
	    (x_6841, x_1564)
	 val x_6843: word32 = 
	    << x_6842
      in
	 x_6843
      end
   val x_6844: (word32 -> word32) * word32 * word32 = 
      (x_6839, wordSize, zero)
   val x_6845: (word32 -> real64)
	       * ((word32 -> word32) * word32 * word32)
	       * (real64 -> word32) = 
      (fromWord32Unsafe, x_6844, toWord32Unsafe)
   val x_6846: (word32 -> real64)
	       * (IEEEReal.RoundingMode.t -> real64 -> word32) = 
      make (word32) x_6845
   val x_6847: word32 -> word64 = 
      fn x_1565: word32 => 
      let
	 val x_6848: word64 * word32 = 
	    (maxWord', x_1565)
	 val x_6849: word64 = 
	    >> x_6848
	 val x_6850: word64 * word32 = 
	    (x_6849, x_1565)
	 val x_6851: word64 = 
	    << x_6850
      in
	 x_6851
      end
   val x_6852: (word32 -> word64) * word32 * word64 = 
      (x_6847, wordSize, zero)
   val x_6853: (word64 -> real64)
	       * ((word32 -> word64) * word32 * word64)
	       * (real64 -> word64) = 
      (fromWord64Unsafe, x_6852, toWord64Unsafe)
   val x_6854: (word64 -> real64)
	       * (IEEEReal.RoundingMode.t -> real64 -> word64) = 
      make (word64) x_6853
   val x_6855: (word32 -> real32) * (word32 -> word32) = 
      (castFromWord, bswap)
   val x_6856: word32 -> real32 = 
      o_1 (word32, real32, word32) x_6855
   val x_6857: (word32 -> real32) * (word8 array * word64 -> word32) = 
      (x_6856, subArr)
   val subArrRev: word8 array * word64 -> real32 = 
      o_1 (word8 array * word64, real32, word32) x_6857
   val x_6858: (word32 -> real32) * (word32 -> word32) = 
      (castFromWord, bswap)
   val x_6859: word32 -> real32 = 
      o_1 (word32, real32, word32) x_6858
   val x_6860: (word32 -> real32) * (word8 vector * word64 -> word32) = 
      (x_6859, subVec)
   val subVecRev: word8 vector * word64 -> real32 = 
      o_1 (word8 vector * word64, real32, word32) x_6860
   val x_6861: (word32 -> real32) * (word8 array * word64 -> word32) = 
      (castFromWord, subArr)
   val subArr: word8 array * word64 -> real32 = 
      o_1 (word8 array * word64, real32, word32) x_6861
   val x_6862: (word32 -> real32) * (word8 vector * word64 -> word32) = 
      (castFromWord, subVec)
   val subVec: word8 vector * word64 -> real32 = 
      o_1 (word8 vector * word64, real32, word32) x_6862
   val ticksPerSecond: intInf = 
      1000000000
   exception Time
   val x_6863: intInf = 
      1
   val x_6864: intInf * intInf = 
      (ticksPerSecond, x_6863)
   val d: intInf = 
      bigQuot x_6864
   val x_6865: intInf -> Time.time = 
      fn x_1570: intInf => 
      let
	 val x_6866: intInf * intInf = 
	    (x_1570, d)
	 val x_6867: intInf = 
	    bigMul x_6866
	 val x_6868: Time.time = 
	    T x_6867
      in
	 x_6868
      end
   exception Date
   exception BlockingNotSupported
   exception ClosedStream
   exception Io of exn * word8 vector * word8 vector
   val x_6869: exn -> word8 vector Primitive.Option.t = 
      fn x_1571: exn => 
      let
	 val x_6870: word8 vector Primitive.Option.t = 
	    case x_1571 of
	    Io x_6871: exn * word8 vector * word8 vector => 
	       let
		  val x_6872: word8 vector = 
		     #2 x_6871
		  val x_6873: word8 vector = 
		     #1 x_6871
		  val x_6874: exn = 
		     #0 x_6871
		  val x_6875: word8 vector list = 
		     nil[word8 vector]
		  val x_6876: word8 vector = 
		     exnMessage x_6874
		  val x_6877: word8 vector * word8 vector list = 
		     (x_6876, x_6875)
		  val x_6878: word8 vector list = 
		     ::[word8 vector] x_6877
		  val x_6879: word8 vector = 
		     "\" failed with "
		  val x_6880: word8 vector * word8 vector list = 
		     (x_6879, x_6878)
		  val x_6881: word8 vector list = 
		     ::[word8 vector] x_6880
		  val x_6882: word8 vector * word8 vector list = 
		     (x_6872, x_6881)
		  val x_6883: word8 vector list = 
		     ::[word8 vector] x_6882
		  val x_6884: word8 vector = 
		     " \""
		  val x_6885: word8 vector * word8 vector list = 
		     (x_6884, x_6883)
		  val x_6886: word8 vector list = 
		     ::[word8 vector] x_6885
		  val x_6887: word8 vector * word8 vector list = 
		     (x_6873, x_6886)
		  val x_6888: word8 vector list = 
		     ::[word8 vector] x_6887
		  val x_6889: word8 vector = 
		     "Io: "
		  val x_6890: word8 vector * word8 vector list = 
		     (x_6889, x_6888)
		  val x_6891: word8 vector list = 
		     ::[word8 vector] x_6890
		  val x_6892: word8 vector = 
		     concat_1 (word8) x_6891
		  val x_6893: word8 vector Primitive.Option.t = 
		     SOME[word8 vector] x_6892
	       in
		  x_6893
	       end
	      _ => let
		      val x_6894: word8 vector Primitive.Option.t = 
			 NONE[word8 vector]
		   in
		      x_6894
		   end
      in
	 x_6870
      end
   val x_6895: unit = 
      addExnMessager x_6869
   exception NonblockingNotSupported
   exception RandomAccessNotSupported
   val ('b, 'a) stub: word8 vector * ('a -> 'b) -> 'a -> 'b = 
      let
	 val x_6896: word8 vector * ('a -> 'b) -> 'a -> 'b = 
	    fn x_1580: word8 vector * ('a -> 'b) => 
	    let
	       val f: 'a -> 'b = 
		  #1 x_1580
	       val msg: word8 vector = 
		  #0 x_1580
	       val x_6897: Primitive.MLton.Platform.OS.t = 
		  MinGW
	       val x_6898: Primitive.MLton.Platform.OS.t
			   * Primitive.MLton.Platform.OS.t = 
		  (x_6897, x_2126)
	       val x_6899: bool = 
		  = (Primitive.MLton.Platform.OS.t) x_6898
	       val x_6900: 'a -> 'b = 
		  case x_6899 of
		  true => 
		     let
			val x_6901: 'a -> 'b = 
			   fn x_1581: 'a => 
			   let
			      val x_6902: word32 * word8 vector = 
				 (nosys, msg)
			      val x_6903: 'b = 
				 raiseSysWithMsg_0 ('b) x_6902
			   in
			      x_6903
			   end
		     in
			x_6901
		     end
		  false => 
		     let
		     in
			f
		     end
	    in
	       x_6900
	    end
      in
	 x_6896
      end
   val x_6904: word8 vector = 
      "fcntl3"
   val x_6905: word8 vector * (word32 * word32 * word32 -> word32) = 
      (x_6904, fcntl3)
   val fcntl3: word32 * word32 * word32 -> word32 = 
      stub (word32, word32 * word32 * word32) x_6905
   val x_6906: (intInf -> Time.time) * (word64 -> intInf) = 
      (x_6865, sextdFromInt64)
   val fromSeconds: word64 -> Time.time = 
      o_1 (word64, Time.time, intInf) x_6906
   val x_6907: (word32 -> word32) * (word32 -> word32) = 
      (fromRep, toRep)
   val fdToIOD: word32 -> word32 = 
      o_1 (word32, word32, word32) x_6907
   val x_6908: word32 = 
      0x1
   val stdout: word32 = 
      fromRep x_6908
   val x_6909: word32 = 
      0x2
   val stderr: word32 = 
      fromRep x_6909
   val x_6910: word64 = 
      0x0
   val empty: word32 = 
      zextdFromWord64ToInt32 x_6910
   val x_6911: word32 -> word32 list -> word32 = 
      foldl_1 (word32, word32) x_2555
   val flags: word32 list -> word32 = 
      x_6911 empty
   val rec 'a_3886 
      make: (Time.time
	     * Time.time
	     * word64
	     * word32
	     * word64
	     * word32
	     * Time.time
	     * word32
	     * word64
	     * word32
	     -> 'a_3886)
	    -> PosixFileSys.ST.stat -> 'a_3886 = 
	 fn x_1584: Time.time
		    * Time.time
		    * word64
		    * word32
		    * word64
		    * word32
		    * Time.time
		    * word32
		    * word64
		    * word32
		    -> 'a_3886 => 
	 let
	    val x_6912: PosixFileSys.ST.stat -> 'a_3886 = 
	       fn x_1585: PosixFileSys.ST.stat => 
	       let
		  val x_6913: 'a_3886 = 
		     case x_1585 of
		     T x_6914: Time.time
			       * Time.time
			       * word64
			       * word32
			       * word64
			       * word32
			       * Time.time
			       * word32
			       * word64
			       * word32 => 
			let
			   val x_6915: 'a_3886 = 
			      x_1584 x_6914
			in
			   x_6915
			end
	       in
		  x_6913
	       end
	 in
	    x_6912
	 end
   val x_6916: Time.time
	       * Time.time
	       * word64
	       * word32
	       * word64
	       * word32
	       * Time.time
	       * word32
	       * word64
	       * word32
	       -> word32 = 
      fn x_1586: Time.time
		 * Time.time
		 * word64
		 * word32
		 * word64
		 * word32
		 * Time.time
		 * word32
		 * word64
		 * word32 => 
      let
	 val x_6917: word32 = 
	    #5 x_1586
      in
	 x_6917
      end
   val mode: PosixFileSys.ST.stat -> word32 = 
      make (word32) x_6916
   val x_6918: Time.time
	       * Time.time
	       * word64
	       * word32
	       * word64
	       * word32
	       * Time.time
	       * word32
	       * word64
	       * word32
	       -> word64 = 
      fn x_1587: Time.time
		 * Time.time
		 * word64
		 * word32
		 * word64
		 * word32
		 * Time.time
		 * word32
		 * word64
		 * word32 => 
      let
	 val x_6919: word64 = 
	    #8 x_1587
      in
	 x_6919
      end
   val size: PosixFileSys.ST.stat -> word64 = 
      make (word64) x_6918
   val rec 'a_3887 
      make: ('a_3887 -> word32) -> 'a_3887 -> PosixFileSys.ST.stat = 
	 fn x_1590: 'a_3887 -> word32 => 
	 let
	    val x_6920: 'a_3887 -> PosixFileSys.ST.stat = 
	       fn x_1591: 'a_3887 => 
	       let
		  val x_6921: unit -> word32 * (word32 -> PosixFileSys.ST.stat) = 
		     fn x_1592: unit => 
		     let
			val x_6922: word32 = 
			   x_1590 x_1591
			val x_6923: word32 -> PosixFileSys.ST.stat = 
			   fn x_1593: word32 => 
			   let
			      val x_6924: word64 = 
				 Posix_FileSys_Stat_getDev ()
			      val x_6925: word64 = 
				 Posix_FileSys_Stat_getINo ()
			      val x_6926: word32 = 
				 Posix_FileSys_Stat_getMode ()
			      val x_6927: word64 = 
				 Posix_FileSys_Stat_getNLink ()
			      val i: word32 = 
				 zchckFromWord64ToInt32 x_6927
			      val x_6928: word32 * word32 = 
				 (sizeInBits, sizeInBits)
			      val x_6929: bool = 
				 <= x_6928
			      val x_6930: bool = 
				 case x_6929 of
				 true => 
				    let
				       val x_6932: word32 = 
					  0x0
				       val x_6933: word32 * word32 = 
					  (i, x_6932)
				       val x_6934: bool = 
					  < x_6933
				    in
				       x_6934
				    end
				 false => 
				    let
				       val x_6931: bool = 
					  false
				    in
				       x_6931
				    end
			      val x_6935: word32 = 
				 case x_6930 of
				 true => 
				    let
				       val x_6936: exn = 
					  Overflow
				       val x_6937: word32 = 
					  raise x_6936
				    in
				       x_6937
				    end
				 false => 
				    let
				    in
				       i
				    end
			      val x_6938: word32 = 
				 Posix_FileSys_Stat_getUId ()
			      val x_6939: word32 = 
				 Posix_FileSys_Stat_getGId ()
			      val x_6940: word64 = 
				 Posix_FileSys_Stat_getSize ()
			      val x_6941: word64 = 
				 Posix_FileSys_Stat_getATime ()
			      val x_6942: Time.time = 
				 fromSeconds x_6941
			      val x_6943: word64 = 
				 Posix_FileSys_Stat_getMTime ()
			      val x_6944: Time.time = 
				 fromSeconds x_6943
			      val x_6945: word64 = 
				 Posix_FileSys_Stat_getCTime ()
			      val x_6946: Time.time = 
				 fromSeconds x_6945
			      val x_6947: Time.time
					  * Time.time
					  * word64
					  * word32
					  * word64
					  * word32
					  * Time.time
					  * word32
					  * word64
					  * word32 = 
				 (x_6942,
				  x_6946,
				  x_6924,
				  x_6939,
				  x_6925,
				  x_6926,
				  x_6944,
				  x_6935,
				  x_6940,
				  x_6938)
			      val x_6948: PosixFileSys.ST.stat = 
				 T x_6947
			   in
			      x_6948
			   end
			val x_6949: word32 * (word32 -> PosixFileSys.ST.stat) = 
			   (x_6922, x_6923)
		     in
			x_6949
		     end
		  val x_6950: PosixFileSys.ST.stat = 
		     syscall_0 (PosixFileSys.ST.stat) x_6921
	       in
		  x_6950
	       end
	 in
	    x_6920
	 end
   val x_6951: word32 -> PosixFileSys.ST.stat = 
      make (word32) fstat
   val x_6952: (word32 -> PosixFileSys.ST.stat) * (word32 -> word32) = 
      (x_6951, toRep)
   val fstat: word32 -> PosixFileSys.ST.stat = 
      o_1 (word32, PosixFileSys.ST.stat, word32) x_6952
   val rec 
      close: word32 -> unit = 
	 fn x_1594: word32 => 
	 let
	    val x_6953: unit -> word32 = 
	       fn x_1595: unit => 
	       let
		  val x_6954: word32 = 
		     toRep x_1594
		  val x_6955: word32 = 
		     Posix_IO_close (x_6954)
	       in
		  x_6955
	       end
	    val x_6956: unit = 
	       simpleRestart x_6953
	 in
	    x_6956
	 end
   val rec 
      setfl: word32 * word32 -> unit = 
	 fn x_1596: word32 * word32 => 
	 let
	    val flags: word32 = 
	       #1 x_1596
	    val fd: word32 = 
	       #0 x_1596
	    val x_6957: unit -> word32 = 
	       fn x_1597: unit => 
	       let
		  val x_6958: word32 = 
		     toRep fd
		  val x_6959: word32 * word32 * word32 = 
		     (x_6958, F_SETFL, flags)
		  val x_6960: word32 = 
		     fcntl3 x_6959
	       in
		  x_6960
	       end
	    val x_6961: unit = 
	       simpleRestart x_6957
	 in
	    x_6961
	 end
   val rec 
      lseek: word32 * word64 * PosixIO.whence -> word64 = 
	 fn x_1599: word32 * word64 * PosixIO.whence => 
	 let
	    val w: PosixIO.whence = 
	       #2 x_1599
	    val n: word64 = 
	       #1 x_1599
	    val fd: word32 = 
	       #0 x_1599
	    val x_6962: word32 = 
	       0xFFFFFFFF
	    val x_6963: word64 = 
	       sextdFromInt32ToInt64 x_6962
	    val x_6964: unit -> word64 = 
	       fn x_1600: unit => 
	       let
		  val x_6965: word32 = 
		     toRep fd
		  val x_6966: word32 = 
		     case w of
		     SEEK_SET => 
			let
			in
			   SEEK_SET
			end
		     SEEK_END => 
			let
			in
			   SEEK_END
			end
		     SEEK_CUR => 
			let
			in
			   SEEK_CUR
			end
		  val x_6967: word64 = 
		     Posix_IO_lseek (x_6965, n, x_6966)
	       in
		  x_6967
	       end
	    val x_6968: word64 * (unit -> word64) = 
	       (x_6963, x_6964)
	    val x_6969: word64 = 
	       simpleResult'_0 (word64) x_6968
	 in
	    x_6969
	 end
   val x_6970: word32 = 
      0x0
   val pos0: word64 = 
      sextdFromInt32ToInt64 x_6970
   val rec 
      isReg: word32 -> bool = 
	 fn x_1601: word32 => 
	 let
	    val x_6971: PosixFileSys.ST.stat = 
	       fstat x_1601
	    val x_6972: word32 = 
	       mode x_6971
	    val x_6973: word32 = 
	       Posix_FileSys_ST_isReg (x_6972)
	    val x_6974: word32 * word32 = 
	       (x_6973, zero)
	    val x_6975: bool = 
	       <> (word32) x_6974
	 in
	    x_6975
	 end
   val rec 
      posFns: bool ref * word32
	      -> (unit -> word64) Primitive.Option.t
		 * (unit -> word64) Primitive.Option.t
		 * word64 ref
		 * (word64 -> unit) Primitive.Option.t
		 * (unit -> word64) Primitive.Option.t = 
	 fn x_1602: bool ref * word32 => 
	 let
	    val fd: word32 = 
	       #1 x_1602
	    val closed: bool ref = 
	       #0 x_1602
	    val x_6976: bool = 
	       isReg fd
	    val x_6977: (unit -> word64) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* word64 ref
			* (word64 -> unit) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t = 
	       case x_6976 of
	       true => 
		  let
		     val pos: word64 ref = 
			Ref_ref[word64] (pos0)
		     val rec 
			getPos: unit -> word64 = 
			   fn x_1606: unit => 
			   let
			      val x_6984: word64 = 
				 !_1 (word64) pos
			   in
			      x_6984
			   end
		     val rec 
			setPos: word64 -> unit = 
			   fn x_1605: word64 => 
			   let
			      val x_6985: bool = 
				 !_1 (bool) closed
			      val x_6986: unit = 
				 case x_6985 of
				 true => 
				    let
				       val x_6988: exn = 
					  ClosedStream
				       val x_6989: unit = 
					  raise x_6988
				    in
				       x_6989
				    end
				 false => 
				    let
				       val x_6987: unit = 
					  ()
				    in
				       x_6987
				    end
			      val x_6990: PosixIO.whence = 
				 SEEK_SET
			      val x_6991: word32 * word64 * PosixIO.whence = 
				 (fd, x_1605, x_6990)
			      val x_6992: word64 = 
				 lseek x_6991
			      val x_6993: word64 ref * word64 = 
				 (pos, x_6992)
			      val x_6994: unit = 
				 :=_1 (word64) x_6993
			   in
			      x_6994
			   end
		     val rec 
			endPos: unit -> word64 = 
			   fn x_1604: unit => 
			   let
			      val x_6995: bool = 
				 !_1 (bool) closed
			      val x_6996: unit = 
				 case x_6995 of
				 true => 
				    let
				       val x_6998: exn = 
					  ClosedStream
				       val x_6999: unit = 
					  raise x_6998
				    in
				       x_6999
				    end
				 false => 
				    let
				       val x_6997: unit = 
					  ()
				    in
				       x_6997
				    end
			      val x_7000: PosixFileSys.ST.stat = 
				 fstat fd
			      val x_7001: word64 = 
				 size x_7000
			   in
			      x_7001
			   end
		     val rec 
			verifyPos: unit -> word64 = 
			   fn x_1603: unit => 
			   let
			      val x_7002: PosixIO.whence = 
				 SEEK_CUR
			      val x_7003: word32 * word64 * PosixIO.whence = 
				 (fd, pos0, x_7002)
			      val curPos: word64 = 
				 lseek x_7003
			      val x_7004: word64 ref * word64 = 
				 (pos, curPos)
			      val x_7005: unit = 
				 :=_1 (word64) x_7004
			   in
			      curPos
			   end
		     val x_7006: unit = 
			()
		     val x_7007: word64 = 
			verifyPos x_7006
		     val x_7008: (unit -> word64) Primitive.Option.t = 
			SOME[unit -> word64] getPos
		     val x_7009: (word64 -> unit) Primitive.Option.t = 
			SOME[word64 -> unit] setPos
		     val x_7010: (unit -> word64) Primitive.Option.t = 
			SOME[unit -> word64] endPos
		     val x_7011: (unit -> word64) Primitive.Option.t = 
			SOME[unit -> word64] verifyPos
		     val x_7012: (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word64 ref
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t = 
			(x_7010, x_7008, pos, x_7009, x_7011)
		  in
		     x_7012
		  end
	       false => 
		  let
		     val x_6978: word64 ref = 
			Ref_ref[word64] (pos0)
		     val x_6979: (unit -> word64) Primitive.Option.t = 
			NONE[unit -> word64]
		     val x_6980: (word64 -> unit) Primitive.Option.t = 
			NONE[word64 -> unit]
		     val x_6981: (unit -> word64) Primitive.Option.t = 
			NONE[unit -> word64]
		     val x_6982: (unit -> word64) Primitive.Option.t = 
			NONE[unit -> word64]
		     val x_6983: (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word64 ref
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t = 
			(x_6981, x_6979, x_6978, x_6980, x_6982)
		  in
		     x_6983
		  end
	 in
	    x_6977
	 end
   val rec ('a_3912,
	    'a_3911,
	    'a_3910,
	    'a_3909,
	    'a_3908,
	    'a_3907,
	    'a_3906,
	    'a_3905,
	    'a_3904,
	    'a_3903,
	    'a_3902,
	    'a_3901,
	    'a_3900,
	    'a_3899) 
      make: ((unit -> word32 Primitive.Option.t)
	     * 'a_3908 Primitive.Option.t
	     * 'a_3909 Primitive.Option.t
	     * word32
	     * (unit -> unit)
	     * (unit -> word64) Primitive.Option.t
	     * (unit -> word64) Primitive.Option.t
	     * word32 Primitive.Option.t
	     * 'a_3906
	     * ('a_3903 -> word32) Primitive.Option.t
	     * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
	     * (word32 -> 'a_3907) Primitive.Option.t
	     * (word32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t
	     * (word64 -> unit) Primitive.Option.t
	     * (unit -> word64) Primitive.Option.t
	     -> 'a_3910)
	    * ('a_3901 Primitive.Option.t
	       * 'a_3902 Primitive.Option.t
	       * 'a_3900
	       * (unit -> unit)
	       * (unit -> word64) Primitive.Option.t
	       * (unit -> word64) Primitive.Option.t
	       * word32 Primitive.Option.t
	       * 'a_3899
	       * (word64 -> unit) Primitive.Option.t
	       * (unit -> word64) Primitive.Option.t
	       * ('a_3903 -> word32) Primitive.Option.t
	       * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
	       * ('a_3904 -> word32) Primitive.Option.t
	       * ('a_3904 -> word32 Primitive.Option.t) Primitive.Option.t
	       -> 'a_3905)
	    * ('a_3912 vector -> 'a_3907)
	    * (word32 * 'a_3912 array * word32 * word64 -> word64)
	    * (word32 -> unit)
	    * ('a_3903 -> 'a_3912 PrimSequence.Slice.t)
	    * ('a_3904 -> 'a_3911 PrimSequence.Slice.t)
	    * ('a_3907 -> word32)
	    * (word32 * 'a_3912 array * word32 * word64 -> word64)
	    * (word32 * 'a_3911 vector * word32 * word64 -> word64)
	    -> (word32 * bool * 'a_3906 -> 'a_3910)
	       * (bool * 'a_3900 * word32 * bool * 'a_3899 -> 'a_3905)
	       * (word32 * 'a_3903 -> word32)
	       * (word32 * word32 -> 'a_3907)
	       * (word32 * 'a_3903 -> word32)
	       * (word32 * 'a_3904 -> word32) = 
	 fn x_1607: ((unit -> word32 Primitive.Option.t)
		     * 'a_3908 Primitive.Option.t
		     * 'a_3909 Primitive.Option.t
		     * word32
		     * (unit -> unit)
		     * (unit -> word64) Primitive.Option.t
		     * (unit -> word64) Primitive.Option.t
		     * word32 Primitive.Option.t
		     * 'a_3906
		     * ('a_3903 -> word32) Primitive.Option.t
		     * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
		     * (word32 -> 'a_3907) Primitive.Option.t
		     * (word32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t
		     * (word64 -> unit) Primitive.Option.t
		     * (unit -> word64) Primitive.Option.t
		     -> 'a_3910)
		    * ('a_3901 Primitive.Option.t
		       * 'a_3902 Primitive.Option.t
		       * 'a_3900
		       * (unit -> unit)
		       * (unit -> word64) Primitive.Option.t
		       * (unit -> word64) Primitive.Option.t
		       * word32 Primitive.Option.t
		       * 'a_3899
		       * (word64 -> unit) Primitive.Option.t
		       * (unit -> word64) Primitive.Option.t
		       * ('a_3903 -> word32) Primitive.Option.t
		       * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
		       * ('a_3904 -> word32) Primitive.Option.t
		       * ('a_3904 -> word32 Primitive.Option.t) Primitive.Option.t
		       -> 'a_3905)
		    * ('a_3912 vector -> 'a_3907)
		    * (word32 * 'a_3912 array * word32 * word64 -> word64)
		    * (word32 -> unit)
		    * ('a_3903 -> 'a_3912 PrimSequence.Slice.t)
		    * ('a_3904 -> 'a_3911 PrimSequence.Slice.t)
		    * ('a_3907 -> word32)
		    * (word32 * 'a_3912 array * word32 * word64 -> word64)
		    * (word32 * 'a_3911 vector * word32 * word64 -> word64) => 
	 let
	    val writeVec: word32 * 'a_3911 vector * word32 * word64 -> word64 = 
	       #9 x_1607
	    val writeArr: word32 * 'a_3912 array * word32 * word64 -> word64 = 
	       #8 x_1607
	    val vectorLength: 'a_3907 -> word32 = 
	       #7 x_1607
	    val toVectorSlice: 'a_3904 -> 'a_3911 PrimSequence.Slice.t = 
	       #6 x_1607
	    val toArraySlice: 'a_3903 -> 'a_3912 PrimSequence.Slice.t = 
	       #5 x_1607
	    val readArr: word32 * 'a_3912 array * word32 * word64 -> word64 = 
	       #3 x_1607
	    val fromVector: 'a_3912 vector -> 'a_3907 = 
	       #2 x_1607
	    val WR: 'a_3901 Primitive.Option.t
		    * 'a_3902 Primitive.Option.t
		    * 'a_3900
		    * (unit -> unit)
		    * (unit -> word64) Primitive.Option.t
		    * (unit -> word64) Primitive.Option.t
		    * word32 Primitive.Option.t
		    * 'a_3899
		    * (word64 -> unit) Primitive.Option.t
		    * (unit -> word64) Primitive.Option.t
		    * ('a_3903 -> word32) Primitive.Option.t
		    * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
		    * ('a_3904 -> word32) Primitive.Option.t
		    * ('a_3904 -> word32 Primitive.Option.t) Primitive.Option.t
		    -> 'a_3905 = 
	       #1 x_1607
	    val RD: (unit -> word32 Primitive.Option.t)
		    * 'a_3908 Primitive.Option.t
		    * 'a_3909 Primitive.Option.t
		    * word32
		    * (unit -> unit)
		    * (unit -> word64) Primitive.Option.t
		    * (unit -> word64) Primitive.Option.t
		    * word32 Primitive.Option.t
		    * 'a_3906
		    * ('a_3903 -> word32) Primitive.Option.t
		    * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
		    * (word32 -> 'a_3907) Primitive.Option.t
		    * (word32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t
		    * (word64 -> unit) Primitive.Option.t
		    * (unit -> word64) Primitive.Option.t
		    -> 'a_3910 = 
	       #0 x_1607
	    val primReadArr: word32 * 'a_3912 array * word32 * word32 -> word64 = 
	       fn x_1647: word32 * 'a_3912 array * word32 * word32 => 
	       let
		  val sz: word32 = 
		     #3 x_1647
		  val i: word32 = 
		     #2 x_1647
		  val buf: 'a_3912 array = 
		     #1 x_1647
		  val fd: word32 = 
		     #0 x_1647
		  val x_7013: word32 = 
		     toRep fd
		  val x_7014: word32 = 
		     sextdFromInt32ToInt32 i
		  val x_7015: word64 = 
		     sextdFromInt32ToWord64 sz
		  val x_7016: word32 * 'a_3912 array * word32 * word64 = 
		     (x_7013, buf, x_7014, x_7015)
		  val x_7017: word64 = 
		     readArr x_7016
	       in
		  x_7017
	       end
	    val setMode: word32 -> unit = 
	       fn x_1644: word32 => 
	       let
		  val x_7018: unit = 
		     ()
	       in
		  x_7018
	       end
	    val rec 
	       readArr: word32 * 'a_3903 -> word32 = 
		  fn x_1642: word32 * 'a_3903 => 
		  let
		     val sl: 'a_3903 = 
			#1 x_1642
		     val fd: word32 = 
			#0 x_1642
		     val x_7019: 'a_3912 PrimSequence.Slice.t = 
			toArraySlice sl
		     val x_7020: 'a_3912 array * word32 * word32 = 
			base_9 ('a_3912) x_7019
		     val sz: word32 = 
			#2 x_7020
		     val i: word32 = 
			#1 x_7020
		     val buf: 'a_3912 array = 
			#0 x_7020
		     val x_7021: word64 = 
			0xFFFFFFFFFFFFFFFF
		     val x_7022: word64 = 
			sextdFromInt64ToInt64 x_7021
		     val x_7023: unit -> word64 = 
			fn x_1643: unit => 
			let
			   val x_7024: word32 * 'a_3912 array * word32 * word32 = 
			      (fd, buf, i, sz)
			   val x_7025: word64 = 
			      primReadArr x_7024
			in
			   x_7025
			end
		     val x_7026: word64 * (unit -> word64) = 
			(x_7022, x_7023)
		     val bytesRead: word64 = 
			simpleResultRestart'_0 (word64) x_7026
		     val bytesRead: word32 = 
			schckFromInt64ToInt32 bytesRead
		  in
		     bytesRead
		  end
	    val rec 
	       readVec: word32 * word32 -> 'a_3907 = 
		  fn x_1640: word32 * word32 => 
		  let
		     val n: word32 = 
			#1 x_1640
		     val fd: word32 = 
			#0 x_1640
		     val buf: 'a_3912 array = 
			arrayUninit_0 ('a_3912) n
		     val x_7027: word64 = 
			0xFFFFFFFFFFFFFFFF
		     val x_7028: word64 = 
			sextdFromInt64ToInt64 x_7027
		     val x_7029: unit -> word64 = 
			fn x_1641: unit => 
			let
			   val x_7030: word32 = 
			      0x0
			   val x_7031: word32 * 'a_3912 array * word32 * word32 = 
			      (fd, buf, x_7030, n)
			   val x_7032: word64 = 
			      primReadArr x_7031
			in
			   x_7032
			end
		     val x_7033: word64 * (unit -> word64) = 
			(x_7028, x_7029)
		     val bytesRead: word64 = 
			simpleResultRestart'_0 (word64) x_7033
		     val bytesRead: word32 = 
			schckFromInt64ToInt32 bytesRead
		     val x_7034: word32 * word32 = 
			(n, bytesRead)
		     val x_7035: bool = 
			= (word32) x_7034
		     val x_7036: 'a_3912 vector = 
			case x_7035 of
			true => 
			   let
			      val x_7042: 'a_3912 vector = 
				 unsafeFromArray_0 ('a_3912) buf
			   in
			      x_7042
			   end
			false => 
			   let
			      val x_7037: word32 = 
				 0x0
			      val x_7038: word32 Primitive.Option.t = 
				 SOME[word32] bytesRead
			      val x_7039: 'a_3912 array
					  * word32
					  * word32 Primitive.Option.t = 
				 (buf, x_7037, x_7038)
			      val x_7040: 'a_3912 PrimSequence.Slice.t = 
				 slice_5 ('a_3912) x_7039
			      val x_7041: 'a_3912 vector = 
				 vector_3 ('a_3912) x_7040
			   in
			      x_7041
			   end
		     val x_7043: 'a_3907 = 
			fromVector x_7036
		  in
		     x_7043
		  end
	    val rec 
	       writeArr: word32 * 'a_3903 -> word32 = 
		  fn x_1638: word32 * 'a_3903 => 
		  let
		     val sl: 'a_3903 = 
			#1 x_1638
		     val fd: word32 = 
			#0 x_1638
		     val x_7044: 'a_3912 PrimSequence.Slice.t = 
			toArraySlice sl
		     val x_7045: 'a_3912 array * word32 * word32 = 
			base_9 ('a_3912) x_7044
		     val sz: word32 = 
			#2 x_7045
		     val i: word32 = 
			#1 x_7045
		     val buf: 'a_3912 array = 
			#0 x_7045
		     val x_7046: word64 = 
			0xFFFFFFFFFFFFFFFF
		     val x_7047: word64 = 
			sextdFromInt64ToInt64 x_7046
		     val x_7048: unit -> word64 = 
			fn x_1639: unit => 
			let
			   val x_7049: word32 = 
			      toRep fd
			   val x_7050: word32 = 
			      sextdFromInt32ToInt32 i
			   val x_7051: word64 = 
			      sextdFromInt32ToWord64 sz
			   val x_7052: word32 * 'a_3912 array * word32 * word64 = 
			      (x_7049, buf, x_7050, x_7051)
			   val x_7053: word64 = 
			      writeArr x_7052
			in
			   x_7053
			end
		     val x_7054: word64 * (unit -> word64) = 
			(x_7047, x_7048)
		     val bytesWrote: word64 = 
			simpleResultRestart'_0 (word64) x_7054
		     val bytesWrote: word32 = 
			schckFromInt64ToInt32 bytesWrote
		  in
		     bytesWrote
		  end
	    val rec 
	       writeVec: word32 * 'a_3904 -> word32 = 
		  fn x_1636: word32 * 'a_3904 => 
		  let
		     val sl: 'a_3904 = 
			#1 x_1636
		     val fd: word32 = 
			#0 x_1636
		     val x_7055: 'a_3911 PrimSequence.Slice.t = 
			toVectorSlice sl
		     val x_7056: 'a_3911 vector * word32 * word32 = 
			base_5 ('a_3911) x_7055
		     val sz: word32 = 
			#2 x_7056
		     val i: word32 = 
			#1 x_7056
		     val buf: 'a_3911 vector = 
			#0 x_7056
		     val x_7057: word64 = 
			0xFFFFFFFFFFFFFFFF
		     val x_7058: word64 = 
			sextdFromInt64ToInt64 x_7057
		     val x_7059: unit -> word64 = 
			fn x_1637: unit => 
			let
			   val x_7060: word32 = 
			      toRep fd
			   val x_7061: word32 = 
			      sextdFromInt32ToInt32 i
			   val x_7062: word64 = 
			      sextdFromInt32ToWord64 sz
			   val x_7063: word32 * 'a_3911 vector * word32 * word64 = 
			      (x_7060, buf, x_7061, x_7062)
			   val x_7064: word64 = 
			      writeVec x_7063
			in
			   x_7064
			end
		     val x_7065: word64 * (unit -> word64) = 
			(x_7058, x_7059)
		     val bytesWrote: word64 = 
			simpleResultRestart'_0 (word64) x_7065
		     val bytesWrote: word32 = 
			schckFromInt64ToInt32 bytesWrote
		  in
		     bytesWrote
		  end
	    val rec 
	       mkReader: word32 * bool * 'a_3906 -> 'a_3910 = 
		  fn x_1621: word32 * bool * 'a_3906 => 
		  let
		     val name: 'a_3906 = 
			#2 x_1621
		     val initBlkMode: bool = 
			#1 x_1621
		     val fd: word32 = 
			#0 x_1621
		     val x_7066: bool = 
			false
		     val closed: bool ref = 
			Ref_ref[bool] (x_7066)
		     val x_7067: bool ref * word32 = 
			(closed, fd)
		     val x_7068: (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word64 ref
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t = 
			posFns x_7067
		     val verifyPos: (unit -> word64) Primitive.Option.t = 
			#4 x_7068
		     val setPos: (word64 -> unit) Primitive.Option.t = 
			#3 x_7068
		     val pos: word64 ref = 
			#2 x_7068
		     val getPos: (unit -> word64) Primitive.Option.t = 
			#1 x_7068
		     val endPos: (unit -> word64) Primitive.Option.t = 
			#0 x_7068
		     val blocking: bool ref = 
			Ref_ref[bool] (initBlkMode)
		     val rec 
			ensureOpen: unit -> unit = 
			   fn x_1633: unit => 
			   let
			      val x_7069: bool = 
				 !_1 (bool) closed
			      val x_7070: unit = 
				 case x_7069 of
				 true => 
				    let
				       val x_7072: exn = 
					  ClosedStream
				       val x_7073: unit = 
					  raise x_7072
				    in
				       x_7073
				    end
				 false => 
				    let
				       val x_7071: unit = 
					  ()
				    in
				       x_7071
				    end
			   in
			      x_7070
			   end
		     val rec 
			incPos: word32 -> unit = 
			   fn x_1632: word32 => 
			   let
			      val x_7074: word64 = 
				 !_1 (word64) pos
			      val x_7075: word64 = 
				 sextdFromInt32ToInt64 x_1632
			      val x_7076: word64 * word64 = 
				 (x_7074, x_7075)
			      val x_7077: word64 = 
				 +! x_7076
			      val x_7078: word64 ref * word64 = 
				 (pos, x_7077)
			      val x_7079: unit = 
				 :=_1 (word64) x_7078
			   in
			      x_7079
			   end
		     val readVec: word32 -> 'a_3907 = 
			fn x_1631: word32 => 
			let
			   val x_7080: word32 * word32 = 
			      (fd, x_1631)
			   val v: 'a_3907 = 
			      readVec x_7080
			   val x_7081: word32 = 
			      vectorLength v
			   val x_7082: unit = 
			      incPos x_7081
			in
			   v
			end
		     val readArr: 'a_3903 -> word32 = 
			fn x_1630: 'a_3903 => 
			let
			   val x_7083: word32 * 'a_3903 = 
			      (fd, x_1630)
			   val k: word32 = 
			      readArr x_7083
			   val x_7084: unit = 
			      incPos k
			in
			   k
			end
		     val rec ('a_3892, 'a_3891) 
			blockWrap: ('a_3891 -> 'a_3892) -> 'a_3891 -> 'a_3892 = 
			   fn x_1628: 'a_3891 -> 'a_3892 => 
			   let
			      val x_7085: 'a_3891 -> 'a_3892 = 
				 fn x_1629: 'a_3891 => 
				 let
				    val x_7086: unit = 
				       ()
				    val x_7087: unit = 
				       ensureOpen x_7086
				    val x_7088: bool = 
				       !_1 (bool) blocking
				    val x_7089: unit = 
				       case x_7088 of
				       true => 
					  let
					     val x_7097: unit = 
						()
					  in
					     x_7097
					  end
				       false => 
					  let
					     val x_7090: word32 list = 
						nil[word32]
					     val x_7091: word32 = 
						flags x_7090
					     val x_7092: word32 * word32 = 
						(fd, x_7091)
					     val x_7093: unit = 
						setfl x_7092
					     val x_7094: bool = 
						true
					     val x_7095: bool ref * bool = 
						(blocking, x_7094)
					     val x_7096: unit = 
						:=_1 (bool) x_7095
					  in
					     x_7096
					  end
				    val x_7098: 'a_3892 = 
				       x_1628 x_1629
				 in
				    x_7098
				 end
			   in
			      x_7085
			   end
		     val rec ('a_3894, 'a_3893) 
			noBlockWrap: ('a_3893 -> 'a_3894)
				     -> 'a_3893 -> 'a_3894 Primitive.Option.t = 
			   fn x_1625: 'a_3893 -> 'a_3894 => 
			   let
			      val x_7099: 'a_3893 -> 'a_3894 Primitive.Option.t = 
				 fn x_1626: 'a_3893 => 
				 let
				    val x_7100: unit = 
				       ()
				    val x_7101: unit = 
				       ensureOpen x_7100
				    val x_7102: bool = 
				       !_1 (bool) blocking
				    val x_7103: unit = 
				       case x_7102 of
				       true => 
					  let
					     val x_7105: word32 * word32 = 
						(fd, NONBLOCK)
					     val x_7106: unit = 
						setfl x_7105
					     val x_7107: bool = 
						false
					     val x_7108: bool ref * bool = 
						(blocking, x_7107)
					     val x_7109: unit = 
						:=_1 (bool) x_7108
					  in
					     x_7109
					  end
				       false => 
					  let
					     val x_7104: unit = 
						()
					  in
					     x_7104
					  end
				    val x_7110: 'a_3894 Primitive.Option.t = 
				       let
					  val x_7111: 'a_3894 = 
					     x_1625 x_1626
					  val x_7112: 'a_3894 Primitive.Option.t = 
					     SOME['a_3894] x_7111
				       in
					  x_7112
				       end
				       handle x_1627 => let
							   val x_7113: exn
								       -> 'a_3894 Primitive.Option.t = 
							      fn x_7114: exn => 
							      let
								 val x_7115: 'a_3894 Primitive.Option.t = 
								    raise x_7114
							      in
								 x_7115
							      end
							   val x_7116: 'a_3894 Primitive.Option.t = 
							      case x_1627 of
							      SysErr x_7117: word8 vector
									     * word32 Primitive.Option.t => 
								 let
								    val x_7118: word32 Primitive.Option.t = 
								       #1 x_7117
								    val x_7119: 'a_3894 Primitive.Option.t = 
								       case x_7118 of
								       SOME[word32] x_7120: word32 => 
									  let
									     val x_7121: word32
											 * word32 = 
										(x_7120,
										 again)
									     val x_7122: bool = 
										= (word32) x_7121
									     val x_7123: 'a_3894 Primitive.Option.t = 
										case x_7122 of
										true => 
										   let
										      val x_7125: 'a_3894 Primitive.Option.t = 
											 NONE['a_3894]
										   in
										      x_7125
										   end
										false => 
										   let
										      val x_7124: 'a_3894 Primitive.Option.t = 
											 raise x_1627
										   in
										      x_7124
										   end
									  in
									     x_7123
									  end
									 _ => let
										 val x_7126: 'a_3894 Primitive.Option.t = 
										    x_7113 x_1627
									      in
										 x_7126
									      end
								 in
								    x_7119
								 end
								_ => let
									val x_7127: 'a_3894 Primitive.Option.t = 
									   x_7113 x_1627
								     in
									x_7127
								     end
							in
							   x_7116
							end
				 in
				    x_7110
				 end
			   in
			      x_7099
			   end
		     val close: unit -> unit = 
			fn x_1624: unit => 
			let
			   val x_7128: bool = 
			      !_1 (bool) closed
			   val x_7129: unit = 
			      case x_7128 of
			      true => 
				 let
				    val x_7134: unit = 
				       ()
				 in
				    x_7134
				 end
			      false => 
				 let
				    val x_7130: bool = 
				       true
				    val x_7131: bool ref * bool = 
				       (closed, x_7130)
				    val x_7132: unit = 
				       :=_1 (bool) x_7131
				    val x_7133: unit = 
				       close fd
				 in
				    x_7133
				 end
			in
			   x_7129
			end
		     val x_7135: bool = 
			isReg fd
		     val x_7136: unit -> word32 Primitive.Option.t = 
			case x_7135 of
			true => 
			   let
			      val x_7143: unit -> word32 Primitive.Option.t = 
				 fn x_1622: unit => 
				 let
				    val x_7144: bool = 
				       !_1 (bool) closed
				    val x_7145: word32 Primitive.Option.t = 
				       case x_7144 of
				       true => 
					  let
					     val x_7153: word32 = 
						0x0
					     val x_7154: word32 Primitive.Option.t = 
						SOME[word32] x_7153
					  in
					     x_7154
					  end
				       false => 
					  let
					     val x_7146: PosixFileSys.ST.stat = 
						fstat fd
					     val x_7147: word64 = 
						size x_7146
					     val x_7148: word64 = 
						!_1 (word64) pos
					     val x_7149: word64 * word64 = 
						(x_7147, x_7148)
					     val x_7150: word64 = 
						-! x_7149
					     val x_7151: word32 = 
						schckFromInt64ToInt32 x_7150
					     val x_7152: word32 Primitive.Option.t = 
						SOME[word32] x_7151
					  in
					     x_7152
					  end
				 in
				    x_7145
				 end
			   in
			      x_7143
			   end
			false => 
			   let
			      val x_7137: unit -> word32 Primitive.Option.t = 
				 fn x_1623: unit => 
				 let
				    val x_7138: bool = 
				       !_1 (bool) closed
				    val x_7139: word32 Primitive.Option.t = 
				       case x_7138 of
				       true => 
					  let
					     val x_7141: word32 = 
						0x0
					     val x_7142: word32 Primitive.Option.t = 
						SOME[word32] x_7141
					  in
					     x_7142
					  end
				       false => 
					  let
					     val x_7140: word32 Primitive.Option.t = 
						NONE[word32]
					  in
					     x_7140
					  end
				 in
				    x_7139
				 end
			   in
			      x_7137
			   end
		     val x_7155: unit = 
			setMode fd
		     val x_7156: 'a_3908 Primitive.Option.t = 
			NONE['a_3908]
		     val x_7157: 'a_3909 Primitive.Option.t = 
			NONE['a_3909]
		     val x_7158: word32 = 
			sextdFromInt32ToInt32 bufSize
		     val x_7159: word32 = 
			fdToIOD fd
		     val x_7160: word32 Primitive.Option.t = 
			SOME[word32] x_7159
		     val x_7161: 'a_3903 -> word32 = 
			blockWrap (word32, 'a_3903) readArr
		     val x_7162: ('a_3903 -> word32) Primitive.Option.t = 
			SOME['a_3903 -> word32] x_7161
		     val x_7163: 'a_3903 -> word32 Primitive.Option.t = 
			noBlockWrap (word32, 'a_3903) readArr
		     val x_7164: ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t = 
			SOME['a_3903 -> word32 Primitive.Option.t] x_7163
		     val x_7165: word32 -> 'a_3907 = 
			blockWrap ('a_3907, word32) readVec
		     val x_7166: (word32 -> 'a_3907) Primitive.Option.t = 
			SOME[word32 -> 'a_3907] x_7165
		     val x_7167: word32 -> 'a_3907 Primitive.Option.t = 
			noBlockWrap ('a_3907, word32) readVec
		     val x_7168: (word32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t = 
			SOME[word32 -> 'a_3907 Primitive.Option.t] x_7167
		     val x_7169: (unit -> word32 Primitive.Option.t)
				 * 'a_3908 Primitive.Option.t
				 * 'a_3909 Primitive.Option.t
				 * word32
				 * (unit -> unit)
				 * (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word32 Primitive.Option.t
				 * 'a_3906
				 * ('a_3903 -> word32) Primitive.Option.t
				 * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
				 * (word32 -> 'a_3907) Primitive.Option.t
				 * (word32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t = 
			(x_7136,
			 x_7156,
			 x_7157,
			 x_7158,
			 close,
			 endPos,
			 getPos,
			 x_7160,
			 name,
			 x_7162,
			 x_7164,
			 x_7166,
			 x_7168,
			 setPos,
			 verifyPos)
		     val x_7170: 'a_3910 = 
			RD x_7169
		  in
		     x_7170
		  end
	    val rec 
	       mkWriter: bool * 'a_3900 * word32 * bool * 'a_3899 -> 'a_3905 = 
		  fn x_1608: bool * 'a_3900 * word32 * bool * 'a_3899 => 
		  let
		     val name: 'a_3899 = 
			#4 x_1608
		     val initBlkMode: bool = 
			#3 x_1608
		     val fd: word32 = 
			#2 x_1608
		     val chunkSize: 'a_3900 = 
			#1 x_1608
		     val appendMode: bool = 
			#0 x_1608
		     val x_7171: bool = 
			false
		     val closed: bool ref = 
			Ref_ref[bool] (x_7171)
		     val x_7172: bool ref * word32 = 
			(closed, fd)
		     val x_7173: (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word64 ref
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t = 
			posFns x_7172
		     val verifyPos: (unit -> word64) Primitive.Option.t = 
			#4 x_7173
		     val setPos: (word64 -> unit) Primitive.Option.t = 
			#3 x_7173
		     val pos: word64 ref = 
			#2 x_7173
		     val getPos: (unit -> word64) Primitive.Option.t = 
			#1 x_7173
		     val endPos: (unit -> word64) Primitive.Option.t = 
			#0 x_7173
		     val rec 
			incPos: word32 -> word32 = 
			   fn x_1620: word32 => 
			   let
			      val x_7174: word64 = 
				 !_1 (word64) pos
			      val x_7175: word64 = 
				 sextdFromInt32ToInt64 x_1620
			      val x_7176: word64 * word64 = 
				 (x_7174, x_7175)
			      val x_7177: word64 = 
				 +! x_7176
			      val x_7178: word64 ref * word64 = 
				 (pos, x_7177)
			      val x_7179: unit = 
				 :=_1 (word64) x_7178
			   in
			      x_1620
			   end
		     val blocking: bool ref = 
			Ref_ref[bool] (initBlkMode)
		     val x_7180: word32 list = 
			case appendMode of
			true => 
			   let
			      val x_7182: word32 list = 
				 nil[word32]
			      val x_7183: word32 * word32 list = 
				 (APPEND, x_7182)
			      val x_7184: word32 list = 
				 ::[word32] x_7183
			   in
			      x_7184
			   end
			false => 
			   let
			      val x_7181: word32 list = 
				 nil[word32]
			   in
			      x_7181
			   end
		     val appendFlgs: word32 = 
			flags x_7180
		     val rec 
			putV: word32 * 'a_3904 -> word32 = 
			   fn x_1616: word32 * 'a_3904 => 
			   let
			      val x_7185: word32 = 
				 writeVec x_1616
			      val x_7186: word32 = 
				 incPos x_7185
			   in
			      x_7186
			   end
		     val rec 
			putA: word32 * 'a_3903 -> word32 = 
			   fn x_1615: word32 * 'a_3903 => 
			   let
			      val x_7187: word32 = 
				 writeArr x_1615
			      val x_7188: word32 = 
				 incPos x_7187
			   in
			      x_7188
			   end
		     val rec ('a_3896, 'a_3895) 
			write: (word32 * 'a_3895 -> 'a_3896) * bool
			       -> 'a_3895 -> 'a_3896 = 
			   fn x_1613: (word32 * 'a_3895 -> 'a_3896) * bool => 
			   let
			      val x_7189: 'a_3895 -> 'a_3896 = 
				 fn x_1614: 'a_3895 => 
				 let
				    val x_7190: bool = 
				       #1 x_1613
				    val x_7191: word32 * 'a_3895 -> 'a_3896 = 
				       #0 x_1613
				    val x_7192: bool = 
				       !_1 (bool) closed
				    val x_7193: unit = 
				       case x_7192 of
				       true => 
					  let
					     val x_7195: exn = 
						ClosedStream
					     val x_7196: unit = 
						raise x_7195
					  in
					     x_7196
					  end
				       false => 
					  let
					     val x_7194: unit = 
						()
					  in
					     x_7194
					  end
				    val x_7197: bool = 
				       !_1 (bool) blocking
				    val x_7198: unit = 
				       case x_7197 of
				       true => 
					  let
					     val x_7211: unit = 
						()
					  in
					     x_7211
					  end
				       false => 
					  let
					     val x_7199: bool ref * bool = 
						(blocking, x_7190)
					     val x_7200: unit = 
						:=_1 (bool) x_7199
					     val x_7201: bool = 
						!_1 (bool) blocking
					     val x_7202: word32 = 
						case x_7201 of
						true => 
						   let
						   in
						      appendFlgs
						   end
						false => 
						   let
						      val x_7203: word32 list = 
							 nil[word32]
						      val x_7204: word32
								  * word32 list = 
							 (appendFlgs, x_7203)
						      val x_7205: word32 list = 
							 ::[word32] x_7204
						      val x_7206: word32
								  * word32 list = 
							 (NONBLOCK, x_7205)
						      val x_7207: word32 list = 
							 ::[word32] x_7206
						      val x_7208: word32 = 
							 flags x_7207
						   in
						      x_7208
						   end
					     val x_7209: word32 * word32 = 
						(fd, x_7202)
					     val x_7210: unit = 
						setfl x_7209
					  in
					     x_7210
					  end
				    val x_7212: word32 * 'a_3895 = 
				       (fd, x_1614)
				    val x_7213: 'a_3896 = 
				       x_7191 x_7212
				 in
				    x_7213
				 end
			   in
			      x_7189
			   end
		     val rec ('a_3898, 'a_3897) 
			handleBlock: ('a_3897 -> 'a_3898)
				     -> 'a_3897 -> 'a_3898 Primitive.Option.t = 
			   fn x_1610: 'a_3897 -> 'a_3898 => 
			   let
			      val x_7214: 'a_3897 -> 'a_3898 Primitive.Option.t = 
				 fn x_1611: 'a_3897 => 
				 let
				    val x_7215: 'a_3898 Primitive.Option.t = 
				       let
					  val x_7216: 'a_3898 = 
					     x_1610 x_1611
					  val x_7217: 'a_3898 Primitive.Option.t = 
					     SOME['a_3898] x_7216
				       in
					  x_7217
				       end
				       handle x_1612 => let
							   val x_7218: exn
								       -> 'a_3898 Primitive.Option.t = 
							      fn x_7219: exn => 
							      let
								 val x_7220: 'a_3898 Primitive.Option.t = 
								    raise x_7219
							      in
								 x_7220
							      end
							   val x_7221: 'a_3898 Primitive.Option.t = 
							      case x_1612 of
							      SysErr x_7222: word8 vector
									     * word32 Primitive.Option.t => 
								 let
								    val x_7223: word32 Primitive.Option.t = 
								       #1 x_7222
								    val x_7224: 'a_3898 Primitive.Option.t = 
								       case x_7223 of
								       SOME[word32] x_7225: word32 => 
									  let
									     val x_7226: word32
											 * word32 = 
										(x_7225,
										 again)
									     val x_7227: bool = 
										= (word32) x_7226
									     val x_7228: 'a_3898 Primitive.Option.t = 
										case x_7227 of
										true => 
										   let
										      val x_7230: 'a_3898 Primitive.Option.t = 
											 NONE['a_3898]
										   in
										      x_7230
										   end
										false => 
										   let
										      val x_7229: 'a_3898 Primitive.Option.t = 
											 raise x_1612
										   in
										      x_7229
										   end
									  in
									     x_7228
									  end
									 _ => let
										 val x_7231: 'a_3898 Primitive.Option.t = 
										    x_7218 x_1612
									      in
										 x_7231
									      end
								 in
								    x_7224
								 end
								_ => let
									val x_7232: 'a_3898 Primitive.Option.t = 
									   x_7218 x_1612
								     in
									x_7232
								     end
							in
							   x_7221
							end
				 in
				    x_7215
				 end
			   in
			      x_7214
			   end
		     val close: unit -> unit = 
			fn x_1609: unit => 
			let
			   val x_7233: bool = 
			      !_1 (bool) closed
			   val x_7234: unit = 
			      case x_7233 of
			      true => 
				 let
				    val x_7239: unit = 
				       ()
				 in
				    x_7239
				 end
			      false => 
				 let
				    val x_7235: bool = 
				       true
				    val x_7236: bool ref * bool = 
				       (closed, x_7235)
				    val x_7237: unit = 
				       :=_1 (bool) x_7236
				    val x_7238: unit = 
				       close fd
				 in
				    x_7238
				 end
			in
			   x_7234
			end
		     val x_7240: unit = 
			setMode fd
		     val x_7241: 'a_3901 Primitive.Option.t = 
			NONE['a_3901]
		     val x_7242: 'a_3902 Primitive.Option.t = 
			NONE['a_3902]
		     val x_7243: word32 = 
			fdToIOD fd
		     val x_7244: word32 Primitive.Option.t = 
			SOME[word32] x_7243
		     val x_7245: bool = 
			true
		     val x_7246: (word32 * 'a_3903 -> word32) * bool = 
			(putA, x_7245)
		     val x_7247: 'a_3903 -> word32 = 
			write (word32, 'a_3903) x_7246
		     val x_7248: ('a_3903 -> word32) Primitive.Option.t = 
			SOME['a_3903 -> word32] x_7247
		     val x_7249: bool = 
			false
		     val x_7250: (word32 * 'a_3903 -> word32) * bool = 
			(putA, x_7249)
		     val x_7251: 'a_3903 -> word32 = 
			write (word32, 'a_3903) x_7250
		     val x_7252: 'a_3903 -> word32 Primitive.Option.t = 
			handleBlock (word32, 'a_3903) x_7251
		     val x_7253: ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t = 
			SOME['a_3903 -> word32 Primitive.Option.t] x_7252
		     val x_7254: bool = 
			true
		     val x_7255: (word32 * 'a_3904 -> word32) * bool = 
			(putV, x_7254)
		     val x_7256: 'a_3904 -> word32 = 
			write (word32, 'a_3904) x_7255
		     val x_7257: ('a_3904 -> word32) Primitive.Option.t = 
			SOME['a_3904 -> word32] x_7256
		     val x_7258: bool = 
			false
		     val x_7259: (word32 * 'a_3904 -> word32) * bool = 
			(putV, x_7258)
		     val x_7260: 'a_3904 -> word32 = 
			write (word32, 'a_3904) x_7259
		     val x_7261: 'a_3904 -> word32 Primitive.Option.t = 
			handleBlock (word32, 'a_3904) x_7260
		     val x_7262: ('a_3904 -> word32 Primitive.Option.t) Primitive.Option.t = 
			SOME['a_3904 -> word32 Primitive.Option.t] x_7261
		     val x_7263: 'a_3901 Primitive.Option.t
				 * 'a_3902 Primitive.Option.t
				 * 'a_3900
				 * (unit -> unit)
				 * (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word32 Primitive.Option.t
				 * 'a_3899
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * ('a_3903 -> word32) Primitive.Option.t
				 * ('a_3903 -> word32 Primitive.Option.t) Primitive.Option.t
				 * ('a_3904 -> word32) Primitive.Option.t
				 * ('a_3904 -> word32 Primitive.Option.t) Primitive.Option.t = 
			(x_7241,
			 x_7242,
			 chunkSize,
			 close,
			 endPos,
			 getPos,
			 x_7244,
			 name,
			 setPos,
			 verifyPos,
			 x_7248,
			 x_7253,
			 x_7257,
			 x_7262)
		     val x_7264: 'a_3905 = 
			WR x_7263
		  in
		     x_7264
		  end
	    val x_7265: (word32 * bool * 'a_3906 -> 'a_3910)
			* (bool * 'a_3900 * word32 * bool * 'a_3899 -> 'a_3905)
			* (word32 * 'a_3903 -> word32)
			* (word32 * word32 -> 'a_3907)
			* (word32 * 'a_3903 -> word32)
			* (word32 * 'a_3904 -> word32) = 
	       (mkReader, mkWriter, readArr, readVec, writeArr, writeVec)
	 in
	    x_7265
	 end
   val x_7266: (unit -> word32 Primitive.Option.t)
	       * (unit -> unit) Primitive.Option.t
	       * (unit -> bool) Primitive.Option.t
	       * word32
	       * (unit -> unit)
	       * (unit -> word64) Primitive.Option.t
	       * (unit -> word64) Primitive.Option.t
	       * word32 Primitive.Option.t
	       * word8 vector
	       * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
	       * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
	       * (word32 -> word8 vector) Primitive.Option.t
	       * (word32 -> word8 vector Primitive.Option.t) Primitive.Option.t
	       * (word64 -> unit) Primitive.Option.t
	       * (unit -> word64) Primitive.Option.t
	       -> PrimIO.reader = 
      fn x_7267: (unit -> word32 Primitive.Option.t)
		 * (unit -> unit) Primitive.Option.t
		 * (unit -> bool) Primitive.Option.t
		 * word32
		 * (unit -> unit)
		 * (unit -> word64) Primitive.Option.t
		 * (unit -> word64) Primitive.Option.t
		 * word32 Primitive.Option.t
		 * word8 vector
		 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		 * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		 * (word32 -> word8 vector) Primitive.Option.t
		 * (word32 -> word8 vector Primitive.Option.t) Primitive.Option.t
		 * (word64 -> unit) Primitive.Option.t
		 * (unit -> word64) Primitive.Option.t => 
      let
	 val x_7268: PrimIO.reader = 
	    RD x_7267
      in
	 x_7268
      end
   val x_7269: (unit -> unit) Primitive.Option.t
	       * (unit -> bool) Primitive.Option.t
	       * word32
	       * (unit -> unit)
	       * (unit -> word64) Primitive.Option.t
	       * (unit -> word64) Primitive.Option.t
	       * word32 Primitive.Option.t
	       * word8 vector
	       * (word64 -> unit) Primitive.Option.t
	       * (unit -> word64) Primitive.Option.t
	       * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
	       * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
	       * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
	       * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
	       -> PrimIO.writer = 
      fn x_7270: (unit -> unit) Primitive.Option.t
		 * (unit -> bool) Primitive.Option.t
		 * word32
		 * (unit -> unit)
		 * (unit -> word64) Primitive.Option.t
		 * (unit -> word64) Primitive.Option.t
		 * word32 Primitive.Option.t
		 * word8 vector
		 * (word64 -> unit) Primitive.Option.t
		 * (unit -> word64) Primitive.Option.t
		 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		 * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		 * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t => 
      let
	 val x_7271: PrimIO.writer = 
	    WR x_7270
      in
	 x_7271
      end
   val x_7272: word8 vector -> word8 vector = 
      fn x_1648: word8 vector => 
      let
      in
	 x_1648
      end
   val x_7273: ((unit -> word32 Primitive.Option.t)
		* (unit -> unit) Primitive.Option.t
		* (unit -> bool) Primitive.Option.t
		* word32
		* (unit -> unit)
		* (unit -> word64) Primitive.Option.t
		* (unit -> word64) Primitive.Option.t
		* word32 Primitive.Option.t
		* word8 vector
		* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		* (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		* (word32 -> word8 vector) Primitive.Option.t
		* (word32 -> word8 vector Primitive.Option.t) Primitive.Option.t
		* (word64 -> unit) Primitive.Option.t
		* (unit -> word64) Primitive.Option.t
		-> PrimIO.reader)
	       * ((unit -> unit) Primitive.Option.t
		  * (unit -> bool) Primitive.Option.t
		  * word32
		  * (unit -> unit)
		  * (unit -> word64) Primitive.Option.t
		  * (unit -> word64) Primitive.Option.t
		  * word32 Primitive.Option.t
		  * word8 vector
		  * (word64 -> unit) Primitive.Option.t
		  * (unit -> word64) Primitive.Option.t
		  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		  * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		  * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		  -> PrimIO.writer)
	       * (word8 vector -> word8 vector)
	       * (word32 * word8 array * word32 * word64 -> word64)
	       * (word32 -> unit)
	       * (word8 PrimSequence.Slice.t -> word8 PrimSequence.Slice.t)
	       * (word8 PrimSequence.Slice.t -> word8 PrimSequence.Slice.t)
	       * (word8 vector -> word32)
	       * (word32 * word8 array * word32 * word64 -> word64)
	       * (word32 * word8 vector * word32 * word64 -> word64) = 
      (x_7266,
       x_7269,
       x_7272,
       readChar8,
       settext,
       toPoly (word8 PrimSequence.Slice.t),
       toPoly (word8 PrimSequence.Slice.t),
       length_9 (word8),
       writeChar8Arr,
       writeChar8Vec)
   val x_7274: (word32 * bool * word8 vector -> PrimIO.reader)
	       * (bool * word32 * word32 * bool * word8 vector -> PrimIO.writer)
	       * (word32 * word8 PrimSequence.Slice.t -> word32)
	       * (word32 * word32 -> word8 vector)
	       * (word32 * word8 PrimSequence.Slice.t -> word32)
	       * (word32 * word8 PrimSequence.Slice.t -> word32) = 
      make (word8,
	    word8,
	    PrimIO.reader,
	    unit -> bool,
	    unit -> unit,
	    word8 vector,
	    word8 vector,
	    PrimIO.writer,
	    word8 PrimSequence.Slice.t,
	    word8 PrimSequence.Slice.t,
	    unit -> bool,
	    unit -> unit,
	    word32,
	    word8 vector) x_7273
   val x_7275: bool * word32 * word32 * bool * word8 vector -> PrimIO.writer = 
      #1 x_7274
   val chunkSize: word32 = 
      sextdFromInt32ToInt32 bufSize
   val x_7276: word8 -> bool = 
      fn x_1649: word8 => 
      let
	 val x_7277: word8 = 
	    0xA
	 val x_7278: word8 * word8 = 
	    (x_1649, x_7277)
	 val x_7279: bool = 
	    = (word8) x_7278
      in
	 x_7279
      end
   val someElem: word8 = 
      0x0
   val rec 'a_3950 
      liftExn: word8 vector -> word8 vector -> exn -> 'a_3950 = 
	 fn x_1650: word8 vector => 
	 let
	    val x_7280: word8 vector -> exn -> 'a_3950 = 
	       fn x_1651: word8 vector => 
	       let
		  val x_7281: exn -> 'a_3950 = 
		     fn x_1652: exn => 
		     let
			val x_7282: exn * word8 vector * word8 vector = 
			   (x_1652, x_1651, x_1650)
			val x_7283: exn = 
			   Io x_7282
			val x_7284: 'a_3950 = 
			   raise x_7283
		     in
			x_7284
		     end
	       in
		  x_7281
	       end
	 in
	    x_7280
	 end
   val rec 
      terminated: StreamIOExtra.state -> bool = 
	 fn x_1656: StreamIOExtra.state => 
	 let
	    val x_7285: bool = 
	       case x_1656 of
	       Active => 
		  let
		     val x_7286: bool = 
			true
		  in
		     x_7286
		  end
		 _ => let
			 val x_7287: bool = 
			    false
		      in
			 x_7287
		      end
	    val x_7288: bool = 
	       not x_7285
	 in
	    x_7288
	 end
   val rec 'a_3951 
      outstreamSel: StreamIOExtra.outstream
		    * (PrimIO.writer
		       * StreamIOExtra.bufferMode ref
		       * StreamIOExtra.state ref
		       * PrimIO.writer
		       -> 'a_3951)
		    -> 'a_3951 = 
	 fn x_1658: StreamIOExtra.outstream
		    * (PrimIO.writer
		       * StreamIOExtra.bufferMode ref
		       * StreamIOExtra.state ref
		       * PrimIO.writer
		       -> 'a_3951) => 
	 let
	    val x_7289: PrimIO.writer
			* StreamIOExtra.bufferMode ref
			* StreamIOExtra.state ref
			* PrimIO.writer
			-> 'a_3951 = 
	       #1 x_1658
	    val x_7290: StreamIOExtra.outstream = 
	       #0 x_1658
	    val x_7291: 'a_3951 = 
	       case x_7290 of
	       Out x_7292: PrimIO.writer
			   * StreamIOExtra.bufferMode ref
			   * StreamIOExtra.state ref
			   * PrimIO.writer => 
		  let
		     val x_7293: 'a_3951 = 
			x_7289 x_7292
		  in
		     x_7293
		  end
	 in
	    x_7291
	 end
   val rec 
      outstreamWriter: StreamIOExtra.outstream -> PrimIO.writer = 
	 fn x_1659: StreamIOExtra.outstream => 
	 let
	    val x_7294: PrimIO.writer
			* StreamIOExtra.bufferMode ref
			* StreamIOExtra.state ref
			* PrimIO.writer
			-> PrimIO.writer = 
	       fn x_1660: PrimIO.writer
			  * StreamIOExtra.bufferMode ref
			  * StreamIOExtra.state ref
			  * PrimIO.writer => 
	       let
		  val x_7295: PrimIO.writer = 
		     #3 x_1660
	       in
		  x_7295
	       end
	    val x_7296: StreamIOExtra.outstream
			* (PrimIO.writer
			   * StreamIOExtra.bufferMode ref
			   * StreamIOExtra.state ref
			   * PrimIO.writer
			   -> PrimIO.writer) = 
	       (x_1659, x_7294)
	    val x_7297: PrimIO.writer = 
	       outstreamSel (PrimIO.writer) x_7296
	 in
	    x_7297
	 end
   val rec 'a_3952 
      writerSel: PrimIO.writer
		 * ((unit -> unit) Primitive.Option.t
		    * (unit -> bool) Primitive.Option.t
		    * word32
		    * (unit -> unit)
		    * (unit -> word64) Primitive.Option.t
		    * (unit -> word64) Primitive.Option.t
		    * word32 Primitive.Option.t
		    * word8 vector
		    * (word64 -> unit) Primitive.Option.t
		    * (unit -> word64) Primitive.Option.t
		    * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		    * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		    * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		    * (word8 PrimSequence.Slice.t -> word32 Primitive.Option.t) Primitive.Option.t
		    -> 'a_3952)
		 -> 'a_3952 = 
	 fn x_1661: PrimIO.writer
		    * ((unit -> unit) Primitive.Option.t
		       * (unit -> bool) Primitive.Option.t
		       * word32
		       * (unit -> unit)
		       * (unit -> word64) Primitive.Option.t
		       * (unit -> word64) Primitive.Option.t
		       * word32 Primitive.Option.t
		       * word8 vector
		       * (word64 -> unit) Primitive.Option.t
		       * (unit -> word64) Primitive.Option.t
		       * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		       * (word8 PrimSequence.Slice.t
			  -> word32 Primitive.Option.t) Primitive.Option.t
		       * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
		       * (word8 PrimSequence.Slice.t
			  -> word32 Primitive.Option.t) Primitive.Option.t
		       -> 'a_3952) => 
	 let
	    val x_7298: (unit -> unit) Primitive.Option.t
			* (unit -> bool) Primitive.Option.t
			* word32
			* (unit -> unit)
			* (unit -> word64) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* word32 Primitive.Option.t
			* word8 vector
			* (word64 -> unit) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			* (word8 PrimSequence.Slice.t
			   -> word32 Primitive.Option.t) Primitive.Option.t
			* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			* (word8 PrimSequence.Slice.t
			   -> word32 Primitive.Option.t) Primitive.Option.t
			-> 'a_3952 = 
	       #1 x_1661
	    val x_7299: PrimIO.writer = 
	       #0 x_1661
	    val x_7300: 'a_3952 = 
	       case x_7299 of
	       WR x_7301: (unit -> unit) Primitive.Option.t
			  * (unit -> bool) Primitive.Option.t
			  * word32
			  * (unit -> unit)
			  * (unit -> word64) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * word32 Primitive.Option.t
			  * word8 vector
			  * (word64 -> unit) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t => 
		  let
		     val x_7302: 'a_3952 = 
			x_7298 x_7301
		  in
		     x_7302
		  end
	 in
	    x_7300
	 end
   val rec 
      outstreamName: StreamIOExtra.outstream -> word8 vector = 
	 fn x_1662: StreamIOExtra.outstream => 
	 let
	    val x_7303: PrimIO.writer = 
	       outstreamWriter x_1662
	    val x_7304: (unit -> unit) Primitive.Option.t
			* (unit -> bool) Primitive.Option.t
			* word32
			* (unit -> unit)
			* (unit -> word64) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* word32 Primitive.Option.t
			* word8 vector
			* (word64 -> unit) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			* (word8 PrimSequence.Slice.t
			   -> word32 Primitive.Option.t) Primitive.Option.t
			* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			* (word8 PrimSequence.Slice.t
			   -> word32 Primitive.Option.t) Primitive.Option.t
			-> word8 vector = 
	       fn x_1663: (unit -> unit) Primitive.Option.t
			  * (unit -> bool) Primitive.Option.t
			  * word32
			  * (unit -> unit)
			  * (unit -> word64) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * word32 Primitive.Option.t
			  * word8 vector
			  * (word64 -> unit) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t => 
	       let
		  val x_7305: word8 vector = 
		     #7 x_1663
	       in
		  x_7305
	       end
	    val x_7306: PrimIO.writer
			* ((unit -> unit) Primitive.Option.t
			   * (unit -> bool) Primitive.Option.t
			   * word32
			   * (unit -> unit)
			   * (unit -> word64) Primitive.Option.t
			   * (unit -> word64) Primitive.Option.t
			   * word32 Primitive.Option.t
			   * word8 vector
			   * (word64 -> unit) Primitive.Option.t
			   * (unit -> word64) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t
			      -> word32 Primitive.Option.t) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t
			      -> word32 Primitive.Option.t) Primitive.Option.t
			   -> word8 vector) = 
	       (x_7303, x_7304)
	    val x_7307: word8 vector = 
	       writerSel (word8 vector) x_7306
	 in
	    x_7307
	 end
   val rec ('b, 'a) 
      flushGen: ('a -> word32)
		* ('a -> 'b * word32 * word32)
		* ('b * word32 * word32 Primitive.Option.t -> 'a)
		* 'a
		-> unit = 
	 fn x_1664: ('a -> word32)
		    * ('a -> 'b * word32 * word32)
		    * ('b * word32 * word32 Primitive.Option.t -> 'a)
		    * 'a => 
	 let
	    val a: 'a = 
	       #3 x_1664
	    val slice: 'b * word32 * word32 Primitive.Option.t -> 'a = 
	       #2 x_1664
	    val base: 'a -> 'b * word32 * word32 = 
	       #1 x_1664
	    val write: 'a -> word32 = 
	       #0 x_1664
	    val x_7308: 'b * word32 * word32 = 
	       base a
	    val sz: word32 = 
	       #2 x_7308
	    val i: word32 = 
	       #1 x_7308
	    val b: 'b = 
	       #0 x_7308
	    val x_7309: word32 * word32 = 
	       (i, sz)
	    val max: word32 = 
	       +! x_7309
	    val rec 
	       loop: word32 -> unit = 
		  fn x_1665: word32 => 
		  let
		     val x_7310: word32 * word32 = 
			(x_1665, max)
		     val x_7311: bool = 
			= (word32) x_7310
		     val x_7312: unit = 
			case x_7311 of
			true => 
			   let
			      val x_7328: unit = 
				 ()
			   in
			      x_7328
			   end
			false => 
			   let
			      val x_7313: word32 * word32 = 
				 (max, x_1665)
			      val x_7314: word32 = 
				 -! x_7313
			      val x_7315: word32 Primitive.Option.t = 
				 SOME[word32] x_7314
			      val x_7316: 'b
					  * word32
					  * word32 Primitive.Option.t = 
				 (b, x_1665, x_7315)
			      val x_7317: 'a = 
				 slice x_7316
			      val j: word32 = 
				 write x_7317
			      val x_7318: word32 = 
				 0x0
			      val x_7319: word32 * word32 = 
				 (j, x_7318)
			      val x_7320: bool = 
				 = (word32) x_7319
			      val x_7321: unit = 
				 case x_7320 of
				 true => 
				    let
				       val x_7325: word8 vector = 
					  "partial write"
				       val x_7326: exn = 
					  Fail x_7325
				       val x_7327: unit = 
					  raise x_7326
				    in
				       x_7327
				    end
				 false => 
				    let
				       val x_7322: word32 * word32 = 
					  (x_1665, j)
				       val x_7323: word32 = 
					  +! x_7322
				       val x_7324: unit = 
					  loop x_7323
				    in
				       x_7324
				    end
			   in
			      x_7321
			   end
		  in
		     x_7312
		  end
	    val x_7329: unit = 
	       loop i
	 in
	    x_7329
	 end
   val rec 
      flushBuf: PrimIO.writer * StreamIOExtra.buf -> unit = 
	 fn x_1671: PrimIO.writer * StreamIOExtra.buf => 
	 let
	    val x_7330: StreamIOExtra.buf = 
	       #1 x_1671
	    val x_7331: PrimIO.writer = 
	       #0 x_1671
	    val x_7332: unit = 
	       case x_7330 of
	       Buf x_7333: word8 array * word32 ref => 
		  let
		     val x_7334: word32 ref = 
			#1 x_7333
		     val x_7335: word8 array = 
			#0 x_7333
		     val size': word32 = 
			!_1 (word32) x_7334
		     val x_7336: word32 = 
			0x0
		     val x_7337: word32 ref * word32 = 
			(x_7334, x_7336)
		     val x_7338: unit = 
			:=_1 (word32) x_7337
		     val x_7339: word32 = 
			0x0
		     val x_7340: word32 Primitive.Option.t = 
			SOME[word32] size'
		     val x_7341: word8 array
				 * word32
				 * word32 Primitive.Option.t = 
			(x_7335, x_7339, x_7340)
		     val x_7342: word8 PrimSequence.Slice.t = 
			slice_4 (word8) x_7341
		     val x_7343: (unit -> unit) Primitive.Option.t
				 * (unit -> bool) Primitive.Option.t
				 * word32
				 * (unit -> unit)
				 * (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word32 Primitive.Option.t
				 * word8 vector
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t
				 -> (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			fn x_1669: (unit -> unit) Primitive.Option.t
				   * (unit -> bool) Primitive.Option.t
				   * word32
				   * (unit -> unit)
				   * (unit -> word64) Primitive.Option.t
				   * (unit -> word64) Primitive.Option.t
				   * word32 Primitive.Option.t
				   * word8 vector
				   * (word64 -> unit) Primitive.Option.t
				   * (unit -> word64) Primitive.Option.t
				   * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				   * (word8 PrimSequence.Slice.t
				      -> word32 Primitive.Option.t) Primitive.Option.t
				   * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				   * (word8 PrimSequence.Slice.t
				      -> word32 Primitive.Option.t) Primitive.Option.t => 
			let
			   val x_7344: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			      #10 x_1669
			in
			   x_7344
			end
		     val x_7345: PrimIO.writer
				 * ((unit -> unit) Primitive.Option.t
				    * (unit -> bool) Primitive.Option.t
				    * word32
				    * (unit -> unit)
				    * (unit -> word64) Primitive.Option.t
				    * (unit -> word64) Primitive.Option.t
				    * word32 Primitive.Option.t
				    * word8 vector
				    * (word64 -> unit) Primitive.Option.t
				    * (unit -> word64) Primitive.Option.t
				    * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				    * (word8 PrimSequence.Slice.t
				       -> word32 Primitive.Option.t) Primitive.Option.t
				    * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				    * (word8 PrimSequence.Slice.t
				       -> word32 Primitive.Option.t) Primitive.Option.t
				    -> (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t) = 
			(x_7331, x_7343)
		     val x_7346: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			writerSel ((word8 PrimSequence.Slice.t -> word32) Primitive.Option.t) x_7345
		     val x_7347: unit = 
			case x_7346 of
			NONE[word8 PrimSequence.Slice.t -> word32] => 
			   let
			      val x_7351: exn = 
				 BlockingNotSupported
			      val x_7352: unit = 
				 raise x_7351
			   in
			      x_7352
			   end
			SOME[word8 PrimSequence.Slice.t -> word32] x_7348: word8 PrimSequence.Slice.t
									   -> word32 => 
			   let
			      val x_7349: (word8 PrimSequence.Slice.t -> word32)
					  * (word8 PrimSequence.Slice.t
					     -> word8 array * word32 * word32)
					  * (word8 array
					     * word32
					     * word32 Primitive.Option.t
					     -> word8 PrimSequence.Slice.t)
					  * word8 PrimSequence.Slice.t = 
				 (x_7348,
				  base_8 (word8),
				  slice_4 (word8),
				  x_7342)
			      val x_7350: unit = 
				 flushGen (word8 array,
					   word8 PrimSequence.Slice.t) x_7349
			   in
			      x_7350
			   end
		  in
		     x_7347
		  end
	 in
	    x_7332
	 end
   val rec 
      flushOut: StreamIOExtra.outstream -> unit = 
	 fn x_1678: StreamIOExtra.outstream => 
	 let
	    val x_7353: unit = 
	       case x_1678 of
	       Out x_7354: PrimIO.writer
			   * StreamIOExtra.bufferMode ref
			   * StreamIOExtra.state ref
			   * PrimIO.writer => 
		  let
		     val x_7355: StreamIOExtra.state ref = 
			#2 x_7354
		     val x_7356: StreamIOExtra.bufferMode ref = 
			#1 x_7354
		     val x_7357: PrimIO.writer = 
			#0 x_7354
		     val x_7358: StreamIOExtra.state = 
			!_1 (StreamIOExtra.state) x_7355
		     val x_7359: bool = 
			terminated x_7358
		     val x_7360: unit = 
			case x_7359 of
			true => 
			   let
			      val x_7376: unit = 
				 ()
			   in
			      x_7376
			   end
			false => 
			   let
			      val x_7361: StreamIOExtra.bufferMode = 
				 !_1 (StreamIOExtra.bufferMode) x_7356
			      val x_7362: unit = 
				 case x_7361 of
				 NO_BUF => 
				    let
				       val x_7375: unit = 
					  ()
				    in
				       x_7375
				    end
				 BLOCK_BUF x_7366: StreamIOExtra.buf => 
				    let
				       val x_7367: unit = 
					  let
					     val x_7368: PrimIO.writer
							 * StreamIOExtra.buf = 
						(x_7357, x_7366)
					     val x_7369: unit = 
						flushBuf x_7368
					  in
					     x_7369
					  end
					  handle x_1679 => let
							      val x_7370: word8 vector = 
								 outstreamName x_1678
							      val x_7371: word8 vector
									  -> exn
									     -> unit = 
								 liftExn (unit) x_7370
							      val x_7372: word8 vector = 
								 "flushOut"
							      val x_7373: exn
									  -> unit = 
								 x_7371 x_7372
							      val x_7374: unit = 
								 x_7373 x_1679
							   in
							      x_7374
							   end
				    in
				       x_7367
				    end
				 LINE_BUF x_7363: StreamIOExtra.buf => 
				    let
				       val x_7364: PrimIO.writer
						   * StreamIOExtra.buf = 
					  (x_7357, x_7363)
				       val x_7365: unit = 
					  flushBuf x_7364
				    in
				       x_7365
				    end
			   in
			      x_7362
			   end
		  in
		     x_7360
		  end
	 in
	    x_7353
	 end
   val x_7377: (StreamIOExtra.outstream * bool) list = 
      nil[StreamIOExtra.outstream * bool]
   val openOutstreams: (StreamIOExtra.outstream * bool) list ref = 
      Ref_ref[(StreamIOExtra.outstream * bool) list] (x_7377)
   val x_7378: unit -> unit = 
      fn x_1687: unit => 
      let
	 val x_7379: StreamIOExtra.outstream * bool -> unit = 
	    fn x_1688: StreamIOExtra.outstream * bool => 
	    let
	       val close: bool = 
		  #1 x_1688
	       val os: StreamIOExtra.outstream = 
		  #0 x_1688
	       val x_7380: unit = 
		  case close of
		  true => 
		     let
			val x_7382: unit = 
			   case os of
			   Out x_7383: PrimIO.writer
				       * StreamIOExtra.bufferMode ref
				       * StreamIOExtra.state ref
				       * PrimIO.writer => 
			      let
				 val x_7384: StreamIOExtra.state ref = 
				    #2 x_7383
				 val x_7385: StreamIOExtra.state = 
				    !_1 (StreamIOExtra.state) x_7384
				 val x_7386: bool = 
				    case x_7385 of
				    Closed => 
				       let
					  val x_7387: bool = 
					     true
				       in
					  x_7387
				       end
				      _ => let
					      val x_7388: bool = 
						 false
					   in
					      x_7388
					   end
				 val x_7389: unit = 
				    case x_7386 of
				    true => 
				       let
					  val x_7428: unit = 
					     ()
				       in
					  x_7428
				       end
				    false => 
				       let
					  val x_7390: unit = 
					     let
						val x_7391: unit = 
						   flushOut os
						val x_7392: StreamIOExtra.state = 
						   !_1 (StreamIOExtra.state) x_7384
						val x_7393: bool = 
						   terminated x_7392
						val x_7394: unit = 
						   case x_7393 of
						   true => 
						      let
							 val x_7402: unit = 
							    ()
						      in
							 x_7402
						      end
						   false => 
						      let
							 val x_7395: PrimIO.writer = 
							    outstreamWriter os
							 val x_7396: (unit
								      -> unit) Primitive.Option.t
								     * (unit
									-> bool) Primitive.Option.t
								     * word32
								     * (unit
									-> unit)
								     * (unit
									-> word64) Primitive.Option.t
								     * (unit
									-> word64) Primitive.Option.t
								     * word32 Primitive.Option.t
								     * word8 vector
								     * (word64
									-> unit) Primitive.Option.t
								     * (unit
									-> word64) Primitive.Option.t
								     * (word8 PrimSequence.Slice.t
									-> word32) Primitive.Option.t
								     * (word8 PrimSequence.Slice.t
									-> word32 Primitive.Option.t) Primitive.Option.t
								     * (word8 PrimSequence.Slice.t
									-> word32) Primitive.Option.t
								     * (word8 PrimSequence.Slice.t
									-> word32 Primitive.Option.t) Primitive.Option.t
								     -> unit
									-> unit = 
							    fn x_1684: (unit
									-> unit) Primitive.Option.t
								       * (unit
									  -> bool) Primitive.Option.t
								       * word32
								       * (unit
									  -> unit)
								       * (unit
									  -> word64) Primitive.Option.t
								       * (unit
									  -> word64) Primitive.Option.t
								       * word32 Primitive.Option.t
								       * word8 vector
								       * (word64
									  -> unit) Primitive.Option.t
								       * (unit
									  -> word64) Primitive.Option.t
								       * (word8 PrimSequence.Slice.t
									  -> word32) Primitive.Option.t
								       * (word8 PrimSequence.Slice.t
									  -> word32 Primitive.Option.t) Primitive.Option.t
								       * (word8 PrimSequence.Slice.t
									  -> word32) Primitive.Option.t
								       * (word8 PrimSequence.Slice.t
									  -> word32 Primitive.Option.t) Primitive.Option.t => 
							    let
							       val x_7397: unit
									   -> unit = 
								  #3 x_1684
							    in
							       x_7397
							    end
							 val x_7398: PrimIO.writer
								     * ((unit
									 -> unit) Primitive.Option.t
									* (unit
									   -> bool) Primitive.Option.t
									* word32
									* (unit
									   -> unit)
									* (unit
									   -> word64) Primitive.Option.t
									* (unit
									   -> word64) Primitive.Option.t
									* word32 Primitive.Option.t
									* word8 vector
									* (word64
									   -> unit) Primitive.Option.t
									* (unit
									   -> word64) Primitive.Option.t
									* (word8 PrimSequence.Slice.t
									   -> word32) Primitive.Option.t
									* (word8 PrimSequence.Slice.t
									   -> word32 Primitive.Option.t) Primitive.Option.t
									* (word8 PrimSequence.Slice.t
									   -> word32) Primitive.Option.t
									* (word8 PrimSequence.Slice.t
									   -> word32 Primitive.Option.t) Primitive.Option.t
									-> unit
									   -> unit) = 
							    (x_7395, x_7396)
							 val x_7399: unit
								     -> unit = 
							    writerSel (unit
								       -> unit) x_7398
							 val x_7400: unit = 
							    ()
							 val x_7401: unit = 
							    x_7399 x_7400
						      in
							 x_7401
						      end
						val x_7403: StreamIOExtra.state = 
						   Closed
						val x_7404: StreamIOExtra.state ref
							    * StreamIOExtra.state = 
						   (x_7384, x_7403)
						val x_7405: unit = 
						   :=_1 (StreamIOExtra.state) x_7404
						val x_7406: unit = 
						   case os of
						   Out x_7407: PrimIO.writer
							       * StreamIOExtra.bufferMode ref
							       * StreamIOExtra.state ref
							       * PrimIO.writer => 
						      let
							 val x_7408: StreamIOExtra.bufferMode ref = 
							    #1 x_7407
							 val rec 
							    doit: StreamIOExtra.buf
								  -> unit = 
							       fn x_1681: StreamIOExtra.buf => 
							       let
								  val x_7409: unit = 
								     case x_1681 of
								     Buf x_7410: word8 array
										 * word32 ref => 
									let
									   val x_7411: word32 ref = 
									      #1 x_7410
									   val x_7412: word8 array = 
									      #0 x_7410
									   val x_7413: word32 = 
									      length_13 (word8) x_7412
									   val x_7414: word32 ref
										       * word32 = 
									      (x_7411,
									       x_7413)
									   val x_7415: unit = 
									      :=_1 (word32) x_7414
									in
									   x_7415
									end
							       in
								  x_7409
							       end
							 val x_7416: StreamIOExtra.bufferMode = 
							    !_1 (StreamIOExtra.bufferMode) x_7408
							 val x_7417: unit = 
							    case x_7416 of
							    BLOCK_BUF x_7421: StreamIOExtra.buf => 
							       let
								  val x_7422: unit = 
								     doit x_7421
							       in
								  x_7422
							       end
							    NO_BUF => 
							       let
								  val x_7420: unit = 
								     ()
							       in
								  x_7420
							       end
							    LINE_BUF x_7418: StreamIOExtra.buf => 
							       let
								  val x_7419: unit = 
								     doit x_7418
							       in
								  x_7419
							       end
						      in
							 x_7417
						      end
					     in
						x_7406
					     end
					     handle x_1683 => let
								 val x_7423: word8 vector = 
								    outstreamName os
								 val x_7424: word8 vector
									     -> exn
										-> unit = 
								    liftExn (unit) x_7423
								 val x_7425: word8 vector = 
								    "closeOut"
								 val x_7426: exn
									     -> unit = 
								    x_7424 x_7425
								 val x_7427: unit = 
								    x_7426 x_1683
							      in
								 x_7427
							      end
				       in
					  x_7390
				       end
			      in
				 x_7389
			      end
		     in
			x_7382
		     end
		  false => 
		     let
			val x_7381: unit = 
			   flushOut os
		     in
			x_7381
		     end
	    in
	       x_7380
	    end
	 val x_7429: (StreamIOExtra.outstream * bool) list -> unit = 
	    app_0 (StreamIOExtra.outstream * bool) x_7379
	 val x_7430: (StreamIOExtra.outstream * bool) list = 
	    !_1 ((StreamIOExtra.outstream * bool) list) openOutstreams
	 val x_7431: unit = 
	    x_7429 x_7430
      in
	 x_7431
      end
   val x_7432: (unit -> unit) list ref * (unit -> unit) = 
      (atExit, x_7378)
   val x_7433: unit = 
      addNew (unit -> unit) x_7432
   val rec 
      get: ImperativeIOExtra.Outstream.t -> StreamIOExtra.outstream = 
	 fn x_1690: ImperativeIOExtra.Outstream.t => 
	 let
	    val x_7434: StreamIOExtra.outstream = 
	       case x_1690 of
	       T x_7435: StreamIOExtra.outstream ref => 
		  let
		     val x_7436: StreamIOExtra.outstream = 
			!_1 (StreamIOExtra.outstream) x_7435
		  in
		     x_7436
		  end
	 in
	    x_7434
	 end
   val rec 
      output: ImperativeIOExtra.Outstream.t * word8 vector -> unit = 
	 fn x_1692: ImperativeIOExtra.Outstream.t * word8 vector => 
	 let
	    val v: word8 vector = 
	       #1 x_1692
	    val os: ImperativeIOExtra.Outstream.t = 
	       #0 x_1692
	    val x_7437: StreamIOExtra.outstream = 
	       get os
	    val x_7438: unit = 
	       case x_7437 of
	       Out x_7439: PrimIO.writer
			   * StreamIOExtra.bufferMode ref
			   * StreamIOExtra.state ref
			   * PrimIO.writer => 
		  let
		     val x_7440: StreamIOExtra.state ref = 
			#2 x_7439
		     val x_7441: StreamIOExtra.bufferMode ref = 
			#1 x_7439
		     val x_7442: PrimIO.writer = 
			#0 x_7439
		     val x_7443: StreamIOExtra.state = 
			!_1 (StreamIOExtra.state) x_7440
		     val x_7444: bool = 
			terminated x_7443
		     val x_7445: unit = 
			case x_7444 of
			true => 
			   let
			      val x_7502: word8 vector = 
				 outstreamName x_7437
			      val x_7503: word8 vector -> exn -> unit = 
				 liftExn (unit) x_7502
			      val x_7504: word8 vector = 
				 "output"
			      val x_7505: exn -> unit = 
				 x_7503 x_7504
			      val x_7506: exn = 
				 ClosedStream
			      val x_7507: unit = 
				 x_7505 x_7506
			   in
			      x_7507
			   end
			false => 
			   let
			      val x_7446: unit = 
				 let
				    val rec 
				       put: unit -> unit = 
					  fn x_1675: unit => 
					  let
					     val x_7447: word8 PrimSequence.Slice.t = 
						full_4 (word8) v
					     val x_7448: (unit -> unit) Primitive.Option.t
							 * (unit -> bool) Primitive.Option.t
							 * word32
							 * (unit -> unit)
							 * (unit -> word64) Primitive.Option.t
							 * (unit -> word64) Primitive.Option.t
							 * word32 Primitive.Option.t
							 * word8 vector
							 * (word64 -> unit) Primitive.Option.t
							 * (unit -> word64) Primitive.Option.t
							 * (word8 PrimSequence.Slice.t
							    -> word32) Primitive.Option.t
							 * (word8 PrimSequence.Slice.t
							    -> word32 Primitive.Option.t) Primitive.Option.t
							 * (word8 PrimSequence.Slice.t
							    -> word32) Primitive.Option.t
							 * (word8 PrimSequence.Slice.t
							    -> word32 Primitive.Option.t) Primitive.Option.t
							 -> (word8 PrimSequence.Slice.t
							     -> word32) Primitive.Option.t = 
						fn x_1667: (unit -> unit) Primitive.Option.t
							   * (unit -> bool) Primitive.Option.t
							   * word32
							   * (unit -> unit)
							   * (unit -> word64) Primitive.Option.t
							   * (unit -> word64) Primitive.Option.t
							   * word32 Primitive.Option.t
							   * word8 vector
							   * (word64 -> unit) Primitive.Option.t
							   * (unit -> word64) Primitive.Option.t
							   * (word8 PrimSequence.Slice.t
							      -> word32) Primitive.Option.t
							   * (word8 PrimSequence.Slice.t
							      -> word32 Primitive.Option.t) Primitive.Option.t
							   * (word8 PrimSequence.Slice.t
							      -> word32) Primitive.Option.t
							   * (word8 PrimSequence.Slice.t
							      -> word32 Primitive.Option.t) Primitive.Option.t => 
						let
						   val x_7449: (word8 PrimSequence.Slice.t
								-> word32) Primitive.Option.t = 
						      #12 x_1667
						in
						   x_7449
						end
					     val x_7450: PrimIO.writer
							 * ((unit -> unit) Primitive.Option.t
							    * (unit -> bool) Primitive.Option.t
							    * word32
							    * (unit -> unit)
							    * (unit -> word64) Primitive.Option.t
							    * (unit -> word64) Primitive.Option.t
							    * word32 Primitive.Option.t
							    * word8 vector
							    * (word64 -> unit) Primitive.Option.t
							    * (unit -> word64) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> word32) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> word32 Primitive.Option.t) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> word32) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> word32 Primitive.Option.t) Primitive.Option.t
							    -> (word8 PrimSequence.Slice.t
								-> word32) Primitive.Option.t) = 
						(x_7442, x_7448)
					     val x_7451: (word8 PrimSequence.Slice.t
							  -> word32) Primitive.Option.t = 
						writerSel ((word8 PrimSequence.Slice.t
							    -> word32) Primitive.Option.t) x_7450
					     val x_7452: unit = 
						case x_7451 of
						NONE[word8 PrimSequence.Slice.t
						     -> word32] => 
						   let
						      val x_7456: exn = 
							 BlockingNotSupported
						      val x_7457: unit = 
							 raise x_7456
						   in
						      x_7457
						   end
						SOME[word8 PrimSequence.Slice.t
						     -> word32] x_7453: word8 PrimSequence.Slice.t
									-> word32 => 
						   let
						      val x_7454: (word8 PrimSequence.Slice.t
								   -> word32)
								  * (word8 PrimSequence.Slice.t
								     -> word8 vector
									* word32
									* word32)
								  * (word8 vector
								     * word32
								     * word32 Primitive.Option.t
								     -> word8 PrimSequence.Slice.t)
								  * word8 PrimSequence.Slice.t = 
							 (x_7453,
							  base_4 (word8),
							  slice_2 (word8),
							  x_7447)
						      val x_7455: unit = 
							 flushGen (word8 vector,
								   word8 PrimSequence.Slice.t) x_7454
						   in
						      x_7455
						   end
					  in
					     x_7452
					  end
				    val rec 
				       doit: StreamIOExtra.buf * (unit -> bool)
					     -> unit = 
					  fn x_1674: StreamIOExtra.buf
						     * (unit -> bool) => 
					  let
					     val x_7458: unit -> bool = 
						#1 x_1674
					     val x_7459: StreamIOExtra.buf = 
						#0 x_1674
					     val x_7460: unit = 
						case x_7459 of
						Buf x_7461: word8 array
							    * word32 ref => 
						   let
						      val x_7462: word32 ref = 
							 #1 x_7461
						      val x_7463: word8 array = 
							 #0 x_7461
						      val curSize: word32 = 
							 !_1 (word32) x_7462
						      val x_7464: word32 = 
							 length_9 (word8) v
						      val x_7465: word32
								  * word32 = 
							 (curSize, x_7464)
						      val newSize: word32 = 
							 +! x_7465
						      val x_7466: word32 = 
							 length_13 (word8) x_7463
						      val x_7467: word32
								  * word32 = 
							 (newSize, x_7466)
						      val x_7468: bool = 
							 >= x_7467
						      val x_7469: bool = 
							 case x_7468 of
							 true => 
							    let
							       val x_7472: bool = 
								  true
							    in
							       x_7472
							    end
							 false => 
							    let
							       val x_7470: unit = 
								  ()
							       val x_7471: bool = 
								  x_7458 x_7470
							    in
							       x_7471
							    end
						      val x_7473: unit = 
							 case x_7469 of
							 true => 
							    let
							       val x_7478: PrimIO.writer
									   * StreamIOExtra.buf = 
								  (x_7442,
								   x_7459)
							       val x_7479: unit = 
								  flushBuf x_7478
							       val x_7480: unit = 
								  ()
							       val x_7481: unit = 
								  put x_7480
							    in
							       x_7481
							    end
							 false => 
							    let
							       val x_7474: word32
									   * word8 array
									   * word8 vector = 
								  (curSize,
								   x_7463,
								   v)
							       val x_7475: unit = 
								  copyVec_0 (word8) x_7474
							       val x_7476: word32 ref
									   * word32 = 
								  (x_7462,
								   newSize)
							       val x_7477: unit = 
								  :=_1 (word32) x_7476
							    in
							       x_7477
							    end
						   in
						      x_7473
						   end
					  in
					     x_7460
					  end
				    val x_7482: StreamIOExtra.bufferMode = 
				       !_1 (StreamIOExtra.bufferMode) x_7441
				    val x_7483: unit = 
				       case x_7482 of
				       NO_BUF => 
					  let
					     val x_7495: unit = 
						()
					     val x_7496: unit = 
						put x_7495
					  in
					     x_7496
					  end
				       BLOCK_BUF x_7490: StreamIOExtra.buf => 
					  let
					     val x_7491: unit -> bool = 
						fn x_1677: unit => 
						let
						   val x_7492: bool = 
						      false
						in
						   x_7492
						end
					     val x_7493: StreamIOExtra.buf
							 * (unit -> bool) = 
						(x_7490, x_7491)
					     val x_7494: unit = 
						doit x_7493
					  in
					     x_7494
					  end
				       LINE_BUF x_7484: StreamIOExtra.buf => 
					  let
					     val x_7485: unit -> bool = 
						fn x_1676: unit => 
						let
						   val x_7486: word8 vector
							       -> bool = 
						      exists_3 (word8) x_7276
						   val x_7487: bool = 
						      x_7486 v
						in
						   x_7487
						end
					     val x_7488: StreamIOExtra.buf
							 * (unit -> bool) = 
						(x_7484, x_7485)
					     val x_7489: unit = 
						doit x_7488
					  in
					     x_7489
					  end
				 in
				    x_7483
				 end
				 handle x_1673 => let
						     val x_7497: word8 vector = 
							outstreamName x_7437
						     val x_7498: word8 vector
								 -> exn -> unit = 
							liftExn (unit) x_7497
						     val x_7499: word8 vector = 
							"output"
						     val x_7500: exn -> unit = 
							x_7498 x_7499
						     val x_7501: unit = 
							x_7500 x_1673
						  in
						     x_7501
						  end
			   in
			      x_7446
			   end
		  in
		     x_7445
		  end
	 in
	    x_7438
	 end
   val rec 
      newOut: bool * IO.buffer_mode * bool * word32 * word8 vector
	      -> ImperativeIOExtra.Outstream.t = 
	 fn x_1694: bool * IO.buffer_mode * bool * word32 * word8 vector => 
	 let
	    val name: word8 vector = 
	       #4 x_1694
	    val fd: word32 = 
	       #3 x_1694
	    val closeAtExit: bool = 
	       #2 x_1694
	    val bufferMode: IO.buffer_mode = 
	       #1 x_1694
	    val appendMode: bool = 
	       #0 x_1694
	    val x_7508: bool = 
	       true
	    val x_7509: bool * word32 * word32 * bool * word8 vector = 
	       (appendMode, chunkSize, fd, x_7508, name)
	    val writer: PrimIO.writer = 
	       x_7275 x_7509
	    val x_7510: (unit -> unit) Primitive.Option.t
			* (unit -> bool) Primitive.Option.t
			* word32
			* (unit -> unit)
			* (unit -> word64) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* word32 Primitive.Option.t
			* word8 vector
			* (word64 -> unit) Primitive.Option.t
			* (unit -> word64) Primitive.Option.t
			* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			* (word8 PrimSequence.Slice.t
			   -> word32 Primitive.Option.t) Primitive.Option.t
			* (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			* (word8 PrimSequence.Slice.t
			   -> word32 Primitive.Option.t) Primitive.Option.t
			-> word32 = 
	       fn x_1686: (unit -> unit) Primitive.Option.t
			  * (unit -> bool) Primitive.Option.t
			  * word32
			  * (unit -> unit)
			  * (unit -> word64) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * word32 Primitive.Option.t
			  * word8 vector
			  * (word64 -> unit) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t => 
	       let
		  val x_7511: word32 = 
		     #2 x_1686
	       in
		  x_7511
	       end
	    val x_7512: PrimIO.writer
			* ((unit -> unit) Primitive.Option.t
			   * (unit -> bool) Primitive.Option.t
			   * word32
			   * (unit -> unit)
			   * (unit -> word64) Primitive.Option.t
			   * (unit -> word64) Primitive.Option.t
			   * word32 Primitive.Option.t
			   * word8 vector
			   * (word64 -> unit) Primitive.Option.t
			   * (unit -> word64) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t
			      -> word32 Primitive.Option.t) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			   * (word8 PrimSequence.Slice.t
			      -> word32 Primitive.Option.t) Primitive.Option.t
			   -> word32) = 
	       (writer, x_7510)
	    val bufSize: word32 = 
	       writerSel (word32) x_7512
	    val x_7513: PrimIO.writer = 
	       case writer of
	       WR x_7514: (unit -> unit) Primitive.Option.t
			  * (unit -> bool) Primitive.Option.t
			  * word32
			  * (unit -> unit)
			  * (unit -> word64) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * word32 Primitive.Option.t
			  * word8 vector
			  * (word64 -> unit) Primitive.Option.t
			  * (unit -> word64) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
			  * (word8 PrimSequence.Slice.t
			     -> word32 Primitive.Option.t) Primitive.Option.t => 
		  let
		     val x_7515: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t = 
			#13 x_7514
		     val x_7516: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			#12 x_7514
		     val x_7517: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t = 
			#11 x_7514
		     val x_7518: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			#10 x_7514
		     val x_7519: (unit -> word64) Primitive.Option.t = 
			#9 x_7514
		     val x_7520: (word64 -> unit) Primitive.Option.t = 
			#8 x_7514
		     val x_7521: word8 vector = 
			#7 x_7514
		     val x_7522: word32 Primitive.Option.t = 
			#6 x_7514
		     val x_7523: (unit -> word64) Primitive.Option.t = 
			#5 x_7514
		     val x_7524: (unit -> word64) Primitive.Option.t = 
			#4 x_7514
		     val x_7525: unit -> unit = 
			#3 x_7514
		     val x_7526: word32 = 
			#2 x_7514
		     val x_7527: (unit -> bool) Primitive.Option.t = 
			#1 x_7514
		     val x_7528: (unit -> unit) Primitive.Option.t = 
			#0 x_7514
		     val rec 'a_3878 
			augmentWrite: (word8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
				      * (word8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
				      -> (word8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
					 * (word8 PrimSequence.Slice.t
					    -> 'a_3878) Primitive.Option.t = 
			   fn x_1576: (word8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
				      * (word8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t => 
			   let
			      val writeArr: (word8 PrimSequence.Slice.t
					     -> 'a_3878) Primitive.Option.t = 
				 #1 x_1576
			      val writeVec: (word8 PrimSequence.Slice.t
					     -> 'a_3878) Primitive.Option.t = 
				 #0 x_1576
			      val x_7529: (word8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
					  * (word8 PrimSequence.Slice.t
					     -> 'a_3878) Primitive.Option.t = 
				 case writeVec of
				 SOME[word8 PrimSequence.Slice.t -> 'a_3878] x_7547: word8 PrimSequence.Slice.t
										     -> 'a_3878 => 
				    let
				       val x_7548: (word8 PrimSequence.Slice.t
						    -> 'a_3878) Primitive.Option.t
						   * (word8 PrimSequence.Slice.t
						      -> 'a_3878) Primitive.Option.t = 
					  case writeArr of
					  SOME[word8 PrimSequence.Slice.t
					       -> 'a_3878] x_7556: word8 PrimSequence.Slice.t
								   -> 'a_3878 => 
					     let
						val x_7557: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   SOME[word8 PrimSequence.Slice.t
							-> 'a_3878] x_7547
						val x_7558: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   SOME[word8 PrimSequence.Slice.t
							-> 'a_3878] x_7556
						val x_7559: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> 'a_3878) Primitive.Option.t = 
						   (x_7557, x_7558)
					     in
						x_7559
					     end
					  NONE[word8 PrimSequence.Slice.t
					       -> 'a_3878] => 
					     let
						val x_7549: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   SOME[word8 PrimSequence.Slice.t
							-> 'a_3878] x_7547
						val x_7550: word8 PrimSequence.Slice.t
							    -> 'a_3878 = 
						   fn x_1579: word8 PrimSequence.Slice.t => 
						   let
						      val x_7551: word8 vector = 
							 vector_2 (word8) x_1579
						      val x_7552: word8 PrimSequence.Slice.t = 
							 full_4 (word8) x_7551
						      val x_7553: 'a_3878 = 
							 x_7547 x_7552
						   in
						      x_7553
						   end
						val x_7554: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   SOME[word8 PrimSequence.Slice.t
							-> 'a_3878] x_7550
						val x_7555: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> 'a_3878) Primitive.Option.t = 
						   (x_7549, x_7554)
					     in
						x_7555
					     end
				    in
				       x_7548
				    end
				 NONE[word8 PrimSequence.Slice.t -> 'a_3878] => 
				    let
				       val x_7530: (word8 PrimSequence.Slice.t
						    -> 'a_3878) Primitive.Option.t
						   * (word8 PrimSequence.Slice.t
						      -> 'a_3878) Primitive.Option.t = 
					  case writeArr of
					  SOME[word8 PrimSequence.Slice.t
					       -> 'a_3878] x_7534: word8 PrimSequence.Slice.t
								   -> 'a_3878 => 
					     let
						val x_7535: word8 PrimSequence.Slice.t
							    -> 'a_3878 = 
						   fn x_1577: word8 PrimSequence.Slice.t => 
						   let
						      val x_7536: word32 = 
							 length_10 (word8) x_1577
						      val x_7537: word32
								  -> word8 = 
							 fn x_1578: word32 => 
							 let
							    val x_7538: word8 PrimSequence.Slice.t
									* word32 = 
							       (x_1577, x_1578)
							    val x_7539: word8 = 
							       sub_6 (word8) x_7538
							 in
							    x_7539
							 end
						      val x_7540: word32
								  * (word32
								     -> word8) = 
							 (x_7536, x_7537)
						      val x_7541: word8 array = 
							 tabulate_4 (word8) x_7540
						      val x_7542: word8 PrimSequence.Slice.t = 
							 full_7 (word8) x_7541
						      val x_7543: 'a_3878 = 
							 x_7534 x_7542
						   in
						      x_7543
						   end
						val x_7544: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   SOME[word8 PrimSequence.Slice.t
							-> 'a_3878] x_7535
						val x_7545: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   SOME[word8 PrimSequence.Slice.t
							-> 'a_3878] x_7534
						val x_7546: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> 'a_3878) Primitive.Option.t = 
						   (x_7544, x_7545)
					     in
						x_7546
					     end
					  NONE[word8 PrimSequence.Slice.t
					       -> 'a_3878] => 
					     let
						val x_7531: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   NONE[word8 PrimSequence.Slice.t
							-> 'a_3878]
						val x_7532: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t = 
						   NONE[word8 PrimSequence.Slice.t
							-> 'a_3878]
						val x_7533: (word8 PrimSequence.Slice.t
							     -> 'a_3878) Primitive.Option.t
							    * (word8 PrimSequence.Slice.t
							       -> 'a_3878) Primitive.Option.t = 
						   (x_7531, x_7532)
					     in
						x_7533
					     end
				    in
				       x_7530
				    end
			   in
			      x_7529
			   end
		     val rec ('a_3880, 'a_3879) 
			augmentSeq: ('a_3880 -> 'a_3879) Primitive.Option.t
				    * ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t
				    -> ('a_3880 -> 'a_3879) Primitive.Option.t
				       * ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
			   fn x_1573: ('a_3880 -> 'a_3879) Primitive.Option.t
				      * ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t => 
			   let
			      val writeSeqNB: ('a_3880
					       -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
				 #1 x_1573
			      val writeSeq: ('a_3880 -> 'a_3879) Primitive.Option.t = 
				 #0 x_1573
			      val x_7560: ('a_3880 -> 'a_3879) Primitive.Option.t
					  * ('a_3880
					     -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
				 case writeSeq of
				 SOME['a_3880 -> 'a_3879] x_7577: 'a_3880
								  -> 'a_3879 => 
				    let
				       val x_7578: ('a_3880 -> 'a_3879) Primitive.Option.t
						   * ('a_3880
						      -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
					  case writeSeqNB of
					  SOME['a_3880
					       -> 'a_3879 Primitive.Option.t] x_7592: 'a_3880
										      -> 'a_3879 Primitive.Option.t => 
					     let
						val x_7593: ('a_3880 -> 'a_3879) Primitive.Option.t = 
						   SOME['a_3880 -> 'a_3879] x_7577
						val x_7594: ('a_3880
							     -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   SOME['a_3880
							-> 'a_3879 Primitive.Option.t] x_7592
						val x_7595: ('a_3880 -> 'a_3879) Primitive.Option.t
							    * ('a_3880
							       -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   (x_7593, x_7594)
					     in
						x_7595
					     end
					  NONE['a_3880
					       -> 'a_3879 Primitive.Option.t] => 
					     let
						val x_7579: ('a_3880 -> 'a_3879) Primitive.Option.t = 
						   SOME['a_3880 -> 'a_3879] x_7577
						val x_7580: ('a_3880
							     -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   case x_7527 of
						   NONE[unit -> bool] => 
						      let
							 val x_7590: ('a_3880
								      -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
							    NONE['a_3880
								 -> 'a_3879 Primitive.Option.t]
						      in
							 x_7590
						      end
						   SOME[unit -> bool] x_7581: unit
									      -> bool => 
						      let
							 val x_7582: 'a_3880
								     -> 'a_3879 Primitive.Option.t = 
							    fn x_1575: 'a_3880 => 
							    let
							       val x_7583: unit = 
								  ()
							       val x_7584: bool = 
								  x_7581 x_7583
							       val x_7585: 'a_3879 Primitive.Option.t = 
								  case x_7584 of
								  true => 
								     let
									val x_7587: 'a_3879 = 
									   x_7577 x_1575
									val x_7588: 'a_3879 Primitive.Option.t = 
									   SOME['a_3879] x_7587
								     in
									x_7588
								     end
								  false => 
								     let
									val x_7586: 'a_3879 Primitive.Option.t = 
									   NONE['a_3879]
								     in
									x_7586
								     end
							    in
							       x_7585
							    end
							 val x_7589: ('a_3880
								      -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
							    SOME['a_3880
								 -> 'a_3879 Primitive.Option.t] x_7582
						      in
							 x_7589
						      end
						val x_7591: ('a_3880 -> 'a_3879) Primitive.Option.t
							    * ('a_3880
							       -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   (x_7579, x_7580)
					     in
						x_7591
					     end
				    in
				       x_7578
				    end
				 NONE['a_3880 -> 'a_3879] => 
				    let
				       val x_7561: ('a_3880 -> 'a_3879) Primitive.Option.t
						   * ('a_3880
						      -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
					  case writeSeqNB of
					  SOME['a_3880
					       -> 'a_3879 Primitive.Option.t] x_7565: 'a_3880
										      -> 'a_3879 Primitive.Option.t => 
					     let
						val x_7566: ('a_3880 -> 'a_3879) Primitive.Option.t = 
						   case x_7528 of
						   NONE[unit -> unit] => 
						      let
							 val x_7574: ('a_3880
								      -> 'a_3879) Primitive.Option.t = 
							    NONE['a_3880
								 -> 'a_3879]
						      in
							 x_7574
						      end
						   SOME[unit -> unit] x_7567: unit
									      -> unit => 
						      let
							 val x_7568: 'a_3880
								     -> 'a_3879 = 
							    fn x_1574: 'a_3880 => 
							    let
							       val x_7569: unit = 
								  ()
							       val x_7570: unit = 
								  x_7567 x_7569
							       val x_7571: 'a_3879 Primitive.Option.t = 
								  x_7565 x_1574
							       val x_7572: 'a_3879 = 
								  valOf_1 ('a_3879) x_7571
							    in
							       x_7572
							    end
							 val x_7573: ('a_3880
								      -> 'a_3879) Primitive.Option.t = 
							    SOME['a_3880
								 -> 'a_3879] x_7568
						      in
							 x_7573
						      end
						val x_7575: ('a_3880
							     -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   SOME['a_3880
							-> 'a_3879 Primitive.Option.t] x_7565
						val x_7576: ('a_3880 -> 'a_3879) Primitive.Option.t
							    * ('a_3880
							       -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   (x_7566, x_7575)
					     in
						x_7576
					     end
					  NONE['a_3880
					       -> 'a_3879 Primitive.Option.t] => 
					     let
						val x_7562: ('a_3880 -> 'a_3879) Primitive.Option.t = 
						   NONE['a_3880 -> 'a_3879]
						val x_7563: ('a_3880
							     -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   NONE['a_3880
							-> 'a_3879 Primitive.Option.t]
						val x_7564: ('a_3880 -> 'a_3879) Primitive.Option.t
							    * ('a_3880
							       -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
						   (x_7562, x_7563)
					     in
						x_7564
					     end
				    in
				       x_7561
				    end
			   in
			      x_7560
			   end
		     val x_7596: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			(x_7516, x_7518)
		     val x_7597: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			augmentWrite (word32) x_7596
		     val x_7598: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			(x_7515, x_7517)
		     val x_7599: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			augmentWrite (word32 Primitive.Option.t) x_7598
		     val x_7600: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			#1 x_7597
		     val x_7601: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			#0 x_7597
		     val x_7602: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t = 
			#1 x_7599
		     val x_7603: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t = 
			#0 x_7599
		     val x_7604: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			(x_7601, x_7603)
		     val x_7605: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			augmentSeq (word8 PrimSequence.Slice.t, word32) x_7604
		     val x_7606: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			(x_7600, x_7602)
		     val x_7607: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			augmentSeq (word8 PrimSequence.Slice.t, word32) x_7606
		     val x_7608: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t = 
			#1 x_7605
		     val x_7609: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			#0 x_7605
		     val x_7610: (word8 PrimSequence.Slice.t
				  -> word32 Primitive.Option.t) Primitive.Option.t = 
			#1 x_7607
		     val x_7611: (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t = 
			#0 x_7607
		     val x_7612: (unit -> unit) Primitive.Option.t
				 * (unit -> bool) Primitive.Option.t
				 * word32
				 * (unit -> unit)
				 * (unit -> word64) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * word32 Primitive.Option.t
				 * word8 vector
				 * (word64 -> unit) Primitive.Option.t
				 * (unit -> word64) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t -> word32) Primitive.Option.t
				 * (word8 PrimSequence.Slice.t
				    -> word32 Primitive.Option.t) Primitive.Option.t = 
			(x_7528,
			 x_7527,
			 x_7526,
			 x_7525,
			 x_7524,
			 x_7523,
			 x_7522,
			 x_7521,
			 x_7520,
			 x_7519,
			 x_7611,
			 x_7610,
			 x_7609,
			 x_7608)
		     val x_7613: PrimIO.writer = 
			WR x_7612
		  in
		     x_7613
		  end
	    val x_7614: StreamIOExtra.state = 
	       Active
	    val x_7615: StreamIOExtra.state ref = 
	       Ref_ref[StreamIOExtra.state] (x_7614)
	    val x_7616: StreamIOExtra.bufferMode = 
	       case bufferMode of
	       NO_BUF => 
		  let
		     val x_7631: StreamIOExtra.bufferMode = 
			NO_BUF
		  in
		     x_7631
		  end
	       BLOCK_BUF => 
		  let
		     val x_7624: word32 = 
			0x0
		     val x_7625: word32 ref = 
			Ref_ref[word32] (x_7624)
		     val x_7626: word32 * word8 = 
			(bufSize, someElem)
		     val x_7627: word8 array = 
			array_0 (word8) x_7626
		     val x_7628: word8 array * word32 ref = 
			(x_7627, x_7625)
		     val x_7629: StreamIOExtra.buf = 
			Buf x_7628
		     val x_7630: StreamIOExtra.bufferMode = 
			BLOCK_BUF x_7629
		  in
		     x_7630
		  end
	       LINE_BUF => 
		  let
		     val x_7617: word32 = 
			0x0
		     val x_7618: word32 ref = 
			Ref_ref[word32] (x_7617)
		     val x_7619: word32 * word8 = 
			(bufSize, someElem)
		     val x_7620: word8 array = 
			array_0 (word8) x_7619
		     val x_7621: word8 array * word32 ref = 
			(x_7620, x_7618)
		     val x_7622: StreamIOExtra.buf = 
			Buf x_7621
		     val x_7623: StreamIOExtra.bufferMode = 
			LINE_BUF x_7622
		  in
		     x_7623
		  end
	    val x_7632: StreamIOExtra.bufferMode ref = 
	       Ref_ref[StreamIOExtra.bufferMode] (x_7616)
	    val x_7633: PrimIO.writer
			* StreamIOExtra.bufferMode ref
			* StreamIOExtra.state ref
			* PrimIO.writer = 
	       (x_7513, x_7632, x_7615, writer)
	    val x_7634: StreamIOExtra.outstream = 
	       Out x_7633
	    val x_7635: StreamIOExtra.outstream * bool = 
	       (x_7634, closeAtExit)
	    val x_7636: (StreamIOExtra.outstream * bool) list = 
	       !_1 ((StreamIOExtra.outstream * bool) list) openOutstreams
	    val x_7637: (StreamIOExtra.outstream * bool)
			* (StreamIOExtra.outstream * bool) list = 
	       (x_7635, x_7636)
	    val x_7638: (StreamIOExtra.outstream * bool) list = 
	       ::[StreamIOExtra.outstream * bool] x_7637
	    val x_7639: (StreamIOExtra.outstream * bool) list ref
			* (StreamIOExtra.outstream * bool) list = 
	       (openOutstreams, x_7638)
	    val x_7640: unit = 
	       :=_1 ((StreamIOExtra.outstream * bool) list) x_7639
	    val x_7641: StreamIOExtra.outstream ref = 
	       Ref_ref[StreamIOExtra.outstream] (x_7634)
	    val x_7642: ImperativeIOExtra.Outstream.t = 
	       T x_7641
	 in
	    x_7642
	 end
   val x_7643: bool = 
      true
   val x_7644: IO.buffer_mode = 
      NO_BUF
   val x_7645: bool = 
      false
   val x_7646: word8 vector = 
      "<stderr>"
   val x_7647: bool * IO.buffer_mode * bool * word32 * word8 vector = 
      (x_7643, x_7644, x_7645, stderr, x_7646)
   val stdErr: ImperativeIOExtra.Outstream.t = 
      newOut x_7647
   val x_7648: bool = 
      true
   val x_7649: bool = 
      false
   val x_7650: word8 vector = 
      "<stdout>"
   val x_7651: word32 = 
      toRep stdout
   val x_7652: word32 = 
      Posix_ProcEnv_isatty (x_7651)
   val x_7653: word32 * word32 = 
      (x_7652, zero)
   val x_7654: bool = 
      <> (word32) x_7653
   val x_7655: IO.buffer_mode = 
      case x_7654 of
      true => 
	 let
	    val x_7657: IO.buffer_mode = 
	       LINE_BUF
	 in
	    x_7657
	 end
      false => 
	 let
	    val x_7656: IO.buffer_mode = 
	       BLOCK_BUF
	 in
	    x_7656
	 end
   val x_7658: bool * IO.buffer_mode * bool * word32 * word8 vector = 
      (x_7648, x_7655, x_7649, stdout, x_7650)
   val x_7659: ImperativeIOExtra.Outstream.t = 
      newOut x_7658
   exception Path
   exception InvalidArc
   exception Sqrt
   exception Ln
   exception Ord
   exception Io of word8 vector
   exception Interrupt
   val rec ('a_3966, 'a_3965) 
      wrap: ('a_3966 * word64 -> 'a_3965) -> 'a_3966 * word32 -> 'a_3965 = 
	 fn x_1697: 'a_3966 * word64 -> 'a_3965 => 
	 let
	    val x_7660: 'a_3966 * word32 -> 'a_3965 = 
	       fn x_1698: 'a_3966 * word32 => 
	       let
		  val x_7661: word32 = 
		     #1 x_1698
		  val x_7662: 'a_3966 = 
		     #0 x_1698
		  val x_7663: word64 = 
		     sextdFromInt32ToInt64 x_7661
		  val x_7664: 'a_3966 * word64 = 
		     (x_7662, x_7663)
		  val x_7665: 'a_3965 = 
		     x_1697 x_7664
	       in
		  x_7665
	       end
	 in
	    x_7660
	 end
   val getCPointer: cpointer * word32 -> cpointer = 
      wrap (cpointer, cpointer) getCPointer
   val getInt32: cpointer * word32 -> word32 = 
      wrap (cpointer, word32) getInt32
   val getWord32: cpointer * word32 -> word32 = 
      wrap (cpointer, word32) getWord32
   val x_7666: (word32 -> word32) * (word32 -> word32) = 
      (fromRep, sextdFromInt32ToInt32)
   val fromInt: word32 -> word32 = 
      o_1 (word32, word32, word32) x_7666
   val x_7667: (word32 -> word32) * (word32 -> word32) = 
      (sextdFromInt32ToInt32, toRep)
   val toInt: word32 -> word32 = 
      o_1 (word32, word32, word32) x_7667
   val x_7668: word32 = 
      0x1
   val failure: word32 = 
      fromInt x_7668
   val x_7669: word32 = 
      0x0
   val success: word32 = 
      fromInt x_7669
   val x_7670: bool = 
      false
   val exiting: bool ref = 
      Ref_ref[bool] (x_7670)
   val rec 
      halt: word32 -> unit = 
	 fn x_1703: word32 => 
	 let
	    val x_7671: word32 = 
	       toRep x_1703
	    val x_7672: unit = 
	       halt x_7671
	 in
	    x_7672
	 end
   val rec 'a 
      exit: word32 -> 'a = 
	 fn x_1704: word32 => 
	 let
	    val x_7673: bool = 
	       !_1 (bool) exiting
	    val x_7674: 'a = 
	       case x_7673 of
	       true => 
		  let
		     val x_7768: word8 vector = 
			"MLton.Exit.exit"
		     val x_7769: exn = 
			Fail x_7768
		     val x_7770: 'a = 
			raise x_7769
		  in
		     x_7770
		  end
	       false => 
		  let
		     val x_7675: bool = 
			true
		     val x_7676: bool ref * bool = 
			(exiting, x_7675)
		     val x_7677: unit = 
			:=_1 (bool) x_7676
		     val i: word32 = 
			toInt x_1704
		     val x_7678: word32 = 
			0x0
		     val x_7679: word32 * word32 = 
			(x_7678, i)
		     val x_7680: bool = 
			<= x_7679
		     val x_7681: bool = 
			case x_7680 of
			true => 
			   let
			      val x_7683: word32 = 
				 0x100
			      val x_7684: word32 * word32 = 
				 (i, x_7683)
			      val x_7685: bool = 
				 < x_7684
			   in
			      x_7685
			   end
			false => 
			   let
			      val x_7682: bool = 
				 false
			   in
			      x_7682
			   end
		     val x_7686: 'a = 
			case x_7681 of
			true => 
			   let
			      val x_7756: (unit -> unit) -> unit = 
				 fn x_1377: unit -> unit => 
				 let
				    val x_7757: unit = 
				       let
					  val x_7758: unit = 
					     ()
					  val x_7759: unit = 
					     x_1377 x_7758
				       in
					  x_7759
				       end
				       handle x_1378 => let
							   val x_7760: unit = 
							      ()
							in
							   x_7760
							end
				 in
				    x_7757
				 end
			      val x_7761: (unit -> unit) list -> unit = 
				 app_1 (unit -> unit) x_7756
			      val x_7762: (unit -> unit) list = 
				 !_1 ((unit -> unit) list) atExit
			      val x_7763: unit = 
				 x_7761 x_7762
			      val x_7764: unit = 
				 halt x_1704
			      val x_7765: word8 vector = 
				 "MLton.Exit.exit"
			      val x_7766: exn = 
				 Fail x_7765
			      val x_7767: 'a = 
				 raise x_7766
			   in
			      x_7767
			   end
			false => 
			   let
			      val x_7687: word8 vector list = 
				 nil[word8 vector]
			      val x_7688: word8 vector = 
				 "exit must have 0 <= status < 256"
			      val x_7689: word8 vector * word8 vector list = 
				 (x_7688, x_7687)
			      val x_7690: word8 vector list = 
				 ::[word8 vector] x_7689
			      val x_7691: word8 vector = 
				 "): "
			      val x_7692: word8 vector * word8 vector list = 
				 (x_7691, x_7690)
			      val x_7693: word8 vector list = 
				 ::[word8 vector] x_7692
			      val x_7694: word8 array -> word8 vector = 
				 fn x_1301: word8 array => 
				 let
				    val x_7695: word32 = 
				       radixToInt x_4517
				    val radix: word32 = 
				       sextdFromInt32ToInt32 x_7695
				    val rec 
				       loop: word32 * word32 -> word8 vector = 
					  fn x_1302: word32 * word32 => 
					  let
					     val i: word32 = 
						#1 x_1302
					     val q: word32 = 
						#0 x_1302
					     val x_7696: word32 * word32 = 
						(radix, zero)
					     val x_7697: bool = 
						= (word32) x_7696
					     val x_7698: word32 = 
						case x_7697 of
						true => 
						   let
						      val x_7709: exn = 
							 Div
						      val x_7710: word32 = 
							 raise x_7709
						   in
						      x_7710
						   end
						false => 
						   let
						      val x_7699: word32
								  * word32 = 
							 (q, minInt')
						      val x_7700: bool = 
							 = (word32) x_7699
						      val x_7701: bool = 
							 case x_7700 of
							 true => 
							    let
							       val x_7703: word32 = 
								  ~! one
							       val x_7704: word32
									   * word32 = 
								  (radix, x_7703)
							       val x_7705: bool = 
								  = (word32) x_7704
							    in
							       x_7705
							    end
							 false => 
							    let
							       val x_7702: bool = 
								  false
							    in
							       x_7702
							    end
						      val x_7706: word32 = 
							 case x_7701 of
							 true => 
							    let
							    in
							       zero
							    end
							 false => 
							    let
							       val x_7707: word32
									   * word32 = 
								  (q, radix)
							       val x_7708: word32 = 
								  remUnsafe x_7707
							    in
							       x_7708
							    end
						   in
						      x_7706
						   end
					     val x_7711: word32 = 
						~? x_7698
					     val x_7712: word32 = 
						sextdFromInt32ToInt32 x_7711
					     val x_7713: word8 = 
						digitToChar x_7712
					     val x_7714: word8 array
							 * word32
							 * word8 = 
						(x_1301, i, x_7713)
					     val x_7715: unit = 
						update_0 (word8) x_7714
					     val x_7716: word32 * word32 = 
						(q, radix)
					     val q: word32 = 
						quot x_7716
					     val x_7717: word32 * word32 = 
						(q, zero)
					     val x_7718: bool = 
						= (word32) x_7717
					     val x_7719: word8 vector = 
						case x_7718 of
						true => 
						   let
						      val x_7725: word32
								  * word32 = 
							 (i, zero)
						      val x_7726: bool = 
							 < x_7725
						      val x_7727: word32 = 
							 case x_7726 of
							 true => 
							    let
							       val x_7728: word32 = 
								  0x1
							       val x_7729: word32
									   * word32 = 
								  (i, x_7728)
							       val i: word32 = 
								  -! x_7729
							       val x_7730: word8 = 
								  0x7E
							       val x_7731: word8 array
									   * word32
									   * word8 = 
								  (x_1301,
								   i,
								   x_7730)
							       val x_7732: unit = 
								  update_0 (word8) x_7731
							    in
							       i
							    end
							 false => 
							    let
							    in
							       i
							    end
						      val x_7733: word32 Primitive.Option.t = 
							 NONE[word32]
						      val x_7734: word8 array
								  * word32
								  * word32 Primitive.Option.t = 
							 (x_1301, x_7727, x_7733)
						      val x_7735: word8 PrimSequence.Slice.t = 
							 slice_4 (word8) x_7734
						      val x_7736: word8 vector = 
							 vector_2 (word8) x_7735
						   in
						      x_7736
						   end
						false => 
						   let
						      val x_7720: word32 = 
							 0x1
						      val x_7721: word32
								  * word32 = 
							 (i, x_7720)
						      val x_7722: word32 = 
							 -! x_7721
						      val x_7723: word32
								  * word32 = 
							 (q, x_7722)
						      val x_7724: word8 vector = 
							 loop x_7723
						   in
						      x_7724
						   end
					  in
					     x_7719
					  end
				    val x_7737: word32 * word32 = 
				       (i, zero)
				    val x_7738: bool = 
				       < x_7737
				    val x_7739: word32 = 
				       case x_7738 of
				       true => 
					  let
					  in
					     i
					  end
				       false => 
					  let
					     val x_7740: word32 = 
						~? i
					  in
					     x_7740
					  end
				    val x_7741: word32 = 
				       0x1
				    val x_7742: word32 * word32 = 
				       (maxNumDigits, x_7741)
				    val x_7743: word32 = 
				       -! x_7742
				    val x_7744: word32 * word32 = 
				       (x_7739, x_7743)
				    val x_7745: word8 vector = 
				       loop x_7744
				 in
				    x_7745
				 end
			      val x_7746: word8 array One.t
					  * (word8 array -> word8 vector) = 
				 (oneBuf, x_7694)
			      val x_7747: word8 vector = 
				 use_0 (word8 vector, word8 array) x_7746
			      val x_7748: word8 vector * word8 vector list = 
				 (x_7747, x_7693)
			      val x_7749: word8 vector list = 
				 ::[word8 vector] x_7748
			      val x_7750: word8 vector = 
				 "MLton.Exit.exit("
			      val x_7751: word8 vector * word8 vector list = 
				 (x_7750, x_7749)
			      val x_7752: word8 vector list = 
				 ::[word8 vector] x_7751
			      val x_7753: word8 vector = 
				 concat_1 (word8) x_7752
			      val x_7754: exn = 
				 Fail x_7753
			      val x_7755: 'a = 
				 raise x_7754
			   in
			      x_7755
			   end
		  in
		     x_7686
		  end
	 in
	    x_7674
	 end
   val rec 'a 
      wrapSuffix: (unit -> unit) -> unit -> 'a = 
	 fn x_1705: unit -> unit => 
	 let
	    val x_7771: unit -> 'a = 
	       fn x_1706: unit => 
	       let
		  val x_7772: 'a = 
		     let
			val x_7773: unit = 
			   ()
			val x_7774: unit = 
			   x_1705 x_7773
			val x_7775: word8 vector = 
			   "Top-level suffix returned.\n"
			val x_7776: unit = 
			   print x_7775
			val x_7777: 'a = 
			   exit ('a) failure
		     in
			x_7777
		     end
		     handle x_1707 => let
					 val x_7778: word8 vector = 
					    "Top-level suffix raised exception.\n"
					 val x_7779: unit = 
					    print x_7778
					 val x_7780: unit = 
					    halt failure
					 val x_7781: word8 vector = 
					    "MLton.Exit.wrapSuffix"
					 val x_7782: exn = 
					    Fail x_7781
					 val x_7783: 'a = 
					    raise x_7782
				      in
					 x_7783
				      end
	       in
		  x_7772
	       end
	 in
	    x_7771
	 end
   val rec 'a_3972 
      suffixExecutable: unit -> 'a_3972 = 
	 fn x_1709: unit => 
	 let
	    val x_7784: 'a_3972 = 
	       exit ('a_3972) success
	 in
	    x_7784
	 end
   val rec 'a 
      defaultTopLevelSuffix: unit -> 'a = 
	 fn x_1710: unit => 
	 let
	    val x_7785: unit -> 'a = 
	       wrapSuffix ('a) suffixExecutable (unit)
	    val x_7786: unit = 
	       ()
	    val x_7787: 'a = 
	       x_7785 x_7786
	 in
	    x_7787
	 end
   val rec 'a 
      wrapHandler: (exn -> unit) -> exn -> 'a = 
	 fn x_1715: exn -> unit => 
	 let
	    val x_7788: exn -> 'a = 
	       fn x_1716: exn => 
	       let
		  val x_7789: 'a = 
		     let
			val x_7790: unit = 
			   x_1715 x_1716
			val x_7791: word8 vector = 
			   "Top-level handler returned.\n"
			val x_7792: unit = 
			   print x_7791
			val x_7793: 'a = 
			   exit ('a) failure
		     in
			x_7793
		     end
		     handle x_1717 => let
					 val x_7794: word8 vector = 
					    "Top-level handler raised exception.\n"
					 val x_7795: unit = 
					    print x_7794
					 val x_7796: unit = 
					    halt failure
					 val x_7797: word8 vector = 
					    "MLton.Exn.wrapHandler"
					 val x_7798: exn = 
					    Fail x_7797
					 val x_7799: 'a = 
					    raise x_7798
				      in
					 x_7799
				      end
	       in
		  x_7789
	       end
	 in
	    x_7788
	 end
   val 'a_3973 defaultHandler: exn -> 'a_3973 = 
      let
	 val x_7800: exn -> 'a_3973 = 
	    fn x_1718: exn => 
	    let
	       val x_7801: word8 vector list = 
		  nil[word8 vector]
	       val x_7802: word8 vector = 
		  "\n"
	       val x_7803: word8 vector * word8 vector list = 
		  (x_7802, x_7801)
	       val x_7804: word8 vector list = 
		  ::[word8 vector] x_7803
	       val x_7805: word8 vector = 
		  exnMessage x_1718
	       val x_7806: word8 vector * word8 vector list = 
		  (x_7805, x_7804)
	       val x_7807: word8 vector list = 
		  ::[word8 vector] x_7806
	       val x_7808: word8 vector = 
		  "unhandled exception: "
	       val x_7809: word8 vector * word8 vector list = 
		  (x_7808, x_7807)
	       val x_7810: word8 vector list = 
		  ::[word8 vector] x_7809
	       val x_7811: word8 vector = 
		  concat_1 (word8) x_7810
	       val x_7812: unit = 
		  print x_7811
	       val x_7813: word8 vector list = 
		  nil[word8 vector]
	       val x_7814: unit = 
		  ()
	       val x_7815: 'a_3973 = 
		  exit ('a_3973) failure
	    in
	       x_7815
	    end
      in
	 x_7800
      end
   val rec 'a 
      defaultTopLevelHandler: exn -> 'a = 
	 fn x_1720: exn => 
	 let
	    val x_7816: exn -> 'a = 
	       wrapHandler ('a) defaultHandler (unit)
	    val x_7817: 'a = 
	       x_7816 x_1720
	 in
	    x_7817
	 end
   val rec 'a 
      topLevelHandler: exn -> 'a = 
	 fn x_1721: exn => 
	 let
	    val x_7818: exn -> unit = 
	       TopLevel_getHandler ()
	    val x_7819: unit = 
	       x_7818 x_1721
	    val x_7820: word8 vector = 
	       "MLton.Exn.topLevelHandler"
	    val x_7821: exn = 
	       Fail x_7820
	    val x_7822: 'a = 
	       raise x_7821
	 in
	    x_7822
	 end
   val rec 'a 
      die: word8 vector -> 'a = 
	 fn x_1722: word8 vector => 
	 let
	    val x_7823: unit = 
	       print x_1722
	    val x_7824: word32 = 
	       0x1
	    val x_7825: unit = 
	       Posix_Process_exit (x_7824)
	    exception DieFailed
	    val x_7826: exn = 
	       DieFailed
	    val x_7827: 'a = 
	       raise x_7826
	 in
	    x_7827
	 end
   val rec ('b, 'a) 
      prepend: 'a MLtonThread.t * ('b -> 'a) -> 'b MLtonThread.t = 
	 fn x_1723: 'a MLtonThread.t * ('b -> 'a) => 
	 let
	    val x_7828: 'b -> 'a = 
	       #1 x_1723
	    val x_7829: 'a MLtonThread.t = 
	       #0 x_1723
	    val x_7830: 'b MLtonThread.t = 
	       case x_7829 of
	       T['a] x_7831: 'a MLtonThread.thread ref => 
		  let
		     val x_7832: 'a MLtonThread.thread = 
			!_1 ('a MLtonThread.thread) x_7831
		     val x_7833: 'b MLtonThread.thread = 
			case x_7832 of
			Dead['a] => 
			   let
			      val x_7851: word8 vector = 
				 "prepend to a Dead thread"
			      val x_7852: exn = 
				 Fail x_7851
			      val x_7853: 'b MLtonThread.thread = 
				 raise x_7852
			   in
			      x_7853
			   end
			New['a] x_7847: 'a -> unit => 
			   let
			      val x_7848: ('a -> unit) * ('b -> 'a) = 
				 (x_7847, x_7828)
			      val x_7849: 'b -> unit = 
				 o_1 ('b, unit, 'a) x_7848
			      val x_7850: 'b MLtonThread.thread = 
				 New['b] x_7849
			   in
			      x_7850
			   end
			Paused['a] x_7838: ((unit -> 'a) -> unit) * thread => 
			   let
			      val x_7839: thread = 
				 #1 x_7838
			      val x_7840: (unit -> 'a) -> unit = 
				 #0 x_7838
			      val x_7841: (unit -> 'b) -> unit = 
				 fn x_1724: unit -> 'b => 
				 let
				    val x_7842: ('b -> 'a) * (unit -> 'b) = 
				       (x_7828, x_1724)
				    val x_7843: unit -> 'a = 
				       o_1 (unit, 'a, 'b) x_7842
				    val x_7844: unit = 
				       x_7840 x_7843
				 in
				    x_7844
				 end
			      val x_7845: ((unit -> 'b) -> unit) * thread = 
				 (x_7841, x_7839)
			      val x_7846: 'b MLtonThread.thread = 
				 Paused['b] x_7845
			   in
			      x_7846
			   end
			Interrupted['a] x_7834: thread => 
			   let
			      val x_7835: word8 vector = 
				 "prepend to a Interrupted thread"
			      val x_7836: exn = 
				 Fail x_7835
			      val x_7837: 'b MLtonThread.thread = 
				 raise x_7836
			   in
			      x_7837
			   end
		     val x_7854: 'a MLtonThread.thread = 
			Dead['a]
		     val x_7855: 'a MLtonThread.thread ref
				 * 'a MLtonThread.thread = 
			(x_7831, x_7854)
		     val x_7856: unit = 
			:=_1 ('a MLtonThread.thread) x_7855
		     val x_7857: 'b MLtonThread.thread ref = 
			Ref_ref['b MLtonThread.thread] (x_7833)
		     val x_7858: 'b MLtonThread.t = 
			T['b] x_7857
		  in
		     x_7858
		  end
	 in
	    x_7830
	 end
   val rec 'a 
      prepare: 'a MLtonThread.t * 'a -> unit MLtonThread.t = 
	 fn x_1725: 'a MLtonThread.t * 'a => 
	 let
	    val v: 'a = 
	       #1 x_1725
	    val t: 'a MLtonThread.t = 
	       #0 x_1725
	    val x_7859: unit -> 'a = 
	       fn x_1726: unit => 
	       let
	       in
		  v
	       end
	    val x_7860: 'a MLtonThread.t * (unit -> 'a) = 
	       (t, x_7859)
	    val x_7861: unit MLtonThread.t = 
	       prepend (unit, 'a) x_7860
	 in
	    x_7861
	 end
   val rec 'a_3975 
      new: ('a_3975 -> unit) -> 'a_3975 MLtonThread.t = 
	 fn x_1727: 'a_3975 -> unit => 
	 let
	    val x_7862: 'a_3975 MLtonThread.thread = 
	       New['a_3975] x_1727
	    val x_7863: 'a_3975 MLtonThread.thread ref = 
	       Ref_ref['a_3975 MLtonThread.thread] (x_7862)
	    val x_7864: 'a_3975 MLtonThread.t = 
	       T['a_3975] x_7863
	 in
	    x_7864
	 end
   val x_7865: (unit -> unit) Primitive.Option.t = 
      NONE[unit -> unit]
   val func: (unit -> unit) Primitive.Option.t ref = 
      Ref_ref[(unit -> unit) Primitive.Option.t] (x_7865)
   val x_7866: unit = 
      Thread_copyCurrent ()
   val x_7867: (unit -> unit) Primitive.Option.t = 
      !_1 ((unit -> unit) Primitive.Option.t) func
   val x_7868: thread = 
      case x_7867 of
      NONE[unit -> unit] => 
	 let
	    val x_7881: thread = 
	       GC_getSavedThread (x_2121)
	 in
	    x_7881
	 end
      SOME[unit -> unit] x_7869: unit -> unit => 
	 let
	    val x_7870: (unit -> unit) Primitive.Option.t = 
	       NONE[unit -> unit]
	    val x_7871: (unit -> unit) Primitive.Option.t ref
			* (unit -> unit) Primitive.Option.t = 
	       (func, x_7870)
	    val x_7872: unit = 
	       :=_1 ((unit -> unit) Primitive.Option.t) x_7871
	    val x_7873: unit = 
	       ()
	    val x_7874: unit = 
	       atomicEnd x_7873
	    val x_7875: unit = 
	       let
		  val x_7876: unit = 
		     ()
		  val x_7877: unit = 
		     x_7869 x_7876
	       in
		  x_7877
	       end
	       handle x_1728 => let
				   val x_7878: unit = 
				      topLevelHandler (unit) x_1728
				in
				   x_7878
				end
	    val x_7879: word8 vector = 
	       "Thread didn't exit properly.\n"
	    val x_7880: thread = 
	       die (thread) x_7879
	 in
	    x_7880
	 end
   val x_7882: bool = 
      false
   val switching: bool ref = 
      Ref_ref[bool] (x_7882)
   val rec 'a 
      atomicSwitch: ('a MLtonThread.t -> unit MLtonThread.t) -> 'a = 
	 fn x_1730: 'a MLtonThread.t -> unit MLtonThread.t => 
	 let
	    val x_7883: bool = 
	       !_1 (bool) switching
	    val x_7884: 'a = 
	       case x_7883 of
	       true => 
		  let
		     val x_7943: unit = 
			()
		     val x_7944: unit = 
			atomicEnd x_7943
		     val x_7945: word8 vector = 
			"nested Thread.switch"
		     val x_7946: exn = 
			Fail x_7945
		     val x_7947: 'a = 
			raise x_7946
		  in
		     x_7947
		  end
	       false => 
		  let
		     val x_7885: bool = 
			true
		     val x_7886: bool ref * bool = 
			(switching, x_7885)
		     val x_7887: unit = 
			:=_1 (bool) x_7886
		     val x_7888: unit -> 'a = 
			fn x_1735: unit => 
			let
			   val x_7889: word8 vector = 
			      "Thread.atomicSwitch didn't set r.\n"
			   val x_7890: 'a = 
			      die ('a) x_7889
			in
			   x_7890
			end
		     val r: (unit -> 'a) ref = 
			Ref_ref[unit -> 'a] (x_7888)
		     val x_7891: (unit -> 'a) -> unit = 
			fn x_1734: unit -> 'a => 
			let
			   val x_7892: (unit -> 'a) ref * (unit -> 'a) = 
			      (r, x_1734)
			   val x_7893: unit = 
			      :=_1 (unit -> 'a) x_7892
			in
			   x_7893
			end
		     val x_7894: thread = 
			GC_getCurrentThread (x_2121)
		     val x_7895: ((unit -> 'a) -> unit) * thread = 
			(x_7891, x_7894)
		     val x_7896: 'a MLtonThread.thread = 
			Paused['a] x_7895
		     val t: 'a MLtonThread.thread ref = 
			Ref_ref['a MLtonThread.thread] (x_7896)
		     val rec 'a_3976 
			fail: exn -> 'a_3976 = 
			   fn x_1733: exn => 
			   let
			      val x_7897: 'a MLtonThread.thread = 
				 Dead['a]
			      val x_7898: 'a MLtonThread.thread ref
					  * 'a MLtonThread.thread = 
				 (t, x_7897)
			      val x_7899: unit = 
				 :=_1 ('a MLtonThread.thread) x_7898
			      val x_7900: bool = 
				 false
			      val x_7901: bool ref * bool = 
				 (switching, x_7900)
			      val x_7902: unit = 
				 :=_1 (bool) x_7901
			      val x_7903: unit = 
				 ()
			      val x_7904: unit = 
				 atomicEnd x_7903
			      val x_7905: 'a_3976 = 
				 raise x_1733
			   in
			      x_7905
			   end
		     val x_7906: unit MLtonThread.t = 
			let
			   val x_7907: 'a MLtonThread.t = 
			      T['a] t
			   val x_7908: unit MLtonThread.t = 
			      x_1730 x_7907
			in
			   x_7908
			end
			handle x_1732 => let
					    val x_7909: unit MLtonThread.t = 
					       fail (unit MLtonThread.t) x_1732
					 in
					    x_7909
					 end
		     val x_7910: 'a = 
			case x_7906 of
			T[unit] x_7911: unit MLtonThread.thread ref => 
			   let
			      val x_7912: unit MLtonThread.thread = 
				 !_1 (unit MLtonThread.thread) x_7911
			      val x_7913: unit MLtonThread.thread = 
				 Dead[unit]
			      val x_7914: unit MLtonThread.thread ref
					  * unit MLtonThread.thread = 
				 (x_7911, x_7913)
			      val x_7915: unit = 
				 :=_1 (unit MLtonThread.thread) x_7914
			      val x_7916: unit MLtonThread.thread * unit = 
				 (x_7912, x_7915)
			      val x_7917: unit MLtonThread.thread = 
				 before_1 (unit MLtonThread.thread) x_7916
			      val x_7918: thread = 
				 case x_7917 of
				 Dead[unit] => 
				    let
				       val x_7933: word8 vector = 
					  "switch to a Dead thread"
				       val x_7934: exn = 
					  Fail x_7933
				       val x_7935: thread = 
					  fail (thread) x_7934
				    in
				       x_7935
				    end
				 New[unit] x_7926: unit -> unit => 
				    let
				       val x_7927: unit = 
					  ()
				       val x_7928: unit = 
					  atomicBegin x_7927
				       val x_7929: (unit -> unit) Primitive.Option.t = 
					  SOME[unit -> unit] x_7926
				       val x_7930: (unit -> unit) Primitive.Option.t ref
						   * (unit -> unit) Primitive.Option.t = 
					  (func, x_7929)
				       val x_7931: unit = 
					  :=_1 ((unit -> unit) Primitive.Option.t) x_7930
				       val x_7932: thread = 
					  Thread_copy (x_7868)
				    in
				       x_7932
				    end
				 Paused[unit] x_7920: ((unit -> unit) -> unit)
						      * thread => 
				    let
				       val x_7921: thread = 
					  #1 x_7920
				       val x_7922: (unit -> unit) -> unit = 
					  #0 x_7920
				       val x_7923: unit -> unit = 
					  fn x_1731: unit => 
					  let
					     val x_7924: unit = 
						()
					  in
					     x_7924
					  end
				       val x_7925: unit = 
					  x_7922 x_7923
				    in
				       x_7921
				    end
				 Interrupted[unit] x_7919: thread => 
				    let
				    in
				       x_7919
				    end
			      val x_7936: bool = 
				 false
			      val x_7937: bool ref * bool = 
				 (switching, x_7936)
			      val x_7938: unit = 
				 :=_1 (bool) x_7937
			      val x_7939: unit = 
				 switchTo x_7918
			      val x_7940: unit -> 'a = 
				 !_1 (unit -> 'a) r
			      val x_7941: unit = 
				 ()
			      val x_7942: 'a = 
				 x_7940 x_7941
			   in
			      x_7942
			   end
		  in
		     x_7910
		  end
	 in
	    x_7884
	 end
   val rec 'a_3977 
      switch: ('a_3977 MLtonThread.t -> unit MLtonThread.t) -> 'a_3977 = 
	 fn x_1736: 'a_3977 MLtonThread.t -> unit MLtonThread.t => 
	 let
	    val x_7948: unit = 
	       ()
	    val x_7949: unit = 
	       atomicBegin x_7948
	    val x_7950: 'a_3977 = 
	       atomicSwitch ('a_3977) x_1736
	 in
	    x_7950
	 end
   val rec 
      toPrimitive: unit MLtonThread.t -> thread = 
	 fn x_1737: unit MLtonThread.t => 
	 let
	    val x_7951: thread = 
	       case x_1737 of
	       T[unit] x_7952: unit MLtonThread.thread ref => 
		  let
		     val x_7953: unit MLtonThread.thread = 
			!_1 (unit MLtonThread.thread) x_7952
		     val x_7954: thread = 
			case x_7953 of
			Dead[unit] => 
			   let
			      val x_7982: word8 vector = 
				 "Thread.toPrimitive saw Dead.\n"
			      val x_7983: thread = 
				 die (thread) x_7982
			   in
			      x_7983
			   end
			New[unit] x_7968: unit -> unit => 
			   let
			      val x_7969: thread MLtonThread.t
					  -> unit MLtonThread.t = 
				 fn x_1738: thread MLtonThread.t => 
				 let
				    val x_7970: unit -> unit = 
				       fn x_1739: unit => 
				       let
					  val x_7971: unit MLtonThread.t
						      -> unit MLtonThread.t = 
					     fn x_1740: unit MLtonThread.t => 
					     let
						val x_7972: thread = 
						   toPrimitive x_1740
						val x_7973: thread MLtonThread.t
							    * thread = 
						   (x_1738, x_7972)
						val x_7974: unit MLtonThread.t = 
						   prepare (thread) x_7973
					     in
						x_7974
					     end
					  val x_7975: unit = 
					     switch (unit) x_7971
				       in
					  x_7975
				       end
				    val x_7976: unit MLtonThread.t
						* (unit -> unit) = 
				       (x_1737, x_7970)
				    val x_7977: unit MLtonThread.t = 
				       prepend (unit, unit) x_7976
				    val x_7978: unit = 
				       ()
				    val x_7979: unit MLtonThread.t * unit = 
				       (x_7977, x_7978)
				    val x_7980: unit MLtonThread.t = 
				       prepare (unit) x_7979
				 in
				    x_7980
				 end
			      val x_7981: thread = 
				 switch (thread) x_7969
			   in
			      x_7981
			   end
			Paused[unit] x_7959: ((unit -> unit) -> unit) * thread => 
			   let
			      val x_7960: thread = 
				 #1 x_7959
			      val x_7961: (unit -> unit) -> unit = 
				 #0 x_7959
			      val x_7962: unit MLtonThread.thread = 
				 Dead[unit]
			      val x_7963: unit MLtonThread.thread ref
					  * unit MLtonThread.thread = 
				 (x_7952, x_7962)
			      val x_7964: unit = 
				 :=_1 (unit MLtonThread.thread) x_7963
			      val x_7965: unit -> unit = 
				 fn x_1741: unit => 
				 let
				    val x_7966: unit = 
				       ()
				 in
				    x_7966
				 end
			      val x_7967: unit = 
				 x_7961 x_7965
			   in
			      x_7960
			   end
			Interrupted[unit] x_7955: thread => 
			   let
			      val x_7956: unit MLtonThread.thread = 
				 Dead[unit]
			      val x_7957: unit MLtonThread.thread ref
					  * unit MLtonThread.thread = 
				 (x_7952, x_7956)
			      val x_7958: unit = 
				 :=_1 (unit MLtonThread.thread) x_7957
			   in
			      x_7955
			   end
		  in
		     x_7954
		  end
	 in
	    x_7951
	 end
   val x_7984: word32 = 
      sextdFromInt32ToInt32 numExports
   val x_7985: cpointer -> unit = 
      fn x_1746: cpointer => 
      let
	 val x_7986: word8 vector = 
	    "undefined export"
	 val x_7987: exn = 
	    Fail x_7986
	 val x_7988: unit = 
	    raise x_7987
      in
	 x_7988
      end
   val x_7989: word32 * (cpointer -> unit) = 
      (x_7984, x_7985)
   val exports: (cpointer -> unit) array = 
      array_0 (cpointer -> unit) x_7989
   val x_7990: (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
      NONE[thread * thread Primitive.Option.t ref]
   val worker: (thread * thread Primitive.Option.t ref) Primitive.Option.t ref = 
      Ref_ref[(thread * thread Primitive.Option.t ref) Primitive.Option.t] (x_7990)
   val rec 
      handlerLoop: unit -> unit = 
	 fn x_1742: unit => 
	 let
	    val x_7991: thread = 
	       GC_getSavedThread (x_2121)
	    val x_7992: (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
	       !_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) worker
	    val x_7993: thread * thread Primitive.Option.t ref = 
	       case x_7992 of
	       NONE[thread * thread Primitive.Option.t ref] => 
		  let
		     val x_8001: (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
			NONE[thread * thread Primitive.Option.t ref]
		     val thisWorker: (thread * thread Primitive.Option.t ref) Primitive.Option.t ref = 
			Ref_ref[(thread * thread Primitive.Option.t ref) Primitive.Option.t] (x_8001)
		     val x_8002: thread Primitive.Option.t = 
			NONE[thread]
		     val savedRef: thread Primitive.Option.t ref = 
			Ref_ref[thread Primitive.Option.t] (x_8002)
		     val rec 'a_3978 
			workerLoop: unit -> 'a_3978 = 
			   fn x_1744: unit => 
			   let
			      val x_8003: cpointer = 
				 FFI_getOpArgsResPtr ()
			      val x_8004: unit = 
				 ()
			      val x_8005: unit = 
				 atomicEnd x_8004
			      val x_8006: word32 = 
				 0x0
			      val x_8007: cpointer * word32 = 
				 (x_8003, x_8006)
			      val x_8008: cpointer = 
				 getCPointer x_8007
			      val x_8009: word32 = 
				 0x0
			      val x_8010: cpointer * word32 = 
				 (x_8008, x_8009)
			      val i: word32 = 
				 getInt32 x_8010
			      val x_8011: unit = 
				 let
				    val x_8012: word32 = 
				       sextdFromInt32ToInt32 i
				    val x_8013: (cpointer -> unit) array
						* word32 = 
				       (exports, x_8012)
				    val x_8014: cpointer -> unit = 
				       sub_9 (cpointer -> unit) x_8013
				    val x_8015: unit = 
				       x_8014 x_8003
				 in
				    x_8015
				 end
				 handle x_1745 => let
						     val x_8016: word8 vector = 
							"Call from C to SML raised exception.\n"
						     val x_8017: ImperativeIOExtra.Outstream.t
								 * word8 vector = 
							(stdErr, x_8016)
						     val x_8018: unit = 
							output x_8017
						     val x_8019: unit = 
							topLevelHandler (unit) x_1745
						  in
						     x_8019
						  end
			      val x_8020: unit = 
				 ()
			      val x_8021: unit = 
				 atomicBegin x_8020
			      val x_8022: (thread
					   * thread Primitive.Option.t ref) Primitive.Option.t = 
				 !_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) thisWorker
			      val x_8023: (thread
					   * thread Primitive.Option.t ref) Primitive.Option.t ref
					  * (thread
					     * thread Primitive.Option.t ref) Primitive.Option.t = 
				 (worker, x_8022)
			      val x_8024: unit = 
				 :=_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) x_8023
			      val x_8025: thread Primitive.Option.t = 
				 !_1 (thread Primitive.Option.t) savedRef
			      val x_8026: thread = 
				 valOf_1 (thread) x_8025
			      val x_8027: unit = 
				 GC_setSavedThread (x_2121, x_8026)
			      val x_8028: thread Primitive.Option.t = 
				 NONE[thread]
			      val x_8029: thread Primitive.Option.t ref
					  * thread Primitive.Option.t = 
				 (savedRef, x_8028)
			      val x_8030: unit = 
				 :=_1 (thread Primitive.Option.t) x_8029
			      val x_8031: unit = 
				 Thread_returnToC ()
			      val x_8032: unit = 
				 ()
			      val x_8033: 'a_3978 = 
				 workerLoop ('a_3978) x_8032
			   in
			      x_8033
			   end
		     val x_8034: unit MLtonThread.t = 
			new (unit) workerLoop (unit)
		     val workerThread: thread = 
			toPrimitive x_8034
		     val x_8035: thread * thread Primitive.Option.t ref = 
			(workerThread, savedRef)
		     val x_8036: (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
			SOME[thread * thread Primitive.Option.t ref] x_8035
		     val x_8037: (thread * thread Primitive.Option.t ref) Primitive.Option.t ref
				 * (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
			(thisWorker, x_8036)
		     val x_8038: unit = 
			:=_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) x_8037
		     val x_8039: thread * thread Primitive.Option.t ref = 
			(workerThread, savedRef)
		  in
		     x_8039
		  end
	       SOME[thread * thread Primitive.Option.t ref] x_7994: thread
								    * thread Primitive.Option.t ref => 
		  let
		     val x_7995: thread Primitive.Option.t ref = 
			#1 x_7994
		     val x_7996: thread = 
			#0 x_7994
		     val x_7997: (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
			NONE[thread * thread Primitive.Option.t ref]
		     val x_7998: (thread * thread Primitive.Option.t ref) Primitive.Option.t ref
				 * (thread * thread Primitive.Option.t ref) Primitive.Option.t = 
			(worker, x_7997)
		     val x_7999: unit = 
			:=_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) x_7998
		     val x_8000: thread * thread Primitive.Option.t ref = 
			(x_7996, x_7995)
		  in
		     x_8000
		  end
	    val savedRef: thread Primitive.Option.t ref = 
	       #1 x_7993
	    val workerThread: thread = 
	       #0 x_7993
	    val x_8040: thread Primitive.Option.t = 
	       SOME[thread] x_7991
	    val x_8041: thread Primitive.Option.t ref
			* thread Primitive.Option.t = 
	       (savedRef, x_8040)
	    val x_8042: unit = 
	       :=_1 (thread Primitive.Option.t) x_8041
	    val x_8043: unit = 
	       switchTo workerThread
	    val x_8044: unit = 
	       ()
	    val x_8045: unit = 
	       handlerLoop x_8044
	 in
	    x_8045
	 end
   val x_8046: unit MLtonThread.t = 
      new (unit) handlerLoop
   val handlerThread: thread = 
      toPrimitive x_8046
   val x_8047: unit = 
      GC_setCallFromCHandlerThread (x_2121, handlerThread)
   exception MisuseOfForget
   exception DoublyRedirected
   exception Poll
   val x_8048: (word16 -> word16) * (word16 -> word16) = 
      (idFromWord16ToInt16, htons)
   val x_8049: word16 -> word16 = 
      o_1 (word16, word16, word16) x_8048
   val x_8050: (word16 -> word16) * (word16 -> word16) = 
      (x_8049, idFromInt16ToWord16)
   val hton: word16 -> word16 = 
      o_1 (word16, word16, word16) x_8050
   val x_8051: (word16 -> word16) * (word16 -> word16) = 
      (idFromWord16ToInt16, ntohs)
   val x_8052: word16 -> word16 = 
      o_1 (word16, word16, word16) x_8051
   val x_8053: (word16 -> word16) * (word16 -> word16) = 
      (x_8052, idFromInt16ToWord16)
   val ntoh: word16 -> word16 = 
      o_1 (word16, word16, word16) x_8053
   val ('a_4120, 'a_4119) fInt8: 'a_4120 -> 'a_4119 = 
      let
	 val x_8054: 'a_4120 -> 'a_4119 = 
	    fn x_1748: 'a_4120 => 
	    let
	       val x_8055: word8 vector = 
		  "Net.C_Int.hton: fInt8"
	       val x_8056: exn = 
		  Fail x_8055
	       val x_8057: 'a_4119 = 
		  raise x_8056
	    in
	       x_8057
	    end
      in
	 x_8054
      end
   val ('a_4122, 'a_4121) fInt64: 'a_4122 -> 'a_4121 = 
      let
	 val x_8058: 'a_4122 -> 'a_4121 = 
	    fn x_1749: 'a_4122 => 
	    let
	       val x_8059: word8 vector = 
		  "Net.C_Int.hton: fInt64"
	       val x_8060: exn = 
		  Fail x_8059
	       val x_8061: 'a_4121 = 
		  raise x_8060
	    in
	       x_8061
	    end
      in
	 x_8058
      end
   val ('a_4126, 'a_4125) fInt8: 'a_4126 -> 'a_4125 = 
      let
	 val x_8062: 'a_4126 -> 'a_4125 = 
	    fn x_1750: 'a_4126 => 
	    let
	       val x_8063: word8 vector = 
		  "Net.C_Int.ntoh: fInt8"
	       val x_8064: exn = 
		  Fail x_8063
	       val x_8065: 'a_4125 = 
		  raise x_8064
	    in
	       x_8065
	    end
      in
	 x_8062
      end
   val ('a_4128, 'a_4127) fInt64: 'a_4128 -> 'a_4127 = 
      let
	 val x_8066: 'a_4128 -> 'a_4127 = 
	    fn x_1751: 'a_4128 => 
	    let
	       val x_8067: word8 vector = 
		  "Net.C_Int.ntoh: fInt64"
	       val x_8068: exn = 
		  Fail x_8067
	       val x_8069: 'a_4127 = 
		  raise x_8068
	    in
	       x_8069
	    end
      in
	 x_8066
      end
   val x_8070: word32 = 
      0x0
   val x_8071: cpointer -> unit = 
      fn x_1754: cpointer => 
      let
	 val x_8072: word8 vector = 
	    "hihi\n"
	 val x_8073: ImperativeIOExtra.Outstream.t * word8 vector = 
	    (x_7659, x_8072)
	 val x_8074: unit = 
	    output x_8073
	 val x_8075: StreamIOExtra.outstream = 
	    get x_7659
	 val x_8076: unit = 
	    flushOut x_8075
	 val x_8077: unit = 
	    ()
      in
	 x_8077
      end
   val x_8078: (cpointer -> unit) array * word32 * (cpointer -> unit) = 
      (exports, x_8070, x_8071)
   val x_8079: unit = 
      update_0 (cpointer -> unit) x_8078
   val x_8080: MLtonProfile.Data.t list = 
      nil[MLtonProfile.Data.t]
   val all: MLtonProfile.Data.t list ref = 
      Ref_ref[MLtonProfile.Data.t list] (x_8080)
   val rec 'a_4211 
      make: (bool ref * bool ref * cpointer -> 'a_4211)
	    -> MLtonProfile.Data.t -> 'a_4211 = 
	 fn x_1755: bool ref * bool ref * cpointer -> 'a_4211 => 
	 let
	    val x_8081: MLtonProfile.Data.t -> 'a_4211 = 
	       fn x_1756: MLtonProfile.Data.t => 
	       let
		  val x_8082: 'a_4211 = 
		     case x_1756 of
		     T x_8083: bool ref * bool ref * cpointer => 
			let
			   val x_8084: 'a_4211 = 
			      x_1755 x_8083
			in
			   x_8084
			end
	       in
		  x_8082
	       end
	 in
	    x_8081
	 end
   val x_8085: bool ref * bool ref * cpointer -> cpointer = 
      fn x_1757: bool ref * bool ref * cpointer => 
      let
	 val x_8086: cpointer = 
	    #2 x_1757
      in
	 x_8086
      end
   val raw: MLtonProfile.Data.t -> cpointer = 
      make (cpointer) x_8085
   val rec 
      make: cpointer -> MLtonProfile.Data.t = 
	 fn x_1758: cpointer => 
	 let
	    val x_8087: bool = 
	       false
	    val x_8088: bool ref = 
	       Ref_ref[bool] (x_8087)
	    val x_8089: bool = 
	       false
	    val x_8090: bool ref = 
	       Ref_ref[bool] (x_8089)
	    val x_8091: bool ref * bool ref * cpointer = 
	       (x_8088, x_8090, x_1758)
	    val x_8092: MLtonProfile.Data.t = 
	       T x_8091
	 in
	    x_8092
	 end
   val x_8093: MLtonProfile.Data.t = 
      make null
   val r: MLtonProfile.Data.t ref = 
      Ref_ref[MLtonProfile.Data.t] (x_8093)
   val rec 
      current: unit -> MLtonProfile.Data.t = 
	 fn x_1760: unit => 
	 let
	    val x_8094: MLtonProfile.Data.t = 
	       !_1 (MLtonProfile.Data.t) r
	 in
	    x_8094
	 end
   val rec 
      init: unit -> unit = 
	 fn x_1762: unit => 
	 let
	    val x_8095: cpointer = 
	       GC_getProfileCurrent (x_2121)
	    val x_8096: MLtonProfile.Data.t = 
	       make x_8095
	    val x_8097: unit = 
	       case x_8096 of
	       T x_8098: bool ref * bool ref * cpointer => 
		  let
		     val x_8099: cpointer = 
			#2 x_8098
		     val x_8100: bool ref = 
			#1 x_8098
		     val x_8101: bool ref = 
			#0 x_8098
		     val x_8102: bool = 
			not isOn
		     val x_8103: unit = 
			case x_8102 of
			true => 
			   let
			      val x_8124: unit = 
				 ()
			   in
			      x_8124
			   end
			false => 
			   let
			      val x_8104: bool = 
				 !_1 (bool) x_8100
			      val x_8105: unit = 
				 case x_8104 of
				 true => 
				    let
				       val x_8121: word8 vector = 
					  "setCurrent of freed profile data"
				       val x_8122: exn = 
					  Fail x_8121
				       val x_8123: unit = 
					  raise x_8122
				    in
				       x_8123
				    end
				 false => 
				    let
				       val x_8106: unit = 
					  ()
				       val x_8107: MLtonProfile.Data.t = 
					  current x_8106
				       val x_8108: unit = 
					  case x_8107 of
					  T x_8109: bool ref
						    * bool ref
						    * cpointer => 
					     let
						val x_8110: bool ref = 
						   #0 x_8109
						val x_8111: bool = 
						   false
						val x_8112: bool ref * bool = 
						   (x_8110, x_8111)
						val x_8113: unit = 
						   :=_1 (bool) x_8112
						val x_8114: bool = 
						   true
						val x_8115: bool ref * bool = 
						   (x_8101, x_8114)
						val x_8116: unit = 
						   :=_1 (bool) x_8115
						val x_8117: MLtonProfile.Data.t ref
							    * MLtonProfile.Data.t = 
						   (r, x_8096)
						val x_8118: unit = 
						   :=_1 (MLtonProfile.Data.t) x_8117
						val x_8119: unit = 
						   GC_setProfileCurrent (x_2121,
									 x_8099)
						val x_8120: unit = 
						   ()
					     in
						x_8120
					     end
				    in
				       x_8108
				    end
			   in
			      x_8105
			   end
		  in
		     x_8103
		  end
	 in
	    x_8097
	 end
   val x_8125: bool = 
      not isOn
   val x_8126: unit = 
      case x_8125 of
      true => 
	 let
	    val x_8165: unit = 
	       ()
	 in
	    x_8165
	 end
      false => 
	 let
	    val x_8127: unit -> unit = 
	       fn x_1764: unit => 
	       let
		  val x_8128: unit = 
		     GC_profileDone (x_2121)
		  val x_8129: unit = 
		     ()
		  val x_8130: MLtonProfile.Data.t = 
		     current x_8129
		  val x_8131: word8 vector = 
		     "mlmon.out"
		  val x_8132: unit = 
		     case x_8130 of
		     T x_8133: bool ref * bool ref * cpointer => 
			let
			   val x_8134: cpointer = 
			      #2 x_8133
			   val x_8135: bool ref = 
			      #1 x_8133
			   val x_8136: bool = 
			      not isOn
			   val x_8137: unit = 
			      case x_8136 of
			      true => 
				 let
				    val x_8146: unit = 
				       ()
				 in
				    x_8146
				 end
			      false => 
				 let
				    val x_8138: bool = 
				       !_1 (bool) x_8135
				    val x_8139: unit = 
				       case x_8138 of
				       true => 
					  let
					     val x_8143: word8 vector = 
						"write of freed profile data"
					     val x_8144: exn = 
						Fail x_8143
					     val x_8145: unit = 
						raise x_8144
					  in
					     x_8145
					  end
				       false => 
					  let
					     val x_8140: word8 vector = 
						nullTerm x_8131
					     val x_8141: word8 vector = 
						fromString x_8140
					     val x_8142: unit = 
						GC_profileWrite (x_2121,
								 x_8134,
								 x_8141)
					  in
					     x_8142
					  end
				 in
				    x_8139
				 end
			in
			   x_8137
			end
		  val x_8147: MLtonProfile.Data.t -> unit = 
		     fn x_1765: MLtonProfile.Data.t => 
		     let
			val x_8148: cpointer = 
			   raw x_1765
			val x_8149: unit = 
			   GC_profileFree (x_2121, x_8148)
		     in
			x_8149
		     end
		  val x_8150: MLtonProfile.Data.t list -> unit = 
		     app_0 (MLtonProfile.Data.t) x_8147
		  val x_8151: MLtonProfile.Data.t list = 
		     !_1 (MLtonProfile.Data.t list) all
		  val x_8152: unit = 
		     x_8150 x_8151
	       in
		  x_8152
	       end
	    val x_8153: (unit -> unit) list ref * (unit -> unit) = 
	       (atExit, x_8127)
	    val x_8154: unit = 
	       addNew (unit -> unit) x_8153
	    val x_8155: unit -> unit = 
	       fn x_1763: unit => 
	       let
		  val x_8156: MLtonProfile.Data.t list = 
		     nil[MLtonProfile.Data.t]
		  val x_8157: MLtonProfile.Data.t list ref
			      * MLtonProfile.Data.t list = 
		     (all, x_8156)
		  val x_8158: unit = 
		     :=_1 (MLtonProfile.Data.t list) x_8157
		  val x_8159: unit = 
		     ()
		  val x_8160: unit = 
		     init x_8159
	       in
		  x_8160
	       end
	    val x_8161: (unit -> unit) list ref * (unit -> unit) = 
	       (atLoadWorld, x_8155)
	    val x_8162: unit = 
	       addNew (unit -> unit) x_8161
	    val x_8163: unit = 
	       ()
	    val x_8164: unit = 
	       init x_8163
	 in
	    x_8164
	 end
   val x_8166: unit = 
      setHandler defaultTopLevelHandler (unit)
   val x_8167: unit = 
      setSuffix defaultTopLevelSuffix (unit)
   exception UNKNOWN
   val x_8168: unit = 
      ()
in
   x_8168
end
