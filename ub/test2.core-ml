MLton gd05531c-dirty (built Wed Jun 29 03:10:58 UTC 2016 on ip-10-11-0-169)
  created this file on Wed Jun 29 03:19:13 2016.
Do not edit this file.
Flag settings: 
   align: 8
   atMLtons: (@MLton, --)
   chunk: coalesce 4096
   closureConvertGlobalize: true
   closureConvertShrink: true
   codegen: c
   contifyIntoMain: false
   debug: true
   defaultChar: char8
   defaultWideChar: widechar32
   defaultInt: int32
   defaultReal: real64
   defaultWord: word32
   diag passes: []
   drop passes: []
   elaborate allowConstant (default): false
   elaborate allowConstant (enabled): true
   elaborate allowFFI (default): false
   elaborate allowFFI (enabled): true
   elaborate allowPrim (default): false
   elaborate allowPrim (enabled): true
   elaborate allowOverload (default): false
   elaborate allowOverload (enabled): true
   elaborate allowOptBar (default): false
   elaborate allowOptBar (enabled): true
   elaborate allowOptSemicolon (default): false
   elaborate allowOptSemicolon (enabled): true
   elaborate allowLineComments (default): false
   elaborate allowLineComments (enabled): true
   elaborate allowDoDecls (default): false
   elaborate allowDoDecls (enabled): true
   elaborate allowRecPunning (default): false
   elaborate allowRecPunning (enabled): true
   elaborate allowOrPats (default): false
   elaborate allowOrPats (enabled): true
   elaborate allowExtendedLiterals (default): false
   elaborate allowExtendedLiterals (enabled): true
   elaborate allowSigWithtype (default): false
   elaborate allowSigWithtype (enabled): true
   elaborate allowRebindEquals (default): false
   elaborate allowRebindEquals (enabled): true
   elaborate deadCode (default): false
   elaborate deadCode (enabled): true
   elaborate forceUsed (default): false
   elaborate forceUsed (enabled): true
   elaborate ffiStr (default): 
   elaborate ffiStr (enabled): true
   elaborate nonexhaustiveExnMatch (default): default
   elaborate nonexhaustiveExnMatch (enabled): true
   elaborate nonexhaustiveMatch (default): warn
   elaborate nonexhaustiveMatch (enabled): true
   elaborate redundantMatch (default): warn
   elaborate redundantMatch (enabled): true
   elaborate resolveScope (default): strdec
   elaborate resolveScope (enabled): true
   elaborate sequenceNonUnit (default): ignore
   elaborate sequenceNonUnit (enabled): true
   elaborate valrecConstr (default): warn
   elaborate valrecConstr (enabled): true
   elaborate warnUnused (default): false
   elaborate warnUnused (enabled): true
   elaborate only: false
   emit main: true
   export header: None
   exn history: false
   generated output format: executable
   gc check: Limit
   indentation: 3
   inlineIntoMain: true
   inlineLeafA: {loops = true, repeat = true, size = Some 20}
   inlineLeafB: {loops = true, repeat = true, size = Some 40}
   inlineNonRec: {small = 60, product = 320}
   input file: test2.core-ml
   keep AST: false
   keep CoreML: true
   keep def use: true
   keep dot: false
   keep Machine: true
   keep passes: []
   keep RSSA: true
   keep SSA: true
   keep SSA2: true
   keep SXML: true
   keep XML: true
   extra_: false
   lib dir: /home/jcmurphy/MLton/build/lib
   lib target dir: /home/jcmurphy/MLton/build/lib/targets/self
   loop passes: 1
   mark cards: true
   max function size: 10000
   mlb path vars: [{var = MLTON_ROOT, path = $(LIB_MLTON_DIR)/sml}, {var = SML_LIB, path = $(LIB_MLTON_DIR)/sml}]
   native commented: 0
   native live stack: false
   native optimize: 1
   native move hoist: true
   native copy prop: true
   native copy prop cutoff: 1000
   native cutoff: 100
   native live transfer: 8
   native shuffle: true
   native ieee fp: false
   native split: Some 20000
   optimizationPasses: [<ssa2::default>, <ssa::default>, <sxml::default>, <xml::default>]
   polyvariance: Some {hofo = true, rounds = 2, small = 30, product = 300}
   prefer abs paths: false
   prof passes: []
   profile: None
   profile branch: false
   profile C: []
   profile IL: ProfileSource
   profile include/exclude: [(Seq [Star [.], Or [Seq [Seq [[$], [(], [S], [M], [L], [_], [L], [I], [B], [)]]]], Star [.]], false)]
   profile raise: false
   profile stack: false
   profile val: false
   show basis: None
   show def-use: None
   show types: true
   target: self
   target arch: AMD64
   target OS: Linux
   type check: false
   verbosity: Pass
   warn unrecognized annotation: true
   warn deprecated features: true
   zone cut depth: 100


Decs:
datatype bool = false
		| true
	 'a_0 list = nil
		     | :: of 'a_0 * 'a_0 list
	 'a_1 ref = ref of 'a_1
exception Bind
exception Match
exception Overflow
val rec
   not: bool -> bool = 
      (fn x_0: bool =>
       case x_0 of
	 (b: bool) => case b of true => false | false => true)
val detectOverflow: bool = 0x1
val safe: bool = 0x1
val bufSize: int32 = 0x1000
val name: exn -> string = (fn x_1: exn => Exn_name (x_1))
exception Div
exception Domain
exception Fail8 of string
exception Fail16 of char16 vector
exception Fail32 of char32 vector
exception Overflow
exception Size
exception Span
exception Subscript
val ('b, 'a) wrapOverflow: ('a -> 'b) -> 'a -> 'b =
   (fn x_2: 'a -> 'b =>
    case x_2 of
      f: 'a -> 'b =>
      (fn x_3: 'a =>
       case x_3 of
	 a: 'a => (f a) handle x_4 => case x_4 of Overflow => raise Overflow))
datatype Primitive.Order.t = LESS
			     | EQUAL
			     | GREATER
datatype 'a Primitive.Option.t = NONE
				 | SOME of 'a
val 'a deref: 'a ref -> 'a = (fn x_5: 'a ref => Ref_deref['a] (x_5))
val 'a assign: 'a ref * 'a -> unit =
   (fn x_6: 'a ref * 'a =>
    case x_6 of
      (x_8: 'a ref, x_7: 'a) => Ref_assign['a] (x_8, x_7))
val getHandler: unit -> exn -> unit =
   (fn x_9: unit =>
    case x_9 of
      () => TopLevel_getHandler ())
val setHandler: (exn -> unit) -> unit =
   (fn x_10: exn -> unit =>
    TopLevel_setHandler (x_10))
val setSuffix: (unit -> unit) -> unit =
   (fn x_11: unit -> unit =>
    TopLevel_setSuffix (x_11))
val not: bool -> bool = not
val ''a =: ''a * ''a -> bool =
   (fn x_12: ''a * ''a =>
    case x_12 of
      (x_14: ''a, x_13: ''a) => MLton_equal[''a] (x_14, x_13))
val ''a_2 <>: ''a_2 * ''a_2 -> bool =
   (fn x_15: ''a_2 * ''a_2 =>
    case x_15 of
      (x: ''a_2, y: ''a_2) => (not (= (''a_2) (x, y))))
val idFromInt8ToWord8: int8 -> word8 =
   (fn x_16: int8 =>
    WordU8_extdToWord8 (x_16))
val idFromInt16ToWord16: int16 -> word16 =
   (fn x_17: int16 =>
    WordU16_extdToWord16 (x_17))
val idFromInt32ToWord32: int32 -> word32 =
   (fn x_18: int32 =>
    WordU32_extdToWord32 (x_18))
val idFromInt64ToWord64: int64 -> word64 =
   (fn x_19: int64 =>
    WordU64_extdToWord64 (x_19))
val idFromWord8ToInt8: word8 -> int8 =
   (fn x_20: word8 =>
    WordU8_extdToWord8 (x_20))
val idFromWord16ToInt16: word16 -> int16 =
   (fn x_21: word16 =>
    WordU16_extdToWord16 (x_21))
val idFromWord32ToInt32: word32 -> int32 =
   (fn x_22: word32 =>
    WordU32_extdToWord32 (x_22))
val idFromWord64ToInt64: word64 -> int64 =
   (fn x_23: word64 =>
    WordU64_extdToWord64 (x_23))
val zextdFromInt8ToInt8: int8 -> int8 =
   (fn x_24: int8 =>
    WordU8_extdToWord8 (x_24))
val zextdFromInt8ToInt16: int8 -> int16 =
   (fn x_25: int8 =>
    WordU8_extdToWord16 (x_25))
val zextdFromInt8ToInt32: int8 -> int32 =
   (fn x_26: int8 =>
    WordU8_extdToWord32 (x_26))
val zextdFromInt8ToInt64: int8 -> int64 =
   (fn x_27: int8 =>
    WordU8_extdToWord64 (x_27))
val zextdFromInt8ToWord8: int8 -> word8 =
   (fn x_28: int8 =>
    WordU8_extdToWord8 (x_28))
val zextdFromInt8ToWord16: int8 -> word16 =
   (fn x_29: int8 =>
    WordU8_extdToWord16 (x_29))
val zextdFromInt8ToWord32: int8 -> word32 =
   (fn x_30: int8 =>
    WordU8_extdToWord32 (x_30))
val zextdFromInt8ToWord64: int8 -> word64 =
   (fn x_31: int8 =>
    WordU8_extdToWord64 (x_31))
val zextdFromInt16ToInt8: int16 -> int8 =
   (fn x_32: int16 =>
    WordU16_extdToWord8 (x_32))
val zextdFromInt16ToInt16: int16 -> int16 =
   (fn x_33: int16 =>
    WordU16_extdToWord16 (x_33))
val zextdFromInt16ToInt32: int16 -> int32 =
   (fn x_34: int16 =>
    WordU16_extdToWord32 (x_34))
val zextdFromInt16ToInt64: int16 -> int64 =
   (fn x_35: int16 =>
    WordU16_extdToWord64 (x_35))
val zextdFromInt16ToWord8: int16 -> word8 =
   (fn x_36: int16 =>
    WordU16_extdToWord8 (x_36))
val zextdFromInt16ToWord16: int16 -> word16 =
   (fn x_37: int16 =>
    WordU16_extdToWord16 (x_37))
val zextdFromInt16ToWord32: int16 -> word32 =
   (fn x_38: int16 =>
    WordU16_extdToWord32 (x_38))
val zextdFromInt16ToWord64: int16 -> word64 =
   (fn x_39: int16 =>
    WordU16_extdToWord64 (x_39))
val zextdFromInt32ToInt8: int32 -> int8 =
   (fn x_40: int32 =>
    WordU32_extdToWord8 (x_40))
val zextdFromInt32ToInt16: int32 -> int16 =
   (fn x_41: int32 =>
    WordU32_extdToWord16 (x_41))
val zextdFromInt32ToInt32: int32 -> int32 =
   (fn x_42: int32 =>
    WordU32_extdToWord32 (x_42))
val zextdFromInt32ToInt64: int32 -> int64 =
   (fn x_43: int32 =>
    WordU32_extdToWord64 (x_43))
val zextdFromInt32ToWord8: int32 -> word8 =
   (fn x_44: int32 =>
    WordU32_extdToWord8 (x_44))
val zextdFromInt32ToWord16: int32 -> word16 =
   (fn x_45: int32 =>
    WordU32_extdToWord16 (x_45))
val zextdFromInt32ToWord32: int32 -> word32 =
   (fn x_46: int32 =>
    WordU32_extdToWord32 (x_46))
val zextdFromInt32ToWord64: int32 -> word64 =
   (fn x_47: int32 =>
    WordU32_extdToWord64 (x_47))
val zextdFromInt64ToInt8: int64 -> int8 =
   (fn x_48: int64 =>
    WordU64_extdToWord8 (x_48))
val zextdFromInt64ToInt16: int64 -> int16 =
   (fn x_49: int64 =>
    WordU64_extdToWord16 (x_49))
val zextdFromInt64ToInt32: int64 -> int32 =
   (fn x_50: int64 =>
    WordU64_extdToWord32 (x_50))
val zextdFromInt64ToInt64: int64 -> int64 =
   (fn x_51: int64 =>
    WordU64_extdToWord64 (x_51))
val zextdFromInt64ToWord8: int64 -> word8 =
   (fn x_52: int64 =>
    WordU64_extdToWord8 (x_52))
val zextdFromInt64ToWord16: int64 -> word16 =
   (fn x_53: int64 =>
    WordU64_extdToWord16 (x_53))
val zextdFromInt64ToWord32: int64 -> word32 =
   (fn x_54: int64 =>
    WordU64_extdToWord32 (x_54))
val zextdFromInt64ToWord64: int64 -> word64 =
   (fn x_55: int64 =>
    WordU64_extdToWord64 (x_55))
val zextdFromWord8ToInt8: word8 -> int8 =
   (fn x_56: word8 =>
    WordU8_extdToWord8 (x_56))
val zextdFromWord8ToInt16: word8 -> int16 =
   (fn x_57: word8 =>
    WordU8_extdToWord16 (x_57))
val zextdFromWord8ToInt32: word8 -> int32 =
   (fn x_58: word8 =>
    WordU8_extdToWord32 (x_58))
val zextdFromWord8ToInt64: word8 -> int64 =
   (fn x_59: word8 =>
    WordU8_extdToWord64 (x_59))
val zextdFromWord8ToWord8: word8 -> word8 =
   (fn x_60: word8 =>
    WordU8_extdToWord8 (x_60))
val zextdFromWord8ToWord16: word8 -> word16 =
   (fn x_61: word8 =>
    WordU8_extdToWord16 (x_61))
val zextdFromWord8ToWord32: word8 -> word32 =
   (fn x_62: word8 =>
    WordU8_extdToWord32 (x_62))
val zextdFromWord8ToWord64: word8 -> word64 =
   (fn x_63: word8 =>
    WordU8_extdToWord64 (x_63))
val zextdFromWord16ToInt8: word16 -> int8 =
   (fn x_64: word16 =>
    WordU16_extdToWord8 (x_64))
val zextdFromWord16ToInt16: word16 -> int16 =
   (fn x_65: word16 =>
    WordU16_extdToWord16 (x_65))
val zextdFromWord16ToInt32: word16 -> int32 =
   (fn x_66: word16 =>
    WordU16_extdToWord32 (x_66))
val zextdFromWord16ToInt64: word16 -> int64 =
   (fn x_67: word16 =>
    WordU16_extdToWord64 (x_67))
val zextdFromWord16ToWord8: word16 -> word8 =
   (fn x_68: word16 =>
    WordU16_extdToWord8 (x_68))
val zextdFromWord16ToWord16: word16 -> word16 =
   (fn x_69: word16 =>
    WordU16_extdToWord16 (x_69))
val zextdFromWord16ToWord32: word16 -> word32 =
   (fn x_70: word16 =>
    WordU16_extdToWord32 (x_70))
val zextdFromWord16ToWord64: word16 -> word64 =
   (fn x_71: word16 =>
    WordU16_extdToWord64 (x_71))
val zextdFromWord32ToInt8: word32 -> int8 =
   (fn x_72: word32 =>
    WordU32_extdToWord8 (x_72))
val zextdFromWord32ToInt16: word32 -> int16 =
   (fn x_73: word32 =>
    WordU32_extdToWord16 (x_73))
val zextdFromWord32ToInt32: word32 -> int32 =
   (fn x_74: word32 =>
    WordU32_extdToWord32 (x_74))
val zextdFromWord32ToInt64: word32 -> int64 =
   (fn x_75: word32 =>
    WordU32_extdToWord64 (x_75))
val zextdFromWord32ToWord8: word32 -> word8 =
   (fn x_76: word32 =>
    WordU32_extdToWord8 (x_76))
val zextdFromWord32ToWord16: word32 -> word16 =
   (fn x_77: word32 =>
    WordU32_extdToWord16 (x_77))
val zextdFromWord32ToWord32: word32 -> word32 =
   (fn x_78: word32 =>
    WordU32_extdToWord32 (x_78))
val zextdFromWord32ToWord64: word32 -> word64 =
   (fn x_79: word32 =>
    WordU32_extdToWord64 (x_79))
val zextdFromWord64ToInt8: word64 -> int8 =
   (fn x_80: word64 =>
    WordU64_extdToWord8 (x_80))
val zextdFromWord64ToInt16: word64 -> int16 =
   (fn x_81: word64 =>
    WordU64_extdToWord16 (x_81))
val zextdFromWord64ToInt32: word64 -> int32 =
   (fn x_82: word64 =>
    WordU64_extdToWord32 (x_82))
val zextdFromWord64ToInt64: word64 -> int64 =
   (fn x_83: word64 =>
    WordU64_extdToWord64 (x_83))
val zextdFromWord64ToWord8: word64 -> word8 =
   (fn x_84: word64 =>
    WordU64_extdToWord8 (x_84))
val zextdFromWord64ToWord16: word64 -> word16 =
   (fn x_85: word64 =>
    WordU64_extdToWord16 (x_85))
val zextdFromWord64ToWord32: word64 -> word32 =
   (fn x_86: word64 =>
    WordU64_extdToWord32 (x_86))
val zextdFromWord64ToWord64: word64 -> word64 =
   (fn x_87: word64 =>
    WordU64_extdToWord64 (x_87))
val sextdFromInt8ToInt8: int8 -> int8 =
   (fn x_88: int8 =>
    WordS8_extdToWord8 (x_88))
val sextdFromInt8ToInt16: int8 -> int16 =
   (fn x_89: int8 =>
    WordS8_extdToWord16 (x_89))
val sextdFromInt8ToInt32: int8 -> int32 =
   (fn x_90: int8 =>
    WordS8_extdToWord32 (x_90))
val sextdFromInt8ToInt64: int8 -> int64 =
   (fn x_91: int8 =>
    WordS8_extdToWord64 (x_91))
val sextdFromInt8ToWord8: int8 -> word8 =
   (fn x_92: int8 =>
    WordS8_extdToWord8 (x_92))
val sextdFromInt8ToWord16: int8 -> word16 =
   (fn x_93: int8 =>
    WordS8_extdToWord16 (x_93))
val sextdFromInt8ToWord32: int8 -> word32 =
   (fn x_94: int8 =>
    WordS8_extdToWord32 (x_94))
val sextdFromInt8ToWord64: int8 -> word64 =
   (fn x_95: int8 =>
    WordS8_extdToWord64 (x_95))
val sextdFromInt16ToInt8: int16 -> int8 =
   (fn x_96: int16 =>
    WordS16_extdToWord8 (x_96))
val sextdFromInt16ToInt16: int16 -> int16 =
   (fn x_97: int16 =>
    WordS16_extdToWord16 (x_97))
val sextdFromInt16ToInt32: int16 -> int32 =
   (fn x_98: int16 =>
    WordS16_extdToWord32 (x_98))
val sextdFromInt16ToInt64: int16 -> int64 =
   (fn x_99: int16 =>
    WordS16_extdToWord64 (x_99))
val sextdFromInt16ToWord8: int16 -> word8 =
   (fn x_100: int16 =>
    WordS16_extdToWord8 (x_100))
val sextdFromInt16ToWord16: int16 -> word16 =
   (fn x_101: int16 =>
    WordS16_extdToWord16 (x_101))
val sextdFromInt16ToWord32: int16 -> word32 =
   (fn x_102: int16 =>
    WordS16_extdToWord32 (x_102))
val sextdFromInt16ToWord64: int16 -> word64 =
   (fn x_103: int16 =>
    WordS16_extdToWord64 (x_103))
val sextdFromInt32ToInt8: int32 -> int8 =
   (fn x_104: int32 =>
    WordS32_extdToWord8 (x_104))
val sextdFromInt32ToInt16: int32 -> int16 =
   (fn x_105: int32 =>
    WordS32_extdToWord16 (x_105))
val sextdFromInt32ToInt32: int32 -> int32 =
   (fn x_106: int32 =>
    WordS32_extdToWord32 (x_106))
val sextdFromInt32ToInt64: int32 -> int64 =
   (fn x_107: int32 =>
    WordS32_extdToWord64 (x_107))
val sextdFromInt32ToWord8: int32 -> word8 =
   (fn x_108: int32 =>
    WordS32_extdToWord8 (x_108))
val sextdFromInt32ToWord16: int32 -> word16 =
   (fn x_109: int32 =>
    WordS32_extdToWord16 (x_109))
val sextdFromInt32ToWord32: int32 -> word32 =
   (fn x_110: int32 =>
    WordS32_extdToWord32 (x_110))
val sextdFromInt32ToWord64: int32 -> word64 =
   (fn x_111: int32 =>
    WordS32_extdToWord64 (x_111))
val sextdFromInt64ToInt8: int64 -> int8 =
   (fn x_112: int64 =>
    WordS64_extdToWord8 (x_112))
val sextdFromInt64ToInt16: int64 -> int16 =
   (fn x_113: int64 =>
    WordS64_extdToWord16 (x_113))
val sextdFromInt64ToInt32: int64 -> int32 =
   (fn x_114: int64 =>
    WordS64_extdToWord32 (x_114))
val sextdFromInt64ToInt64: int64 -> int64 =
   (fn x_115: int64 =>
    WordS64_extdToWord64 (x_115))
val sextdFromInt64ToWord8: int64 -> word8 =
   (fn x_116: int64 =>
    WordS64_extdToWord8 (x_116))
val sextdFromInt64ToWord16: int64 -> word16 =
   (fn x_117: int64 =>
    WordS64_extdToWord16 (x_117))
val sextdFromInt64ToWord32: int64 -> word32 =
   (fn x_118: int64 =>
    WordS64_extdToWord32 (x_118))
val sextdFromInt64ToWord64: int64 -> word64 =
   (fn x_119: int64 =>
    WordS64_extdToWord64 (x_119))
val sextdFromWord8ToInt8: word8 -> int8 =
   (fn x_120: word8 =>
    WordS8_extdToWord8 (x_120))
val sextdFromWord8ToInt16: word8 -> int16 =
   (fn x_121: word8 =>
    WordS8_extdToWord16 (x_121))
val sextdFromWord8ToInt32: word8 -> int32 =
   (fn x_122: word8 =>
    WordS8_extdToWord32 (x_122))
val sextdFromWord8ToInt64: word8 -> int64 =
   (fn x_123: word8 =>
    WordS8_extdToWord64 (x_123))
val sextdFromWord8ToWord8: word8 -> word8 =
   (fn x_124: word8 =>
    WordS8_extdToWord8 (x_124))
val sextdFromWord8ToWord16: word8 -> word16 =
   (fn x_125: word8 =>
    WordS8_extdToWord16 (x_125))
val sextdFromWord8ToWord32: word8 -> word32 =
   (fn x_126: word8 =>
    WordS8_extdToWord32 (x_126))
val sextdFromWord8ToWord64: word8 -> word64 =
   (fn x_127: word8 =>
    WordS8_extdToWord64 (x_127))
val sextdFromWord16ToInt8: word16 -> int8 =
   (fn x_128: word16 =>
    WordS16_extdToWord8 (x_128))
val sextdFromWord16ToInt16: word16 -> int16 =
   (fn x_129: word16 =>
    WordS16_extdToWord16 (x_129))
val sextdFromWord16ToInt32: word16 -> int32 =
   (fn x_130: word16 =>
    WordS16_extdToWord32 (x_130))
val sextdFromWord16ToInt64: word16 -> int64 =
   (fn x_131: word16 =>
    WordS16_extdToWord64 (x_131))
val sextdFromWord16ToWord8: word16 -> word8 =
   (fn x_132: word16 =>
    WordS16_extdToWord8 (x_132))
val sextdFromWord16ToWord16: word16 -> word16 =
   (fn x_133: word16 =>
    WordS16_extdToWord16 (x_133))
val sextdFromWord16ToWord32: word16 -> word32 =
   (fn x_134: word16 =>
    WordS16_extdToWord32 (x_134))
val sextdFromWord16ToWord64: word16 -> word64 =
   (fn x_135: word16 =>
    WordS16_extdToWord64 (x_135))
val sextdFromWord32ToInt8: word32 -> int8 =
   (fn x_136: word32 =>
    WordS32_extdToWord8 (x_136))
val sextdFromWord32ToInt16: word32 -> int16 =
   (fn x_137: word32 =>
    WordS32_extdToWord16 (x_137))
val sextdFromWord32ToInt32: word32 -> int32 =
   (fn x_138: word32 =>
    WordS32_extdToWord32 (x_138))
val sextdFromWord32ToInt64: word32 -> int64 =
   (fn x_139: word32 =>
    WordS32_extdToWord64 (x_139))
val sextdFromWord32ToWord8: word32 -> word8 =
   (fn x_140: word32 =>
    WordS32_extdToWord8 (x_140))
val sextdFromWord32ToWord16: word32 -> word16 =
   (fn x_141: word32 =>
    WordS32_extdToWord16 (x_141))
val sextdFromWord32ToWord32: word32 -> word32 =
   (fn x_142: word32 =>
    WordS32_extdToWord32 (x_142))
val sextdFromWord32ToWord64: word32 -> word64 =
   (fn x_143: word32 =>
    WordS32_extdToWord64 (x_143))
val sextdFromWord64ToInt8: word64 -> int8 =
   (fn x_144: word64 =>
    WordS64_extdToWord8 (x_144))
val sextdFromWord64ToInt16: word64 -> int16 =
   (fn x_145: word64 =>
    WordS64_extdToWord16 (x_145))
val sextdFromWord64ToInt32: word64 -> int32 =
   (fn x_146: word64 =>
    WordS64_extdToWord32 (x_146))
val sextdFromWord64ToInt64: word64 -> int64 =
   (fn x_147: word64 =>
    WordS64_extdToWord64 (x_147))
val sextdFromWord64ToWord8: word64 -> word8 =
   (fn x_148: word64 =>
    WordS64_extdToWord8 (x_148))
val sextdFromWord64ToWord16: word64 -> word16 =
   (fn x_149: word64 =>
    WordS64_extdToWord16 (x_149))
val sextdFromWord64ToWord32: word64 -> word32 =
   (fn x_150: word64 =>
    WordS64_extdToWord32 (x_150))
val sextdFromWord64ToWord64: word64 -> word64 =
   (fn x_151: word64 =>
    WordS64_extdToWord64 (x_151))
val sizeInBits: int32 = 0x1
val sizeInBits: int32 = 0x2
val sizeInBits: int32 = 0x3
val sizeInBits: int32 = 0x4
val sizeInBits: int32 = 0x5
val sizeInBits: int32 = 0x6
val sizeInBits: int32 = 0x7
val sizeInBits: int32 = 0x8
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val <<?: word8 * word32 -> word8 =
   (fn x_152: word8 * word32 =>
    case x_152 of
      (x_154: word8, x_153: word32) => Word8_lshift (x_154, x_153))
val ~: word8 -> word8 = (fn x_155: word8 => Word8_neg (x_155))
val notb: word8 -> word8 = (fn x_156: word8 => Word8_notb (x_156))
val orb: word8 * word8 -> word8 =
   (fn x_157: word8 * word8 =>
    case x_157 of
      (x_159: word8, x_158: word8) => Word8_orb (x_159, x_158))
val ~>>?: word8 * word32 -> word8 =
   (fn x_160: word8 * word32 =>
    case x_160 of
      (x_162: word8, x_161: word32) => WordS8_rshift (x_162, x_161))
val >>?: word8 * word32 -> word8 =
   (fn x_163: word8 * word32 =>
    case x_163 of
      (x_165: word8, x_164: word32) => WordU8_rshift (x_165, x_164))
val sizeInBits: int32 = 0x9
val sizeInBits: int32 = 0xA
val sizeInBits: int32 = 0xB
val sizeInBits: int32 = 0xC
val sizeInBits: int32 = 0xD
val sizeInBits: int32 = 0xE
val sizeInBits: int32 = 0xF
val sizeInBits: int32 = 0x10
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val <<?: word16 * word32 -> word16 =
   (fn x_166: word16 * word32 =>
    case x_166 of
      (x_168: word16, x_167: word32) => Word16_lshift (x_168, x_167))
val ~: word16 -> word16 = (fn x_169: word16 => Word16_neg (x_169))
val notb: word16 -> word16 = (fn x_170: word16 => Word16_notb (x_170))
val orb: word16 * word16 -> word16 =
   (fn x_171: word16 * word16 =>
    case x_171 of
      (x_173: word16, x_172: word16) => Word16_orb (x_173, x_172))
val ~>>?: word16 * word32 -> word16 =
   (fn x_174: word16 * word32 =>
    case x_174 of
      (x_176: word16, x_175: word32) => WordS16_rshift (x_176, x_175))
val >>?: word16 * word32 -> word16 =
   (fn x_177: word16 * word32 =>
    case x_177 of
      (x_179: word16, x_178: word32) => WordU16_rshift (x_179, x_178))
val sizeInBits: int32 = 0x11
val sizeInBits: int32 = 0x12
val sizeInBits: int32 = 0x13
val sizeInBits: int32 = 0x14
val sizeInBits: int32 = 0x15
val sizeInBits: int32 = 0x16
val sizeInBits: int32 = 0x17
val sizeInBits: int32 = 0x18
val sizeInBits: int32 = 0x19
val sizeInBits: int32 = 0x1A
val sizeInBits: int32 = 0x1B
val sizeInBits: int32 = 0x1C
val sizeInBits: int32 = 0x1D
val sizeInBits: int32 = 0x1E
val sizeInBits: int32 = 0x1F
val sizeInBits: int32 = 0x20
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val +: word32 * word32 -> word32 =
   (fn x_180: word32 * word32 =>
    case x_180 of
      (x_182: word32, x_181: word32) => Word32_add (x_182, x_181))
val andb: word32 * word32 -> word32 =
   (fn x_183: word32 * word32 =>
    case x_183 of
      (x_185: word32, x_184: word32) => Word32_andb (x_185, x_184))
val <<?: word32 * word32 -> word32 =
   (fn x_186: word32 * word32 =>
    case x_186 of
      (x_188: word32, x_187: word32) => Word32_lshift (x_188, x_187))
val ~: word32 -> word32 = (fn x_189: word32 => Word32_neg (x_189))
val notb: word32 -> word32 = (fn x_190: word32 => Word32_notb (x_190))
val orb: word32 * word32 -> word32 =
   (fn x_191: word32 * word32 =>
    case x_191 of
      (x_193: word32, x_192: word32) => Word32_orb (x_193, x_192))
val ~>>?: word32 * word32 -> word32 =
   (fn x_194: word32 * word32 =>
    case x_194 of
      (x_196: word32, x_195: word32) => WordS32_rshift (x_196, x_195))
val >>?: word32 * word32 -> word32 =
   (fn x_197: word32 * word32 =>
    case x_197 of
      (x_199: word32, x_198: word32) => WordU32_rshift (x_199, x_198))
val -: word32 * word32 -> word32 =
   (fn x_200: word32 * word32 =>
    case x_200 of
      (x_202: word32, x_201: word32) => Word32_sub (x_202, x_201))
val xorb: word32 * word32 -> word32 =
   (fn x_203: word32 * word32 =>
    case x_203 of
      (x_205: word32, x_204: word32) => Word32_xorb (x_205, x_204))
val <: word32 * word32 -> bool =
   (fn x_206: word32 * word32 =>
    case x_206 of
      (x_208: word32, x_207: word32) => WordU32_lt (x_208, x_207))
val <: word32 * word32 -> bool = <
val rec
   <=: word32 * word32 -> bool = 
      (fn x_209: word32 * word32 =>
       case x_209 of
	 ((a: word32, b: word32)) => (not (< (b, a))))
val rec
   >=: word32 * word32 -> bool = 
      (fn x_210: word32 * word32 =>
       case x_210 of
	 ((a: word32, b: word32)) => (<= (b, a)))
val sizeInBits: int32 = 0x40
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val +: word64 * word64 -> word64 =
   (fn x_211: word64 * word64 =>
    case x_211 of
      (x_213: word64, x_212: word64) => Word64_add (x_213, x_212))
val andb: word64 * word64 -> word64 =
   (fn x_214: word64 * word64 =>
    case x_214 of
      (x_216: word64, x_215: word64) => Word64_andb (x_216, x_215))
val <<?: word64 * word32 -> word64 =
   (fn x_217: word64 * word32 =>
    case x_217 of
      (x_219: word64, x_218: word32) => Word64_lshift (x_219, x_218))
val *: word64 * word64 -> word64 =
   (fn x_220: word64 * word64 =>
    case x_220 of
      (x_222: word64, x_221: word64) => WordU64_mul (x_222, x_221))
val ~: word64 -> word64 = (fn x_223: word64 => Word64_neg (x_223))
val notb: word64 -> word64 = (fn x_224: word64 => Word64_notb (x_224))
val orb: word64 * word64 -> word64 =
   (fn x_225: word64 * word64 =>
    case x_225 of
      (x_227: word64, x_226: word64) => Word64_orb (x_227, x_226))
val ~>>?: word64 * word32 -> word64 =
   (fn x_228: word64 * word32 =>
    case x_228 of
      (x_230: word64, x_229: word32) => WordS64_rshift (x_230, x_229))
val >>?: word64 * word32 -> word64 =
   (fn x_231: word64 * word32 =>
    case x_231 of
      (x_233: word64, x_232: word32) => WordU64_rshift (x_233, x_232))
val -: word64 * word64 -> word64 =
   (fn x_234: word64 * word64 =>
    case x_234 of
      (x_236: word64, x_235: word64) => Word64_sub (x_236, x_235))
val xorb: word64 * word64 -> word64 =
   (fn x_237: word64 * word64 =>
    case x_237 of
      (x_239: word64, x_238: word64) => Word64_xorb (x_239, x_238))
val <: word64 * word64 -> bool =
   (fn x_240: word64 * word64 =>
    case x_240 of
      (x_242: word64, x_241: word64) => WordU64_lt (x_242, x_241))
val <: word64 * word64 -> bool = <
val sizeInBits: int32 = 0x1
val sizeInBits: int32 = 0x2
val sizeInBits: int32 = 0x3
val sizeInBits: int32 = 0x4
val sizeInBits: int32 = 0x5
val sizeInBits: int32 = 0x6
val sizeInBits: int32 = 0x7
val sizeInBits: int32 = 0x8
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val <: int8 * int8 -> bool =
   (fn x_243: int8 * int8 =>
    case x_243 of
      (x_245: int8, x_244: int8) => WordS8_lt (x_245, x_244))
val <: int8 * int8 -> bool = <
val rec
   >: int8 * int8 -> bool = 
      (fn x_246: int8 * int8 =>
       case x_246 of
	 ((a: int8, b: int8)) => (< (b, a)))
val sizeInBits: int32 = 0x9
val sizeInBits: int32 = 0xA
val sizeInBits: int32 = 0xB
val sizeInBits: int32 = 0xC
val sizeInBits: int32 = 0xD
val sizeInBits: int32 = 0xE
val sizeInBits: int32 = 0xF
val sizeInBits: int32 = 0x10
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val <: int16 * int16 -> bool =
   (fn x_247: int16 * int16 =>
    case x_247 of
      (x_249: int16, x_248: int16) => WordS16_lt (x_249, x_248))
val <: int16 * int16 -> bool = <
val rec
   >: int16 * int16 -> bool = 
      (fn x_250: int16 * int16 =>
       case x_250 of
	 ((a: int16, b: int16)) => (< (b, a)))
val sizeInBits: int32 = 0x11
val sizeInBits: int32 = 0x12
val sizeInBits: int32 = 0x13
val sizeInBits: int32 = 0x14
val sizeInBits: int32 = 0x15
val sizeInBits: int32 = 0x16
val sizeInBits: int32 = 0x17
val sizeInBits: int32 = 0x18
val sizeInBits: int32 = 0x19
val sizeInBits: int32 = 0x1A
val sizeInBits: int32 = 0x1B
val sizeInBits: int32 = 0x1C
val sizeInBits: int32 = 0x1D
val sizeInBits: int32 = 0x1E
val sizeInBits: int32 = 0x1F
val sizeInBits: int32 = 0x20
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val +!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_251: int32 * int32 =>
					 case x_251 of
					   (x_253: int32, x_252: int32) =>
					   WordS32_addCheck (x_253, x_252)))
val +?: int32 * int32 -> int32 =
   (fn x_254: int32 * int32 =>
    case x_254 of
      (x_256: int32, x_255: int32) => Word32_add (x_256, x_255))
val +: int32 * int32 -> int32 = case detectOverflow of true => +! | false => +?
val *!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_257: int32 * int32 =>
					 case x_257 of
					   (x_259: int32, x_258: int32) =>
					   WordS32_mulCheck (x_259, x_258)))
val *?: int32 * int32 -> int32 =
   (fn x_260: int32 * int32 =>
    case x_260 of
      (x_262: int32, x_261: int32) => WordS32_mul (x_262, x_261))
val *: int32 * int32 -> int32 = case detectOverflow of true => *! | false => *?
val ~!: int32 -> int32 =
   (wrapOverflow (int32, int32) (fn x_263: int32 =>
				 Word32_negCheck (x_263)))
val ~?: int32 -> int32 = (fn x_264: int32 => Word32_neg (x_264))
val ~: int32 -> int32 = case detectOverflow of true => ~! | false => ~?
val quotUnsafe: int32 * int32 -> int32 =
   (fn x_265: int32 * int32 =>
    case x_265 of
      (x_267: int32, x_266: int32) => WordS32_quot (x_267, x_266))
val -!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_268: int32 * int32 =>
					 case x_268 of
					   (x_270: int32, x_269: int32) =>
					   WordS32_subCheck (x_270, x_269)))
val -?: int32 * int32 -> int32 =
   (fn x_271: int32 * int32 =>
    case x_271 of
      (x_273: int32, x_272: int32) => Word32_sub (x_273, x_272))
val -: int32 * int32 -> int32 = case detectOverflow of true => -! | false => -?
val remUnsafe: int32 * int32 -> int32 =
   (fn x_274: int32 * int32 =>
    case x_274 of
      (x_276: int32, x_275: int32) => WordS32_rem (x_276, x_275))
val <: int32 * int32 -> bool =
   (fn x_277: int32 * int32 =>
    case x_277 of
      (x_279: int32, x_278: int32) => WordS32_lt (x_279, x_278))
val <: int32 * int32 -> bool = <
val rec
   <=: int32 * int32 -> bool = 
      (fn x_280: int32 * int32 =>
       case x_280 of
	 ((a: int32, b: int32)) => (not (< (b, a))))
val rec
   >: int32 * int32 -> bool = 
      (fn x_281: int32 * int32 =>
       case x_281 of
	 ((a: int32, b: int32)) => (< (b, a)))
val rec
   >=: int32 * int32 -> bool = 
      (fn x_282: int32 * int32 =>
       case x_282 of
	 ((a: int32, b: int32)) => (<= (b, a)))
val sizeInBits: int32 = 0x40
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val +!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_283: int64 * int64 =>
					 case x_283 of
					   (x_285: int64, x_284: int64) =>
					   WordS64_addCheck (x_285, x_284)))
val +?: int64 * int64 -> int64 =
   (fn x_286: int64 * int64 =>
    case x_286 of
      (x_288: int64, x_287: int64) => Word64_add (x_288, x_287))
val +: int64 * int64 -> int64 = case detectOverflow of true => +! | false => +?
val *!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_289: int64 * int64 =>
					 case x_289 of
					   (x_291: int64, x_290: int64) =>
					   WordS64_mulCheck (x_291, x_290)))
val ~!: int64 -> int64 =
   (wrapOverflow (int64, int64) (fn x_292: int64 =>
				 Word64_negCheck (x_292)))
val ~?: int64 -> int64 = (fn x_293: int64 => Word64_neg (x_293))
val ~: int64 -> int64 = case detectOverflow of true => ~! | false => ~?
val quotUnsafe: int64 * int64 -> int64 =
   (fn x_294: int64 * int64 =>
    case x_294 of
      (x_296: int64, x_295: int64) => WordS64_quot (x_296, x_295))
val -!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_297: int64 * int64 =>
					 case x_297 of
					   (x_299: int64, x_298: int64) =>
					   WordS64_subCheck (x_299, x_298)))
val -?: int64 * int64 -> int64 =
   (fn x_300: int64 * int64 =>
    case x_300 of
      (x_302: int64, x_301: int64) => Word64_sub (x_302, x_301))
val -: int64 * int64 -> int64 = case detectOverflow of true => -! | false => -?
val remUnsafe: int64 * int64 -> int64 =
   (fn x_303: int64 * int64 =>
    case x_303 of
      (x_305: int64, x_304: int64) => WordS64_rem (x_305, x_304))
val <: int64 * int64 -> bool =
   (fn x_306: int64 * int64 =>
    case x_306 of
      (x_308: int64, x_307: int64) => WordS64_lt (x_308, x_307))
val <: int64 * int64 -> bool = <
val rec
   <=: int64 * int64 -> bool = 
      (fn x_309: int64 * int64 =>
       case x_309 of
	 ((a: int64, b: int64)) => (not (< (b, a))))
val rec
   >: int64 * int64 -> bool = 
      (fn x_310: int64 * int64 =>
       case x_310 of
	 ((a: int64, b: int64)) => (< (b, a)))
val rec
   >=: int64 * int64 -> bool = 
      (fn x_311: int64 * int64 =>
       case x_311 of
	 ((a: int64, b: int64)) => (<= (b, a)))
val rec
   min: int64 * int64 -> int64 = 
      (fn x_312: int64 * int64 =>
       case x_312 of
	 ((x: int64, y: int64)) => case (< (x, y)) of true => x | false => y)
val rec
   max: int64 * int64 -> int64 = 
      (fn x_313: int64 * int64 =>
       case x_313 of
	 ((x: int64, y: int64)) => case (< (x, y)) of true => y | false => x)
val 'a_165 check: 'a_165 -> 'a_165 =
   (fn x_314: 'a_165 =>
    case x_314 of
      x: 'a_165 => x)
val 'a check_0: 'a -> 'a = check ('a)
val 'a arrayUnsafe: int64 -> 'a array =
   (fn x_315: int64 =>
    Array_array['a] (x_315))
val 'a array0Const: unit -> 'a array =
   (fn x_316: unit =>
    case x_316 of
      () => Array_array0Const['a] ())
val 'a length: 'a array -> int64 =
   (fn x_317: 'a array =>
    Array_length['a] (x_317))
val 'a subUnsafe: 'a array * int64 -> 'a =
   (fn x_318: 'a array * int64 =>
    case x_318 of
      (x_320: 'a array, x_319: int64) => Array_sub['a] (x_320, x_319))
val 'a updateUnsafe: 'a array * int64 * 'a -> unit =
   (fn x_321: 'a array * int64 * 'a =>
    case x_321 of
      (x_324: 'a array, x_323: int64, x_322: 'a) =>
      Array_update['a] (x_324, x_323, x_322))
val 'a fromArrayUnsafe: 'a array -> 'a vector =
   (fn x_325: 'a array =>
    Array_toVector['a] (x_325))
val 'a length: 'a vector -> int64 =
   (fn x_326: 'a vector =>
    Vector_length['a] (x_326))
val 'a subUnsafe: 'a vector * int64 -> 'a =
   (fn x_327: 'a vector * int64 =>
    case x_327 of
      (x_329: 'a vector, x_328: int64) => Vector_sub['a] (x_329, x_328))
val rec
   fromString: string -> string = 
      (fn x_330: string =>
       case x_330 of
	 (s: string) =>
	 case (= (char8) (0x0,
			  (subUnsafe (char8) (s, (- ((length (char8) s), 0x1)))))) of
	   true => s | false => raise (Fail8 "NullString.fromString"))
val +: intInf * intInf * word64 -> intInf =
   (fn x_331: intInf * intInf * word64 =>
    case x_331 of
      (x_334: intInf, x_333: intInf, x_332: word64) =>
      IntInf_add (x_334, x_333, x_332))
val compare: intInf * intInf -> int32 =
   (fn x_335: intInf * intInf =>
    case x_335 of
      (x_337: intInf, x_336: intInf) => IntInf_compare (x_337, x_336))
val fromVector: word64 vector -> intInf =
   (fn x_338: word64 vector =>
    WordVector_toIntInf (x_338))
val fromWord: word64 -> intInf = (fn x_339: word64 => Word_toIntInf (x_339))
val *: intInf * intInf * word64 -> intInf =
   (fn x_340: intInf * intInf * word64 =>
    case x_340 of
      (x_343: intInf, x_342: intInf, x_341: word64) =>
      IntInf_mul (x_343, x_342, x_341))
val ~: intInf * word64 -> intInf =
   (fn x_344: intInf * word64 =>
    case x_344 of
      (x_346: intInf, x_345: word64) => IntInf_neg (x_346, x_345))
val quot: intInf * intInf * word64 -> intInf =
   (fn x_347: intInf * intInf * word64 =>
    case x_347 of
      (x_350: intInf, x_349: intInf, x_348: word64) =>
      IntInf_quot (x_350, x_349, x_348))
val toString: intInf * int32 * word64 -> string =
   (fn x_351: intInf * int32 * word64 =>
    case x_351 of
      (x_354: intInf, x_353: int32, x_352: word64) =>
      IntInf_toString (x_354, x_353, x_352))
val toVector: intInf -> word64 vector =
   (fn x_355: intInf =>
    IntInf_toVector (x_355))
val toWord: intInf -> word64 = (fn x_356: intInf => IntInf_toWord (x_356))
val <: char8 * char8 -> bool =
   (fn x_357: char8 * char8 =>
    case x_357 of
      (x_359: char8, x_358: char8) => WordU8_lt (x_359, x_358))
val idToWord8: char8 -> word8 = (fn x_360: char8 => WordU8_extdToWord8 (x_360))
val idFromWord8: word8 -> char8 =
   (fn x_361: word8 =>
    WordU8_extdToWord8 (x_361))
val <: char8 * char8 -> bool = <
val rec
   <=: char8 * char8 -> bool = 
      (fn x_362: char8 * char8 =>
       case x_362 of
	 ((a: char8, b: char8)) => (not (< (b, a))))
val idToWord16: char16 -> word16 =
   (fn x_363: char16 =>
    WordU16_extdToWord16 (x_363))
val idFromWord16: word16 -> char16 =
   (fn x_364: word16 =>
    WordU16_extdToWord16 (x_364))
val idToWord32: char32 -> word32 =
   (fn x_365: char32 =>
    WordU32_extdToWord32 (x_365))
val idFromWord32: word32 -> char32 =
   (fn x_366: word32 =>
    WordU32_extdToWord32 (x_366))
val realSize: int32 = 0x20
val exponentBias: int32 = 0x7F
val precision: int32 = 0x18
val acos: real32 -> real32 = (fn x_367: real32 => Real32_Math_acos (x_367))
val asin: real32 -> real32 = (fn x_368: real32 => Real32_Math_asin (x_368))
val atan: real32 -> real32 = (fn x_369: real32 => Real32_Math_atan (x_369))
val atan2: real32 * real32 -> real32 =
   (fn x_370: real32 * real32 =>
    case x_370 of
      (x_372: real32, x_371: real32) => Real32_Math_atan2 (x_372, x_371))
val cos: real32 -> real32 = (fn x_373: real32 => Real32_Math_cos (x_373))
val cosh: real32 -> real32 = (fn x_374: real32 => Real32_Math_cosh (x_374))
val e: real32 =
   (((fn x_375: (unit -> real32) * (real32 -> unit) =>
      case x_375 of
	{1 = #: unit -> real32} => #) ((fn x_377: unit =>
				CPointer_getReal32 (Real32_Math_e (), 0x0)),
			       (fn x_376: real32 =>
				CPointer_setReal32 (Real32_Math_e (), 0x0, x_376)))) ())
val exp: real32 -> real32 = (fn x_378: real32 => Real32_Math_exp (x_378))
val ln: real32 -> real32 = (fn x_379: real32 => Real32_Math_ln (x_379))
val log10: real32 -> real32 = (fn x_380: real32 => Real32_Math_log10 (x_380))
val pi: real32 =
   (((fn x_381: (unit -> real32) * (real32 -> unit) =>
      case x_381 of
	{1 = #: unit -> real32} => #) ((fn x_383: unit =>
				CPointer_getReal32 (Real32_Math_pi (), 0x0)),
			       (fn x_382: real32 =>
				CPointer_setReal32 (Real32_Math_pi (),
						    0x0,
						    x_382)))) ())
val pow: real32 * real32 -> real32 =
   (fn x_384: real32 * real32 =>
    case x_384 of
      (x_386: real32, x_385: real32) => Real32_Math_pow (x_386, x_385))
val sin: real32 -> real32 = (fn x_387: real32 => Real32_Math_sin (x_387))
val sinh: real32 -> real32 = (fn x_388: real32 => Real32_Math_sinh (x_388))
val sqrt: real32 -> real32 = (fn x_389: real32 => Real32_Math_sqrt (x_389))
val tan: real32 -> real32 = (fn x_390: real32 => Real32_Math_tan (x_390))
val tanh: real32 -> real32 = (fn x_391: real32 => Real32_Math_tanh (x_391))
val *: real32 * real32 -> real32 =
   (fn x_392: real32 * real32 =>
    case x_392 of
      (x_394: real32, x_393: real32) => Real32_mul (x_394, x_393))
val *+: real32 * real32 * real32 -> real32 =
   (fn x_395: real32 * real32 * real32 =>
    case x_395 of
      (x_398: real32, x_397: real32, x_396: real32) =>
      Real32_muladd (x_398, x_397, x_396))
val *-: real32 * real32 * real32 -> real32 =
   (fn x_399: real32 * real32 * real32 =>
    case x_399 of
      (x_402: real32, x_401: real32, x_400: real32) =>
      Real32_mulsub (x_402, x_401, x_400))
val +: real32 * real32 -> real32 =
   (fn x_403: real32 * real32 =>
    case x_403 of
      (x_405: real32, x_404: real32) => Real32_add (x_405, x_404))
val -: real32 * real32 -> real32 =
   (fn x_406: real32 * real32 =>
    case x_406 of
      (x_408: real32, x_407: real32) => Real32_sub (x_408, x_407))
val /: real32 * real32 -> real32 =
   (fn x_409: real32 * real32 =>
    case x_409 of
      (x_411: real32, x_410: real32) => Real32_div (x_411, x_410))
val ~: real32 -> real32 = (fn x_412: real32 => Real32_neg (x_412))
val <: real32 * real32 -> bool =
   (fn x_413: real32 * real32 =>
    case x_413 of
      (x_415: real32, x_414: real32) => Real32_lt (x_415, x_414))
val <=: real32 * real32 -> bool =
   (fn x_416: real32 * real32 =>
    case x_416 of
      (x_418: real32, x_417: real32) => Real32_le (x_418, x_417))
val ==: real32 * real32 -> bool =
   (fn x_419: real32 * real32 =>
    case x_419 of
      (x_421: real32, x_420: real32) => Real32_equal (x_421, x_420))
val abs: real32 -> real32 = (fn x_422: real32 => Real32_abs (x_422))
val frexp: real32 * int32 ref -> real32 =
   (fn x_423: real32 * int32 ref =>
    case x_423 of
      (x_425: real32, x_424: int32 ref) => Real32_frexp (x_425, x_424))
val gdtoa: real32 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_426: real32 * int32 * int32 * int32 * int32 ref =>
    case x_426 of
      (x_431: real32, x_430: int32, x_429: int32, x_428: int32, x_427: int32 ref) =>
      Real32_gdtoa (x_431, x_430, x_429, x_428, x_427))
val ldexp: real32 * int32 -> real32 =
   (fn x_432: real32 * int32 =>
    case x_432 of
      (x_434: real32, x_433: int32) => Real32_ldexp (x_434, x_433))
val modf: real32 * real32 ref -> real32 =
   (fn x_435: real32 * real32 ref =>
    case x_435 of
      (x_437: real32, x_436: real32 ref) => Real32_modf (x_437, x_436))
val round: real32 -> real32 = (fn x_438: real32 => Real32_round (x_438))
val realCeil: real32 -> real32 = (fn x_439: real32 => Real32_realCeil (x_439))
val realFloor: real32 -> real32 = (fn x_440: real32 => Real32_realFloor (x_440))
val realTrunc: real32 -> real32 = (fn x_441: real32 => Real32_realTrunc (x_441))
val strtor: string * int32 -> real32 =
   (fn x_442: string * int32 =>
    case x_442 of
      (x_444: string, x_443: int32) => Real32_strtor (x_444, x_443))
val fromInt8Unsafe: int8 -> real32 =
   (fn x_445: int8 =>
    WordS8_rndToReal32 (x_445))
val fromInt16Unsafe: int16 -> real32 =
   (fn x_446: int16 =>
    WordS16_rndToReal32 (x_446))
val fromInt32Unsafe: int32 -> real32 =
   (fn x_447: int32 =>
    WordS32_rndToReal32 (x_447))
val fromInt64Unsafe: int64 -> real32 =
   (fn x_448: int64 =>
    WordS64_rndToReal32 (x_448))
val fromReal32Unsafe: real32 -> real32 =
   (fn x_449: real32 =>
    Real32_rndToReal32 (x_449))
val fromWord8Unsafe: word8 -> real32 =
   (fn x_450: word8 =>
    WordU8_rndToReal32 (x_450))
val fromWord16Unsafe: word16 -> real32 =
   (fn x_451: word16 =>
    WordU16_rndToReal32 (x_451))
val fromWord32Unsafe: word32 -> real32 =
   (fn x_452: word32 =>
    WordU32_rndToReal32 (x_452))
val fromWord64Unsafe: word64 -> real32 =
   (fn x_453: word64 =>
    WordU64_rndToReal32 (x_453))
val toInt8Unsafe: real32 -> int8 =
   (fn x_454: real32 =>
    Real32_rndToWordS8 (x_454))
val toInt16Unsafe: real32 -> int16 =
   (fn x_455: real32 =>
    Real32_rndToWordS16 (x_455))
val toInt32Unsafe: real32 -> int32 =
   (fn x_456: real32 =>
    Real32_rndToWordS32 (x_456))
val toInt64Unsafe: real32 -> int64 =
   (fn x_457: real32 =>
    Real32_rndToWordS64 (x_457))
val toReal32Unsafe: real32 -> real32 =
   (fn x_458: real32 =>
    Real32_rndToReal32 (x_458))
val toWord8Unsafe: real32 -> word8 =
   (fn x_459: real32 =>
    Real32_rndToWordU8 (x_459))
val toWord16Unsafe: real32 -> word16 =
   (fn x_460: real32 =>
    Real32_rndToWordU16 (x_460))
val toWord32Unsafe: real32 -> word32 =
   (fn x_461: real32 =>
    Real32_rndToWordU32 (x_461))
val toWord64Unsafe: real32 -> word64 =
   (fn x_462: real32 =>
    Real32_rndToWordU64 (x_462))
val rec
   >: real32 * real32 -> bool = 
      (fn x_463: real32 * real32 =>
       case x_463 of
	 ((a: real32, b: real32)) => (< (b, a)))
val rec
   >=: real32 * real32 -> bool = 
      (fn x_464: real32 * real32 =>
       case x_464 of
	 ((a: real32, b: real32)) => (<= (b, a)))
val realSize: int32 = 0x40
val exponentBias: int32 = 0x3FF
val precision: int32 = 0x35
val acos: real64 -> real64 = (fn x_465: real64 => Real64_Math_acos (x_465))
val asin: real64 -> real64 = (fn x_466: real64 => Real64_Math_asin (x_466))
val atan: real64 -> real64 = (fn x_467: real64 => Real64_Math_atan (x_467))
val atan2: real64 * real64 -> real64 =
   (fn x_468: real64 * real64 =>
    case x_468 of
      (x_470: real64, x_469: real64) => Real64_Math_atan2 (x_470, x_469))
val cos: real64 -> real64 = (fn x_471: real64 => Real64_Math_cos (x_471))
val cosh: real64 -> real64 = (fn x_472: real64 => Real64_Math_cosh (x_472))
val e: real64 =
   (((fn x_473: (unit -> real64) * (real64 -> unit) =>
      case x_473 of
	{1 = #: unit -> real64} => #) ((fn x_475: unit =>
				CPointer_getReal64 (Real64_Math_e (), 0x0)),
			       (fn x_474: real64 =>
				CPointer_setReal64 (Real64_Math_e (), 0x0, x_474)))) ())
val exp: real64 -> real64 = (fn x_476: real64 => Real64_Math_exp (x_476))
val ln: real64 -> real64 = (fn x_477: real64 => Real64_Math_ln (x_477))
val log10: real64 -> real64 = (fn x_478: real64 => Real64_Math_log10 (x_478))
val pi: real64 =
   (((fn x_479: (unit -> real64) * (real64 -> unit) =>
      case x_479 of
	{1 = #: unit -> real64} => #) ((fn x_481: unit =>
				CPointer_getReal64 (Real64_Math_pi (), 0x0)),
			       (fn x_480: real64 =>
				CPointer_setReal64 (Real64_Math_pi (),
						    0x0,
						    x_480)))) ())
val pow: real64 * real64 -> real64 =
   (fn x_482: real64 * real64 =>
    case x_482 of
      (x_484: real64, x_483: real64) => Real64_Math_pow (x_484, x_483))
val sin: real64 -> real64 = (fn x_485: real64 => Real64_Math_sin (x_485))
val sinh: real64 -> real64 = (fn x_486: real64 => Real64_Math_sinh (x_486))
val sqrt: real64 -> real64 = (fn x_487: real64 => Real64_Math_sqrt (x_487))
val tan: real64 -> real64 = (fn x_488: real64 => Real64_Math_tan (x_488))
val tanh: real64 -> real64 = (fn x_489: real64 => Real64_Math_tanh (x_489))
val *: real64 * real64 -> real64 =
   (fn x_490: real64 * real64 =>
    case x_490 of
      (x_492: real64, x_491: real64) => Real64_mul (x_492, x_491))
val *+: real64 * real64 * real64 -> real64 =
   (fn x_493: real64 * real64 * real64 =>
    case x_493 of
      (x_496: real64, x_495: real64, x_494: real64) =>
      Real64_muladd (x_496, x_495, x_494))
val *-: real64 * real64 * real64 -> real64 =
   (fn x_497: real64 * real64 * real64 =>
    case x_497 of
      (x_500: real64, x_499: real64, x_498: real64) =>
      Real64_mulsub (x_500, x_499, x_498))
val +: real64 * real64 -> real64 =
   (fn x_501: real64 * real64 =>
    case x_501 of
      (x_503: real64, x_502: real64) => Real64_add (x_503, x_502))
val -: real64 * real64 -> real64 =
   (fn x_504: real64 * real64 =>
    case x_504 of
      (x_506: real64, x_505: real64) => Real64_sub (x_506, x_505))
val /: real64 * real64 -> real64 =
   (fn x_507: real64 * real64 =>
    case x_507 of
      (x_509: real64, x_508: real64) => Real64_div (x_509, x_508))
val ~: real64 -> real64 = (fn x_510: real64 => Real64_neg (x_510))
val <: real64 * real64 -> bool =
   (fn x_511: real64 * real64 =>
    case x_511 of
      (x_513: real64, x_512: real64) => Real64_lt (x_513, x_512))
val <=: real64 * real64 -> bool =
   (fn x_514: real64 * real64 =>
    case x_514 of
      (x_516: real64, x_515: real64) => Real64_le (x_516, x_515))
val ==: real64 * real64 -> bool =
   (fn x_517: real64 * real64 =>
    case x_517 of
      (x_519: real64, x_518: real64) => Real64_equal (x_519, x_518))
val abs: real64 -> real64 = (fn x_520: real64 => Real64_abs (x_520))
val frexp: real64 * int32 ref -> real64 =
   (fn x_521: real64 * int32 ref =>
    case x_521 of
      (x_523: real64, x_522: int32 ref) => Real64_frexp (x_523, x_522))
val gdtoa: real64 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_524: real64 * int32 * int32 * int32 * int32 ref =>
    case x_524 of
      (x_529: real64, x_528: int32, x_527: int32, x_526: int32, x_525: int32 ref) =>
      Real64_gdtoa (x_529, x_528, x_527, x_526, x_525))
val ldexp: real64 * int32 -> real64 =
   (fn x_530: real64 * int32 =>
    case x_530 of
      (x_532: real64, x_531: int32) => Real64_ldexp (x_532, x_531))
val modf: real64 * real64 ref -> real64 =
   (fn x_533: real64 * real64 ref =>
    case x_533 of
      (x_535: real64, x_534: real64 ref) => Real64_modf (x_535, x_534))
val round: real64 -> real64 = (fn x_536: real64 => Real64_round (x_536))
val realCeil: real64 -> real64 = (fn x_537: real64 => Real64_realCeil (x_537))
val realFloor: real64 -> real64 = (fn x_538: real64 => Real64_realFloor (x_538))
val realTrunc: real64 -> real64 = (fn x_539: real64 => Real64_realTrunc (x_539))
val strtor: string * int32 -> real64 =
   (fn x_540: string * int32 =>
    case x_540 of
      (x_542: string, x_541: int32) => Real64_strtor (x_542, x_541))
val fromInt8Unsafe: int8 -> real64 =
   (fn x_543: int8 =>
    WordS8_rndToReal64 (x_543))
val fromInt16Unsafe: int16 -> real64 =
   (fn x_544: int16 =>
    WordS16_rndToReal64 (x_544))
val fromInt32Unsafe: int32 -> real64 =
   (fn x_545: int32 =>
    WordS32_rndToReal64 (x_545))
val fromInt64Unsafe: int64 -> real64 =
   (fn x_546: int64 =>
    WordS64_rndToReal64 (x_546))
val fromReal32Unsafe: real32 -> real64 =
   (fn x_547: real32 =>
    Real32_rndToReal64 (x_547))
val fromWord8Unsafe: word8 -> real64 =
   (fn x_548: word8 =>
    WordU8_rndToReal64 (x_548))
val fromWord16Unsafe: word16 -> real64 =
   (fn x_549: word16 =>
    WordU16_rndToReal64 (x_549))
val fromWord32Unsafe: word32 -> real64 =
   (fn x_550: word32 =>
    WordU32_rndToReal64 (x_550))
val fromWord64Unsafe: word64 -> real64 =
   (fn x_551: word64 =>
    WordU64_rndToReal64 (x_551))
val toInt8Unsafe: real64 -> int8 =
   (fn x_552: real64 =>
    Real64_rndToWordS8 (x_552))
val toInt16Unsafe: real64 -> int16 =
   (fn x_553: real64 =>
    Real64_rndToWordS16 (x_553))
val toInt32Unsafe: real64 -> int32 =
   (fn x_554: real64 =>
    Real64_rndToWordS32 (x_554))
val toInt64Unsafe: real64 -> int64 =
   (fn x_555: real64 =>
    Real64_rndToWordS64 (x_555))
val toReal32Unsafe: real64 -> real32 =
   (fn x_556: real64 =>
    Real64_rndToReal32 (x_556))
val toWord8Unsafe: real64 -> word8 =
   (fn x_557: real64 =>
    Real64_rndToWordU8 (x_557))
val toWord16Unsafe: real64 -> word16 =
   (fn x_558: real64 =>
    Real64_rndToWordU16 (x_558))
val toWord32Unsafe: real64 -> word32 =
   (fn x_559: real64 =>
    Real64_rndToWordU32 (x_559))
val toWord64Unsafe: real64 -> word64 =
   (fn x_560: real64 =>
    Real64_rndToWordU64 (x_560))
val rec
   >: real64 * real64 -> bool = 
      (fn x_561: real64 * real64 =>
       case x_561 of
	 ((a: real64, b: real64)) => (< (b, a)))
val rec
   >=: real64 * real64 -> bool = 
      (fn x_562: real64 * real64 =>
       case x_562 of
	 ((a: real64, b: real64)) => (<= (b, a)))
val subArr: word8 array * int64 -> word8 =
   (fn x_563: word8 array * int64 =>
    case x_563 of
      (x_565: word8 array, x_564: int64) => Word8Array_subWord8 (x_565, x_564))
val subVec: word8 vector * int64 -> word8 =
   (fn x_566: word8 vector * int64 =>
    case x_566 of
      (x_568: word8 vector, x_567: int64) => Word8Vector_subWord8 (x_568, x_567))
val update: word8 array * int64 * word8 -> unit =
   (fn x_569: word8 array * int64 * word8 =>
    case x_569 of
      (x_572: word8 array, x_571: int64, x_570: word8) =>
      Word8Array_updateWord8 (x_572, x_571, x_570))
val subArr: word8 array * int64 -> word16 =
   (fn x_573: word8 array * int64 =>
    case x_573 of
      (x_575: word8 array, x_574: int64) => Word8Array_subWord16 (x_575, x_574))
val subVec: word8 vector * int64 -> word16 =
   (fn x_576: word8 vector * int64 =>
    case x_576 of
      (x_578: word8 vector, x_577: int64) =>
      Word8Vector_subWord16 (x_578, x_577))
val update: word8 array * int64 * word16 -> unit =
   (fn x_579: word8 array * int64 * word16 =>
    case x_579 of
      (x_582: word8 array, x_581: int64, x_580: word16) =>
      Word8Array_updateWord16 (x_582, x_581, x_580))
val subArr: word8 array * int64 -> word32 =
   (fn x_583: word8 array * int64 =>
    case x_583 of
      (x_585: word8 array, x_584: int64) => Word8Array_subWord32 (x_585, x_584))
val subVec: word8 vector * int64 -> word32 =
   (fn x_586: word8 vector * int64 =>
    case x_586 of
      (x_588: word8 vector, x_587: int64) =>
      Word8Vector_subWord32 (x_588, x_587))
val update: word8 array * int64 * word32 -> unit =
   (fn x_589: word8 array * int64 * word32 =>
    case x_589 of
      (x_592: word8 array, x_591: int64, x_590: word32) =>
      Word8Array_updateWord32 (x_592, x_591, x_590))
val subArr: word8 array * int64 -> word64 =
   (fn x_593: word8 array * int64 =>
    case x_593 of
      (x_595: word8 array, x_594: int64) => Word8Array_subWord64 (x_595, x_594))
val subVec: word8 vector * int64 -> word64 =
   (fn x_596: word8 vector * int64 =>
    case x_596 of
      (x_598: word8 vector, x_597: int64) =>
      Word8Vector_subWord64 (x_598, x_597))
val update: word8 array * int64 * word64 -> unit =
   (fn x_599: word8 array * int64 * word64 =>
    case x_599 of
      (x_602: word8 array, x_601: int64, x_600: word64) =>
      Word8Array_updateWord64 (x_602, x_601, x_600))
val castFromWord: word32 -> real32 =
   (fn x_603: word32 =>
    Word32_castToReal32 (x_603))
val castToWord: real32 -> word32 =
   (fn x_604: real32 =>
    Real32_castToWord32 (x_604))
val castFromWord: word64 -> real64 =
   (fn x_605: word64 =>
    Word64_castToReal64 (x_605))
val castToWord: real64 -> word64 =
   (fn x_606: real64 =>
    Real64_castToWord64 (x_606))
val halt: int32 -> unit = (fn x_607: int32 => MLton_halt (x_607))
val gcState: cpointer =
   (((fn x_608: (unit -> cpointer) * (cpointer -> unit) =>
      case x_608 of
	{1 = #: unit -> cpointer} => #) ((fn x_610: unit =>
				  CPointer_getCPointer (gcStateAddress (), 0x0)),
				 (fn x_609: cpointer =>
				  CPointer_setCPointer (gcStateAddress (),
							0x0,
							x_609)))) ())
datatype Primitive.MLton.Align.t = Align4
				   | Align8
val align: Primitive.MLton.Align.t =
   case 0x8 of
     0x4 => Align4 | 0x8 => Align8 | _ => raise (Fail8 "MLton_Align_align")
datatype Primitive.MLton.CallStack.t = T of word32 array
val callStack: cpointer * word32 array -> unit =
   (fn x_611: cpointer * word32 array =>
    case x_611 of
      (x_613: cpointer, x_612: word32 array) => GC_callStack (x_613, x_612))
val frameIndexSourceSeq: cpointer * word32 -> cpointer =
   (fn x_614: cpointer * word32 =>
    case x_614 of
      (x_616: cpointer, x_615: word32) => GC_frameIndexSourceSeq (x_616, x_615))
val keep: bool = 0x0
val numStackFrames: cpointer -> word32 =
   (fn x_617: cpointer =>
    GC_numStackFrames (x_617))
val sourceName: cpointer * word32 -> word64 =
   (fn x_618: cpointer * word32 =>
    case x_618 of
      (x_620: cpointer, x_619: word32) => GC_sourceName (x_620, x_619))
datatype Primitive.MLton.Codegen.t = AMD64
				     | C
				     | LLVM
				     | X86
val 'a extra: exn -> 'a = (fn x_621: exn => Exn_extra['a] (x_621))
val extra: exn -> Primitive.MLton.CallStack.t Primitive.Option.t =
   extra (Primitive.MLton.CallStack.t Primitive.Option.t)
val keepHistory: bool = 0x0
val 'a setExtendExtra: ('a -> 'a) -> unit =
   (fn x_622: 'a -> 'a =>
    Exn_setExtendExtra['a] (x_622))
val setExtendExtra: (Primitive.MLton.CallStack.t Primitive.Option.t
		     -> Primitive.MLton.CallStack.t Primitive.Option.t)
		    -> unit =
   setExtendExtra (Primitive.MLton.CallStack.t Primitive.Option.t)
val setExtendExtra: (Primitive.MLton.CallStack.t Primitive.Option.t
		     -> Primitive.MLton.CallStack.t Primitive.Option.t)
		    -> unit =
   case keepHistory of
     true =>
     (setExtendExtra (fn x_623: Primitive.MLton.CallStack.t Primitive.Option.t =>
		      case x_623 of
			_ => NONE[Primitive.MLton.CallStack.t]))
     ;setExtendExtra
   | false =>
     (fn x_624: Primitive.MLton.CallStack.t Primitive.Option.t
		-> Primitive.MLton.CallStack.t Primitive.Option.t =>
      case x_624 of
	_ => ())
val getOpArgsResPtr: unit -> cpointer =
   (fn x_625: unit =>
    case x_625 of
      () => FFI_getOpArgsResPtr ())
val numExports: int32 = 0x1
datatype Primitive.MLton.Platform.Arch.t = Alpha
					   | AMD64
					   | ARM
					   | ARM64
					   | HPPA
					   | IA64
					   | m68k
					   | MIPS
					   | PowerPC
					   | PowerPC64
					   | S390
					   | Sparc
					   | X86
datatype Primitive.MLton.Platform.Format.t = Archive
					     | Executable
					     | LibArchive
					     | Library
val host: Primitive.MLton.Platform.Format.t =
   case "executable" of
     "archive" => Archive
   | "executable" => Executable
   | "libarchive" => LibArchive
   | "library" => Library
   | _ => raise (Fail8 "strange MLton_Platform_Format")
datatype Primitive.MLton.Platform.OS.t = AIX
					 | Cygwin
					 | Darwin
					 | FreeBSD
					 | Hurd
					 | HPUX
					 | Linux
					 | MinGW
					 | NetBSD
					 | OpenBSD
					 | Solaris
val host: Primitive.MLton.Platform.OS.t =
   case "linux" of
     "aix" => AIX
   | "cygwin" => Cygwin
   | "darwin" => Darwin
   | "freebsd" => FreeBSD
   | "hurd" => Hurd
   | "hpux" => HPUX
   | "linux" => Linux
   | "mingw" => MinGW
   | "netbsd" => NetBSD
   | "openbsd" => OpenBSD
   | "solaris" => Solaris
   | _ => raise (Fail8 "strange MLton_Platform_OS_host")
val fromWord: word64 -> cpointer =
   (fn x_626: word64 =>
    CPointer_fromWord (x_626))
val null: cpointer = (fromWord 0x0)
val rec
   isNull: cpointer -> bool = 
      (fn x_627: cpointer =>
       case x_627 of
	 (p: cpointer) => (= (cpointer) (p, null)))
val getCPointer: cpointer * int64 -> cpointer =
   (fn x_628: cpointer * int64 =>
    case x_628 of
      (x_630: cpointer, x_629: int64) => CPointer_getCPointer (x_630, x_629))
val getInt32: cpointer * int64 -> int32 =
   (fn x_631: cpointer * int64 =>
    case x_631 of
      (x_633: cpointer, x_632: int64) => CPointer_getWord32 (x_633, x_632))
val getWord8: cpointer * int64 -> word8 =
   (fn x_634: cpointer * int64 =>
    case x_634 of
      (x_636: cpointer, x_635: int64) => CPointer_getWord8 (x_636, x_635))
val getWord32: cpointer * int64 -> word32 =
   (fn x_637: cpointer * int64 =>
    case x_637 of
      (x_639: cpointer, x_638: int64) => CPointer_getWord32 (x_639, x_638))
val isOn: bool = 0x0
val dummy: cpointer = null
val free: cpointer * cpointer -> unit =
   (fn x_640: cpointer * cpointer =>
    case x_640 of
      (x_642: cpointer, x_641: cpointer) => GC_profileFree (x_642, x_641))
val write: cpointer * cpointer * string -> unit =
   (fn x_643: cpointer * cpointer * string =>
    case x_643 of
      (x_646: cpointer, x_645: cpointer, x_644: string) =>
      GC_profileWrite (x_646, x_645, x_644))
val done: cpointer -> unit = (fn x_647: cpointer => GC_profileDone (x_647))
val getCurrent: cpointer -> cpointer =
   (fn x_648: cpointer =>
    GC_getProfileCurrent (x_648))
val setCurrent: cpointer * cpointer -> unit =
   (fn x_649: cpointer * cpointer =>
    case x_649 of
      (x_651: cpointer, x_650: cpointer) => GC_setProfileCurrent (x_651, x_650))
val atomicState: unit -> word32 =
   (fn x_652: unit =>
    case x_652 of
      () => Thread_atomicState ())
val atomicBegin: unit -> unit =
   (fn x_653: unit =>
    case x_653 of
      () => Thread_atomicBegin ())
val rec
   atomicEnd: unit -> unit = 
      (fn x_654: unit =>
       case x_654 of
	 (()) =>
	 case (= (word32) ((atomicState ()), 0x0)) of
	   true => raise (Fail8 "Thread.atomicEnd")
	 | false =>
	   ((fn x_655: unit =>
	     case x_655 of
	       () => Thread_atomicEnd ()) ()))
val copy: thread -> thread = (fn x_656: thread => Thread_copy (x_656))
val copyCurrent: unit -> unit =
   (fn x_657: unit =>
    case x_657 of
      () => Thread_copyCurrent ())
val current: cpointer -> thread =
   (fn x_658: cpointer =>
    GC_getCurrentThread (x_658))
val returnToC: unit -> unit =
   (fn x_659: unit =>
    case x_659 of
      () => Thread_returnToC ())
val saved: cpointer -> thread =
   (fn x_660: cpointer =>
    GC_getSavedThread (x_660))
val savedPre: cpointer -> thread =
   (fn x_661: cpointer =>
    GC_getSavedThread (x_661))
val setCallFromCHandler: cpointer * thread -> unit =
   (fn x_662: cpointer * thread =>
    case x_662 of
      (x_664: cpointer, x_663: thread) =>
      GC_setCallFromCHandlerThread (x_664, x_663))
val setSaved: cpointer * thread -> unit =
   (fn x_665: cpointer * thread =>
    case x_665 of
      (x_667: cpointer, x_666: thread) => GC_setSavedThread (x_667, x_666))
val switchTo: thread -> unit = (fn x_668: thread => Thread_switchTo (x_668))
val getRoundingMode: unit -> int32 =
   (fn x_669: unit =>
    case x_669 of
      () => IEEEReal_getRoundingMode ())
val FE_DOWNWARD: int32 = 0x400
val FE_NOSUPPORT: int32 = 0xFFFFFFFF
val FE_TONEAREST: int32 = 0x0
val FE_TOWARDZERO: int32 = 0xC00
val FE_UPWARD: int32 = 0x800
val setRoundingMode: int32 -> int32 =
   (fn x_670: int32 =>
    IEEEReal_setRoundingMode (x_670))
val bug: string -> unit = (fn x_671: string => MLton_bug (x_671))
val htons: word16 -> word16 = (fn x_672: word16 => Net_htons (x_672))
val ntohs: word16 -> word16 = (fn x_673: word16 => Net_ntohs (x_673))
val clearErrno: unit -> unit =
   (fn x_674: unit =>
    case x_674 of
      () => Posix_Error_clearErrno ())
val E2BIG: int32 = 0x7
val EACCES: int32 = 0xD
val EADDRINUSE: int32 = 0x62
val EADDRNOTAVAIL: int32 = 0x63
val EAFNOSUPPORT: int32 = 0x61
val EAGAIN: int32 = 0xB
val EALREADY: int32 = 0x72
val EBADF: int32 = 0x9
val EBADMSG: int32 = 0x4A
val EBUSY: int32 = 0x10
val ECANCELED: int32 = 0x7D
val ECHILD: int32 = 0xA
val ECONNABORTED: int32 = 0x67
val ECONNREFUSED: int32 = 0x6F
val ECONNRESET: int32 = 0x68
val EDEADLK: int32 = 0x23
val EDESTADDRREQ: int32 = 0x59
val EDOM: int32 = 0x21
val EDQUOT: int32 = 0x7A
val EEXIST: int32 = 0x11
val EFAULT: int32 = 0xE
val EFBIG: int32 = 0x1B
val EHOSTUNREACH: int32 = 0x71
val EIDRM: int32 = 0x2B
val EILSEQ: int32 = 0x54
val EINPROGRESS: int32 = 0x73
val EINTR: int32 = 0x4
val EINVAL: int32 = 0x16
val EIO: int32 = 0x5
val EISCONN: int32 = 0x6A
val EISDIR: int32 = 0x15
val ELOOP: int32 = 0x28
val EMFILE: int32 = 0x18
val EMLINK: int32 = 0x1F
val EMSGSIZE: int32 = 0x5A
val EMULTIHOP: int32 = 0x48
val ENAMETOOLONG: int32 = 0x24
val ENETDOWN: int32 = 0x64
val ENETRESET: int32 = 0x66
val ENETUNREACH: int32 = 0x65
val ENFILE: int32 = 0x17
val ENOBUFS: int32 = 0x69
val ENODATA: int32 = 0x3D
val ENODEV: int32 = 0x13
val ENOENT: int32 = 0x2
val ENOEXEC: int32 = 0x8
val ENOLCK: int32 = 0x25
val ENOLINK: int32 = 0x43
val ENOMEM: int32 = 0xC
val ENOMSG: int32 = 0x2A
val ENOPROTOOPT: int32 = 0x5C
val ENOSPC: int32 = 0x1C
val ENOSR: int32 = 0x3F
val ENOSTR: int32 = 0x3C
val ENOSYS: int32 = 0x26
val ENOTCONN: int32 = 0x6B
val ENOTDIR: int32 = 0x14
val ENOTEMPTY: int32 = 0x27
val ENOTSOCK: int32 = 0x58
val ENOTSUP: int32 = 0x5F
val ENOTTY: int32 = 0x19
val ENXIO: int32 = 0x6
val EOPNOTSUPP: int32 = 0x5F
val EOVERFLOW: int32 = 0x4B
val EPERM: int32 = 0x1
val EPIPE: int32 = 0x20
val EPROTO: int32 = 0x47
val EPROTONOSUPPORT: int32 = 0x5D
val EPROTOTYPE: int32 = 0x5B
val ERANGE: int32 = 0x22
val EROFS: int32 = 0x1E
val ESPIPE: int32 = 0x1D
val ESRCH: int32 = 0x3
val ESTALE: int32 = 0x74
val ETIME: int32 = 0x3E
val ETIMEDOUT: int32 = 0x6E
val ETXTBSY: int32 = 0x1A
val EWOULDBLOCK: int32 = 0xB
val EXDEV: int32 = 0x12
val getErrno: unit -> int32 =
   (fn x_675: unit =>
    case x_675 of
      () => Posix_Error_getErrno ())
val strError: int32 -> word64 =
   (fn x_676: int32 =>
    Posix_Error_strError (x_676))
val APPEND: int32 = 0x400
val NONBLOCK: int32 = 0x800
val isReg: word32 -> int32 =
   (fn x_677: word32 =>
    Posix_FileSys_ST_isReg (x_677))
val fstat: int32 -> int32 =
   (fn x_678: int32 =>
    Posix_FileSys_Stat_fstat (x_678))
val getATime: unit -> int64 =
   (fn x_679: unit =>
    case x_679 of
      () => Posix_FileSys_Stat_getATime ())
val getCTime: unit -> int64 =
   (fn x_680: unit =>
    case x_680 of
      () => Posix_FileSys_Stat_getCTime ())
val getDev: unit -> word64 =
   (fn x_681: unit =>
    case x_681 of
      () => Posix_FileSys_Stat_getDev ())
val getGId: unit -> word32 =
   (fn x_682: unit =>
    case x_682 of
      () => Posix_FileSys_Stat_getGId ())
val getINo: unit -> word64 =
   (fn x_683: unit =>
    case x_683 of
      () => Posix_FileSys_Stat_getINo ())
val getMode: unit -> word32 =
   (fn x_684: unit =>
    case x_684 of
      () => Posix_FileSys_Stat_getMode ())
val getMTime: unit -> int64 =
   (fn x_685: unit =>
    case x_685 of
      () => Posix_FileSys_Stat_getMTime ())
val getNLink: unit -> word64 =
   (fn x_686: unit =>
    case x_686 of
      () => Posix_FileSys_Stat_getNLink ())
val getSize: unit -> int64 =
   (fn x_687: unit =>
    case x_687 of
      () => Posix_FileSys_Stat_getSize ())
val getUId: unit -> word32 =
   (fn x_688: unit =>
    case x_688 of
      () => Posix_FileSys_Stat_getUId ())
val close: int32 -> int32 = (fn x_689: int32 => Posix_IO_close (x_689))
val F_SETFL: int32 = 0x4
val fcntl3: int32 * int32 * int32 -> int32 =
   (fn x_690: int32 * int32 * int32 =>
    case x_690 of
      (x_693: int32, x_692: int32, x_691: int32) =>
      Posix_IO_fcntl3 (x_693, x_692, x_691))
val lseek: int32 * int64 * int32 -> int64 =
   (fn x_694: int32 * int64 * int32 =>
    case x_694 of
      (x_697: int32, x_696: int64, x_695: int32) =>
      Posix_IO_lseek (x_697, x_696, x_695))
val readChar8: int32 * char8 array * int32 * word64 -> int64 =
   (fn x_698: int32 * char8 array * int32 * word64 =>
    case x_698 of
      (x_702: int32, x_701: char8 array, x_700: int32, x_699: word64) =>
      Posix_IO_readChar8 (x_702, x_701, x_700, x_699))
val SEEK_CUR: int32 = 0x1
val SEEK_END: int32 = 0x2
val SEEK_SET: int32 = 0x0
val settext: int32 -> unit = (fn x_703: int32 => Posix_IO_settext (x_703))
val writeChar8Arr: int32 * char8 array * int32 * word64 -> int64 =
   (fn x_704: int32 * char8 array * int32 * word64 =>
    case x_704 of
      (x_708: int32, x_707: char8 array, x_706: int32, x_705: word64) =>
      Posix_IO_writeChar8Arr (x_708, x_707, x_706, x_705))
val writeChar8Vec: int32 * string * int32 * word64 -> int64 =
   (fn x_709: int32 * string * int32 * word64 =>
    case x_709 of
      (x_713: int32, x_712: string, x_711: int32, x_710: word64) =>
      Posix_IO_writeChar8Vec (x_713, x_712, x_711, x_710))
val isatty: int32 -> int32 = (fn x_714: int32 => Posix_ProcEnv_isatty (x_714))
val exit: int32 -> unit = (fn x_715: int32 => Posix_Process_exit (x_715))
val abs: real32 -> real32 = (fn x_716: real32 => Real32_abs (x_716))
val add: real32 * real32 -> real32 =
   (fn x_717: real32 * real32 =>
    case x_717 of
      (x_719: real32, x_718: real32) => Real32_add (x_719, x_718))
val div: real32 * real32 -> real32 =
   (fn x_720: real32 * real32 =>
    case x_720 of
      (x_722: real32, x_721: real32) => Real32_div (x_722, x_721))
val equal: real32 * real32 -> bool =
   (fn x_723: real32 * real32 =>
    case x_723 of
      (x_725: real32, x_724: real32) => Real32_equal (x_725, x_724))
val frexp: real32 * int32 ref -> real32 =
   (fn x_726: real32 * int32 ref =>
    case x_726 of
      (x_728: real32, x_727: int32 ref) => Real32_frexp (x_728, x_727))
val gdtoa: real32 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_729: real32 * int32 * int32 * int32 * int32 ref =>
    case x_729 of
      (x_734: real32, x_733: int32, x_732: int32, x_731: int32, x_730: int32 ref) =>
      Real32_gdtoa (x_734, x_733, x_732, x_731, x_730))
val ldexp: real32 * int32 -> real32 =
   (fn x_735: real32 * int32 =>
    case x_735 of
      (x_737: real32, x_736: int32) => Real32_ldexp (x_737, x_736))
val le: real32 * real32 -> bool =
   (fn x_738: real32 * real32 =>
    case x_738 of
      (x_740: real32, x_739: real32) => Real32_le (x_740, x_739))
val lt: real32 * real32 -> bool =
   (fn x_741: real32 * real32 =>
    case x_741 of
      (x_743: real32, x_742: real32) => Real32_lt (x_743, x_742))
val acos: real32 -> real32 = (fn x_744: real32 => Real32_Math_acos (x_744))
val asin: real32 -> real32 = (fn x_745: real32 => Real32_Math_asin (x_745))
val atan: real32 -> real32 = (fn x_746: real32 => Real32_Math_atan (x_746))
val atan2: real32 * real32 -> real32 =
   (fn x_747: real32 * real32 =>
    case x_747 of
      (x_749: real32, x_748: real32) => Real32_Math_atan2 (x_749, x_748))
val cos: real32 -> real32 = (fn x_750: real32 => Real32_Math_cos (x_750))
val cosh: real32 -> real32 = (fn x_751: real32 => Real32_Math_cosh (x_751))
val (eGet: unit -> real32, eSet: real32 -> unit) =
   ((fn x_753: unit =>
     CPointer_getReal32 (Real32_Math_e (), 0x0)),
    (fn x_752: real32 =>
     CPointer_setReal32 (Real32_Math_e (), 0x0, x_752)))
val exp: real32 -> real32 = (fn x_754: real32 => Real32_Math_exp (x_754))
val ln: real32 -> real32 = (fn x_755: real32 => Real32_Math_ln (x_755))
val log10: real32 -> real32 = (fn x_756: real32 => Real32_Math_log10 (x_756))
val (piGet: unit -> real32, piSet: real32 -> unit) =
   ((fn x_758: unit =>
     CPointer_getReal32 (Real32_Math_pi (), 0x0)),
    (fn x_757: real32 =>
     CPointer_setReal32 (Real32_Math_pi (), 0x0, x_757)))
val pow: real32 * real32 -> real32 =
   (fn x_759: real32 * real32 =>
    case x_759 of
      (x_761: real32, x_760: real32) => Real32_Math_pow (x_761, x_760))
val sin: real32 -> real32 = (fn x_762: real32 => Real32_Math_sin (x_762))
val sinh: real32 -> real32 = (fn x_763: real32 => Real32_Math_sinh (x_763))
val sqrt: real32 -> real32 = (fn x_764: real32 => Real32_Math_sqrt (x_764))
val tan: real32 -> real32 = (fn x_765: real32 => Real32_Math_tan (x_765))
val tanh: real32 -> real32 = (fn x_766: real32 => Real32_Math_tanh (x_766))
val modf: real32 * real32 ref -> real32 =
   (fn x_767: real32 * real32 ref =>
    case x_767 of
      (x_769: real32, x_768: real32 ref) => Real32_modf (x_769, x_768))
val mul: real32 * real32 -> real32 =
   (fn x_770: real32 * real32 =>
    case x_770 of
      (x_772: real32, x_771: real32) => Real32_mul (x_772, x_771))
val muladd: real32 * real32 * real32 -> real32 =
   (fn x_773: real32 * real32 * real32 =>
    case x_773 of
      (x_776: real32, x_775: real32, x_774: real32) =>
      Real32_muladd (x_776, x_775, x_774))
val mulsub: real32 * real32 * real32 -> real32 =
   (fn x_777: real32 * real32 * real32 =>
    case x_777 of
      (x_780: real32, x_779: real32, x_778: real32) =>
      Real32_mulsub (x_780, x_779, x_778))
val neg: real32 -> real32 = (fn x_781: real32 => Real32_neg (x_781))
val round: real32 -> real32 = (fn x_782: real32 => Real32_round (x_782))
val strtor: string * int32 -> real32 =
   (fn x_783: string * int32 =>
    case x_783 of
      (x_785: string, x_784: int32) => Real32_strtor (x_785, x_784))
val sub: real32 * real32 -> real32 =
   (fn x_786: real32 * real32 =>
    case x_786 of
      (x_788: real32, x_787: real32) => Real32_sub (x_788, x_787))
val abs: real64 -> real64 = (fn x_789: real64 => Real64_abs (x_789))
val add: real64 * real64 -> real64 =
   (fn x_790: real64 * real64 =>
    case x_790 of
      (x_792: real64, x_791: real64) => Real64_add (x_792, x_791))
val div: real64 * real64 -> real64 =
   (fn x_793: real64 * real64 =>
    case x_793 of
      (x_795: real64, x_794: real64) => Real64_div (x_795, x_794))
val equal: real64 * real64 -> bool =
   (fn x_796: real64 * real64 =>
    case x_796 of
      (x_798: real64, x_797: real64) => Real64_equal (x_798, x_797))
val frexp: real64 * int32 ref -> real64 =
   (fn x_799: real64 * int32 ref =>
    case x_799 of
      (x_801: real64, x_800: int32 ref) => Real64_frexp (x_801, x_800))
val gdtoa: real64 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_802: real64 * int32 * int32 * int32 * int32 ref =>
    case x_802 of
      (x_807: real64, x_806: int32, x_805: int32, x_804: int32, x_803: int32 ref) =>
      Real64_gdtoa (x_807, x_806, x_805, x_804, x_803))
val ldexp: real64 * int32 -> real64 =
   (fn x_808: real64 * int32 =>
    case x_808 of
      (x_810: real64, x_809: int32) => Real64_ldexp (x_810, x_809))
val le: real64 * real64 -> bool =
   (fn x_811: real64 * real64 =>
    case x_811 of
      (x_813: real64, x_812: real64) => Real64_le (x_813, x_812))
val lt: real64 * real64 -> bool =
   (fn x_814: real64 * real64 =>
    case x_814 of
      (x_816: real64, x_815: real64) => Real64_lt (x_816, x_815))
val acos: real64 -> real64 = (fn x_817: real64 => Real64_Math_acos (x_817))
val asin: real64 -> real64 = (fn x_818: real64 => Real64_Math_asin (x_818))
val atan: real64 -> real64 = (fn x_819: real64 => Real64_Math_atan (x_819))
val atan2: real64 * real64 -> real64 =
   (fn x_820: real64 * real64 =>
    case x_820 of
      (x_822: real64, x_821: real64) => Real64_Math_atan2 (x_822, x_821))
val cos: real64 -> real64 = (fn x_823: real64 => Real64_Math_cos (x_823))
val cosh: real64 -> real64 = (fn x_824: real64 => Real64_Math_cosh (x_824))
val (eGet: unit -> real64, eSet: real64 -> unit) =
   ((fn x_826: unit =>
     CPointer_getReal64 (Real64_Math_e (), 0x0)),
    (fn x_825: real64 =>
     CPointer_setReal64 (Real64_Math_e (), 0x0, x_825)))
val exp: real64 -> real64 = (fn x_827: real64 => Real64_Math_exp (x_827))
val ln: real64 -> real64 = (fn x_828: real64 => Real64_Math_ln (x_828))
val log10: real64 -> real64 = (fn x_829: real64 => Real64_Math_log10 (x_829))
val (piGet: unit -> real64, piSet: real64 -> unit) =
   ((fn x_831: unit =>
     CPointer_getReal64 (Real64_Math_pi (), 0x0)),
    (fn x_830: real64 =>
     CPointer_setReal64 (Real64_Math_pi (), 0x0, x_830)))
val pow: real64 * real64 -> real64 =
   (fn x_832: real64 * real64 =>
    case x_832 of
      (x_834: real64, x_833: real64) => Real64_Math_pow (x_834, x_833))
val sin: real64 -> real64 = (fn x_835: real64 => Real64_Math_sin (x_835))
val sinh: real64 -> real64 = (fn x_836: real64 => Real64_Math_sinh (x_836))
val sqrt: real64 -> real64 = (fn x_837: real64 => Real64_Math_sqrt (x_837))
val tan: real64 -> real64 = (fn x_838: real64 => Real64_Math_tan (x_838))
val tanh: real64 -> real64 = (fn x_839: real64 => Real64_Math_tanh (x_839))
val modf: real64 * real64 ref -> real64 =
   (fn x_840: real64 * real64 ref =>
    case x_840 of
      (x_842: real64, x_841: real64 ref) => Real64_modf (x_842, x_841))
val mul: real64 * real64 -> real64 =
   (fn x_843: real64 * real64 =>
    case x_843 of
      (x_845: real64, x_844: real64) => Real64_mul (x_845, x_844))
val muladd: real64 * real64 * real64 -> real64 =
   (fn x_846: real64 * real64 * real64 =>
    case x_846 of
      (x_849: real64, x_848: real64, x_847: real64) =>
      Real64_muladd (x_849, x_848, x_847))
val mulsub: real64 * real64 * real64 -> real64 =
   (fn x_850: real64 * real64 * real64 =>
    case x_850 of
      (x_853: real64, x_852: real64, x_851: real64) =>
      Real64_mulsub (x_853, x_852, x_851))
val neg: real64 -> real64 = (fn x_854: real64 => Real64_neg (x_854))
val round: real64 -> real64 = (fn x_855: real64 => Real64_round (x_855))
val strtor: string * int32 -> real64 =
   (fn x_856: string * int32 =>
    case x_856 of
      (x_858: string, x_857: int32) => Real64_strtor (x_858, x_857))
val sub: real64 * real64 -> real64 =
   (fn x_859: real64 * real64 =>
    case x_859 of
      (x_861: real64, x_860: real64) => Real64_sub (x_861, x_860))
val print: string -> unit = (fn x_862: string => Stdio_print (x_862))
val bug: string -> unit = bug
val _ =
   (setHandler (fn x_863: exn =>
		case x_863 of
		  exn: exn =>
		  (print "unhandled exception: ")
		  ;case exn of
		     Fail8 msg: string => (print "Fail ") ;(print msg)
		   | _ => (print (name exn))
		  ;(print "\n")
		  ;(bug "unhandled exception in Basis Library")))
val _ =
   (setSuffix (fn x_864: unit =>
	       case x_864 of
		 () => (halt 0x0) ;(bug "missing suffix in Basis Library")))
val rec 'a
   check: 'a * 'a -> unit = 
      (fn x_865: 'a * 'a =>
       case x_865 of
	 ((_, _)) => ())
val () = (check (real32 -> real32) (acos, acos))
val () = (check (real32 -> real32) (asin, asin))
val () = (check (real32 -> real32) (atan, atan))
val () = (check (real32 * real32 -> real32) (atan2, atan2))
val () = (check (real32 -> real32) (cos, cos))
val () = (check (real32 -> real32) (cosh, cosh))
val () =
   (check (unit -> real32) ((fn x_866: unit => case x_866 of () => e), eGet))
val () = (check (real32 -> real32) (exp, exp))
val () = (check (real32 -> real32) (ln, ln))
val () = (check (real32 -> real32) (log10, log10))
val () =
   (check (unit -> real32) ((fn x_867: unit => case x_867 of () => pi), piGet))
val () = (check (real32 * real32 -> real32) (pow, pow))
val () = (check (real32 -> real32) (sin, sin))
val () = (check (real32 -> real32) (sinh, sinh))
val () = (check (real32 -> real32) (sqrt, sqrt))
val () = (check (real32 -> real32) (tan, tan))
val () = (check (real32 -> real32) (tanh, tanh))
val () = (check (real32 -> real32) (abs, abs))
val () = (check (real32 * real32 -> real32) (+, add))
val () = (check (real32 * real32 -> real32) (/, div))
val () = (check (real32 * real32 -> bool) (==, equal))
val () = (check (real32 * int32 ref -> real32) (frexp, frexp))
val () =
   (check (real32 * int32 * int32 * int32 * int32 ref -> word64) (gdtoa, gdtoa))
val () = (check (real32 * int32 -> real32) (ldexp, ldexp))
val () = (check (real32 * real32 -> bool) (<=, le))
val () = (check (real32 * real32 -> bool) (<, lt))
val () = (check (real32 * real32 ref -> real32) (modf, modf))
val () = (check (real32 * real32 -> real32) (*, mul))
val () = (check (real32 * real32 * real32 -> real32) (*+, muladd))
val () = (check (real32 * real32 * real32 -> real32) (*-, mulsub))
val () = (check (real32 -> real32) (~, neg))
val () = (check (real32 -> real32) (round, round))
val () = (check (string * int32 -> real32) (strtor, strtor))
val () = (check (real32 * real32 -> real32) (-, sub))
val () = (check (real64 -> real64) (acos, acos))
val () = (check (real64 -> real64) (asin, asin))
val () = (check (real64 -> real64) (atan, atan))
val () = (check (real64 * real64 -> real64) (atan2, atan2))
val () = (check (real64 -> real64) (cos, cos))
val () = (check (real64 -> real64) (cosh, cosh))
val () =
   (check (unit -> real64) ((fn x_868: unit => case x_868 of () => e), eGet))
val () = (check (real64 -> real64) (exp, exp))
val () = (check (real64 -> real64) (ln, ln))
val () = (check (real64 -> real64) (log10, log10))
val () =
   (check (unit -> real64) ((fn x_869: unit => case x_869 of () => pi), piGet))
val () = (check (real64 * real64 -> real64) (pow, pow))
val () = (check (real64 -> real64) (sin, sin))
val () = (check (real64 -> real64) (sinh, sinh))
val () = (check (real64 -> real64) (sqrt, sqrt))
val () = (check (real64 -> real64) (tan, tan))
val () = (check (real64 -> real64) (tanh, tanh))
val () = (check (real64 -> real64) (abs, abs))
val () = (check (real64 * real64 -> real64) (+, add))
val () = (check (real64 * real64 -> real64) (/, div))
val () = (check (real64 * real64 -> bool) (==, equal))
val () = (check (real64 * int32 ref -> real64) (frexp, frexp))
val () =
   (check (real64 * int32 * int32 * int32 * int32 ref -> word64) (gdtoa, gdtoa))
val () = (check (real64 * int32 -> real64) (ldexp, ldexp))
val () = (check (real64 * real64 -> bool) (<=, le))
val () = (check (real64 * real64 -> bool) (<, lt))
val () = (check (real64 * real64 ref -> real64) (modf, modf))
val () = (check (real64 * real64 -> real64) (*, mul))
val () = (check (real64 * real64 * real64 -> real64) (*+, muladd))
val () = (check (real64 * real64 * real64 -> real64) (*-, mulsub))
val () = (check (real64 -> real64) (~, neg))
val () = (check (real64 -> real64) (round, round))
val () = (check (string * int32 -> real64) (strtor, strtor))
val () = (check (real64 * real64 -> real64) (-, sub))
val rec ('a, 'b)
   try: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) -> 'b = 
      (fn x_870: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) =>
       case x_870 of
	 ((f: unit -> 'a, k: 'a -> 'b, h: exn -> 'b)) =>
	 let datatype DynamicWind.try.t = A of 'a
					  | E of exn
	 in
	    case (A (f ()))
		 handle x_871 => case x_871 of
				   e: exn => (E e) of
	      A a: 'a => (k a) | E e: exn => (h e)
	 end)
val rec 'a_174
   wind: (unit -> 'a_174) * (unit -> unit) -> 'a_174 = 
      (fn x_872: (unit -> 'a_174) * (unit -> unit) =>
       case x_872 of
	 ((thunk: unit -> 'a_174, cleanup: unit -> unit)) =>
	 (try ('a_174, 'a_174) (thunk,
				(fn x_874: 'a_174 =>
				 case x_874 of
				   a: 'a_174 => (cleanup ()) ;a),
				(fn x_873: exn =>
				 case x_873 of
				   e: exn => (cleanup ()) ;raise e))))
val 'a wind_0: (unit -> 'a) * (unit -> unit) -> 'a = wind ('a)
val castFromInt8ToInt8: int8 -> int8 = sextdFromInt8ToInt8
val castFromInt8ToInt16: int8 -> int16 = sextdFromInt8ToInt16
val castFromInt8ToInt32: int8 -> int32 = sextdFromInt8ToInt32
val castFromInt8ToInt64: int8 -> int64 = sextdFromInt8ToInt64
val castFromInt8ToWord8: int8 -> word8 = sextdFromInt8ToWord8
val castFromInt8ToWord16: int8 -> word16 = sextdFromInt8ToWord16
val castFromInt8ToWord32: int8 -> word32 = sextdFromInt8ToWord32
val castFromInt8ToWord64: int8 -> word64 = sextdFromInt8ToWord64
val castFromInt16ToInt8: int16 -> int8 = sextdFromInt16ToInt8
val castFromInt16ToInt16: int16 -> int16 = sextdFromInt16ToInt16
val castFromInt16ToInt32: int16 -> int32 = sextdFromInt16ToInt32
val castFromInt16ToInt64: int16 -> int64 = sextdFromInt16ToInt64
val castFromInt16ToWord8: int16 -> word8 = sextdFromInt16ToWord8
val castFromInt16ToWord16: int16 -> word16 = sextdFromInt16ToWord16
val castFromInt16ToWord32: int16 -> word32 = sextdFromInt16ToWord32
val castFromInt16ToWord64: int16 -> word64 = sextdFromInt16ToWord64
val castFromInt32ToInt8: int32 -> int8 = sextdFromInt32ToInt8
val castFromInt32ToInt16: int32 -> int16 = sextdFromInt32ToInt16
val castFromInt32ToInt32: int32 -> int32 = sextdFromInt32ToInt32
val castFromInt32ToInt64: int32 -> int64 = sextdFromInt32ToInt64
val castFromInt32ToWord8: int32 -> word8 = sextdFromInt32ToWord8
val castFromInt32ToWord16: int32 -> word16 = sextdFromInt32ToWord16
val castFromInt32ToWord32: int32 -> word32 = sextdFromInt32ToWord32
val castFromInt32ToWord64: int32 -> word64 = sextdFromInt32ToWord64
val castFromInt64ToInt8: int64 -> int8 = sextdFromInt64ToInt8
val castFromInt64ToInt16: int64 -> int16 = sextdFromInt64ToInt16
val castFromInt64ToInt32: int64 -> int32 = sextdFromInt64ToInt32
val castFromInt64ToInt64: int64 -> int64 = sextdFromInt64ToInt64
val castFromInt64ToWord8: int64 -> word8 = sextdFromInt64ToWord8
val castFromInt64ToWord16: int64 -> word16 = sextdFromInt64ToWord16
val castFromInt64ToWord32: int64 -> word32 = sextdFromInt64ToWord32
val castFromInt64ToWord64: int64 -> word64 = sextdFromInt64ToWord64
val castFromWord8ToInt8: word8 -> int8 = zextdFromWord8ToInt8
val castFromWord8ToInt16: word8 -> int16 = zextdFromWord8ToInt16
val castFromWord8ToInt32: word8 -> int32 = zextdFromWord8ToInt32
val castFromWord8ToInt64: word8 -> int64 = zextdFromWord8ToInt64
val castFromWord8ToWord8: word8 -> word8 = zextdFromWord8ToWord8
val castFromWord8ToWord16: word8 -> word16 = zextdFromWord8ToWord16
val castFromWord8ToWord32: word8 -> word32 = zextdFromWord8ToWord32
val castFromWord8ToWord64: word8 -> word64 = zextdFromWord8ToWord64
val castFromWord16ToInt8: word16 -> int8 = zextdFromWord16ToInt8
val castFromWord16ToInt16: word16 -> int16 = zextdFromWord16ToInt16
val castFromWord16ToInt32: word16 -> int32 = zextdFromWord16ToInt32
val castFromWord16ToInt64: word16 -> int64 = zextdFromWord16ToInt64
val castFromWord16ToWord8: word16 -> word8 = zextdFromWord16ToWord8
val castFromWord16ToWord16: word16 -> word16 = zextdFromWord16ToWord16
val castFromWord16ToWord32: word16 -> word32 = zextdFromWord16ToWord32
val castFromWord16ToWord64: word16 -> word64 = zextdFromWord16ToWord64
val castFromWord32ToInt8: word32 -> int8 = zextdFromWord32ToInt8
val castFromWord32ToInt16: word32 -> int16 = zextdFromWord32ToInt16
val castFromWord32ToInt32: word32 -> int32 = zextdFromWord32ToInt32
val castFromWord32ToInt64: word32 -> int64 = zextdFromWord32ToInt64
val castFromWord32ToWord8: word32 -> word8 = zextdFromWord32ToWord8
val castFromWord32ToWord16: word32 -> word16 = zextdFromWord32ToWord16
val castFromWord32ToWord32: word32 -> word32 = zextdFromWord32ToWord32
val castFromWord32ToWord64: word32 -> word64 = zextdFromWord32ToWord64
val castFromWord64ToInt8: word64 -> int8 = zextdFromWord64ToInt8
val castFromWord64ToInt16: word64 -> int16 = zextdFromWord64ToInt16
val castFromWord64ToInt32: word64 -> int32 = zextdFromWord64ToInt32
val castFromWord64ToInt64: word64 -> int64 = zextdFromWord64ToInt64
val castFromWord64ToWord8: word64 -> word8 = zextdFromWord64ToWord8
val castFromWord64ToWord16: word64 -> word16 = zextdFromWord64ToWord16
val castFromWord64ToWord32: word64 -> word32 = zextdFromWord64ToWord32
val castFromWord64ToWord64: word64 -> word64 = zextdFromWord64ToWord64
val rec (''s, ''l)
   make: {zextdFromLargeToSmall: ''l -> ''s, zextdFromSmallToLarge: ''s -> ''l}
	 -> ''l -> ''s = 
      (fn x_875: {zextdFromLargeToSmall: ''l -> ''s,
		  zextdFromSmallToLarge: ''s -> ''l} =>
       case x_875 of
	 ({zextdFromLargeToSmall = zextdFromLargeToSmall: ''l -> ''s,
	   zextdFromSmallToLarge = zextdFromSmallToLarge: ''s -> ''l}) =>
	 case detectOverflow of
	   true =>
	   (fn x_876: ''l =>
	    case x_876 of
	      x: ''l =>
	      let val res: ''s = (zextdFromLargeToSmall x)
	      in
		 case (= (''l) (x, (zextdFromSmallToLarge res))) of
		   true => res | false => raise Overflow
	      end)
	 | false => zextdFromLargeToSmall)
val zchckFromInt8ToInt8: int8 -> int8 = zextdFromInt8ToInt8
val zchckFromInt8ToInt16: int8 -> int16 = zextdFromInt8ToInt16
val zchckFromInt8ToInt32: int8 -> int32 = zextdFromInt8ToInt32
val zchckFromInt8ToInt64: int8 -> int64 = zextdFromInt8ToInt64
val zchckFromInt8ToWord8: int8 -> word8 = zextdFromInt8ToWord8
val zchckFromInt8ToWord16: int8 -> word16 = zextdFromInt8ToWord16
val zchckFromInt8ToWord32: int8 -> word32 = zextdFromInt8ToWord32
val zchckFromInt8ToWord64: int8 -> word64 = zextdFromInt8ToWord64
val zchckFromInt16ToInt8: int16 -> int8 =
   (make (int8, int16) {zextdFromLargeToSmall = zextdFromInt16ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt16})
val zchckFromInt16ToInt16: int16 -> int16 = zextdFromInt16ToInt16
val zchckFromInt16ToInt32: int16 -> int32 = zextdFromInt16ToInt32
val zchckFromInt16ToInt64: int16 -> int64 = zextdFromInt16ToInt64
val zchckFromInt16ToWord8: int16 -> word8 =
   (make (word8, int16) {zextdFromLargeToSmall = zextdFromInt16ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt16})
val zchckFromInt16ToWord16: int16 -> word16 = zextdFromInt16ToWord16
val zchckFromInt16ToWord32: int16 -> word32 = zextdFromInt16ToWord32
val zchckFromInt16ToWord64: int16 -> word64 = zextdFromInt16ToWord64
val zchckFromInt32ToInt8: int32 -> int8 =
   (make (int8, int32) {zextdFromLargeToSmall = zextdFromInt32ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt32})
val zchckFromInt32ToInt16: int32 -> int16 =
   (make (int16, int32) {zextdFromLargeToSmall = zextdFromInt32ToInt16,
			 zextdFromSmallToLarge = zextdFromInt16ToInt32})
val zchckFromInt32ToInt32: int32 -> int32 = zextdFromInt32ToInt32
val zchckFromInt32ToInt64: int32 -> int64 = zextdFromInt32ToInt64
val zchckFromInt32ToWord8: int32 -> word8 =
   (make (word8, int32) {zextdFromLargeToSmall = zextdFromInt32ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt32})
val zchckFromInt32ToWord16: int32 -> word16 =
   (make (word16, int32) {zextdFromLargeToSmall = zextdFromInt32ToWord16,
			  zextdFromSmallToLarge = zextdFromWord16ToInt32})
val zchckFromInt32ToWord32: int32 -> word32 = zextdFromInt32ToWord32
val zchckFromInt32ToWord64: int32 -> word64 = zextdFromInt32ToWord64
val zchckFromInt64ToInt8: int64 -> int8 =
   (make (int8, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt64})
val zchckFromInt64ToInt16: int64 -> int16 =
   (make (int16, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt16,
			 zextdFromSmallToLarge = zextdFromInt16ToInt64})
val zchckFromInt64ToInt32: int64 -> int32 =
   (make (int32, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt32,
			 zextdFromSmallToLarge = zextdFromInt32ToInt64})
val zchckFromInt64ToInt64: int64 -> int64 = zextdFromInt64ToInt64
val zchckFromInt64ToWord8: int64 -> word8 =
   (make (word8, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt64})
val zchckFromInt64ToWord16: int64 -> word16 =
   (make (word16, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord16,
			  zextdFromSmallToLarge = zextdFromWord16ToInt64})
val zchckFromInt64ToWord32: int64 -> word32 =
   (make (word32, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord32,
			  zextdFromSmallToLarge = zextdFromWord32ToInt64})
val zchckFromInt64ToWord64: int64 -> word64 = zextdFromInt64ToWord64
val zchckFromWord8ToInt8: word8 -> int8 = zextdFromWord8ToInt8
val zchckFromWord8ToInt16: word8 -> int16 = zextdFromWord8ToInt16
val zchckFromWord8ToInt32: word8 -> int32 = zextdFromWord8ToInt32
val zchckFromWord8ToInt64: word8 -> int64 = zextdFromWord8ToInt64
val zchckFromWord8ToWord8: word8 -> word8 = zextdFromWord8ToWord8
val zchckFromWord8ToWord16: word8 -> word16 = zextdFromWord8ToWord16
val zchckFromWord8ToWord32: word8 -> word32 = zextdFromWord8ToWord32
val zchckFromWord8ToWord64: word8 -> word64 = zextdFromWord8ToWord64
val zchckFromWord16ToInt8: word16 -> int8 =
   (make (int8, word16) {zextdFromLargeToSmall = zextdFromWord16ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord16})
val zchckFromWord16ToInt16: word16 -> int16 = zextdFromWord16ToInt16
val zchckFromWord16ToInt32: word16 -> int32 = zextdFromWord16ToInt32
val zchckFromWord16ToInt64: word16 -> int64 = zextdFromWord16ToInt64
val zchckFromWord16ToWord8: word16 -> word8 =
   (make (word8, word16) {zextdFromLargeToSmall = zextdFromWord16ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord16})
val zchckFromWord16ToWord16: word16 -> word16 = zextdFromWord16ToWord16
val zchckFromWord16ToWord32: word16 -> word32 = zextdFromWord16ToWord32
val zchckFromWord16ToWord64: word16 -> word64 = zextdFromWord16ToWord64
val zchckFromWord32ToInt8: word32 -> int8 =
   (make (int8, word32) {zextdFromLargeToSmall = zextdFromWord32ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord32})
val zchckFromWord32ToInt16: word32 -> int16 =
   (make (int16, word32) {zextdFromLargeToSmall = zextdFromWord32ToInt16,
			  zextdFromSmallToLarge = zextdFromInt16ToWord32})
val zchckFromWord32ToInt32: word32 -> int32 = zextdFromWord32ToInt32
val zchckFromWord32ToInt64: word32 -> int64 = zextdFromWord32ToInt64
val zchckFromWord32ToWord8: word32 -> word8 =
   (make (word8, word32) {zextdFromLargeToSmall = zextdFromWord32ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord32})
val zchckFromWord32ToWord16: word32 -> word16 =
   (make (word16, word32) {zextdFromLargeToSmall = zextdFromWord32ToWord16,
			   zextdFromSmallToLarge = zextdFromWord16ToWord32})
val zchckFromWord32ToWord32: word32 -> word32 = zextdFromWord32ToWord32
val zchckFromWord32ToWord64: word32 -> word64 = zextdFromWord32ToWord64
val zchckFromWord64ToInt8: word64 -> int8 =
   (make (int8, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord64})
val zchckFromWord64ToInt16: word64 -> int16 =
   (make (int16, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt16,
			  zextdFromSmallToLarge = zextdFromInt16ToWord64})
val zchckFromWord64ToInt32: word64 -> int32 =
   (make (int32, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt32,
			  zextdFromSmallToLarge = zextdFromInt32ToWord64})
val zchckFromWord64ToInt64: word64 -> int64 = zextdFromWord64ToInt64
val zchckFromWord64ToWord8: word64 -> word8 =
   (make (word8, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord64})
val zchckFromWord64ToWord16: word64 -> word16 =
   (make (word16, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord16,
			   zextdFromSmallToLarge = zextdFromWord16ToWord64})
val zchckFromWord64ToWord32: word64 -> word32 =
   (make (word32, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord32,
			   zextdFromSmallToLarge = zextdFromWord32ToWord64})
val zchckFromWord64ToWord64: word64 -> word64 = zextdFromWord64ToWord64
val rec (''s, ''l)
   make: {sextdFromLargeToSmall: ''l -> ''s, sextdFromSmallToLarge: ''s -> ''l}
	 -> ''l -> ''s = 
      (fn x_877: {sextdFromLargeToSmall: ''l -> ''s,
		  sextdFromSmallToLarge: ''s -> ''l} =>
       case x_877 of
	 ({sextdFromLargeToSmall = sextdFromLargeToSmall: ''l -> ''s,
	   sextdFromSmallToLarge = sextdFromSmallToLarge: ''s -> ''l}) =>
	 case detectOverflow of
	   true =>
	   (fn x_878: ''l =>
	    case x_878 of
	      x: ''l =>
	      let val res: ''s = (sextdFromLargeToSmall x)
	      in
		 case (= (''l) (x, (sextdFromSmallToLarge res))) of
		   true => res | false => raise Overflow
	      end)
	 | false => sextdFromLargeToSmall)
val schckFromInt8ToInt8: int8 -> int8 = sextdFromInt8ToInt8
val schckFromInt8ToInt16: int8 -> int16 = sextdFromInt8ToInt16
val schckFromInt8ToInt32: int8 -> int32 = sextdFromInt8ToInt32
val schckFromInt8ToInt64: int8 -> int64 = sextdFromInt8ToInt64
val schckFromInt8ToWord8: int8 -> word8 = sextdFromInt8ToWord8
val schckFromInt8ToWord16: int8 -> word16 = sextdFromInt8ToWord16
val schckFromInt8ToWord32: int8 -> word32 = sextdFromInt8ToWord32
val schckFromInt8ToWord64: int8 -> word64 = sextdFromInt8ToWord64
val schckFromInt16ToInt8: int16 -> int8 =
   (make (int8, int16) {sextdFromLargeToSmall = sextdFromInt16ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt16})
val schckFromInt16ToInt16: int16 -> int16 = sextdFromInt16ToInt16
val schckFromInt16ToInt32: int16 -> int32 = sextdFromInt16ToInt32
val schckFromInt16ToInt64: int16 -> int64 = sextdFromInt16ToInt64
val schckFromInt16ToWord8: int16 -> word8 =
   (make (word8, int16) {sextdFromLargeToSmall = sextdFromInt16ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt16})
val schckFromInt16ToWord16: int16 -> word16 = sextdFromInt16ToWord16
val schckFromInt16ToWord32: int16 -> word32 = sextdFromInt16ToWord32
val schckFromInt16ToWord64: int16 -> word64 = sextdFromInt16ToWord64
val schckFromInt32ToInt8: int32 -> int8 =
   (make (int8, int32) {sextdFromLargeToSmall = sextdFromInt32ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt32})
val schckFromInt32ToInt16: int32 -> int16 =
   (make (int16, int32) {sextdFromLargeToSmall = sextdFromInt32ToInt16,
			 sextdFromSmallToLarge = sextdFromInt16ToInt32})
val schckFromInt32ToInt32: int32 -> int32 = sextdFromInt32ToInt32
val schckFromInt32ToInt64: int32 -> int64 = sextdFromInt32ToInt64
val schckFromInt32ToWord8: int32 -> word8 =
   (make (word8, int32) {sextdFromLargeToSmall = sextdFromInt32ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt32})
val schckFromInt32ToWord16: int32 -> word16 =
   (make (word16, int32) {sextdFromLargeToSmall = sextdFromInt32ToWord16,
			  sextdFromSmallToLarge = sextdFromWord16ToInt32})
val schckFromInt32ToWord32: int32 -> word32 = sextdFromInt32ToWord32
val schckFromInt32ToWord64: int32 -> word64 = sextdFromInt32ToWord64
val schckFromInt64ToInt8: int64 -> int8 =
   (make (int8, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt64})
val schckFromInt64ToInt16: int64 -> int16 =
   (make (int16, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt16,
			 sextdFromSmallToLarge = sextdFromInt16ToInt64})
val schckFromInt64ToInt32: int64 -> int32 =
   (make (int32, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt32,
			 sextdFromSmallToLarge = sextdFromInt32ToInt64})
val schckFromInt64ToInt64: int64 -> int64 = sextdFromInt64ToInt64
val schckFromInt64ToWord8: int64 -> word8 =
   (make (word8, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt64})
val schckFromInt64ToWord16: int64 -> word16 =
   (make (word16, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord16,
			  sextdFromSmallToLarge = sextdFromWord16ToInt64})
val schckFromInt64ToWord32: int64 -> word32 =
   (make (word32, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord32,
			  sextdFromSmallToLarge = sextdFromWord32ToInt64})
val schckFromInt64ToWord64: int64 -> word64 = sextdFromInt64ToWord64
val schckFromWord8ToInt8: word8 -> int8 = sextdFromWord8ToInt8
val schckFromWord8ToInt16: word8 -> int16 = sextdFromWord8ToInt16
val schckFromWord8ToInt32: word8 -> int32 = sextdFromWord8ToInt32
val schckFromWord8ToInt64: word8 -> int64 = sextdFromWord8ToInt64
val schckFromWord8ToWord8: word8 -> word8 = sextdFromWord8ToWord8
val schckFromWord8ToWord16: word8 -> word16 = sextdFromWord8ToWord16
val schckFromWord8ToWord32: word8 -> word32 = sextdFromWord8ToWord32
val schckFromWord8ToWord64: word8 -> word64 = sextdFromWord8ToWord64
val schckFromWord16ToInt8: word16 -> int8 =
   (make (int8, word16) {sextdFromLargeToSmall = sextdFromWord16ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord16})
val schckFromWord16ToInt16: word16 -> int16 = sextdFromWord16ToInt16
val schckFromWord16ToInt32: word16 -> int32 = sextdFromWord16ToInt32
val schckFromWord16ToInt64: word16 -> int64 = sextdFromWord16ToInt64
val schckFromWord16ToWord8: word16 -> word8 =
   (make (word8, word16) {sextdFromLargeToSmall = sextdFromWord16ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord16})
val schckFromWord16ToWord16: word16 -> word16 = sextdFromWord16ToWord16
val schckFromWord16ToWord32: word16 -> word32 = sextdFromWord16ToWord32
val schckFromWord16ToWord64: word16 -> word64 = sextdFromWord16ToWord64
val schckFromWord32ToInt8: word32 -> int8 =
   (make (int8, word32) {sextdFromLargeToSmall = sextdFromWord32ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord32})
val schckFromWord32ToInt16: word32 -> int16 =
   (make (int16, word32) {sextdFromLargeToSmall = sextdFromWord32ToInt16,
			  sextdFromSmallToLarge = sextdFromInt16ToWord32})
val schckFromWord32ToInt32: word32 -> int32 = sextdFromWord32ToInt32
val schckFromWord32ToInt64: word32 -> int64 = sextdFromWord32ToInt64
val schckFromWord32ToWord8: word32 -> word8 =
   (make (word8, word32) {sextdFromLargeToSmall = sextdFromWord32ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord32})
val schckFromWord32ToWord16: word32 -> word16 =
   (make (word16, word32) {sextdFromLargeToSmall = sextdFromWord32ToWord16,
			   sextdFromSmallToLarge = sextdFromWord16ToWord32})
val schckFromWord32ToWord32: word32 -> word32 = sextdFromWord32ToWord32
val schckFromWord32ToWord64: word32 -> word64 = sextdFromWord32ToWord64
val schckFromWord64ToInt8: word64 -> int8 =
   (make (int8, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord64})
val schckFromWord64ToInt16: word64 -> int16 =
   (make (int16, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt16,
			  sextdFromSmallToLarge = sextdFromInt16ToWord64})
val schckFromWord64ToInt32: word64 -> int32 =
   (make (int32, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt32,
			  sextdFromSmallToLarge = sextdFromInt32ToWord64})
val schckFromWord64ToInt64: word64 -> int64 = sextdFromWord64ToInt64
val schckFromWord64ToWord8: word64 -> word8 =
   (make (word8, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord64})
val schckFromWord64ToWord16: word64 -> word16 =
   (make (word16, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord16,
			   sextdFromSmallToLarge = sextdFromWord16ToWord64})
val schckFromWord64ToWord32: word64 -> word32 =
   (make (word32, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord32,
			   sextdFromSmallToLarge = sextdFromWord32ToWord64})
val schckFromWord64ToWord64: word64 -> word64 = sextdFromWord64ToWord64
val zextdFromInt8: int8 -> int8 = zextdFromInt8ToInt8
val zextdFromInt16: int16 -> int8 = zextdFromInt16ToInt8
val zextdFromInt32: int32 -> int8 = zextdFromInt32ToInt8
val zextdFromInt64: int64 -> int8 = zextdFromInt64ToInt8
val zextdFromWord8: word8 -> int8 = zextdFromWord8ToInt8
val zextdFromWord16: word16 -> int8 = zextdFromWord16ToInt8
val zextdFromWord32: word32 -> int8 = zextdFromWord32ToInt8
val zextdFromWord64: word64 -> int8 = zextdFromWord64ToInt8
val zextdToInt8: int8 -> int8 = zextdFromInt8ToInt8
val zextdToInt16: int8 -> int16 = zextdFromInt8ToInt16
val zextdToInt32: int8 -> int32 = zextdFromInt8ToInt32
val zextdToInt64: int8 -> int64 = zextdFromInt8ToInt64
val zextdToWord8: int8 -> word8 = zextdFromInt8ToWord8
val zextdToWord16: int8 -> word16 = zextdFromInt8ToWord16
val zextdToWord32: int8 -> word32 = zextdFromInt8ToWord32
val zextdToWord64: int8 -> word64 = zextdFromInt8ToWord64
val sextdFromInt8: int8 -> int8 = sextdFromInt8ToInt8
val sextdFromInt16: int16 -> int8 = sextdFromInt16ToInt8
val sextdFromInt32: int32 -> int8 = sextdFromInt32ToInt8
val sextdFromInt64: int64 -> int8 = sextdFromInt64ToInt8
val sextdFromWord8: word8 -> int8 = sextdFromWord8ToInt8
val sextdFromWord16: word16 -> int8 = sextdFromWord16ToInt8
val sextdFromWord32: word32 -> int8 = sextdFromWord32ToInt8
val sextdFromWord64: word64 -> int8 = sextdFromWord64ToInt8
val sextdToInt8: int8 -> int8 = sextdFromInt8ToInt8
val sextdToInt16: int8 -> int16 = sextdFromInt8ToInt16
val sextdToInt32: int8 -> int32 = sextdFromInt8ToInt32
val sextdToInt64: int8 -> int64 = sextdFromInt8ToInt64
val sextdToWord8: int8 -> word8 = sextdFromInt8ToWord8
val sextdToWord16: int8 -> word16 = sextdFromInt8ToWord16
val sextdToWord32: int8 -> word32 = sextdFromInt8ToWord32
val sextdToWord64: int8 -> word64 = sextdFromInt8ToWord64
val castFromInt8: int8 -> int8 = castFromInt8ToInt8
val castFromInt16: int16 -> int8 = castFromInt16ToInt8
val castFromInt32: int32 -> int8 = castFromInt32ToInt8
val castFromInt64: int64 -> int8 = castFromInt64ToInt8
val castFromWord8: word8 -> int8 = castFromWord8ToInt8
val castFromWord16: word16 -> int8 = castFromWord16ToInt8
val castFromWord32: word32 -> int8 = castFromWord32ToInt8
val castFromWord64: word64 -> int8 = castFromWord64ToInt8
val castToInt8: int8 -> int8 = castFromInt8ToInt8
val castToInt16: int8 -> int16 = castFromInt8ToInt16
val castToInt32: int8 -> int32 = castFromInt8ToInt32
val castToInt64: int8 -> int64 = castFromInt8ToInt64
val castToWord8: int8 -> word8 = castFromInt8ToWord8
val castToWord16: int8 -> word16 = castFromInt8ToWord16
val castToWord32: int8 -> word32 = castFromInt8ToWord32
val castToWord64: int8 -> word64 = castFromInt8ToWord64
val zchckFromInt8: int8 -> int8 = zchckFromInt8ToInt8
val zchckFromInt16: int16 -> int8 = zchckFromInt16ToInt8
val zchckFromInt32: int32 -> int8 = zchckFromInt32ToInt8
val zchckFromInt64: int64 -> int8 = zchckFromInt64ToInt8
val zchckFromWord8: word8 -> int8 = zchckFromWord8ToInt8
val zchckFromWord16: word16 -> int8 = zchckFromWord16ToInt8
val zchckFromWord32: word32 -> int8 = zchckFromWord32ToInt8
val zchckFromWord64: word64 -> int8 = zchckFromWord64ToInt8
val zchckToInt8: int8 -> int8 = zchckFromInt8ToInt8
val zchckToInt16: int8 -> int16 = zchckFromInt8ToInt16
val zchckToInt32: int8 -> int32 = zchckFromInt8ToInt32
val zchckToInt64: int8 -> int64 = zchckFromInt8ToInt64
val zchckToWord8: int8 -> word8 = zchckFromInt8ToWord8
val zchckToWord16: int8 -> word16 = zchckFromInt8ToWord16
val zchckToWord32: int8 -> word32 = zchckFromInt8ToWord32
val zchckToWord64: int8 -> word64 = zchckFromInt8ToWord64
val schckFromInt8: int8 -> int8 = schckFromInt8ToInt8
val schckFromInt16: int16 -> int8 = schckFromInt16ToInt8
val schckFromInt32: int32 -> int8 = schckFromInt32ToInt8
val schckFromInt64: int64 -> int8 = schckFromInt64ToInt8
val schckFromWord8: word8 -> int8 = schckFromWord8ToInt8
val schckFromWord16: word16 -> int8 = schckFromWord16ToInt8
val schckFromWord32: word32 -> int8 = schckFromWord32ToInt8
val schckFromWord64: word64 -> int8 = schckFromWord64ToInt8
val schckToInt8: int8 -> int8 = schckFromInt8ToInt8
val schckToInt16: int8 -> int16 = schckFromInt8ToInt16
val schckToInt32: int8 -> int32 = schckFromInt8ToInt32
val schckToInt64: int8 -> int64 = schckFromInt8ToInt64
val schckToWord8: int8 -> word8 = schckFromInt8ToWord8
val schckToWord16: int8 -> word16 = schckFromInt8ToWord16
val schckToWord32: int8 -> word32 = schckFromInt8ToWord32
val schckToWord64: int8 -> word64 = schckFromInt8ToWord64
val zextdFromInt8: int8 -> int16 = zextdFromInt8ToInt16
val zextdFromInt16: int16 -> int16 = zextdFromInt16ToInt16
val zextdFromInt32: int32 -> int16 = zextdFromInt32ToInt16
val zextdFromInt64: int64 -> int16 = zextdFromInt64ToInt16
val zextdFromWord8: word8 -> int16 = zextdFromWord8ToInt16
val zextdFromWord16: word16 -> int16 = zextdFromWord16ToInt16
val zextdFromWord32: word32 -> int16 = zextdFromWord32ToInt16
val zextdFromWord64: word64 -> int16 = zextdFromWord64ToInt16
val zextdToInt8: int16 -> int8 = zextdFromInt16ToInt8
val zextdToInt16: int16 -> int16 = zextdFromInt16ToInt16
val zextdToInt32: int16 -> int32 = zextdFromInt16ToInt32
val zextdToInt64: int16 -> int64 = zextdFromInt16ToInt64
val zextdToWord8: int16 -> word8 = zextdFromInt16ToWord8
val zextdToWord16: int16 -> word16 = zextdFromInt16ToWord16
val zextdToWord32: int16 -> word32 = zextdFromInt16ToWord32
val zextdToWord64: int16 -> word64 = zextdFromInt16ToWord64
val sextdFromInt8: int8 -> int16 = sextdFromInt8ToInt16
val sextdFromInt16: int16 -> int16 = sextdFromInt16ToInt16
val sextdFromInt32: int32 -> int16 = sextdFromInt32ToInt16
val sextdFromInt64: int64 -> int16 = sextdFromInt64ToInt16
val sextdFromWord8: word8 -> int16 = sextdFromWord8ToInt16
val sextdFromWord16: word16 -> int16 = sextdFromWord16ToInt16
val sextdFromWord32: word32 -> int16 = sextdFromWord32ToInt16
val sextdFromWord64: word64 -> int16 = sextdFromWord64ToInt16
val sextdToInt8: int16 -> int8 = sextdFromInt16ToInt8
val sextdToInt16: int16 -> int16 = sextdFromInt16ToInt16
val sextdToInt32: int16 -> int32 = sextdFromInt16ToInt32
val sextdToInt64: int16 -> int64 = sextdFromInt16ToInt64
val sextdToWord8: int16 -> word8 = sextdFromInt16ToWord8
val sextdToWord16: int16 -> word16 = sextdFromInt16ToWord16
val sextdToWord32: int16 -> word32 = sextdFromInt16ToWord32
val sextdToWord64: int16 -> word64 = sextdFromInt16ToWord64
val castFromInt8: int8 -> int16 = castFromInt8ToInt16
val castFromInt16: int16 -> int16 = castFromInt16ToInt16
val castFromInt32: int32 -> int16 = castFromInt32ToInt16
val castFromInt64: int64 -> int16 = castFromInt64ToInt16
val castFromWord8: word8 -> int16 = castFromWord8ToInt16
val castFromWord16: word16 -> int16 = castFromWord16ToInt16
val castFromWord32: word32 -> int16 = castFromWord32ToInt16
val castFromWord64: word64 -> int16 = castFromWord64ToInt16
val castToInt8: int16 -> int8 = castFromInt16ToInt8
val castToInt16: int16 -> int16 = castFromInt16ToInt16
val castToInt32: int16 -> int32 = castFromInt16ToInt32
val castToInt64: int16 -> int64 = castFromInt16ToInt64
val castToWord8: int16 -> word8 = castFromInt16ToWord8
val castToWord16: int16 -> word16 = castFromInt16ToWord16
val castToWord32: int16 -> word32 = castFromInt16ToWord32
val castToWord64: int16 -> word64 = castFromInt16ToWord64
val zchckFromInt8: int8 -> int16 = zchckFromInt8ToInt16
val zchckFromInt16: int16 -> int16 = zchckFromInt16ToInt16
val zchckFromInt32: int32 -> int16 = zchckFromInt32ToInt16
val zchckFromInt64: int64 -> int16 = zchckFromInt64ToInt16
val zchckFromWord8: word8 -> int16 = zchckFromWord8ToInt16
val zchckFromWord16: word16 -> int16 = zchckFromWord16ToInt16
val zchckFromWord32: word32 -> int16 = zchckFromWord32ToInt16
val zchckFromWord64: word64 -> int16 = zchckFromWord64ToInt16
val zchckToInt8: int16 -> int8 = zchckFromInt16ToInt8
val zchckToInt16: int16 -> int16 = zchckFromInt16ToInt16
val zchckToInt32: int16 -> int32 = zchckFromInt16ToInt32
val zchckToInt64: int16 -> int64 = zchckFromInt16ToInt64
val zchckToWord8: int16 -> word8 = zchckFromInt16ToWord8
val zchckToWord16: int16 -> word16 = zchckFromInt16ToWord16
val zchckToWord32: int16 -> word32 = zchckFromInt16ToWord32
val zchckToWord64: int16 -> word64 = zchckFromInt16ToWord64
val schckFromInt8: int8 -> int16 = schckFromInt8ToInt16
val schckFromInt16: int16 -> int16 = schckFromInt16ToInt16
val schckFromInt32: int32 -> int16 = schckFromInt32ToInt16
val schckFromInt64: int64 -> int16 = schckFromInt64ToInt16
val schckFromWord8: word8 -> int16 = schckFromWord8ToInt16
val schckFromWord16: word16 -> int16 = schckFromWord16ToInt16
val schckFromWord32: word32 -> int16 = schckFromWord32ToInt16
val schckFromWord64: word64 -> int16 = schckFromWord64ToInt16
val schckToInt8: int16 -> int8 = schckFromInt16ToInt8
val schckToInt16: int16 -> int16 = schckFromInt16ToInt16
val schckToInt32: int16 -> int32 = schckFromInt16ToInt32
val schckToInt64: int16 -> int64 = schckFromInt16ToInt64
val schckToWord8: int16 -> word8 = schckFromInt16ToWord8
val schckToWord16: int16 -> word16 = schckFromInt16ToWord16
val schckToWord32: int16 -> word32 = schckFromInt16ToWord32
val schckToWord64: int16 -> word64 = schckFromInt16ToWord64
val zextdFromInt8: int8 -> int32 = zextdFromInt8ToInt32
val zextdFromInt16: int16 -> int32 = zextdFromInt16ToInt32
val zextdFromInt32: int32 -> int32 = zextdFromInt32ToInt32
val zextdFromInt64: int64 -> int32 = zextdFromInt64ToInt32
val zextdFromWord8: word8 -> int32 = zextdFromWord8ToInt32
val zextdFromWord16: word16 -> int32 = zextdFromWord16ToInt32
val zextdFromWord32: word32 -> int32 = zextdFromWord32ToInt32
val zextdFromWord64: word64 -> int32 = zextdFromWord64ToInt32
val zextdToInt8: int32 -> int8 = zextdFromInt32ToInt8
val zextdToInt16: int32 -> int16 = zextdFromInt32ToInt16
val zextdToInt32: int32 -> int32 = zextdFromInt32ToInt32
val zextdToInt64: int32 -> int64 = zextdFromInt32ToInt64
val zextdToWord8: int32 -> word8 = zextdFromInt32ToWord8
val zextdToWord16: int32 -> word16 = zextdFromInt32ToWord16
val zextdToWord32: int32 -> word32 = zextdFromInt32ToWord32
val zextdToWord64: int32 -> word64 = zextdFromInt32ToWord64
val sextdFromInt8: int8 -> int32 = sextdFromInt8ToInt32
val sextdFromInt16: int16 -> int32 = sextdFromInt16ToInt32
val sextdFromInt32: int32 -> int32 = sextdFromInt32ToInt32
val sextdFromInt64: int64 -> int32 = sextdFromInt64ToInt32
val sextdFromWord8: word8 -> int32 = sextdFromWord8ToInt32
val sextdFromWord16: word16 -> int32 = sextdFromWord16ToInt32
val sextdFromWord32: word32 -> int32 = sextdFromWord32ToInt32
val sextdFromWord64: word64 -> int32 = sextdFromWord64ToInt32
val sextdToInt8: int32 -> int8 = sextdFromInt32ToInt8
val sextdToInt16: int32 -> int16 = sextdFromInt32ToInt16
val sextdToInt32: int32 -> int32 = sextdFromInt32ToInt32
val sextdToInt64: int32 -> int64 = sextdFromInt32ToInt64
val sextdToWord8: int32 -> word8 = sextdFromInt32ToWord8
val sextdToWord16: int32 -> word16 = sextdFromInt32ToWord16
val sextdToWord32: int32 -> word32 = sextdFromInt32ToWord32
val sextdToWord64: int32 -> word64 = sextdFromInt32ToWord64
val castFromInt8: int8 -> int32 = castFromInt8ToInt32
val castFromInt16: int16 -> int32 = castFromInt16ToInt32
val castFromInt32: int32 -> int32 = castFromInt32ToInt32
val castFromInt64: int64 -> int32 = castFromInt64ToInt32
val castFromWord8: word8 -> int32 = castFromWord8ToInt32
val castFromWord16: word16 -> int32 = castFromWord16ToInt32
val castFromWord32: word32 -> int32 = castFromWord32ToInt32
val castFromWord64: word64 -> int32 = castFromWord64ToInt32
val castToInt8: int32 -> int8 = castFromInt32ToInt8
val castToInt16: int32 -> int16 = castFromInt32ToInt16
val castToInt32: int32 -> int32 = castFromInt32ToInt32
val castToInt64: int32 -> int64 = castFromInt32ToInt64
val castToWord8: int32 -> word8 = castFromInt32ToWord8
val castToWord16: int32 -> word16 = castFromInt32ToWord16
val castToWord32: int32 -> word32 = castFromInt32ToWord32
val castToWord64: int32 -> word64 = castFromInt32ToWord64
val zchckFromInt8: int8 -> int32 = zchckFromInt8ToInt32
val zchckFromInt16: int16 -> int32 = zchckFromInt16ToInt32
val zchckFromInt32: int32 -> int32 = zchckFromInt32ToInt32
val zchckFromInt64: int64 -> int32 = zchckFromInt64ToInt32
val zchckFromWord8: word8 -> int32 = zchckFromWord8ToInt32
val zchckFromWord16: word16 -> int32 = zchckFromWord16ToInt32
val zchckFromWord32: word32 -> int32 = zchckFromWord32ToInt32
val zchckFromWord64: word64 -> int32 = zchckFromWord64ToInt32
val zchckToInt8: int32 -> int8 = zchckFromInt32ToInt8
val zchckToInt16: int32 -> int16 = zchckFromInt32ToInt16
val zchckToInt32: int32 -> int32 = zchckFromInt32ToInt32
val zchckToInt64: int32 -> int64 = zchckFromInt32ToInt64
val zchckToWord8: int32 -> word8 = zchckFromInt32ToWord8
val zchckToWord16: int32 -> word16 = zchckFromInt32ToWord16
val zchckToWord32: int32 -> word32 = zchckFromInt32ToWord32
val zchckToWord64: int32 -> word64 = zchckFromInt32ToWord64
val schckFromInt8: int8 -> int32 = schckFromInt8ToInt32
val schckFromInt16: int16 -> int32 = schckFromInt16ToInt32
val schckFromInt32: int32 -> int32 = schckFromInt32ToInt32
val schckFromInt64: int64 -> int32 = schckFromInt64ToInt32
val schckFromWord8: word8 -> int32 = schckFromWord8ToInt32
val schckFromWord16: word16 -> int32 = schckFromWord16ToInt32
val schckFromWord32: word32 -> int32 = schckFromWord32ToInt32
val schckFromWord64: word64 -> int32 = schckFromWord64ToInt32
val schckToInt8: int32 -> int8 = schckFromInt32ToInt8
val schckToInt16: int32 -> int16 = schckFromInt32ToInt16
val schckToInt32: int32 -> int32 = schckFromInt32ToInt32
val schckToInt64: int32 -> int64 = schckFromInt32ToInt64
val schckToWord8: int32 -> word8 = schckFromInt32ToWord8
val schckToWord16: int32 -> word16 = schckFromInt32ToWord16
val schckToWord32: int32 -> word32 = schckFromInt32ToWord32
val schckToWord64: int32 -> word64 = schckFromInt32ToWord64
val zextdFromInt8: int8 -> int64 = zextdFromInt8ToInt64
val zextdFromInt16: int16 -> int64 = zextdFromInt16ToInt64
val zextdFromInt32: int32 -> int64 = zextdFromInt32ToInt64
val zextdFromInt64: int64 -> int64 = zextdFromInt64ToInt64
val zextdFromWord8: word8 -> int64 = zextdFromWord8ToInt64
val zextdFromWord16: word16 -> int64 = zextdFromWord16ToInt64
val zextdFromWord32: word32 -> int64 = zextdFromWord32ToInt64
val zextdFromWord64: word64 -> int64 = zextdFromWord64ToInt64
val zextdToInt8: int64 -> int8 = zextdFromInt64ToInt8
val zextdToInt16: int64 -> int16 = zextdFromInt64ToInt16
val zextdToInt32: int64 -> int32 = zextdFromInt64ToInt32
val zextdToInt64: int64 -> int64 = zextdFromInt64ToInt64
val zextdToWord8: int64 -> word8 = zextdFromInt64ToWord8
val zextdToWord16: int64 -> word16 = zextdFromInt64ToWord16
val zextdToWord32: int64 -> word32 = zextdFromInt64ToWord32
val zextdToWord64: int64 -> word64 = zextdFromInt64ToWord64
val sextdFromInt8: int8 -> int64 = sextdFromInt8ToInt64
val sextdFromInt16: int16 -> int64 = sextdFromInt16ToInt64
val sextdFromInt32: int32 -> int64 = sextdFromInt32ToInt64
val sextdFromInt64: int64 -> int64 = sextdFromInt64ToInt64
val sextdFromWord8: word8 -> int64 = sextdFromWord8ToInt64
val sextdFromWord16: word16 -> int64 = sextdFromWord16ToInt64
val sextdFromWord32: word32 -> int64 = sextdFromWord32ToInt64
val sextdFromWord64: word64 -> int64 = sextdFromWord64ToInt64
val sextdToInt8: int64 -> int8 = sextdFromInt64ToInt8
val sextdToInt16: int64 -> int16 = sextdFromInt64ToInt16
val sextdToInt32: int64 -> int32 = sextdFromInt64ToInt32
val sextdToInt64: int64 -> int64 = sextdFromInt64ToInt64
val sextdToWord8: int64 -> word8 = sextdFromInt64ToWord8
val sextdToWord16: int64 -> word16 = sextdFromInt64ToWord16
val sextdToWord32: int64 -> word32 = sextdFromInt64ToWord32
val sextdToWord64: int64 -> word64 = sextdFromInt64ToWord64
val castFromInt8: int8 -> int64 = castFromInt8ToInt64
val castFromInt16: int16 -> int64 = castFromInt16ToInt64
val castFromInt32: int32 -> int64 = castFromInt32ToInt64
val castFromInt64: int64 -> int64 = castFromInt64ToInt64
val castFromWord8: word8 -> int64 = castFromWord8ToInt64
val castFromWord16: word16 -> int64 = castFromWord16ToInt64
val castFromWord32: word32 -> int64 = castFromWord32ToInt64
val castFromWord64: word64 -> int64 = castFromWord64ToInt64
val castToInt8: int64 -> int8 = castFromInt64ToInt8
val castToInt16: int64 -> int16 = castFromInt64ToInt16
val castToInt32: int64 -> int32 = castFromInt64ToInt32
val castToInt64: int64 -> int64 = castFromInt64ToInt64
val castToWord8: int64 -> word8 = castFromInt64ToWord8
val castToWord16: int64 -> word16 = castFromInt64ToWord16
val castToWord32: int64 -> word32 = castFromInt64ToWord32
val castToWord64: int64 -> word64 = castFromInt64ToWord64
val zchckFromInt8: int8 -> int64 = zchckFromInt8ToInt64
val zchckFromInt16: int16 -> int64 = zchckFromInt16ToInt64
val zchckFromInt32: int32 -> int64 = zchckFromInt32ToInt64
val zchckFromInt64: int64 -> int64 = zchckFromInt64ToInt64
val zchckFromWord8: word8 -> int64 = zchckFromWord8ToInt64
val zchckFromWord16: word16 -> int64 = zchckFromWord16ToInt64
val zchckFromWord32: word32 -> int64 = zchckFromWord32ToInt64
val zchckFromWord64: word64 -> int64 = zchckFromWord64ToInt64
val zchckToInt8: int64 -> int8 = zchckFromInt64ToInt8
val zchckToInt16: int64 -> int16 = zchckFromInt64ToInt16
val zchckToInt32: int64 -> int32 = zchckFromInt64ToInt32
val zchckToInt64: int64 -> int64 = zchckFromInt64ToInt64
val zchckToWord8: int64 -> word8 = zchckFromInt64ToWord8
val zchckToWord16: int64 -> word16 = zchckFromInt64ToWord16
val zchckToWord32: int64 -> word32 = zchckFromInt64ToWord32
val zchckToWord64: int64 -> word64 = zchckFromInt64ToWord64
val schckFromInt8: int8 -> int64 = schckFromInt8ToInt64
val schckFromInt16: int16 -> int64 = schckFromInt16ToInt64
val schckFromInt32: int32 -> int64 = schckFromInt32ToInt64
val schckFromInt64: int64 -> int64 = schckFromInt64ToInt64
val schckFromWord8: word8 -> int64 = schckFromWord8ToInt64
val schckFromWord16: word16 -> int64 = schckFromWord16ToInt64
val schckFromWord32: word32 -> int64 = schckFromWord32ToInt64
val schckFromWord64: word64 -> int64 = schckFromWord64ToInt64
val schckToInt8: int64 -> int8 = schckFromInt64ToInt8
val schckToInt16: int64 -> int16 = schckFromInt64ToInt16
val schckToInt32: int64 -> int32 = schckFromInt64ToInt32
val schckToInt64: int64 -> int64 = schckFromInt64ToInt64
val schckToWord8: int64 -> word8 = schckFromInt64ToWord8
val schckToWord16: int64 -> word16 = schckFromInt64ToWord16
val schckToWord32: int64 -> word32 = schckFromInt64ToWord32
val schckToWord64: int64 -> word64 = schckFromInt64ToWord64
val zextdFromInt8: int8 -> word8 = zextdFromInt8ToWord8
val zextdFromInt16: int16 -> word8 = zextdFromInt16ToWord8
val zextdFromInt32: int32 -> word8 = zextdFromInt32ToWord8
val zextdFromInt64: int64 -> word8 = zextdFromInt64ToWord8
val zextdFromWord8: word8 -> word8 = zextdFromWord8ToWord8
val zextdFromWord16: word16 -> word8 = zextdFromWord16ToWord8
val zextdFromWord32: word32 -> word8 = zextdFromWord32ToWord8
val zextdFromWord64: word64 -> word8 = zextdFromWord64ToWord8
val zextdToInt8: word8 -> int8 = zextdFromWord8ToInt8
val zextdToInt16: word8 -> int16 = zextdFromWord8ToInt16
val zextdToInt32: word8 -> int32 = zextdFromWord8ToInt32
val zextdToInt64: word8 -> int64 = zextdFromWord8ToInt64
val zextdToWord8: word8 -> word8 = zextdFromWord8ToWord8
val zextdToWord16: word8 -> word16 = zextdFromWord8ToWord16
val zextdToWord32: word8 -> word32 = zextdFromWord8ToWord32
val zextdToWord64: word8 -> word64 = zextdFromWord8ToWord64
val sextdFromInt8: int8 -> word8 = sextdFromInt8ToWord8
val sextdFromInt16: int16 -> word8 = sextdFromInt16ToWord8
val sextdFromInt32: int32 -> word8 = sextdFromInt32ToWord8
val sextdFromInt64: int64 -> word8 = sextdFromInt64ToWord8
val sextdFromWord8: word8 -> word8 = sextdFromWord8ToWord8
val sextdFromWord16: word16 -> word8 = sextdFromWord16ToWord8
val sextdFromWord32: word32 -> word8 = sextdFromWord32ToWord8
val sextdFromWord64: word64 -> word8 = sextdFromWord64ToWord8
val sextdToInt8: word8 -> int8 = sextdFromWord8ToInt8
val sextdToInt16: word8 -> int16 = sextdFromWord8ToInt16
val sextdToInt32: word8 -> int32 = sextdFromWord8ToInt32
val sextdToInt64: word8 -> int64 = sextdFromWord8ToInt64
val sextdToWord8: word8 -> word8 = sextdFromWord8ToWord8
val sextdToWord16: word8 -> word16 = sextdFromWord8ToWord16
val sextdToWord32: word8 -> word32 = sextdFromWord8ToWord32
val sextdToWord64: word8 -> word64 = sextdFromWord8ToWord64
val castFromInt8: int8 -> word8 = castFromInt8ToWord8
val castFromInt16: int16 -> word8 = castFromInt16ToWord8
val castFromInt32: int32 -> word8 = castFromInt32ToWord8
val castFromInt64: int64 -> word8 = castFromInt64ToWord8
val castFromWord8: word8 -> word8 = castFromWord8ToWord8
val castFromWord16: word16 -> word8 = castFromWord16ToWord8
val castFromWord32: word32 -> word8 = castFromWord32ToWord8
val castFromWord64: word64 -> word8 = castFromWord64ToWord8
val castToInt8: word8 -> int8 = castFromWord8ToInt8
val castToInt16: word8 -> int16 = castFromWord8ToInt16
val castToInt32: word8 -> int32 = castFromWord8ToInt32
val castToInt64: word8 -> int64 = castFromWord8ToInt64
val castToWord8: word8 -> word8 = castFromWord8ToWord8
val castToWord16: word8 -> word16 = castFromWord8ToWord16
val castToWord32: word8 -> word32 = castFromWord8ToWord32
val castToWord64: word8 -> word64 = castFromWord8ToWord64
val zchckFromInt8: int8 -> word8 = zchckFromInt8ToWord8
val zchckFromInt16: int16 -> word8 = zchckFromInt16ToWord8
val zchckFromInt32: int32 -> word8 = zchckFromInt32ToWord8
val zchckFromInt64: int64 -> word8 = zchckFromInt64ToWord8
val zchckFromWord8: word8 -> word8 = zchckFromWord8ToWord8
val zchckFromWord16: word16 -> word8 = zchckFromWord16ToWord8
val zchckFromWord32: word32 -> word8 = zchckFromWord32ToWord8
val zchckFromWord64: word64 -> word8 = zchckFromWord64ToWord8
val zchckToInt8: word8 -> int8 = zchckFromWord8ToInt8
val zchckToInt16: word8 -> int16 = zchckFromWord8ToInt16
val zchckToInt32: word8 -> int32 = zchckFromWord8ToInt32
val zchckToInt64: word8 -> int64 = zchckFromWord8ToInt64
val zchckToWord8: word8 -> word8 = zchckFromWord8ToWord8
val zchckToWord16: word8 -> word16 = zchckFromWord8ToWord16
val zchckToWord32: word8 -> word32 = zchckFromWord8ToWord32
val zchckToWord64: word8 -> word64 = zchckFromWord8ToWord64
val schckFromInt8: int8 -> word8 = schckFromInt8ToWord8
val schckFromInt16: int16 -> word8 = schckFromInt16ToWord8
val schckFromInt32: int32 -> word8 = schckFromInt32ToWord8
val schckFromInt64: int64 -> word8 = schckFromInt64ToWord8
val schckFromWord8: word8 -> word8 = schckFromWord8ToWord8
val schckFromWord16: word16 -> word8 = schckFromWord16ToWord8
val schckFromWord32: word32 -> word8 = schckFromWord32ToWord8
val schckFromWord64: word64 -> word8 = schckFromWord64ToWord8
val schckToInt8: word8 -> int8 = schckFromWord8ToInt8
val schckToInt16: word8 -> int16 = schckFromWord8ToInt16
val schckToInt32: word8 -> int32 = schckFromWord8ToInt32
val schckToInt64: word8 -> int64 = schckFromWord8ToInt64
val schckToWord8: word8 -> word8 = schckFromWord8ToWord8
val schckToWord16: word8 -> word16 = schckFromWord8ToWord16
val schckToWord32: word8 -> word32 = schckFromWord8ToWord32
val schckToWord64: word8 -> word64 = schckFromWord8ToWord64
val zextdFromInt8: int8 -> word16 = zextdFromInt8ToWord16
val zextdFromInt16: int16 -> word16 = zextdFromInt16ToWord16
val zextdFromInt32: int32 -> word16 = zextdFromInt32ToWord16
val zextdFromInt64: int64 -> word16 = zextdFromInt64ToWord16
val zextdFromWord8: word8 -> word16 = zextdFromWord8ToWord16
val zextdFromWord16: word16 -> word16 = zextdFromWord16ToWord16
val zextdFromWord32: word32 -> word16 = zextdFromWord32ToWord16
val zextdFromWord64: word64 -> word16 = zextdFromWord64ToWord16
val zextdToInt8: word16 -> int8 = zextdFromWord16ToInt8
val zextdToInt16: word16 -> int16 = zextdFromWord16ToInt16
val zextdToInt32: word16 -> int32 = zextdFromWord16ToInt32
val zextdToInt64: word16 -> int64 = zextdFromWord16ToInt64
val zextdToWord8: word16 -> word8 = zextdFromWord16ToWord8
val zextdToWord16: word16 -> word16 = zextdFromWord16ToWord16
val zextdToWord32: word16 -> word32 = zextdFromWord16ToWord32
val zextdToWord64: word16 -> word64 = zextdFromWord16ToWord64
val sextdFromInt8: int8 -> word16 = sextdFromInt8ToWord16
val sextdFromInt16: int16 -> word16 = sextdFromInt16ToWord16
val sextdFromInt32: int32 -> word16 = sextdFromInt32ToWord16
val sextdFromInt64: int64 -> word16 = sextdFromInt64ToWord16
val sextdFromWord8: word8 -> word16 = sextdFromWord8ToWord16
val sextdFromWord16: word16 -> word16 = sextdFromWord16ToWord16
val sextdFromWord32: word32 -> word16 = sextdFromWord32ToWord16
val sextdFromWord64: word64 -> word16 = sextdFromWord64ToWord16
val sextdToInt8: word16 -> int8 = sextdFromWord16ToInt8
val sextdToInt16: word16 -> int16 = sextdFromWord16ToInt16
val sextdToInt32: word16 -> int32 = sextdFromWord16ToInt32
val sextdToInt64: word16 -> int64 = sextdFromWord16ToInt64
val sextdToWord8: word16 -> word8 = sextdFromWord16ToWord8
val sextdToWord16: word16 -> word16 = sextdFromWord16ToWord16
val sextdToWord32: word16 -> word32 = sextdFromWord16ToWord32
val sextdToWord64: word16 -> word64 = sextdFromWord16ToWord64
val castFromInt8: int8 -> word16 = castFromInt8ToWord16
val castFromInt16: int16 -> word16 = castFromInt16ToWord16
val castFromInt32: int32 -> word16 = castFromInt32ToWord16
val castFromInt64: int64 -> word16 = castFromInt64ToWord16
val castFromWord8: word8 -> word16 = castFromWord8ToWord16
val castFromWord16: word16 -> word16 = castFromWord16ToWord16
val castFromWord32: word32 -> word16 = castFromWord32ToWord16
val castFromWord64: word64 -> word16 = castFromWord64ToWord16
val castToInt8: word16 -> int8 = castFromWord16ToInt8
val castToInt16: word16 -> int16 = castFromWord16ToInt16
val castToInt32: word16 -> int32 = castFromWord16ToInt32
val castToInt64: word16 -> int64 = castFromWord16ToInt64
val castToWord8: word16 -> word8 = castFromWord16ToWord8
val castToWord16: word16 -> word16 = castFromWord16ToWord16
val castToWord32: word16 -> word32 = castFromWord16ToWord32
val castToWord64: word16 -> word64 = castFromWord16ToWord64
val zchckFromInt8: int8 -> word16 = zchckFromInt8ToWord16
val zchckFromInt16: int16 -> word16 = zchckFromInt16ToWord16
val zchckFromInt32: int32 -> word16 = zchckFromInt32ToWord16
val zchckFromInt64: int64 -> word16 = zchckFromInt64ToWord16
val zchckFromWord8: word8 -> word16 = zchckFromWord8ToWord16
val zchckFromWord16: word16 -> word16 = zchckFromWord16ToWord16
val zchckFromWord32: word32 -> word16 = zchckFromWord32ToWord16
val zchckFromWord64: word64 -> word16 = zchckFromWord64ToWord16
val zchckToInt8: word16 -> int8 = zchckFromWord16ToInt8
val zchckToInt16: word16 -> int16 = zchckFromWord16ToInt16
val zchckToInt32: word16 -> int32 = zchckFromWord16ToInt32
val zchckToInt64: word16 -> int64 = zchckFromWord16ToInt64
val zchckToWord8: word16 -> word8 = zchckFromWord16ToWord8
val zchckToWord16: word16 -> word16 = zchckFromWord16ToWord16
val zchckToWord32: word16 -> word32 = zchckFromWord16ToWord32
val zchckToWord64: word16 -> word64 = zchckFromWord16ToWord64
val schckFromInt8: int8 -> word16 = schckFromInt8ToWord16
val schckFromInt16: int16 -> word16 = schckFromInt16ToWord16
val schckFromInt32: int32 -> word16 = schckFromInt32ToWord16
val schckFromInt64: int64 -> word16 = schckFromInt64ToWord16
val schckFromWord8: word8 -> word16 = schckFromWord8ToWord16
val schckFromWord16: word16 -> word16 = schckFromWord16ToWord16
val schckFromWord32: word32 -> word16 = schckFromWord32ToWord16
val schckFromWord64: word64 -> word16 = schckFromWord64ToWord16
val schckToInt8: word16 -> int8 = schckFromWord16ToInt8
val schckToInt16: word16 -> int16 = schckFromWord16ToInt16
val schckToInt32: word16 -> int32 = schckFromWord16ToInt32
val schckToInt64: word16 -> int64 = schckFromWord16ToInt64
val schckToWord8: word16 -> word8 = schckFromWord16ToWord8
val schckToWord16: word16 -> word16 = schckFromWord16ToWord16
val schckToWord32: word16 -> word32 = schckFromWord16ToWord32
val schckToWord64: word16 -> word64 = schckFromWord16ToWord64
val zextdFromInt8: int8 -> word32 = zextdFromInt8ToWord32
val zextdFromInt16: int16 -> word32 = zextdFromInt16ToWord32
val zextdFromInt32: int32 -> word32 = zextdFromInt32ToWord32
val zextdFromInt64: int64 -> word32 = zextdFromInt64ToWord32
val zextdFromWord8: word8 -> word32 = zextdFromWord8ToWord32
val zextdFromWord16: word16 -> word32 = zextdFromWord16ToWord32
val zextdFromWord32: word32 -> word32 = zextdFromWord32ToWord32
val zextdFromWord64: word64 -> word32 = zextdFromWord64ToWord32
val zextdToInt8: word32 -> int8 = zextdFromWord32ToInt8
val zextdToInt16: word32 -> int16 = zextdFromWord32ToInt16
val zextdToInt32: word32 -> int32 = zextdFromWord32ToInt32
val zextdToInt64: word32 -> int64 = zextdFromWord32ToInt64
val zextdToWord8: word32 -> word8 = zextdFromWord32ToWord8
val zextdToWord16: word32 -> word16 = zextdFromWord32ToWord16
val zextdToWord32: word32 -> word32 = zextdFromWord32ToWord32
val zextdToWord64: word32 -> word64 = zextdFromWord32ToWord64
val sextdFromInt8: int8 -> word32 = sextdFromInt8ToWord32
val sextdFromInt16: int16 -> word32 = sextdFromInt16ToWord32
val sextdFromInt32: int32 -> word32 = sextdFromInt32ToWord32
val sextdFromInt64: int64 -> word32 = sextdFromInt64ToWord32
val sextdFromWord8: word8 -> word32 = sextdFromWord8ToWord32
val sextdFromWord16: word16 -> word32 = sextdFromWord16ToWord32
val sextdFromWord32: word32 -> word32 = sextdFromWord32ToWord32
val sextdFromWord64: word64 -> word32 = sextdFromWord64ToWord32
val sextdToInt8: word32 -> int8 = sextdFromWord32ToInt8
val sextdToInt16: word32 -> int16 = sextdFromWord32ToInt16
val sextdToInt32: word32 -> int32 = sextdFromWord32ToInt32
val sextdToInt64: word32 -> int64 = sextdFromWord32ToInt64
val sextdToWord8: word32 -> word8 = sextdFromWord32ToWord8
val sextdToWord16: word32 -> word16 = sextdFromWord32ToWord16
val sextdToWord32: word32 -> word32 = sextdFromWord32ToWord32
val sextdToWord64: word32 -> word64 = sextdFromWord32ToWord64
val castFromInt8: int8 -> word32 = castFromInt8ToWord32
val castFromInt16: int16 -> word32 = castFromInt16ToWord32
val castFromInt32: int32 -> word32 = castFromInt32ToWord32
val castFromInt64: int64 -> word32 = castFromInt64ToWord32
val castFromWord8: word8 -> word32 = castFromWord8ToWord32
val castFromWord16: word16 -> word32 = castFromWord16ToWord32
val castFromWord32: word32 -> word32 = castFromWord32ToWord32
val castFromWord64: word64 -> word32 = castFromWord64ToWord32
val castToInt8: word32 -> int8 = castFromWord32ToInt8
val castToInt16: word32 -> int16 = castFromWord32ToInt16
val castToInt32: word32 -> int32 = castFromWord32ToInt32
val castToInt64: word32 -> int64 = castFromWord32ToInt64
val castToWord8: word32 -> word8 = castFromWord32ToWord8
val castToWord16: word32 -> word16 = castFromWord32ToWord16
val castToWord32: word32 -> word32 = castFromWord32ToWord32
val castToWord64: word32 -> word64 = castFromWord32ToWord64
val zchckFromInt8: int8 -> word32 = zchckFromInt8ToWord32
val zchckFromInt16: int16 -> word32 = zchckFromInt16ToWord32
val zchckFromInt32: int32 -> word32 = zchckFromInt32ToWord32
val zchckFromInt64: int64 -> word32 = zchckFromInt64ToWord32
val zchckFromWord8: word8 -> word32 = zchckFromWord8ToWord32
val zchckFromWord16: word16 -> word32 = zchckFromWord16ToWord32
val zchckFromWord32: word32 -> word32 = zchckFromWord32ToWord32
val zchckFromWord64: word64 -> word32 = zchckFromWord64ToWord32
val zchckToInt8: word32 -> int8 = zchckFromWord32ToInt8
val zchckToInt16: word32 -> int16 = zchckFromWord32ToInt16
val zchckToInt32: word32 -> int32 = zchckFromWord32ToInt32
val zchckToInt64: word32 -> int64 = zchckFromWord32ToInt64
val zchckToWord8: word32 -> word8 = zchckFromWord32ToWord8
val zchckToWord16: word32 -> word16 = zchckFromWord32ToWord16
val zchckToWord32: word32 -> word32 = zchckFromWord32ToWord32
val zchckToWord64: word32 -> word64 = zchckFromWord32ToWord64
val schckFromInt8: int8 -> word32 = schckFromInt8ToWord32
val schckFromInt16: int16 -> word32 = schckFromInt16ToWord32
val schckFromInt32: int32 -> word32 = schckFromInt32ToWord32
val schckFromInt64: int64 -> word32 = schckFromInt64ToWord32
val schckFromWord8: word8 -> word32 = schckFromWord8ToWord32
val schckFromWord16: word16 -> word32 = schckFromWord16ToWord32
val schckFromWord32: word32 -> word32 = schckFromWord32ToWord32
val schckFromWord64: word64 -> word32 = schckFromWord64ToWord32
val schckToInt8: word32 -> int8 = schckFromWord32ToInt8
val schckToInt16: word32 -> int16 = schckFromWord32ToInt16
val schckToInt32: word32 -> int32 = schckFromWord32ToInt32
val schckToInt64: word32 -> int64 = schckFromWord32ToInt64
val schckToWord8: word32 -> word8 = schckFromWord32ToWord8
val schckToWord16: word32 -> word16 = schckFromWord32ToWord16
val schckToWord32: word32 -> word32 = schckFromWord32ToWord32
val schckToWord64: word32 -> word64 = schckFromWord32ToWord64
val zextdFromInt8: int8 -> word64 = zextdFromInt8ToWord64
val zextdFromInt16: int16 -> word64 = zextdFromInt16ToWord64
val zextdFromInt32: int32 -> word64 = zextdFromInt32ToWord64
val zextdFromInt64: int64 -> word64 = zextdFromInt64ToWord64
val zextdFromWord8: word8 -> word64 = zextdFromWord8ToWord64
val zextdFromWord16: word16 -> word64 = zextdFromWord16ToWord64
val zextdFromWord32: word32 -> word64 = zextdFromWord32ToWord64
val zextdFromWord64: word64 -> word64 = zextdFromWord64ToWord64
val zextdToInt8: word64 -> int8 = zextdFromWord64ToInt8
val zextdToInt16: word64 -> int16 = zextdFromWord64ToInt16
val zextdToInt32: word64 -> int32 = zextdFromWord64ToInt32
val zextdToInt64: word64 -> int64 = zextdFromWord64ToInt64
val zextdToWord8: word64 -> word8 = zextdFromWord64ToWord8
val zextdToWord16: word64 -> word16 = zextdFromWord64ToWord16
val zextdToWord32: word64 -> word32 = zextdFromWord64ToWord32
val zextdToWord64: word64 -> word64 = zextdFromWord64ToWord64
val sextdFromInt8: int8 -> word64 = sextdFromInt8ToWord64
val sextdFromInt16: int16 -> word64 = sextdFromInt16ToWord64
val sextdFromInt32: int32 -> word64 = sextdFromInt32ToWord64
val sextdFromInt64: int64 -> word64 = sextdFromInt64ToWord64
val sextdFromWord8: word8 -> word64 = sextdFromWord8ToWord64
val sextdFromWord16: word16 -> word64 = sextdFromWord16ToWord64
val sextdFromWord32: word32 -> word64 = sextdFromWord32ToWord64
val sextdFromWord64: word64 -> word64 = sextdFromWord64ToWord64
val sextdToInt8: word64 -> int8 = sextdFromWord64ToInt8
val sextdToInt16: word64 -> int16 = sextdFromWord64ToInt16
val sextdToInt32: word64 -> int32 = sextdFromWord64ToInt32
val sextdToInt64: word64 -> int64 = sextdFromWord64ToInt64
val sextdToWord8: word64 -> word8 = sextdFromWord64ToWord8
val sextdToWord16: word64 -> word16 = sextdFromWord64ToWord16
val sextdToWord32: word64 -> word32 = sextdFromWord64ToWord32
val sextdToWord64: word64 -> word64 = sextdFromWord64ToWord64
val castFromInt8: int8 -> word64 = castFromInt8ToWord64
val castFromInt16: int16 -> word64 = castFromInt16ToWord64
val castFromInt32: int32 -> word64 = castFromInt32ToWord64
val castFromInt64: int64 -> word64 = castFromInt64ToWord64
val castFromWord8: word8 -> word64 = castFromWord8ToWord64
val castFromWord16: word16 -> word64 = castFromWord16ToWord64
val castFromWord32: word32 -> word64 = castFromWord32ToWord64
val castFromWord64: word64 -> word64 = castFromWord64ToWord64
val castToInt8: word64 -> int8 = castFromWord64ToInt8
val castToInt16: word64 -> int16 = castFromWord64ToInt16
val castToInt32: word64 -> int32 = castFromWord64ToInt32
val castToInt64: word64 -> int64 = castFromWord64ToInt64
val castToWord8: word64 -> word8 = castFromWord64ToWord8
val castToWord16: word64 -> word16 = castFromWord64ToWord16
val castToWord32: word64 -> word32 = castFromWord64ToWord32
val castToWord64: word64 -> word64 = castFromWord64ToWord64
val zchckFromInt8: int8 -> word64 = zchckFromInt8ToWord64
val zchckFromInt16: int16 -> word64 = zchckFromInt16ToWord64
val zchckFromInt32: int32 -> word64 = zchckFromInt32ToWord64
val zchckFromInt64: int64 -> word64 = zchckFromInt64ToWord64
val zchckFromWord8: word8 -> word64 = zchckFromWord8ToWord64
val zchckFromWord16: word16 -> word64 = zchckFromWord16ToWord64
val zchckFromWord32: word32 -> word64 = zchckFromWord32ToWord64
val zchckFromWord64: word64 -> word64 = zchckFromWord64ToWord64
val zchckToInt8: word64 -> int8 = zchckFromWord64ToInt8
val zchckToInt16: word64 -> int16 = zchckFromWord64ToInt16
val zchckToInt32: word64 -> int32 = zchckFromWord64ToInt32
val zchckToInt64: word64 -> int64 = zchckFromWord64ToInt64
val zchckToWord8: word64 -> word8 = zchckFromWord64ToWord8
val zchckToWord16: word64 -> word16 = zchckFromWord64ToWord16
val zchckToWord32: word64 -> word32 = zchckFromWord64ToWord32
val zchckToWord64: word64 -> word64 = zchckFromWord64ToWord64
val schckFromInt8: int8 -> word64 = schckFromInt8ToWord64
val schckFromInt16: int16 -> word64 = schckFromInt16ToWord64
val schckFromInt32: int32 -> word64 = schckFromInt32ToWord64
val schckFromInt64: int64 -> word64 = schckFromInt64ToWord64
val schckFromWord8: word8 -> word64 = schckFromWord8ToWord64
val schckFromWord16: word16 -> word64 = schckFromWord16ToWord64
val schckFromWord32: word32 -> word64 = schckFromWord32ToWord64
val schckFromWord64: word64 -> word64 = schckFromWord64ToWord64
val schckToInt8: word64 -> int8 = schckFromWord64ToInt8
val schckToInt16: word64 -> int16 = schckFromWord64ToInt16
val schckToInt32: word64 -> int32 = schckFromWord64ToInt32
val schckToInt64: word64 -> int64 = schckFromWord64ToInt64
val schckToWord8: word64 -> word8 = schckFromWord64ToWord8
val schckToWord16: word64 -> word16 = schckFromWord64ToWord16
val schckToWord32: word64 -> word32 = schckFromWord64ToWord32
val schckToWord64: word64 -> word64 = schckFromWord64ToWord64
val idFromIntToWord: int8 -> word8 = idFromInt8ToWord8
val idFromWordToInt: word8 -> int8 = idFromWord8ToInt8
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word8 = (zextdFromWord32 0x0)
val maxWord': word8 = (notb zero)
val zero: int8 = (zextdFromInt32 0x0)
val one: int8 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word8 -> word8) -> int8 -> int8 = 
      (fn x_879: word8 -> word8 =>
       case x_879 of
	 (f: word8 -> word8) =>
	 (fn x_880: int8 =>
	  case x_880 of
	    x: int8 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word8 * word32 -> word8) -> int8 * word32 -> int8 = 
      (fn x_881: word8 * word32 -> word8 =>
       case x_881 of
	 (f: word8 * word32 -> word8) =>
	 (fn x_882: int8 * word32 =>
	  case x_882 of
	    (x: int8, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int8 * word32 -> int8 = (makeShop <<?)
val notb: int8 -> int8 = (makeUnop notb)
val >>?: int8 * word32 -> int8 = (makeShop >>?)
val minInt': int8 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int8 = (>>? ((notb zero), 0x1))
val idFromIntToWord: int16 -> word16 = idFromInt16ToWord16
val idFromWordToInt: word16 -> int16 = idFromWord16ToInt16
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word16 = (zextdFromWord32 0x0)
val maxWord': word16 = (notb zero)
val zero: int16 = (zextdFromInt32 0x0)
val one: int16 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word16 -> word16) -> int16 -> int16 = 
      (fn x_883: word16 -> word16 =>
       case x_883 of
	 (f: word16 -> word16) =>
	 (fn x_884: int16 =>
	  case x_884 of
	    x: int16 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word16 * word32 -> word16) -> int16 * word32 -> int16 = 
      (fn x_885: word16 * word32 -> word16 =>
       case x_885 of
	 (f: word16 * word32 -> word16) =>
	 (fn x_886: int16 * word32 =>
	  case x_886 of
	    (x: int16, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int16 * word32 -> int16 = (makeShop <<?)
val notb: int16 -> int16 = (makeUnop notb)
val >>?: int16 * word32 -> int16 = (makeShop >>?)
val minInt': int16 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int16 = (>>? ((notb zero), 0x1))
val idFromIntToWord: int32 -> word32 = idFromInt32ToWord32
val idFromWordToInt: word32 -> int32 = idFromWord32ToInt32
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word32 = (zextdFromWord32 0x0)
val one: word32 = (zextdFromWord32 0x1)
val maxWord': word32 = (notb zero)
val rec
   log2Word: word32 -> word32 = 
      (fn x_887: word32 =>
       case x_887 of
	 (w: word32) =>
	 let val rec
		loop: word32 * word32 * word32 -> word32 = 
		   (fn x_888: word32 * word32 * word32 =>
		    case x_888 of
		      ((n: word32, s: word32, acc: word32)) =>
		      case (= (word32) (n, one)) of
			true => acc
		      | false =>
			let val (n: word32, acc: word32) =
			       case (>= (n, (<<? (one, s)))) of
				 true => ((>>? (n, s)), (+ (acc, s)))
			       | false => (n, acc)
			in
			   (loop (n, (>>? (s, 0x1)), acc))
			end)
	 in
	    case case safe of
		   true => (= (word32) (w, zero)) | false => false of
	      true => raise Domain
	    | false => (loop (w, (>>? (sizeInBitsWord, 0x1)), 0x0))
	 end)
val rec
   log2: word32 -> int32 = 
      (fn x_889: word32 =>
       case x_889 of
	 (w: word32) => (zextdFromWord32ToInt32 (log2Word w)))
val zero: int32 = (zextdFromInt32 0x0)
val one: int32 = (zextdFromInt32 0x1)
val rec
   makeBinop: (word32 * word32 -> word32) -> int32 * int32 -> int32 = 
      (fn x_890: word32 * word32 -> word32 =>
       case x_890 of
	 (f: word32 * word32 -> word32) =>
	 (fn x_891: int32 * int32 =>
	  case x_891 of
	    (x: int32, y: int32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), (idFromIntToWord y))))))
val rec
   makeUnop: (word32 -> word32) -> int32 -> int32 = 
      (fn x_892: word32 -> word32 =>
       case x_892 of
	 (f: word32 -> word32) =>
	 (fn x_893: int32 =>
	  case x_893 of
	    x: int32 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word32 * word32 -> word32) -> int32 * word32 -> int32 = 
      (fn x_894: word32 * word32 -> word32 =>
       case x_894 of
	 (f: word32 * word32 -> word32) =>
	 (fn x_895: int32 * word32 =>
	  case x_895 of
	    (x: int32, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int32 * word32 -> int32 = (makeShop <<?)
val notb: int32 -> int32 = (makeUnop notb)
val orb: int32 * int32 -> int32 = (makeBinop orb)
val >>?: int32 * word32 -> int32 = (makeShop >>?)
val rec
   log2: int32 -> int32 = 
      (fn x_896: int32 =>
       case x_896 of
	 (i: int32) => (log2 (idFromIntToWord i)))
val minInt': int32 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int32 = (>>? ((notb zero), 0x1))
val rec
   quot: int32 * int32 -> int32 = 
      (fn x_897: int32 * int32 =>
       case x_897 of
	 ((x: int32, y: int32)) =>
	 case case safe of
		true => (= (int32) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case case case detectOverflow of
			    true => true | false => safe of
		       true => (= (int32) (x, minInt')) | false => false of
		  true => (= (int32) (y, (~ one))) | false => false of
	     true =>
	     case detectOverflow of
	       true => raise Overflow | false => minInt'
	   | false => (quotUnsafe (x, y)))
val rec
   rem: int32 * int32 -> int32 = 
      (fn x_898: int32 * int32 =>
       case x_898 of
	 ((x: int32, y: int32)) =>
	 case case safe of
		true => (= (int32) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case (= (int32) (x, minInt')) of
		  true => (= (int32) (y, (~ one))) | false => false of
	     true => zero | false => (remUnsafe (x, y)))
val rec
   mod: int32 * int32 -> int32 = 
      (fn x_899: int32 * int32 =>
       case x_899 of
	 ((x: int32, y: int32)) =>
	 case (>= (x, zero)) of
	   true =>
	   case (> (y, zero)) of
	     true => (remUnsafe (x, y))
	   | false =>
	     case (< (y, zero)) of
	       true =>
	       case (= (int32) (x, zero)) of
		 true => zero
	       | false => (+? ((remUnsafe ((-? (x, one)), y)), (+ (y, one))))
	     | false => raise Div
	 | false =>
	   case (< (y, zero)) of
	     true =>
	     case case (= (int32) (x, minInt')) of
		    true => (= (int32) (y, (~ one))) | false => false of
	       true => zero | false => (remUnsafe (x, y))
	   | false =>
	     case (> (y, zero)) of
	       true => (+? ((remUnsafe ((+? (x, one)), y)), (-? (y, one))))
	     | false => raise Div)
val idFromIntToWord: int32 -> word32 = idFromIntToWord
val <: word32 * word32 -> bool = <
val rec
   ltu: int32 * int32 -> bool = 
      (fn x_900: int32 * int32 =>
       case x_900 of
	 ((i: int32, i': int32)) =>
	 (< ((idFromIntToWord i), (idFromIntToWord i'))))
val <: int32 * int32 -> bool = ltu
val <: int32 * int32 -> bool = <
val rec
   >: int32 * int32 -> bool = 
      (fn x_901: int32 * int32 =>
       case x_901 of
	 ((a: int32, b: int32)) => (< (b, a)))
val gtu: int32 * int32 -> bool = >
val idFromIntToWord: int64 -> word64 = idFromInt64ToWord64
val idFromWordToInt: word64 -> int64 = idFromWord64ToInt64
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word64 = (zextdFromWord32 0x0)
val one: word64 = (zextdFromWord32 0x1)
val maxWord': word64 = (notb zero)
val zero: int64 = (zextdFromInt32 0x0)
val one: int64 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word64 -> word64) -> int64 -> int64 = 
      (fn x_902: word64 -> word64 =>
       case x_902 of
	 (f: word64 -> word64) =>
	 (fn x_903: int64 =>
	  case x_903 of
	    x: int64 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word64 * word32 -> word64) -> int64 * word32 -> int64 = 
      (fn x_904: word64 * word32 -> word64 =>
       case x_904 of
	 (f: word64 * word32 -> word64) =>
	 (fn x_905: int64 * word32 =>
	  case x_905 of
	    (x: int64, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int64 * word32 -> int64 = (makeShop <<?)
val notb: int64 -> int64 = (makeUnop notb)
val ~>>?: int64 * word32 -> int64 = (makeShop ~>>?)
val >>?: int64 * word32 -> int64 = (makeShop >>?)
val minInt': int64 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int64 = (>>? ((notb zero), 0x1))
val rec
   quot: int64 * int64 -> int64 = 
      (fn x_906: int64 * int64 =>
       case x_906 of
	 ((x: int64, y: int64)) =>
	 case case safe of
		true => (= (int64) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case case case detectOverflow of
			    true => true | false => safe of
		       true => (= (int64) (x, minInt')) | false => false of
		  true => (= (int64) (y, (~ one))) | false => false of
	     true =>
	     case detectOverflow of
	       true => raise Overflow | false => minInt'
	   | false => (quotUnsafe (x, y)))
val rec
   rem: int64 * int64 -> int64 = 
      (fn x_907: int64 * int64 =>
       case x_907 of
	 ((x: int64, y: int64)) =>
	 case case safe of
		true => (= (int64) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case (= (int64) (x, minInt')) of
		  true => (= (int64) (y, (~ one))) | false => false of
	     true => zero | false => (remUnsafe (x, y)))
val idFromIntToWord: int64 -> word64 = idFromIntToWord
val <: word64 * word64 -> bool = <
val rec
   ltu: int64 * int64 -> bool = 
      (fn x_908: int64 * int64 =>
       case x_908 of
	 ((i: int64, i': int64)) =>
	 (< ((idFromIntToWord i), (idFromIntToWord i'))))
val <: int64 * int64 -> bool = ltu
val <: int64 * int64 -> bool = <
val rec
   <=: int64 * int64 -> bool = 
      (fn x_909: int64 * int64 =>
       case x_909 of
	 ((a: int64, b: int64)) => (not (< (b, a))))
val rec
   >: int64 * int64 -> bool = 
      (fn x_910: int64 * int64 =>
       case x_910 of
	 ((a: int64, b: int64)) => (< (b, a)))
val rec
   >=: int64 * int64 -> bool = 
      (fn x_911: int64 * int64 =>
       case x_911 of
	 ((a: int64, b: int64)) => (<= (b, a)))
val gtu: int64 * int64 -> bool = >
val geu: int64 * int64 -> bool = >=
val 'a_471 fromArray: 'a_471 array -> 'a_471 vector = fromArrayUnsafe ('a_471)
val isMutable: bool = false
val 'a_472 length: 'a_472 vector -> int64 = length ('a_472)
val 'a_473 subUnsafe: 'a_473 vector * int64 -> 'a_473 = subUnsafe ('a_473)
val 'a subUnsafe_0: 'a vector * int64 -> 'a = subUnsafe ('a)
val 'a length_0: 'a vector -> int64 = length ('a)
val 'a fromArray_0: 'a array -> 'a vector = fromArray ('a)
val +?: int64 * int64 -> int64 = +?
val -?: int64 * int64 -> int64 = -?
val <: int64 * int64 -> bool = <
val >: int64 * int64 -> bool = >
val >=: int64 * int64 -> bool = >=
val gtu: int64 * int64 -> bool = gtu
val geu: int64 * int64 -> bool = geu
val rec ('a_482, 'a_481, 'a_480)
   o: ('a_482 -> 'a_481) * ('a_480 -> 'a_482) -> 'a_480 -> 'a_481 = 
      (fn x_912: ('a_482 -> 'a_481) * ('a_480 -> 'a_482) =>
       (fn x_913: 'a_480 =>
	case (x_912, x_913) of
	  ((f: 'a_482 -> 'a_481, g: 'a_480 -> 'a_482), x: 'a_480) => (f (g x))))
val rec
   valOf: int32 Primitive.Option.t -> int32 = 
      (fn x_914: int32 Primitive.Option.t =>
       case x_914 of
	 (x: int32 Primitive.Option.t) =>
	 case x of
	   SOME[int32] y: int32 => y | NONE[int32] => 0x0)
val rec 'a_483
   doit: int32 * ('a_483 -> int64) * 'a_483 -> int64 = 
      (fn x_915: int32 * ('a_483 -> int64) * 'a_483 =>
       case x_915 of
	 ((precision: int32, fromInt: 'a_483 -> int64, maxInt': 'a_483)) =>
	 case (>= ((valOf precision), precision)) of
	   true => (fromInt maxInt') | false => maxInt')
val fInt8: int64 = (doit (int8) ((valOf precision), schckFromInt8, maxInt'))
val fInt16: int64 = (doit (int16) ((valOf precision), schckFromInt16, maxInt'))
val fInt32: int64 = (doit (int32) ((valOf precision), schckFromInt32, maxInt'))
val fInt64: int64 = (doit (int64) ((valOf precision), schckFromInt64, maxInt'))
val fIntInf: int64 = maxInt'
val _ = fInt8
val _ = fInt16
val f: int64 = fInt32
val _ = fInt64
val _ = fIntInf
val maxLen: int64 = f
val rec 'a_487
   arrayUninit: int64 -> 'a_487 array = 
      (fn x_916: int64 =>
       case x_916 of
	 (n: int64) =>
	 case case (not isMutable) of
		true => (= (int64) (n, 0x0)) | false => false of
	   true => (array0Const ('a_487) ())
	 | false =>
	   case case safe of
		  true => (gtu (n, maxLen)) | false => false of
	     true => raise Size | false => (arrayUnsafe ('a_487) n))
exception GenerateAlreadyGotVector
exception GenerateVectorNotFull
val rec ('a_491, 'a_490)
   unfoldi: int64 * 'a_491 * (int64 * 'a_491 -> 'a_490 * 'a_491)
	    -> 'a_490 vector * 'a_491 = 
      (fn x_917: int64 * 'a_491 * (int64 * 'a_491 -> 'a_490 * 'a_491) =>
       case x_917 of
	 ((n: int64, b: 'a_491, f: int64 * 'a_491 -> 'a_490 * 'a_491)) =>
	 let val a: 'a_490 array = (arrayUninit ('a_490) n)
	     val rec
		loop: int64 * 'a_491 -> 'a_491 = 
		   (fn x_918: int64 * 'a_491 =>
		    case x_918 of
		      ((i: int64, b: 'a_491)) =>
		      case (>= (i, n)) of
			true => b
		      | false =>
			let val (x: 'a_490, b: 'a_491) = (f (i, b))
			    val () = (updateUnsafe ('a_490) (a, i, x))
			in
			   (loop ((+? (i, 0x1)), b))
			end)
	     val b: 'a_491 = (loop (0x0, b))
	 in
	    ((fromArray_0 ('a_490) a), b)
	 end)
val rec ('a_493, 'a_492)
   unfold: int64 * 'a_492 * ('a_492 -> 'a_493 * 'a_492)
	   -> 'a_493 vector * 'a_492 = 
      (fn x_919: int64 * 'a_492 * ('a_492 -> 'a_493 * 'a_492) =>
       case x_919 of
	 ((n: int64, b: 'a_492, f: 'a_492 -> 'a_493 * 'a_492)) =>
	 (unfoldi ('a_492, 'a_493) (n,
				    b,
				    (o ('a_492, 'a_493 * 'a_492, int64 * 'a_492) (f,
										  (fn x_920: int64
											     * 'a_492 =>
										   case x_920 of
										     {2 = #: 'a_492} =>
										     #))))))
val rec 'a_494
   tabulate: int64 * (int64 -> 'a_494) -> 'a_494 vector = 
      (fn x_921: int64 * (int64 -> 'a_494) =>
       case x_921 of
	 ((n: int64, f: int64 -> 'a_494)) =>
	 ((fn x_922: 'a_494 vector * unit =>
	   case x_922 of
	     {1 = #: 'a_494 vector} => #) (unfoldi (unit, 'a_494) (n,
						      (),
						      (fn x_923: int64 * unit =>
						       case x_923 of
							 (i: int64, ()) =>
							 ((f i), ()))))))
datatype 'a PrimSequence.Slice.t = T of {len: int64,
					 seq: 'a vector,
					 start: int64}
val rec 'a_496
   length: 'a_496 PrimSequence.Slice.t -> int64 = 
      (fn x_924: 'a_496 PrimSequence.Slice.t =>
       case x_924 of
	 (T['a_496] {len = len: int64}) => len)
val rec 'a_497
   unsafeSub: 'a_497 PrimSequence.Slice.t * int64 -> 'a_497 = 
      (fn x_925: 'a_497 PrimSequence.Slice.t * int64 =>
       case x_925 of
	 ((T['a_497] {seq = seq: 'a_497 vector, start = start: int64}, i: int64)) =>
	 (subUnsafe_0 ('a_497) (seq, (+? (start, i)))))
val rec 'a_498
   sub: 'a_498 PrimSequence.Slice.t * int64 -> 'a_498 = 
      (fn x_926: 'a_498 PrimSequence.Slice.t * int64 =>
       case x_926 of
	 ((sl: 'a_498 PrimSequence.Slice.t as T['a_498] {len = len: int64},
	   i: int64)) =>
	 case case safe of
		true => (geu (i, len)) | false => false of
	   true => raise Subscript | false => (unsafeSub ('a_498) (sl, i)))
val rec 'a
   full: 'a vector -> 'a PrimSequence.Slice.t = 
      (fn x_927: 'a vector =>
       case x_927 of
	 (seq: 'a vector) =>
	 (T['a] {seq = seq, start = 0x0, len = (length_0 ('a) seq)}))
val rec 'a_505
   unsafeSubslice: 'a_505 PrimSequence.Slice.t
		   * int64
		   * int64 Primitive.Option.t
		   -> 'a_505 PrimSequence.Slice.t = 
      (fn x_928: 'a_505 PrimSequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_928 of
	 ((T['a_505] {seq = seq: 'a_505 vector,
		      start = start: int64,
		      len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 (T['a_505] {seq = seq,
		     start = (+? (start, start')),
		     len = case len' of
			     NONE[int64] => (-? (len, start'))
			   | SOME[int64] len': int64 => len'}))
val rec 'a_506
   unsafeSlice: 'a_506 vector * int64 * int64 Primitive.Option.t
		-> 'a_506 PrimSequence.Slice.t = 
      (fn x_929: 'a_506 vector * int64 * int64 Primitive.Option.t =>
       case x_929 of
	 ((seq: 'a_506 vector, start: int64, len: int64 Primitive.Option.t)) =>
	 (unsafeSubslice ('a_506) ((full ('a_506) seq), start, len)))
val rec 'a_507
   subslice: 'a_507 PrimSequence.Slice.t * int64 * int64 Primitive.Option.t
	     -> 'a_507 PrimSequence.Slice.t = 
      (fn x_930: 'a_507 PrimSequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_930 of
	 ((T['a_507] {seq = seq: 'a_507 vector,
		      start = start: int64,
		      len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 case len' of
	   NONE[int64] =>
	   case case safe of
		  true => (gtu (start', len)) | false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_507] {seq = seq,
			 start = (+? (start, start')),
			 len = (-? (len, start'))})
	 | SOME[int64] len': int64 =>
	   case case safe of
		  true =>
		  case (gtu (start', len)) of
		    true => true | false => (gtu (len', (-? (len, start'))))
		| false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_507] {seq = seq, start = (+? (start, start')), len = len'}))
val rec 'a_508
   base: 'a_508 PrimSequence.Slice.t -> 'a_508 vector * int64 * int64 = 
      (fn x_931: 'a_508 PrimSequence.Slice.t =>
       case x_931 of
	 (T['a_508] {seq = seq: 'a_508 vector,
		     start = start: int64,
		     len = len: int64}) =>
	 (seq, start, len))
val rec ('a_512, 'a_511)
   foldli: (int64 * 'a_512 * 'a_511 -> 'a_511)
	   -> 'a_511 -> 'a_512 PrimSequence.Slice.t -> 'a_511 = 
      (fn x_932: int64 * 'a_512 * 'a_511 -> 'a_511 =>
       (fn x_933: 'a_511 =>
	(fn x_934: 'a_512 PrimSequence.Slice.t =>
	 case (x_932, x_933, x_934) of
	   (f: int64 * 'a_512 * 'a_511 -> 'a_511,
	    b: 'a_511,
	    T['a_512] {seq = seq: 'a_512 vector,
		       start = start: int64,
		       len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_511 -> 'a_511 = 
		     (fn x_935: int64 * 'a_511 =>
		      case x_935 of
			((i: int64, b: 'a_511)) =>
			case (> (i, max)) of
			  true => b
			| false =>
			  (loop ((+? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_0 ('a_512) (seq, i)),
				     b)))))
	   in
	      (loop (min, b))
	   end)))
val rec ('a_521, 'a_520, 'a_519, 'a_518, 'a_517, 'a_516, 'a_515)
   make: (('a_521 * 'a_520 * 'a_519 -> 'a_518) -> 'a_516 -> 'a_515 -> 'a_517)
	 -> ('a_520 * 'a_519 -> 'a_518) -> 'a_516 -> 'a_515 -> 'a_517 = 
      (fn x_936: ('a_521 * 'a_520 * 'a_519 -> 'a_518)
		 -> 'a_516 -> 'a_515 -> 'a_517 =>
       (fn x_937: 'a_520 * 'a_519 -> 'a_518 =>
	(fn x_938: 'a_516 =>
	 (fn x_939: 'a_515 =>
	  case (x_936, x_937, x_938, x_939) of
	    (foldi: ('a_521 * 'a_520 * 'a_519 -> 'a_518)
		    -> 'a_516 -> 'a_515 -> 'a_517,
	     f: 'a_520 * 'a_519 -> 'a_518,
	     b: 'a_516,
	     sl: 'a_515) =>
	    (((foldi (fn x_940: 'a_521 * 'a_520 * 'a_519 =>
		      case x_940 of
			(_, x: 'a_520, b: 'a_519) => (f (x, b)))) b) sl)))))
val rec ('a_523, 'a_522)
   foldl: ('a_523 * 'a_522 -> 'a_522)
	  -> 'a_522 -> 'a_523 PrimSequence.Slice.t -> 'a_522 = 
      (fn x_941: 'a_523 * 'a_522 -> 'a_522 =>
       case x_941 of
	 (f: 'a_523 * 'a_522 -> 'a_522) =>
	 ((make (int64,
		 'a_523,
		 'a_522,
		 'a_522,
		 'a_522,
		 'a_522,
		 'a_523 PrimSequence.Slice.t) foldli ('a_523, 'a_522)) f))
val rec ('a_529, 'a_528)
   mapi: (int64 * 'a_529 -> 'a_528)
	 -> 'a_529 PrimSequence.Slice.t -> 'a_528 vector = 
      (fn x_942: int64 * 'a_529 -> 'a_528 =>
       (fn x_943: 'a_529 PrimSequence.Slice.t =>
	case (x_942, x_943) of
	  (f: int64 * 'a_529 -> 'a_528,
	   T['a_529] {seq = seq: 'a_529 vector,
		      start = start: int64,
		      len = len: int64}) =>
	  (tabulate ('a_528) (len,
			      (fn x_944: int64 =>
			       case x_944 of
				 i: int64 =>
				 (f (i,
				     (subUnsafe_0 ('a_529) (seq, (+? (start, i)))))))))))
val rec ('a_531, 'a_530)
   map: ('a_530 -> 'a_531) -> 'a_530 PrimSequence.Slice.t -> 'a_531 vector = 
      (fn x_945: 'a_530 -> 'a_531 =>
       (fn x_946: 'a_530 PrimSequence.Slice.t =>
	case (x_945, x_946) of
	  (f: 'a_530 -> 'a_531, sl: 'a_530 PrimSequence.Slice.t) =>
	  ((mapi ('a_530, 'a_531) (o ('a_530, 'a_531, int64 * 'a_530) (f,
								       (fn x_947: int64
										  * 'a_530 =>
									case x_947 of
									  {2 = #: 'a_530} =>
									  #)))) sl)))
val rec 'a_532
   findi: (int64 * 'a_532 -> bool)
	  -> 'a_532 PrimSequence.Slice.t -> (int64 * 'a_532) Primitive.Option.t = 
      (fn x_948: int64 * 'a_532 -> bool =>
       (fn x_949: 'a_532 PrimSequence.Slice.t =>
	case (x_948, x_949) of
	  (p: int64 * 'a_532 -> bool,
	   T['a_532] {seq = seq: 'a_532 vector,
		      start = start: int64,
		      len = len: int64}) =>
	  let val min: int64 = start
	      val len: int64 = (-? (len, 0x1))
	      val max: int64 = (+? (start, len))
	      val rec
		 loop: int64 -> (int64 * 'a_532) Primitive.Option.t = 
		    (fn x_950: int64 =>
		     case x_950 of
		       (i: int64) =>
		       case (> (i, max)) of
			 true => NONE[int64 * 'a_532]
		       | false =>
			 let val z: int64 * 'a_532 =
				((-? (i, min)), (subUnsafe_0 ('a_532) (seq, i)))
			 in
			    case (p z) of
			      true => (SOME[int64 * 'a_532] z)
			    | false => (loop (+? (i, 0x1)))
			 end)
	  in
	     (loop min)
	  end))
val rec 'a_534
   existsi: (int64 * 'a_534 -> bool) -> 'a_534 PrimSequence.Slice.t -> bool = 
      (fn x_951: int64 * 'a_534 -> bool =>
       (fn x_952: 'a_534 PrimSequence.Slice.t =>
	case (x_951, x_952) of
	  (p: int64 * 'a_534 -> bool, sl: 'a_534 PrimSequence.Slice.t) =>
	  case ((findi ('a_534) p) sl) of
	    NONE[int64 * 'a_534] => false | SOME[int64 * 'a_534] _ => true))
val rec 'a_535
   exists: ('a_535 -> bool) -> 'a_535 PrimSequence.Slice.t -> bool = 
      (fn x_953: 'a_535 -> bool =>
       (fn x_954: 'a_535 PrimSequence.Slice.t =>
	case (x_953, x_954) of
	  (p: 'a_535 -> bool, sl: 'a_535 PrimSequence.Slice.t) =>
	  ((existsi ('a_535) (o ('a_535, bool, int64 * 'a_535) (p,
								(fn x_955: int64
									   * 'a_535 =>
								 case x_955 of
								   {2 = #: 'a_535} =>
								   #)))) sl)))
val rec 'a
   sequence: 'a PrimSequence.Slice.t -> 'a vector = 
      (fn x_956: 'a PrimSequence.Slice.t =>
       case x_956 of
	 (sl: 'a PrimSequence.Slice.t as T['a] {seq = seq: 'a vector,
						start = start: int64,
						len = len: int64}) =>
	 case case isMutable of
		true => true
	      | false =>
		case (<> (int64) (start, 0x0)) of
		  true => true
		| false => (<> (int64) (len, (length_0 ('a) seq))) of
	   true =>
	   ((map ('a, 'a) (fn x_957: 'a =>
			   case x_957 of
			     x: 'a => x)) sl)
	 | false => seq)
val rec 'a
   append: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t -> 'a vector = 
      (fn x_958: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t =>
       case x_958 of
	 ((sl1: 'a PrimSequence.Slice.t, sl2: 'a PrimSequence.Slice.t)) =>
	 case (= (int64) ((length ('a) sl1), 0x0)) of
	   true => (sequence ('a) sl2)
	 | false =>
	   case (= (int64) ((length ('a) sl2), 0x0)) of
	     true => (sequence ('a) sl1)
	   | false =>
	     let val l1: int64 = (length ('a) sl1)
		 val l2: int64 = (length ('a) sl2)
		 val n: int64 = (+? (l1, l2))
		 val rec
		    loop: int64 * 'a PrimSequence.Slice.t
			  -> 'a * (int64 * 'a PrimSequence.Slice.t) = 
		       (fn x_959: int64 * 'a PrimSequence.Slice.t =>
			case x_959 of
			  ((i: int64, sl: 'a PrimSequence.Slice.t)) =>
			  case (< (i, (length ('a) sl))) of
			    true =>
			    ((unsafeSub ('a) (sl, i)), ((+? (i, 0x1)), sl))
			  | false => ((unsafeSub ('a) (sl2, 0x0)), (0x1, sl2)))
	     in
		((fn x_960: 'a vector * (int64 * 'a PrimSequence.Slice.t) =>
		  case x_960 of
		    {1 = #: 'a vector} => #) (unfoldi (int64 * 'a PrimSequence.Slice.t, 'a) (n,
									 (0x0,
									  sl1),
									 (fn x_961: int64
										    * (int64
										       * 'a PrimSequence.Slice.t) =>
									  case x_961 of
									    (_,
									     ac: int64
										 * 'a PrimSequence.Slice.t) =>
									    (loop ac)))))
	     end)
val rec 'a_540
   split: 'a_540 PrimSequence.Slice.t * int64
	  -> 'a_540 PrimSequence.Slice.t * 'a_540 PrimSequence.Slice.t = 
      (fn x_962: 'a_540 PrimSequence.Slice.t * int64 =>
       case x_962 of
	 ((T['a_540] {seq = seq: 'a_540 vector,
		      start = start: int64,
		      len = len: int64},
	   i: int64)) =>
	 ((unsafeSlice ('a_540) (seq, start, (SOME[int64] (-? (i, start))))),
	  (unsafeSlice ('a_540) (seq,
				 i,
				 (SOME[int64] (-? (len, (-? (i, start)))))))))
val rec 'a_541
   splitl: ('a_541 -> bool)
	   -> 'a_541 PrimSequence.Slice.t
	      -> 'a_541 PrimSequence.Slice.t * 'a_541 PrimSequence.Slice.t = 
      (fn x_963: 'a_541 -> bool =>
       (fn x_964: 'a_541 PrimSequence.Slice.t =>
	case (x_963, x_964) of
	  (f: 'a_541 -> bool,
	   sl: 'a_541 PrimSequence.Slice.t as T['a_541] {seq = seq: 'a_541 vector,
							 start = start: int64,
							 len = len: int64}) =>
	  let val stop: int64 = (+? (start, len))
	      val rec
		 loop: int64 -> int64 = 
		    (fn x_965: int64 =>
		     case x_965 of
		       (i: int64) =>
		       case (>= (i, stop)) of
			 true => i
		       | false =>
			 case (f (subUnsafe_0 ('a_541) (seq, i))) of
			   true => (loop (+? (i, 0x1))) | false => i)
	  in
	     (split ('a_541) (sl, (loop start)))
	  end))
val rec 'a_542
   splitr: ('a_542 -> bool)
	   -> 'a_542 PrimSequence.Slice.t
	      -> 'a_542 PrimSequence.Slice.t * 'a_542 PrimSequence.Slice.t = 
      (fn x_966: 'a_542 -> bool =>
       (fn x_967: 'a_542 PrimSequence.Slice.t =>
	case (x_966, x_967) of
	  (f: 'a_542 -> bool,
	   sl: 'a_542 PrimSequence.Slice.t as T['a_542] {seq = seq: 'a_542 vector,
							 start = start: int64,
							 len = len: int64}) =>
	  let val rec
		 loop: int64 -> int64 = 
		    (fn x_968: int64 =>
		     case x_968 of
		       (i: int64) =>
		       case (< (i, start)) of
			 true => start
		       | false =>
			 case (f (subUnsafe_0 ('a_542) (seq, i))) of
			   true => (loop (-? (i, 0x1))) | false => (+? (i, 0x1)))
	  in
	     (split ('a_542) (sl, (loop (-? ((+? (start, len)), 0x1)))))
	  end))
val rec 'a_545
   dropr: ('a_545 -> bool)
	  -> 'a_545 PrimSequence.Slice.t -> 'a_545 PrimSequence.Slice.t = 
      (fn x_969: 'a_545 -> bool =>
       (fn x_970: 'a_545 PrimSequence.Slice.t =>
	case (x_969, x_970) of
	  (p: 'a_545 -> bool, s: 'a_545 PrimSequence.Slice.t) =>
	  ((fn x_971: 'a_545 PrimSequence.Slice.t * 'a_545 PrimSequence.Slice.t =>
	    case x_971 of
	      {1 = #: 'a_545 PrimSequence.Slice.t} => #) ((splitr ('a_545) p) s))))
val rec 'a_546
   takel: ('a_546 -> bool)
	  -> 'a_546 PrimSequence.Slice.t -> 'a_546 PrimSequence.Slice.t = 
      (fn x_972: 'a_546 -> bool =>
       (fn x_973: 'a_546 PrimSequence.Slice.t =>
	case (x_972, x_973) of
	  (p: 'a_546 -> bool, s: 'a_546 PrimSequence.Slice.t) =>
	  ((fn x_974: 'a_546 PrimSequence.Slice.t * 'a_546 PrimSequence.Slice.t =>
	    case x_974 of
	      {1 = #: 'a_546 PrimSequence.Slice.t} => #) ((splitl ('a_546) p) s))))
val rec 'a_547
   taker: ('a_547 -> bool)
	  -> 'a_547 PrimSequence.Slice.t -> 'a_547 PrimSequence.Slice.t = 
      (fn x_975: 'a_547 -> bool =>
       (fn x_976: 'a_547 PrimSequence.Slice.t =>
	case (x_975, x_976) of
	  (p: 'a_547 -> bool, s: 'a_547 PrimSequence.Slice.t) =>
	  ((fn x_977: 'a_547 PrimSequence.Slice.t * 'a_547 PrimSequence.Slice.t =>
	    case x_977 of
	      {2 = #: 'a_547 PrimSequence.Slice.t} => #) ((splitr ('a_547) p) s))))
val rec 'a_554
   unsafeSub: 'a_554 vector * int64 -> 'a_554 = 
      (fn x_978: 'a_554 vector * int64 =>
       case x_978 of
	 ((seq: 'a_554 vector, i: int64)) =>
	 (unsafeSub ('a_554) ((full ('a_554) seq), i)))
val 'a unsafeSub_0: 'a vector * int64 -> 'a = unsafeSub ('a)
val ('a, 'b) unfoldi_0: int64 * 'b * (int64 * 'b -> 'a * 'b) -> 'a vector * 'b =
   unfoldi ('b, 'a)
val ('a, 'b) unfold_0: int64 * 'b * ('b -> 'a * 'b) -> 'a vector * 'b =
   unfold ('a, 'b)
val 'a tabulate_0: int64 * (int64 -> 'a) -> 'a vector = tabulate ('a)
val 'a unsafeSubslice_0: 'a PrimSequence.Slice.t
			 * int64
			 * int64 Primitive.Option.t
			 -> 'a PrimSequence.Slice.t =
   unsafeSubslice ('a)
val 'a unsafeSub_1: 'a PrimSequence.Slice.t * int64 -> 'a = unsafeSub ('a)
val 'a taker_0: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   taker ('a)
val 'a takel_0: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   takel ('a)
val 'a subslice_0: 'a PrimSequence.Slice.t * int64 * int64 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t =
   subslice ('a)
val 'a sub_0: 'a PrimSequence.Slice.t * int64 -> 'a = sub ('a)
val 'a sequence_0: 'a PrimSequence.Slice.t -> 'a vector = sequence ('a)
val 'a length_1: 'a PrimSequence.Slice.t -> int64 = length ('a)
val 'a full_0: 'a vector -> 'a PrimSequence.Slice.t = full ('a)
val ('b, 'a) foldl_0: ('a * 'b -> 'b) -> 'b -> 'a PrimSequence.Slice.t -> 'b =
   foldl ('a, 'b)
val 'a exists_0: ('a -> bool) -> 'a PrimSequence.Slice.t -> bool = exists ('a)
val 'a dropr_0: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   dropr ('a)
val 'a base_0: 'a PrimSequence.Slice.t -> 'a vector * int64 * int64 = base ('a)
val 'a append_0: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t -> 'a vector =
   append ('a)
val 'a_597 fromArray: 'a_597 -> 'a_597 =
   (fn x_979: 'a_597 =>
    case x_979 of
      a: 'a_597 => a)
val isMutable: bool = true
val 'a_598 length: 'a_598 array -> int64 = length ('a_598)
val 'a_599 subUnsafe: 'a_599 array * int64 -> 'a_599 = subUnsafe ('a_599)
val 'a subUnsafe_1: 'a array * int64 -> 'a = subUnsafe ('a)
val 'a length_2: 'a array -> int64 = length ('a)
val 'a fromArray_1: 'a array -> 'a array = fromArray ('a array)
val +?: int64 * int64 -> int64 = +?
val -?: int64 * int64 -> int64 = -?
val <: int64 * int64 -> bool = <
val >: int64 * int64 -> bool = >
val >=: int64 * int64 -> bool = >=
val gtu: int64 * int64 -> bool = gtu
val geu: int64 * int64 -> bool = geu
val rec ('a_608, 'a_607, 'a_606)
   o: ('a_608 -> 'a_607) * ('a_606 -> 'a_608) -> 'a_606 -> 'a_607 = 
      (fn x_980: ('a_608 -> 'a_607) * ('a_606 -> 'a_608) =>
       (fn x_981: 'a_606 =>
	case (x_980, x_981) of
	  ((f: 'a_608 -> 'a_607, g: 'a_606 -> 'a_608), x: 'a_606) => (f (g x))))
val rec
   valOf: int32 Primitive.Option.t -> int32 = 
      (fn x_982: int32 Primitive.Option.t =>
       case x_982 of
	 (x: int32 Primitive.Option.t) =>
	 case x of
	   SOME[int32] y: int32 => y | NONE[int32] => 0x0)
val rec 'a_609
   doit: int32 * ('a_609 -> int64) * 'a_609 -> int64 = 
      (fn x_983: int32 * ('a_609 -> int64) * 'a_609 =>
       case x_983 of
	 ((precision: int32, fromInt: 'a_609 -> int64, maxInt': 'a_609)) =>
	 case (>= ((valOf precision), precision)) of
	   true => (fromInt maxInt') | false => maxInt')
val fInt8: int64 = (doit (int8) ((valOf precision), schckFromInt8, maxInt'))
val fInt16: int64 = (doit (int16) ((valOf precision), schckFromInt16, maxInt'))
val fInt32: int64 = (doit (int32) ((valOf precision), schckFromInt32, maxInt'))
val fInt64: int64 = (doit (int64) ((valOf precision), schckFromInt64, maxInt'))
val fIntInf: int64 = maxInt'
val _ = fInt8
val _ = fInt16
val f: int64 = fInt32
val _ = fInt64
val _ = fIntInf
val maxLen: int64 = f
val rec 'a_613
   arrayUninit: int64 -> 'a_613 array = 
      (fn x_984: int64 =>
       case x_984 of
	 (n: int64) =>
	 case case (not isMutable) of
		true => (= (int64) (n, 0x0)) | false => false of
	   true => (array0Const ('a_613) ())
	 | false =>
	   case case safe of
		  true => (gtu (n, maxLen)) | false => false of
	     true => raise Size | false => (arrayUnsafe ('a_613) n))
val rec 'a_614
   newUninit: int64 -> 'a_614 array = 
      (fn x_985: int64 =>
       case x_985 of
	 (n: int64) => (fromArray_1 ('a_614) (arrayUninit ('a_614) n)))
exception GenerateAlreadyGotVector
exception GenerateVectorNotFull
val rec ('a_617, 'a_616)
   unfoldi: int64 * 'a_617 * (int64 * 'a_617 -> 'a_616 * 'a_617)
	    -> 'a_616 array * 'a_617 = 
      (fn x_986: int64 * 'a_617 * (int64 * 'a_617 -> 'a_616 * 'a_617) =>
       case x_986 of
	 ((n: int64, b: 'a_617, f: int64 * 'a_617 -> 'a_616 * 'a_617)) =>
	 let val a: 'a_616 array = (arrayUninit ('a_616) n)
	     val rec
		loop: int64 * 'a_617 -> 'a_617 = 
		   (fn x_987: int64 * 'a_617 =>
		    case x_987 of
		      ((i: int64, b: 'a_617)) =>
		      case (>= (i, n)) of
			true => b
		      | false =>
			let val (x: 'a_616, b: 'a_617) = (f (i, b))
			    val () = (updateUnsafe ('a_616) (a, i, x))
			in
			   (loop ((+? (i, 0x1)), b))
			end)
	     val b: 'a_617 = (loop (0x0, b))
	 in
	    ((fromArray_1 ('a_616) a), b)
	 end)
val rec ('a_619, 'a_618)
   unfold: int64 * 'a_618 * ('a_618 -> 'a_619 * 'a_618) -> 'a_619 array * 'a_618 = 
      (fn x_988: int64 * 'a_618 * ('a_618 -> 'a_619 * 'a_618) =>
       case x_988 of
	 ((n: int64, b: 'a_618, f: 'a_618 -> 'a_619 * 'a_618)) =>
	 (unfoldi ('a_618, 'a_619) (n,
				    b,
				    (o ('a_618, 'a_619 * 'a_618, int64 * 'a_618) (f,
										  (fn x_989: int64
											     * 'a_618 =>
										   case x_989 of
										     {2 = #: 'a_618} =>
										     #))))))
datatype 'a PrimSequence.Slice.t = T of {len: int64, seq: 'a array, start: int64}
val rec 'a_622
   length: 'a_622 PrimSequence.Slice.t -> int64 = 
      (fn x_990: 'a_622 PrimSequence.Slice.t =>
       case x_990 of
	 (T['a_622] {len = len: int64}) => len)
val rec 'a_623
   unsafeSub: 'a_623 PrimSequence.Slice.t * int64 -> 'a_623 = 
      (fn x_991: 'a_623 PrimSequence.Slice.t * int64 =>
       case x_991 of
	 ((T['a_623] {seq = seq: 'a_623 array, start = start: int64}, i: int64)) =>
	 (subUnsafe_1 ('a_623) (seq, (+? (start, i)))))
val rec 'a_624
   sub: 'a_624 PrimSequence.Slice.t * int64 -> 'a_624 = 
      (fn x_992: 'a_624 PrimSequence.Slice.t * int64 =>
       case x_992 of
	 ((sl: 'a_624 PrimSequence.Slice.t as T['a_624] {len = len: int64},
	   i: int64)) =>
	 case case safe of
		true => (geu (i, len)) | false => false of
	   true => raise Subscript | false => (unsafeSub ('a_624) (sl, i)))
val rec ('a_627, 'a_626, 'a_625)
   unsafeUpdateMk: ('a_627 array * int64 * 'a_626 -> 'a_625)
		   -> 'a_627 PrimSequence.Slice.t * int64 * 'a_626 -> 'a_625 = 
      (fn x_993: 'a_627 array * int64 * 'a_626 -> 'a_625 =>
       (fn x_994: 'a_627 PrimSequence.Slice.t * int64 * 'a_626 =>
	case (x_993, x_994) of
	  (updateUnsafe: 'a_627 array * int64 * 'a_626 -> 'a_625,
	   (T['a_627] {seq = seq: 'a_627 array, start = start: int64},
	    i: int64,
	    x: 'a_626)) =>
	  (updateUnsafe (seq, (+? (start, i)), x))))
val rec ('a_630, 'a_629, 'a_628)
   updateMk: ('a_630 array * int64 * 'a_629 -> 'a_628)
	     -> 'a_630 PrimSequence.Slice.t * int64 * 'a_629 -> 'a_628 = 
      (fn x_995: 'a_630 array * int64 * 'a_629 -> 'a_628 =>
       (fn x_996: 'a_630 PrimSequence.Slice.t * int64 * 'a_629 =>
	case (x_995, x_996) of
	  (updateUnsafe: 'a_630 array * int64 * 'a_629 -> 'a_628,
	   (sl: 'a_630 PrimSequence.Slice.t as T['a_630] {len = len: int64},
	    i: int64,
	    x: 'a_629)) =>
	  case case safe of
		 true => (geu (i, len)) | false => false of
	    true => raise Subscript
	  | false =>
	    ((unsafeUpdateMk ('a_630, 'a_629, 'a_628) updateUnsafe) (sl, i, x))))
val rec 'a
   full: 'a array -> 'a PrimSequence.Slice.t = 
      (fn x_997: 'a array =>
       case x_997 of
	 (seq: 'a array) =>
	 (T['a] {seq = seq, start = 0x0, len = (length_2 ('a) seq)}))
val rec 'a_631
   unsafeSubslice: 'a_631 PrimSequence.Slice.t
		   * int64
		   * int64 Primitive.Option.t
		   -> 'a_631 PrimSequence.Slice.t = 
      (fn x_998: 'a_631 PrimSequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_998 of
	 ((T['a_631] {seq = seq: 'a_631 array,
		      start = start: int64,
		      len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 (T['a_631] {seq = seq,
		     start = (+? (start, start')),
		     len = case len' of
			     NONE[int64] => (-? (len, start'))
			   | SOME[int64] len': int64 => len'}))
val rec 'a_633
   subslice: 'a_633 PrimSequence.Slice.t * int64 * int64 Primitive.Option.t
	     -> 'a_633 PrimSequence.Slice.t = 
      (fn x_999: 'a_633 PrimSequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_999 of
	 ((T['a_633] {seq = seq: 'a_633 array,
		      start = start: int64,
		      len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 case len' of
	   NONE[int64] =>
	   case case safe of
		  true => (gtu (start', len)) | false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_633] {seq = seq,
			 start = (+? (start, start')),
			 len = (-? (len, start'))})
	 | SOME[int64] len': int64 =>
	   case case safe of
		  true =>
		  case (gtu (start', len)) of
		    true => true | false => (gtu (len', (-? (len, start'))))
		| false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_633] {seq = seq, start = (+? (start, start')), len = len'}))
val rec 'a
   slice: 'a array * int64 * int64 Primitive.Option.t -> 'a PrimSequence.Slice.t = 
      (fn x_1000: 'a array * int64 * int64 Primitive.Option.t =>
       case x_1000 of
	 ((seq: 'a array, start: int64, len: int64 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec 'a_634
   base: 'a_634 PrimSequence.Slice.t -> 'a_634 array * int64 * int64 = 
      (fn x_1001: 'a_634 PrimSequence.Slice.t =>
       case x_1001 of
	 (T['a_634] {seq = seq: 'a_634 array,
		     start = start: int64,
		     len = len: int64}) =>
	 (seq, start, len))
val rec ('a_638, 'a_637)
   foldli: (int64 * 'a_638 * 'a_637 -> 'a_637)
	   -> 'a_637 -> 'a_638 PrimSequence.Slice.t -> 'a_637 = 
      (fn x_1002: int64 * 'a_638 * 'a_637 -> 'a_637 =>
       (fn x_1003: 'a_637 =>
	(fn x_1004: 'a_638 PrimSequence.Slice.t =>
	 case (x_1002, x_1003, x_1004) of
	   (f: int64 * 'a_638 * 'a_637 -> 'a_637,
	    b: 'a_637,
	    T['a_638] {seq = seq: 'a_638 array,
		       start = start: int64,
		       len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_637 -> 'a_637 = 
		     (fn x_1005: int64 * 'a_637 =>
		      case x_1005 of
			((i: int64, b: 'a_637)) =>
			case (> (i, max)) of
			  true => b
			| false =>
			  (loop ((+? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_1 ('a_638) (seq, i)),
				     b)))))
	   in
	      (loop (min, b))
	   end)))
val rec ('a_640, 'a_639)
   foldri: (int64 * 'a_640 * 'a_639 -> 'a_639)
	   -> 'a_639 -> 'a_640 PrimSequence.Slice.t -> 'a_639 = 
      (fn x_1006: int64 * 'a_640 * 'a_639 -> 'a_639 =>
       (fn x_1007: 'a_639 =>
	(fn x_1008: 'a_640 PrimSequence.Slice.t =>
	 case (x_1006, x_1007, x_1008) of
	   (f: int64 * 'a_640 * 'a_639 -> 'a_639,
	    b: 'a_639,
	    T['a_640] {seq = seq: 'a_640 array,
		       start = start: int64,
		       len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_639 -> 'a_639 = 
		     (fn x_1009: int64 * 'a_639 =>
		      case x_1009 of
			((i: int64, b: 'a_639)) =>
			case (< (i, min)) of
			  true => b
			| false =>
			  (loop ((-? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_1 ('a_640) (seq, i)),
				     b)))))
	   in
	      (loop (max, b))
	   end)))
val ('a, 'b) unfoldi_1: int64 * 'b * (int64 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi ('b, 'a)
val ('a, 'b) unfold_1: int64 * 'b * ('b -> 'a * 'b) -> 'a array * 'b =
   unfold ('a, 'b)
val 'a newUninit_0: int64 -> 'a array = newUninit ('a)
val 'a updateMk_0: ('a array * int64 * 'a -> unit)
		   -> 'a PrimSequence.Slice.t * int64 * 'a -> unit =
   updateMk ('a, 'a, unit)
val 'a unsafeUpdateMk_0: ('a array * int64 * 'a -> unit)
			 -> 'a PrimSequence.Slice.t * int64 * 'a -> unit =
   unsafeUpdateMk ('a, 'a, unit)
val 'a unsafeSubslice_1: 'a PrimSequence.Slice.t
			 * int64
			 * int64 Primitive.Option.t
			 -> 'a PrimSequence.Slice.t =
   unsafeSubslice ('a)
val 'a unsafeSub_2: 'a PrimSequence.Slice.t * int64 -> 'a = unsafeSub ('a)
val 'a subslice_1: 'a PrimSequence.Slice.t * int64 * int64 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t =
   subslice ('a)
val 'a sub_1: 'a PrimSequence.Slice.t * int64 -> 'a = sub ('a)
val 'a slice_0: 'a array * int64 * int64 Primitive.Option.t
		-> 'a PrimSequence.Slice.t =
   slice ('a)
val 'a length_3: 'a PrimSequence.Slice.t -> int64 = length ('a)
val 'a full_1: 'a array -> 'a PrimSequence.Slice.t = full ('a)
val ('b, 'a) foldri_0: (int64 * 'a * 'b -> 'b)
		       -> 'b -> 'a PrimSequence.Slice.t -> 'b =
   foldri ('a, 'b)
val ('b, 'a) foldli_0: (int64 * 'a * 'b -> 'b)
		       -> 'b -> 'a PrimSequence.Slice.t -> 'b =
   foldli ('a, 'b)
val 'a base_1: 'a PrimSequence.Slice.t -> 'a array * int64 * int64 = base ('a)
val rec 'a_723
   unsafeUpdate: 'a_723 PrimSequence.Slice.t * int64 * 'a_723 -> unit = 
      (fn x_1010: 'a_723 PrimSequence.Slice.t * int64 * 'a_723 =>
       case x_1010 of
	 (arg: 'a_723 PrimSequence.Slice.t * int64 * 'a_723) =>
	 ((unsafeUpdateMk_0 ('a_723) updateUnsafe ('a_723)) arg))
val rec 'a_724
   vector: 'a_724 PrimSequence.Slice.t -> 'a_724 vector = 
      (fn x_1011: 'a_724 PrimSequence.Slice.t =>
       case x_1011 of
	 (sl: 'a_724 PrimSequence.Slice.t) =>
	 (tabulate_0 ('a_724) ((length_3 ('a_724) sl),
			       (fn x_1012: int64 =>
				case x_1012 of
				  i: int64 => (unsafeSub_2 ('a_724) (sl, i))))))
val rec ('a_733, 'a_732, 'a_731, 'a_730, 'a_729)
   make: ((int64 * 'a_731 * 'a_730 -> unit)
	  -> unit -> 'a_732 PrimSequence.Slice.t -> 'a_729)
	 * ('a_733 -> int64)
	 * ('a_733 * int64 -> 'a_732)
	 -> {di: int64, dst: 'a_732 array, src: 'a_733} -> 'a_729 = 
      (fn x_1013: ((int64 * 'a_731 * 'a_730 -> unit)
		   -> unit -> 'a_732 PrimSequence.Slice.t -> 'a_729)
		  * ('a_733 -> int64)
		  * ('a_733 * int64 -> 'a_732) =>
       (fn x_1014: {di: int64, dst: 'a_732 array, src: 'a_733} =>
	case (x_1013, x_1014) of
	  ((foldFn: (int64 * 'a_731 * 'a_730 -> unit)
		    -> unit -> 'a_732 PrimSequence.Slice.t -> 'a_729,
	    lengthFn: 'a_733 -> int64,
	    unsafeSubFn: 'a_733 * int64 -> 'a_732),
	   {src = src: 'a_733, dst = dst: 'a_732 array, di = di: int64}) =>
	  let val sl: 'a_732 PrimSequence.Slice.t =
		 (slice_0 ('a_732) (dst, di, (SOME[int64] (lengthFn src))))
	      val rec ('a_728, 'a_727)
		 transfer: int64 * 'a_728 * 'a_727 -> unit = 
		    (fn x_1015: int64 * 'a_728 * 'a_727 =>
		     case x_1015 of
		       ((i: int64, _, _)) =>
		       (unsafeUpdate ('a_732) (sl, i, (unsafeSubFn (src, i)))))
	  in
	     (((foldFn transfer ('a_731, 'a_730)) ()) sl)
	  end))
val rec 'a_735
   copyVec: {di: int64, dst: 'a_735 array, src: 'a_735 PrimSequence.Slice.t}
	    -> unit = 
      (fn x_1016: {di: int64,
		   dst: 'a_735 array,
		   src: 'a_735 PrimSequence.Slice.t} =>
       case x_1016 of
	 (arg: {di: int64, dst: 'a_735 array, src: 'a_735 PrimSequence.Slice.t}) =>
	 ((make ('a_735 PrimSequence.Slice.t, 'a_735, 'a_735, unit, unit) (foldli_0 (unit,
										     'a_735),
									   length_1 ('a_735),
									   unsafeSub_1 ('a_735))) arg))
val rec 'a_740
   copyVec: {di: int64, dst: 'a_740 array, src: 'a_740 vector} -> unit = 
      (fn x_1017: {di: int64, dst: 'a_740 array, src: 'a_740 vector} =>
       case x_1017 of
	 ({src = src: 'a_740 vector, dst = dst: 'a_740 array, di = di: int64}) =>
	 (copyVec ('a_740) {src = (full_0 ('a_740) src), dst = dst, di = di}))
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> word64 = fInt64
val idFromObjptrInt: int64 -> word64 = f
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val fInt64: word64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: word64 -> int64 = fInt64
val idToObjptrInt: word64 -> int64 = f
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> word64 = fInt64
val zextdFromSeqIndex: int64 -> word64 = f
val zero: intInf = 0
val rec
   isSmall: intInf -> bool = 
      (fn x_1018: intInf =>
       case x_1018 of
	 (i: intInf) => (<> (word64) (0x0, (andb ((toWord i), 0x1)))))
val rec
   areSmall: intInf * intInf -> bool = 
      (fn x_1019: intInf * intInf =>
       case x_1019 of
	 ((i: intInf, i': intInf)) =>
	 (<> (word64) (0x0, (andb ((andb ((toWord i), (toWord i'))), 0x1)))))
val rec
   bigNumLimbs: intInf -> int64 = 
      (fn x_1020: intInf =>
       case x_1020 of
	 (i: intInf) => (- ((length (word64) (toVector i)), 0x1)))
val rec
   numLimbs: intInf -> int64 = 
      (fn x_1021: intInf =>
       case x_1021 of
	 (i: intInf) =>
	 case (isSmall i) of
	   true => 0x1 | false => (bigNumLimbs i))
val rec
   dropTag: word64 -> word64 = 
      (fn x_1022: word64 =>
       case x_1022 of
	 (w: word64) => (~>>? (w, 0x1)))
val rec
   dropTagCoerce: intInf -> word64 = 
      (fn x_1023: intInf =>
       case x_1023 of
	 (i: intInf) => (dropTag (toWord i)))
val rec
   dropTagCoerceInt: intInf -> int64 = 
      (fn x_1024: intInf =>
       case x_1024 of
	 (i: intInf) => (idToObjptrInt (dropTagCoerce i)))
val rec
   addTag: word64 -> word64 = 
      (fn x_1025: word64 =>
       case x_1025 of
	 (w: word64) => (orb ((<<? (w, 0x1)), 0x1)))
datatype Primitive.IntInf.rep = Big of word64 vector
				| Small of int64
val rec 'a
   make: {other: {eq: 'a * 'a -> bool,
		  isNeg: 'a -> bool,
		  neg: 'a -> 'a,
		  notb: 'a -> 'a,
		  rashift: 'a * word32 -> 'a,
		  rshift: 'a * word32 -> 'a,
		  sizeInBits: int32,
		  zero: 'a},
	  sextdToObjptrWord: 'a -> word64,
	  zextdToMPLimb: 'a -> word64,
	  zextdToObjptrWord: 'a -> word64}
	 -> bool * 'a -> intInf = 
      (fn x_1026: {other: {eq: 'a * 'a -> bool,
			   isNeg: 'a -> bool,
			   neg: 'a -> 'a,
			   notb: 'a -> 'a,
			   rashift: 'a * word32 -> 'a,
			   rshift: 'a * word32 -> 'a,
			   sizeInBits: int32,
			   zero: 'a},
		   sextdToObjptrWord: 'a -> word64,
		   zextdToMPLimb: 'a -> word64,
		   zextdToObjptrWord: 'a -> word64} =>
       (fn x_1027: bool * 'a =>
	case (x_1026, x_1027) of
	  ({zextdToMPLimb = zextdToMPLimb: 'a -> word64,
	    zextdToObjptrWord = zextdToObjptrWord: 'a -> word64,
	    sextdToObjptrWord = sextdToObjptrWord: 'a -> word64,
	    other = other: {eq: 'a * 'a -> bool,
			    isNeg: 'a -> bool,
			    neg: 'a -> 'a,
			    notb: 'a -> 'a,
			    rashift: 'a * word32 -> 'a,
			    rshift: 'a * word32 -> 'a,
			    sizeInBits: int32,
			    zero: 'a}},
	   (sextd: bool, w: 'a)) =>
	  case case (> (sizeInBits,
			((fn x_1040: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			  case x_1040 of
			    {sizeInBits = #: int32} => #) other))) of
		 true => true
	       | false =>
		 let val shift: word32 = (- (sizeInBitsWord, 0x2))
		     val upperBits: 'a =
			(((fn x_1037: {eq: 'a * 'a -> bool,
				       isNeg: 'a -> bool,
				       neg: 'a -> 'a,
				       notb: 'a -> 'a,
				       rashift: 'a * word32 -> 'a,
				       rshift: 'a * word32 -> 'a,
				       sizeInBits: int32,
				       zero: 'a} =>
			   case x_1037 of
			     {rashift = #: 'a * word32 -> 'a} => #) other) (w, shift))
		     val zeroBits: 'a =
			((fn x_1036: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			  case x_1036 of
			    {zero = #: 'a} => #) other)
		     val oneBits: 'a =
			(((fn x_1035: {eq: 'a * 'a -> bool,
				       isNeg: 'a -> bool,
				       neg: 'a -> 'a,
				       notb: 'a -> 'a,
				       rashift: 'a * word32 -> 'a,
				       rshift: 'a * word32 -> 'a,
				       sizeInBits: int32,
				       zero: 'a} =>
			   case x_1035 of
			     {notb = #: 'a -> 'a} => #) other) zeroBits)
		 in
		    case (((fn x_1039: {eq: 'a * 'a -> bool,
					isNeg: 'a -> bool,
					neg: 'a -> 'a,
					notb: 'a -> 'a,
					rashift: 'a * word32 -> 'a,
					rshift: 'a * word32 -> 'a,
					sizeInBits: int32,
					zero: 'a} =>
			    case x_1039 of
			      {eq = #: 'a * 'a -> bool} => #) other) (upperBits, zeroBits)) of
		      true => true
		    | false =>
		      case sextd of
			true =>
			(((fn x_1038: {eq: 'a * 'a -> bool,
				       isNeg: 'a -> bool,
				       neg: 'a -> 'a,
				       notb: 'a -> 'a,
				       rashift: 'a * word32 -> 'a,
				       rshift: 'a * word32 -> 'a,
				       sizeInBits: int32,
				       zero: 'a} =>
			   case x_1038 of
			     {eq = #: 'a * 'a -> bool} => #) other) (upperBits, oneBits))
		      | false => false
		 end of
	    true =>
	    case sextd of
	      true => (fromWord (addTag (sextdToObjptrWord w)))
	    | false => (fromWord (addTag (zextdToObjptrWord w)))
	  | false =>
	    let val rec
		   loop: 'a * int64 * (int64 * word64) list
			 -> int64 * (int64 * word64) list = 
		      (fn x_1031: 'a * int64 * (int64 * word64) list =>
		       case x_1031 of
			 ((w: 'a, i: int64, acc: (int64 * word64) list)) =>
			 case (((fn x_1033: {eq: 'a * 'a -> bool,
					     isNeg: 'a -> bool,
					     neg: 'a -> 'a,
					     notb: 'a -> 'a,
					     rashift: 'a * word32 -> 'a,
					     rshift: 'a * word32 -> 'a,
					     sizeInBits: int32,
					     zero: 'a} =>
				 case x_1033 of
				   {eq = #: 'a * 'a -> bool} => #) other) (w,
					((fn x_1034: {eq: 'a * 'a -> bool,
						      isNeg: 'a -> bool,
						      neg: 'a -> 'a,
						      notb: 'a -> 'a,
						      rashift: 'a * word32 -> 'a,
						      rshift: 'a * word32 -> 'a,
						      sizeInBits: int32,
						      zero: 'a} =>
					  case x_1034 of
					    {zero = #: 'a} => #) other))) of
			   true => (i, acc)
			 | false =>
			   let val limb: word64 = (zextdToMPLimb w)
			       val w: 'a =
				  (((fn x_1032: {eq: 'a * 'a -> bool,
						 isNeg: 'a -> bool,
						 neg: 'a -> 'a,
						 notb: 'a -> 'a,
						 rashift: 'a * word32 -> 'a,
						 rshift: 'a * word32 -> 'a,
						 sizeInBits: int32,
						 zero: 'a} =>
				     case x_1032 of
				       {rshift = #: 'a * word32 -> 'a} => #) other) (w, sizeInBitsWord))
			   in
			      (loop (w,
				     (+ (i, 0x1)),
				     (::[int64 * word64] ((i, limb), acc))))
			   end)
		val (n: int64, acc: (int64 * word64) list) =
		   case case sextd of
			  true =>
			  (((fn x_1030: {eq: 'a * 'a -> bool,
					 isNeg: 'a -> bool,
					 neg: 'a -> 'a,
					 notb: 'a -> 'a,
					 rashift: 'a * word32 -> 'a,
					 rshift: 'a * word32 -> 'a,
					 sizeInBits: int32,
					 zero: 'a} =>
			     case x_1030 of
			       {isNeg = #: 'a -> bool} => #) other) w)
			| false => false of
		     true =>
		     (loop ((((fn x_1029: {eq: 'a * 'a -> bool,
					   isNeg: 'a -> bool,
					   neg: 'a -> 'a,
					   notb: 'a -> 'a,
					   rashift: 'a * word32 -> 'a,
					   rshift: 'a * word32 -> 'a,
					   sizeInBits: int32,
					   zero: 'a} =>
			       case x_1029 of
				 {neg = #: 'a -> 'a} => #) other) w),
			    0x1,
			    [(0x0, 0x1)]))
		   | false => (loop (w, 0x1, [(0x0, 0x0)]))
		val a: word64 array = (arrayUnsafe (word64) n)
		val rec
		   loop: (int64 * word64) list -> unit = 
		      (fn x_1028: (int64 * word64) list =>
		       case x_1028 of
			 (acc: (int64 * word64) list) =>
			 case acc of
			   [] => ()
			 | ::[int64 * word64] ((i: int64, v: word64),
					       acc: (int64 * word64) list) =>
			   (updateUnsafe (word64) (a, i, v)) ;(loop acc))
		val () = (loop acc)
	    in
	       (fromVector (fromArrayUnsafe (word64) a))
	    end))
val rec
   extdFromWord8: bool * word8 -> intInf = 
      (fn x_1041: bool * word8 =>
       case x_1041 of
	 ((sextd: bool, w: word8)) =>
	 ((make (word8) {zextdToMPLimb = zextdFromWord8,
			 zextdToObjptrWord = zextdFromWord8,
			 sextdToObjptrWord = sextdFromWord8,
			 other = {sizeInBits = sizeInBits,
				  zero = zero,
				  eq = = (word8),
				  isNeg = (fn x_1042: word8 =>
					   case x_1042 of
					     w: word8 =>
					     (< ((idFromWord8ToInt8 w), 0x0))),
				  neg = ~,
				  notb = notb,
				  rashift = ~>>?,
				  rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord8: word8 -> intInf = 
      (fn x_1043: word8 =>
       case x_1043 of
	 (w: word8) => (extdFromWord8 (false, w)))
val rec
   zextdFromInt8: int8 -> intInf = 
      (fn x_1044: int8 =>
       case x_1044 of
	 (i: int8) => (zextdFromWord8 (idFromInt8ToWord8 i)))
val rec
   sextdFromWord8: word8 -> intInf = 
      (fn x_1045: word8 =>
       case x_1045 of
	 (w: word8) => (extdFromWord8 (true, w)))
val rec
   sextdFromInt8: int8 -> intInf = 
      (fn x_1046: int8 =>
       case x_1046 of
	 (i: int8) => (sextdFromWord8 (idFromInt8ToWord8 i)))
val castFromInt8: int8 -> intInf = sextdFromInt8
val castFromWord8: word8 -> intInf = zextdFromWord8
val zchckFromInt8: int8 -> intInf = zextdFromInt8
val zchckFromWord8: word8 -> intInf = zextdFromWord8
val schckFromInt8: int8 -> intInf = sextdFromInt8
val schckFromWord8: word8 -> intInf = sextdFromWord8
val rec
   extdFromWord16: bool * word16 -> intInf = 
      (fn x_1047: bool * word16 =>
       case x_1047 of
	 ((sextd: bool, w: word16)) =>
	 ((make (word16) {zextdToMPLimb = zextdFromWord16,
			  zextdToObjptrWord = zextdFromWord16,
			  sextdToObjptrWord = sextdFromWord16,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word16),
				   isNeg = (fn x_1048: word16 =>
					    case x_1048 of
					      w: word16 =>
					      (< ((idFromWord16ToInt16 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord16: word16 -> intInf = 
      (fn x_1049: word16 =>
       case x_1049 of
	 (w: word16) => (extdFromWord16 (false, w)))
val rec
   zextdFromInt16: int16 -> intInf = 
      (fn x_1050: int16 =>
       case x_1050 of
	 (i: int16) => (zextdFromWord16 (idFromInt16ToWord16 i)))
val rec
   sextdFromWord16: word16 -> intInf = 
      (fn x_1051: word16 =>
       case x_1051 of
	 (w: word16) => (extdFromWord16 (true, w)))
val rec
   sextdFromInt16: int16 -> intInf = 
      (fn x_1052: int16 =>
       case x_1052 of
	 (i: int16) => (sextdFromWord16 (idFromInt16ToWord16 i)))
val castFromInt16: int16 -> intInf = sextdFromInt16
val castFromWord16: word16 -> intInf = zextdFromWord16
val zchckFromInt16: int16 -> intInf = zextdFromInt16
val zchckFromWord16: word16 -> intInf = zextdFromWord16
val schckFromInt16: int16 -> intInf = sextdFromInt16
val schckFromWord16: word16 -> intInf = sextdFromWord16
val rec
   extdFromWord32: bool * word32 -> intInf = 
      (fn x_1053: bool * word32 =>
       case x_1053 of
	 ((sextd: bool, w: word32)) =>
	 ((make (word32) {zextdToMPLimb = zextdFromWord32,
			  zextdToObjptrWord = zextdFromWord32,
			  sextdToObjptrWord = sextdFromWord32,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word32),
				   isNeg = (fn x_1054: word32 =>
					    case x_1054 of
					      w: word32 =>
					      (< ((idFromWord32ToInt32 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord32: word32 -> intInf = 
      (fn x_1055: word32 =>
       case x_1055 of
	 (w: word32) => (extdFromWord32 (false, w)))
val rec
   zextdFromInt32: int32 -> intInf = 
      (fn x_1056: int32 =>
       case x_1056 of
	 (i: int32) => (zextdFromWord32 (idFromInt32ToWord32 i)))
val rec
   sextdFromWord32: word32 -> intInf = 
      (fn x_1057: word32 =>
       case x_1057 of
	 (w: word32) => (extdFromWord32 (true, w)))
val rec
   sextdFromInt32: int32 -> intInf = 
      (fn x_1058: int32 =>
       case x_1058 of
	 (i: int32) => (sextdFromWord32 (idFromInt32ToWord32 i)))
val castFromInt32: int32 -> intInf = sextdFromInt32
val castFromWord32: word32 -> intInf = zextdFromWord32
val zchckFromInt32: int32 -> intInf = zextdFromInt32
val zchckFromWord32: word32 -> intInf = zextdFromWord32
val schckFromInt32: int32 -> intInf = sextdFromInt32
val schckFromWord32: word32 -> intInf = sextdFromWord32
val rec
   extdFromWord64: bool * word64 -> intInf = 
      (fn x_1059: bool * word64 =>
       case x_1059 of
	 ((sextd: bool, w: word64)) =>
	 ((make (word64) {zextdToMPLimb = zextdFromWord64,
			  zextdToObjptrWord = zextdFromWord64,
			  sextdToObjptrWord = sextdFromWord64,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word64),
				   isNeg = (fn x_1060: word64 =>
					    case x_1060 of
					      w: word64 =>
					      (< ((idFromWord64ToInt64 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord64: word64 -> intInf = 
      (fn x_1061: word64 =>
       case x_1061 of
	 (w: word64) => (extdFromWord64 (false, w)))
val rec
   zextdFromInt64: int64 -> intInf = 
      (fn x_1062: int64 =>
       case x_1062 of
	 (i: int64) => (zextdFromWord64 (idFromInt64ToWord64 i)))
val rec
   sextdFromWord64: word64 -> intInf = 
      (fn x_1063: word64 =>
       case x_1063 of
	 (w: word64) => (extdFromWord64 (true, w)))
val rec
   sextdFromInt64: int64 -> intInf = 
      (fn x_1064: int64 =>
       case x_1064 of
	 (i: int64) => (sextdFromWord64 (idFromInt64ToWord64 i)))
val castFromInt64: int64 -> intInf = sextdFromInt64
val castFromWord64: word64 -> intInf = zextdFromWord64
val zchckFromInt64: int64 -> intInf = zextdFromInt64
val zchckFromWord64: word64 -> intInf = zextdFromWord64
val schckFromInt64: int64 -> intInf = sextdFromInt64
val schckFromWord64: word64 -> intInf = sextdFromWord64
val rec 'a_753
   zextdFromIntInf: 'a_753 -> 'a_753 = 
      (fn x_1065: 'a_753 =>
       case x_1065 of
	 (ii: 'a_753) => ii)
val rec 'a_754
   sextdFromIntInf: 'a_754 -> 'a_754 = 
      (fn x_1066: 'a_754 =>
       case x_1066 of
	 (ii: 'a_754) => ii)
val rec 'a_755
   castFromIntInf: 'a_755 -> 'a_755 = 
      (fn x_1067: 'a_755 =>
       case x_1067 of
	 (ii: 'a_755) => ii)
val rec 'a_756
   zchckFromIntInf: 'a_756 -> 'a_756 = 
      (fn x_1068: 'a_756 =>
       case x_1068 of
	 (ii: 'a_756) => ii)
val rec 'a_757
   schckFromIntInf: 'a_757 -> 'a_757 = 
      (fn x_1069: 'a_757 =>
       case x_1069 of
	 (ii: 'a_757) => ii)
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val fInt64: int64 -> intInf = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> intInf = fInt64
val sextdFromObjptrInt: int64 -> intInf = f
datatype 'a Primitive.IntInf.ans = Big of bool * bool * 'a
				   | Small of word64
val rec 'a
   make: {other: {lshift: 'a * word32 -> 'a,
		  orb: 'a * 'a -> 'a,
		  sizeInBits: int32,
		  sizeInBitsWord: word32,
		  zero: 'a},
	  zextdFromMPLimb: word64 -> 'a}
	 -> intInf -> 'a Primitive.IntInf.ans = 
      (fn x_1070: {other: {lshift: 'a * word32 -> 'a,
			   orb: 'a * 'a -> 'a,
			   sizeInBits: int32,
			   sizeInBitsWord: word32,
			   zero: 'a},
		   zextdFromMPLimb: word64 -> 'a} =>
       (fn x_1071: intInf =>
	case (x_1070, x_1071) of
	  ({zextdFromMPLimb = zextdFromMPLimb: word64 -> 'a,
	    other = other: {lshift: 'a * word32 -> 'a,
			    orb: 'a * 'a -> 'a,
			    sizeInBits: int32,
			    sizeInBitsWord: word32,
			    zero: 'a}},
	   i: intInf) =>
	  case (isSmall i) of
	    true => (Small['a] (dropTagCoerce i))
	  | false =>
	    let val v: word64 vector = (toVector i)
		val n: int64 = (length (word64) v)
		val isneg: bool =
		   (<> (word64) ((subUnsafe (word64) (v, 0x0)), 0x0))
	    in
	       case (>= (sizeInBits,
			 ((fn x_1078: {lshift: 'a * word32 -> 'a,
				       orb: 'a * 'a -> 'a,
				       sizeInBits: int32,
				       sizeInBitsWord: word32,
				       zero: 'a} =>
			   case x_1078 of
			     {sizeInBits = #: int32} => #) other))) of
		 true =>
		 let val limbsPer: int64 = 0x1
		     val limb: word64 = (subUnsafe (word64) (v, 0x1))
		     val extra: bool =
			case (> (n, (+ (limbsPer, 0x1)))) of
			  true => true
			| false =>
			  (<> (word64) ((>>? (limb,
					      ((fn x_1072: {lshift: 'a * word32
								    -> 'a,
							    orb: 'a * 'a -> 'a,
							    sizeInBits: int32,
							    sizeInBitsWord: word32,
							    zero: 'a} =>
						case x_1072 of
						  {sizeInBitsWord = #: word32} =>
						  #) other))),
					0x0))
		     val ans: 'a = (zextdFromMPLimb limb)
		 in
		    (Big['a] (isneg, extra, ans))
		 end
	       | false =>
		 let val limbsPer: int64 =
			(sextdFromInt32 (quot (((fn x_1077: {lshift: 'a * word32
								     -> 'a,
							     orb: 'a * 'a -> 'a,
							     sizeInBits: int32,
							     sizeInBitsWord: word32,
							     zero: 'a} =>
						 case x_1077 of
						   {sizeInBits = #: int32} => #) other),
					       sizeInBits)))
		     val extra: bool = (> (n, (+ (limbsPer, 0x1))))
		     val ans: 'a =
			let val rec
			       loop: int64 * 'a -> 'a = 
				  (fn x_1073: int64 * 'a =>
				   case x_1073 of
				     ((i: int64, ans: 'a)) =>
				     case (> (i, 0x0)) of
				       true =>
				       let val limb: word64 =
					      (subUnsafe (word64) (v, i))
					   val ans: 'a =
					      (((fn x_1074: {lshift: 'a * word32
								     -> 'a,
							     orb: 'a * 'a -> 'a,
							     sizeInBits: int32,
							     sizeInBitsWord: word32,
							     zero: 'a} =>
						 case x_1074 of
						   {orb = #: 'a * 'a -> 'a} => #) other) ((((fn x_1075: {lshift: 'a * word32 -> 'a,
						      orb: 'a * 'a -> 'a,
						      sizeInBits: int32,
						      sizeInBitsWord: word32,
						      zero: 'a} =>
					  case x_1075 of
					    {lshift = #: 'a * word32 -> 'a} => #) other) (ans, sizeInBitsWord)),
				       (zextdFromMPLimb limb)))
				       in
					  (loop ((- (i, 0x1)), ans))
				       end
				     | false => ans)
			in
			   (loop ((min ((- (n, 0x1)), limbsPer)),
				  ((fn x_1076: {lshift: 'a * word32 -> 'a,
						orb: 'a * 'a -> 'a,
						sizeInBits: int32,
						sizeInBitsWord: word32,
						zero: 'a} =>
				    case x_1076 of
				      {zero = #: 'a} => #) other)))
			end
		 in
		    (Big['a] (isneg, extra, ans))
		 end
	    end))
val chckToWord8Aux: intInf -> word8 Primitive.IntInf.ans =
   (make (word8) {zextdFromMPLimb = zextdToWord8,
		  other = {sizeInBits = sizeInBits,
			   sizeInBitsWord = sizeInBitsWord,
			   zero = zero,
			   lshift = <<?,
			   orb = orb}})
val rec
   sextdToWord8: intInf -> word8 = 
      (fn x_1079: intInf =>
       case x_1079 of
	 (i: intInf) =>
	 case (chckToWord8Aux i) of
	   Small[word8] w: word64 => (sextdToWord8 w)
	 | Big[word8] (isneg: bool, _, ans: word8) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt8: intInf -> int8 = 
      (fn x_1080: intInf =>
       case x_1080 of
	 (i: intInf) => (idFromWord8ToInt8 (sextdToWord8 i)))
val zextdToWord8: intInf -> word8 = sextdToWord8
val rec
   zextdToInt8: intInf -> int8 = 
      (fn x_1081: intInf =>
       case x_1081 of
	 (i: intInf) => (idFromWord8ToInt8 (zextdToWord8 i)))
val castToWord8: intInf -> word8 = sextdToWord8
val castToInt8: intInf -> int8 = sextdToInt8
val rec
   schckToWord8: intInf -> word8 = 
      (fn x_1082: intInf =>
       case x_1082 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord8 i)
	 | false =>
	   case (chckToWord8Aux i) of
	     Small[word8] w: word64 => (schckToWord8 w)
	   | Big[word8] (isneg: bool, extra: bool, ans: word8) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word8 = (~ ans)
		     val ans': int8 = (idFromWord8ToInt8 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int8 = (idFromWord8ToInt8 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt8: intInf -> int8 = 
      (fn x_1083: intInf =>
       case x_1083 of
	 (i: intInf) => (idFromWord8ToInt8 (schckToWord8 i)))
val rec
   zchckToWord8: intInf -> word8 = 
      (fn x_1084: intInf =>
       case x_1084 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord8 i)
	 | false =>
	   case (chckToWord8Aux i) of
	     Small[word8] w: word64 => (schckToWord8 w)
	   | Big[word8] (isneg: bool, extra: bool, ans: word8) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt8: intInf -> int8 = 
      (fn x_1085: intInf =>
       case x_1085 of
	 (i: intInf) => (idFromWord8ToInt8 (zchckToWord8 i)))
val chckToWord16Aux: intInf -> word16 Primitive.IntInf.ans =
   (make (word16) {zextdFromMPLimb = zextdToWord16,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord16: intInf -> word16 = 
      (fn x_1086: intInf =>
       case x_1086 of
	 (i: intInf) =>
	 case (chckToWord16Aux i) of
	   Small[word16] w: word64 => (sextdToWord16 w)
	 | Big[word16] (isneg: bool, _, ans: word16) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt16: intInf -> int16 = 
      (fn x_1087: intInf =>
       case x_1087 of
	 (i: intInf) => (idFromWord16ToInt16 (sextdToWord16 i)))
val zextdToWord16: intInf -> word16 = sextdToWord16
val rec
   zextdToInt16: intInf -> int16 = 
      (fn x_1088: intInf =>
       case x_1088 of
	 (i: intInf) => (idFromWord16ToInt16 (zextdToWord16 i)))
val castToWord16: intInf -> word16 = sextdToWord16
val castToInt16: intInf -> int16 = sextdToInt16
val rec
   schckToWord16: intInf -> word16 = 
      (fn x_1089: intInf =>
       case x_1089 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord16 i)
	 | false =>
	   case (chckToWord16Aux i) of
	     Small[word16] w: word64 => (schckToWord16 w)
	   | Big[word16] (isneg: bool, extra: bool, ans: word16) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word16 = (~ ans)
		     val ans': int16 = (idFromWord16ToInt16 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int16 = (idFromWord16ToInt16 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt16: intInf -> int16 = 
      (fn x_1090: intInf =>
       case x_1090 of
	 (i: intInf) => (idFromWord16ToInt16 (schckToWord16 i)))
val rec
   zchckToWord16: intInf -> word16 = 
      (fn x_1091: intInf =>
       case x_1091 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord16 i)
	 | false =>
	   case (chckToWord16Aux i) of
	     Small[word16] w: word64 => (schckToWord16 w)
	   | Big[word16] (isneg: bool, extra: bool, ans: word16) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt16: intInf -> int16 = 
      (fn x_1092: intInf =>
       case x_1092 of
	 (i: intInf) => (idFromWord16ToInt16 (zchckToWord16 i)))
val chckToWord32Aux: intInf -> word32 Primitive.IntInf.ans =
   (make (word32) {zextdFromMPLimb = zextdToWord32,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord32: intInf -> word32 = 
      (fn x_1093: intInf =>
       case x_1093 of
	 (i: intInf) =>
	 case (chckToWord32Aux i) of
	   Small[word32] w: word64 => (sextdToWord32 w)
	 | Big[word32] (isneg: bool, _, ans: word32) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt32: intInf -> int32 = 
      (fn x_1094: intInf =>
       case x_1094 of
	 (i: intInf) => (idFromWord32ToInt32 (sextdToWord32 i)))
val zextdToWord32: intInf -> word32 = sextdToWord32
val rec
   zextdToInt32: intInf -> int32 = 
      (fn x_1095: intInf =>
       case x_1095 of
	 (i: intInf) => (idFromWord32ToInt32 (zextdToWord32 i)))
val castToWord32: intInf -> word32 = sextdToWord32
val castToInt32: intInf -> int32 = sextdToInt32
val rec
   schckToWord32: intInf -> word32 = 
      (fn x_1096: intInf =>
       case x_1096 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord32 i)
	 | false =>
	   case (chckToWord32Aux i) of
	     Small[word32] w: word64 => (schckToWord32 w)
	   | Big[word32] (isneg: bool, extra: bool, ans: word32) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word32 = (~ ans)
		     val ans': int32 = (idFromWord32ToInt32 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int32 = (idFromWord32ToInt32 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt32: intInf -> int32 = 
      (fn x_1097: intInf =>
       case x_1097 of
	 (i: intInf) => (idFromWord32ToInt32 (schckToWord32 i)))
val rec
   zchckToWord32: intInf -> word32 = 
      (fn x_1098: intInf =>
       case x_1098 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord32 i)
	 | false =>
	   case (chckToWord32Aux i) of
	     Small[word32] w: word64 => (schckToWord32 w)
	   | Big[word32] (isneg: bool, extra: bool, ans: word32) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt32: intInf -> int32 = 
      (fn x_1099: intInf =>
       case x_1099 of
	 (i: intInf) => (idFromWord32ToInt32 (zchckToWord32 i)))
val chckToWord64Aux: intInf -> word64 Primitive.IntInf.ans =
   (make (word64) {zextdFromMPLimb = zextdToWord64,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord64: intInf -> word64 = 
      (fn x_1100: intInf =>
       case x_1100 of
	 (i: intInf) =>
	 case (chckToWord64Aux i) of
	   Small[word64] w: word64 => (sextdToWord64 w)
	 | Big[word64] (isneg: bool, _, ans: word64) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt64: intInf -> int64 = 
      (fn x_1101: intInf =>
       case x_1101 of
	 (i: intInf) => (idFromWord64ToInt64 (sextdToWord64 i)))
val zextdToWord64: intInf -> word64 = sextdToWord64
val rec
   zextdToInt64: intInf -> int64 = 
      (fn x_1102: intInf =>
       case x_1102 of
	 (i: intInf) => (idFromWord64ToInt64 (zextdToWord64 i)))
val castToWord64: intInf -> word64 = sextdToWord64
val castToInt64: intInf -> int64 = sextdToInt64
val rec
   schckToWord64: intInf -> word64 = 
      (fn x_1103: intInf =>
       case x_1103 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord64 i)
	 | false =>
	   case (chckToWord64Aux i) of
	     Small[word64] w: word64 => (schckToWord64 w)
	   | Big[word64] (isneg: bool, extra: bool, ans: word64) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word64 = (~ ans)
		     val ans': int64 = (idFromWord64ToInt64 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int64 = (idFromWord64ToInt64 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt64: intInf -> int64 = 
      (fn x_1104: intInf =>
       case x_1104 of
	 (i: intInf) => (idFromWord64ToInt64 (schckToWord64 i)))
val rec
   zchckToWord64: intInf -> word64 = 
      (fn x_1105: intInf =>
       case x_1105 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord64 i)
	 | false =>
	   case (chckToWord64Aux i) of
	     Small[word64] w: word64 => (schckToWord64 w)
	   | Big[word64] (isneg: bool, extra: bool, ans: word64) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt64: intInf -> int64 = 
      (fn x_1106: intInf =>
       case x_1106 of
	 (i: intInf) => (idFromWord64ToInt64 (zchckToWord64 i)))
val rec 'a_760
   zextdToIntInf: 'a_760 -> 'a_760 = 
      (fn x_1107: 'a_760 =>
       case x_1107 of
	 (ii: 'a_760) => ii)
val rec 'a_761
   sextdToIntInf: 'a_761 -> 'a_761 = 
      (fn x_1108: 'a_761 =>
       case x_1108 of
	 (ii: 'a_761) => ii)
val rec 'a_762
   castToIntInf: 'a_762 -> 'a_762 = 
      (fn x_1109: 'a_762 =>
       case x_1109 of
	 (ii: 'a_762) => ii)
val rec 'a_763
   zchckToIntInf: 'a_763 -> 'a_763 = 
      (fn x_1110: 'a_763 =>
       case x_1110 of
	 (ii: 'a_763) => ii)
val rec 'a_764
   schckToIntInf: 'a_764 -> 'a_764 = 
      (fn x_1111: 'a_764 =>
       case x_1111 of
	 (ii: 'a_764) => ii)
val bytesPerMPLimb: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerCounter: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerLength: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerHeader: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerArrayHeader: word64 =
   (+ (bytesPerCounter, (+ (bytesPerLength, bytesPerHeader))))
val rec
   reserve: int64 * int64 -> word64 = 
      (fn x_1112: int64 * int64 =>
       case x_1112 of
	 ((num: int64, extra: int64)) =>
	 (+ ((* (bytesPerMPLimb, (zextdFromSeqIndex num))),
	     (+ ((* (bytesPerMPLimb, (zextdFromSeqIndex extra))),
		 (+ (bytesPerMPLimb,
		     (+ (bytesPerArrayHeader,
			 case align of
			   Align4 => 0x3 | Align8 => 0x7)))))))))
val badObjptrInt: int64 = (~>>? (minInt', 0x1))
val badObjptrWord: word64 = (idFromObjptrInt badObjptrInt)
val badObjptrWordTagged: word64 = (addTag badObjptrWord)
val negBadIntInf: intInf = (sextdFromObjptrInt (~ badObjptrInt))
val rec
   sameSignBit: word64 * word64 -> bool = 
      (fn x_1113: word64 * word64 =>
       case x_1113 of
	 ((lhs: word64, rhs: word64)) =>
	 (>= ((idToObjptrInt (xorb (lhs, rhs))), 0x0)))
val rec
   make: (int64 * int64 -> int64)
	 * (intInf * intInf * word64 -> intInf)
	 * (int64 * int64 -> int64)
	 * int64
	 -> intInf * intInf -> intInf = 
      (fn x_1114: (int64 * int64 -> int64)
		  * (intInf * intInf * word64 -> intInf)
		  * (int64 * int64 -> int64)
		  * int64 =>
       (fn x_1115: intInf * intInf =>
	case (x_1114, x_1115) of
	  ((smallOp: int64 * int64 -> int64,
	    bigOp: intInf * intInf * word64 -> intInf,
	    limbsFn: int64 * int64 -> int64,
	    extra: int64),
	   (lhs: intInf, rhs: intInf)) =>
	  let val res: intInf Primitive.Option.t =
		 case (areSmall (lhs, rhs)) of
		   true =>
		   let val lhsw: word64 = (dropTagCoerce lhs)
		       val lhsi: int64 = (idToObjptrInt lhsw)
		       val rhsw: word64 = (dropTagCoerce rhs)
		       val rhsi: int64 = (idToObjptrInt rhsw)
		       val ansi: int64 = (smallOp (lhsi, rhsi))
		       val answ: word64 = (idFromObjptrInt ansi)
		       val ans: word64 = (addTag answ)
		   in
		      case (sameSignBit (ans, answ)) of
			true => (SOME[intInf] (fromWord ans))
		      | false => NONE[intInf]
		   end
		   handle x_1116 => case x_1116 of
				      Overflow => NONE[intInf]
		 | false => NONE[intInf]
	  in
	     case res of
	       NONE[intInf] =>
	       (bigOp (lhs,
		       rhs,
		       (reserve ((limbsFn ((numLimbs lhs), (numLimbs rhs))),
				 extra))))
	     | SOME[intInf] i: intInf => i
	  end))
val bigAdd: intInf * intInf -> intInf = (make (+!, +, max, 0x1))
val bigMul: intInf * intInf -> intInf = (make (*!, *, +, 0x0))
val rec
   bigNeg: intInf -> intInf = 
      (fn x_1117: intInf =>
       case x_1117 of
	 (arg: intInf) =>
	 case (isSmall arg) of
	   true =>
	   let val argw: word64 = (toWord arg)
	   in
	      case (= (word64) (argw, badObjptrWordTagged)) of
		true => negBadIntInf | false => (fromWord (- (0x2, argw)))
	   end
	 | false => (~ (arg, (reserve ((numLimbs arg), 0x1)))))
val rec
   bigQuot: intInf * intInf -> intInf = 
      (fn x_1118: intInf * intInf =>
       case x_1118 of
	 ((num: intInf, den: intInf)) =>
	 case (areSmall (num, den)) of
	   true =>
	   let val numw: word64 = (dropTagCoerce num)
	       val numi: int64 = (idToObjptrInt numw)
	       val denw: word64 = (dropTagCoerce den)
	       val deni: int64 = (idToObjptrInt denw)
	   in
	      case case (= (word64) (numw, badObjptrWord)) of
		     true => (= (int64) (deni, 0xFFFFFFFFFFFFFFFF))
		   | false => false of
		true => negBadIntInf
	      | false =>
		let val ansi: int64 = (quot (numi, deni))
		    val answ: word64 = (idFromObjptrInt ansi)
		    val ans: word64 = (addTag answ)
		in
		   (fromWord ans)
		end
	   end
	 | false =>
	   let val nlimbs: int64 = (numLimbs num)
	       val dlimbs: int64 = (numLimbs den)
	   in
	      case (< (nlimbs, dlimbs)) of
		true => zero
	      | false =>
		case (= (intInf) (den, zero)) of
		  true => raise Div
		| false =>
		  (quot (num, den, (reserve ((- (nlimbs, dlimbs)), 0x2))))
	   end)
val rec 'a
   make: (int64 * int64 -> 'a) * (int32 * int32 -> 'a) -> intInf * intInf -> 'a = 
      (fn x_1119: (int64 * int64 -> 'a) * (int32 * int32 -> 'a) =>
       (fn x_1120: intInf * intInf =>
	case (x_1119, x_1120) of
	  ((smallTest: int64 * int64 -> 'a, int32Test: int32 * int32 -> 'a),
	   (lhs: intInf, rhs: intInf)) =>
	  case (areSmall (lhs, rhs)) of
	    true =>
	    (smallTest ((idToObjptrInt (toWord lhs)),
			(idToObjptrInt (toWord rhs))))
	  | false => (int32Test ((compare (lhs, rhs)), 0x0))))
val bigLT: intInf * intInf -> bool = (make (bool) (<, <))
val rec
   mkBigCvt: {base: int32, smallCvt: int64 -> string} -> intInf -> string = 
      (fn x_1121: {base: int32, smallCvt: int64 -> string} =>
       (fn x_1122: intInf =>
	case (x_1121, x_1122) of
	  ({base = base: int32, smallCvt = smallCvt: int64 -> string},
	   arg: intInf) =>
	  case (isSmall arg) of
	    true => (smallCvt (dropTagCoerceInt arg))
	  | false =>
	    let val bpd: int32 = (log2 base)
		val bpl: int32 = sizeInBits
		val dpl: int32 =
		   (+ ((quot (bpl, bpd)),
		       case (= (int32) ((mod (bpl, bpd)), 0x0)) of
			 true => 0x0 | false => 0x1))
		val bytes: word64 =
		   (+ ((+ (bytesPerArrayHeader,
			   (+ (0x1, case align of Align4 => 0x3 | Align8 => 0x7)))),
		       (* ((zextdFromInt32 dpl),
			   (zextdFromSeqIndex (numLimbs arg))))))
	    in
	       (toString (arg, base, bytes))
	    end))
val 'a_765 precision: 'a_765 Primitive.Option.t = NONE['a_765]
val +: intInf * intInf -> intInf = bigAdd
val *: intInf * intInf -> intInf = bigMul
val ~: intInf -> intInf = bigNeg
val quot: intInf * intInf -> intInf = bigQuot
val <: intInf * intInf -> bool = bigLT
val mkCvt: {base: int32, smallCvt: int64 -> string} -> intInf -> string =
   mkBigCvt
val zextdFromInt8ToIntInf: int8 -> intInf = zextdFromInt8
val zextdFromInt16ToIntInf: int16 -> intInf = zextdFromInt16
val zextdFromInt32ToIntInf: int32 -> intInf = zextdFromInt32
val zextdFromInt64ToIntInf: int64 -> intInf = zextdFromInt64
val zextdFromWord8ToIntInf: word8 -> intInf = zextdFromWord8
val zextdFromWord16ToIntInf: word16 -> intInf = zextdFromWord16
val zextdFromWord32ToIntInf: word32 -> intInf = zextdFromWord32
val zextdFromWord64ToIntInf: word64 -> intInf = zextdFromWord64
val zextdFromIntInfToInt8: intInf -> int8 = zextdToInt8
val zextdFromIntInfToInt16: intInf -> int16 = zextdToInt16
val zextdFromIntInfToInt32: intInf -> int32 = zextdToInt32
val zextdFromIntInfToInt64: intInf -> int64 = zextdToInt64
val zextdFromIntInfToWord8: intInf -> word8 = zextdToWord8
val zextdFromIntInfToWord16: intInf -> word16 = zextdToWord16
val zextdFromIntInfToWord32: intInf -> word32 = zextdToWord32
val zextdFromIntInfToWord64: intInf -> word64 = zextdToWord64
val sextdFromInt8ToIntInf: int8 -> intInf = sextdFromInt8
val sextdFromInt16ToIntInf: int16 -> intInf = sextdFromInt16
val sextdFromInt32ToIntInf: int32 -> intInf = sextdFromInt32
val sextdFromInt64ToIntInf: int64 -> intInf = sextdFromInt64
val sextdFromWord8ToIntInf: word8 -> intInf = sextdFromWord8
val sextdFromWord16ToIntInf: word16 -> intInf = sextdFromWord16
val sextdFromWord32ToIntInf: word32 -> intInf = sextdFromWord32
val sextdFromWord64ToIntInf: word64 -> intInf = sextdFromWord64
val sextdFromIntInfToInt8: intInf -> int8 = sextdToInt8
val sextdFromIntInfToInt16: intInf -> int16 = sextdToInt16
val sextdFromIntInfToInt32: intInf -> int32 = sextdToInt32
val sextdFromIntInfToInt64: intInf -> int64 = sextdToInt64
val sextdFromIntInfToWord8: intInf -> word8 = sextdToWord8
val sextdFromIntInfToWord16: intInf -> word16 = sextdToWord16
val sextdFromIntInfToWord32: intInf -> word32 = sextdToWord32
val sextdFromIntInfToWord64: intInf -> word64 = sextdToWord64
val castFromInt8ToIntInf: int8 -> intInf = castFromInt8
val castFromInt16ToIntInf: int16 -> intInf = castFromInt16
val castFromInt32ToIntInf: int32 -> intInf = castFromInt32
val castFromInt64ToIntInf: int64 -> intInf = castFromInt64
val castFromWord8ToIntInf: word8 -> intInf = castFromWord8
val castFromWord16ToIntInf: word16 -> intInf = castFromWord16
val castFromWord32ToIntInf: word32 -> intInf = castFromWord32
val castFromWord64ToIntInf: word64 -> intInf = castFromWord64
val castFromIntInfToInt8: intInf -> int8 = castToInt8
val castFromIntInfToInt16: intInf -> int16 = castToInt16
val castFromIntInfToInt32: intInf -> int32 = castToInt32
val castFromIntInfToInt64: intInf -> int64 = castToInt64
val castFromIntInfToWord8: intInf -> word8 = castToWord8
val castFromIntInfToWord16: intInf -> word16 = castToWord16
val castFromIntInfToWord32: intInf -> word32 = castToWord32
val castFromIntInfToWord64: intInf -> word64 = castToWord64
val zchckFromInt8ToIntInf: int8 -> intInf = zchckFromInt8
val zchckFromInt16ToIntInf: int16 -> intInf = zchckFromInt16
val zchckFromInt32ToIntInf: int32 -> intInf = zchckFromInt32
val zchckFromInt64ToIntInf: int64 -> intInf = zchckFromInt64
val zchckFromWord8ToIntInf: word8 -> intInf = zchckFromWord8
val zchckFromWord16ToIntInf: word16 -> intInf = zchckFromWord16
val zchckFromWord32ToIntInf: word32 -> intInf = zchckFromWord32
val zchckFromWord64ToIntInf: word64 -> intInf = zchckFromWord64
val zchckFromIntInfToInt8: intInf -> int8 = zchckToInt8
val zchckFromIntInfToInt16: intInf -> int16 = zchckToInt16
val zchckFromIntInfToInt32: intInf -> int32 = zchckToInt32
val zchckFromIntInfToInt64: intInf -> int64 = zchckToInt64
val zchckFromIntInfToWord8: intInf -> word8 = zchckToWord8
val zchckFromIntInfToWord16: intInf -> word16 = zchckToWord16
val zchckFromIntInfToWord32: intInf -> word32 = zchckToWord32
val zchckFromIntInfToWord64: intInf -> word64 = zchckToWord64
val schckFromInt8ToIntInf: int8 -> intInf = schckFromInt8
val schckFromInt16ToIntInf: int16 -> intInf = schckFromInt16
val schckFromInt32ToIntInf: int32 -> intInf = schckFromInt32
val schckFromInt64ToIntInf: int64 -> intInf = schckFromInt64
val schckFromWord8ToIntInf: word8 -> intInf = schckFromWord8
val schckFromWord16ToIntInf: word16 -> intInf = schckFromWord16
val schckFromWord32ToIntInf: word32 -> intInf = schckFromWord32
val schckFromWord64ToIntInf: word64 -> intInf = schckFromWord64
val schckFromIntInfToInt8: intInf -> int8 = schckToInt8
val schckFromIntInfToInt16: intInf -> int16 = schckToInt16
val schckFromIntInfToInt32: intInf -> int32 = schckToInt32
val schckFromIntInfToInt64: intInf -> int64 = schckToInt64
val schckFromIntInfToWord8: intInf -> word8 = schckToWord8
val schckFromIntInfToWord16: intInf -> word16 = schckToWord16
val schckFromIntInfToWord32: intInf -> word32 = schckToWord32
val schckFromIntInfToWord64: intInf -> word64 = schckToWord64
val zextdFromIntInf: intInf -> int8 = zextdFromIntInfToInt8
val zextdToIntInf: int8 -> intInf = zextdFromInt8ToIntInf
val sextdFromIntInf: intInf -> int8 = sextdFromIntInfToInt8
val sextdToIntInf: int8 -> intInf = sextdFromInt8ToIntInf
val castFromIntInf: intInf -> int8 = castFromIntInfToInt8
val castToIntInf: int8 -> intInf = castFromInt8ToIntInf
val zchckFromIntInf: intInf -> int8 = zchckFromIntInfToInt8
val zchckToIntInf: int8 -> intInf = zchckFromInt8ToIntInf
val schckFromIntInf: intInf -> int8 = schckFromIntInfToInt8
val schckToIntInf: int8 -> intInf = schckFromInt8ToIntInf
val zextdFromIntInf: intInf -> int16 = zextdFromIntInfToInt16
val zextdToIntInf: int16 -> intInf = zextdFromInt16ToIntInf
val sextdFromIntInf: intInf -> int16 = sextdFromIntInfToInt16
val sextdToIntInf: int16 -> intInf = sextdFromInt16ToIntInf
val castFromIntInf: intInf -> int16 = castFromIntInfToInt16
val castToIntInf: int16 -> intInf = castFromInt16ToIntInf
val zchckFromIntInf: intInf -> int16 = zchckFromIntInfToInt16
val zchckToIntInf: int16 -> intInf = zchckFromInt16ToIntInf
val schckFromIntInf: intInf -> int16 = schckFromIntInfToInt16
val schckToIntInf: int16 -> intInf = schckFromInt16ToIntInf
val zextdFromIntInf: intInf -> int32 = zextdFromIntInfToInt32
val zextdToIntInf: int32 -> intInf = zextdFromInt32ToIntInf
val sextdFromIntInf: intInf -> int32 = sextdFromIntInfToInt32
val sextdToIntInf: int32 -> intInf = sextdFromInt32ToIntInf
val castFromIntInf: intInf -> int32 = castFromIntInfToInt32
val castToIntInf: int32 -> intInf = castFromInt32ToIntInf
val zchckFromIntInf: intInf -> int32 = zchckFromIntInfToInt32
val zchckToIntInf: int32 -> intInf = zchckFromInt32ToIntInf
val schckFromIntInf: intInf -> int32 = schckFromIntInfToInt32
val schckToIntInf: int32 -> intInf = schckFromInt32ToIntInf
val zextdFromIntInf: intInf -> int64 = zextdFromIntInfToInt64
val zextdToIntInf: int64 -> intInf = zextdFromInt64ToIntInf
val sextdFromIntInf: intInf -> int64 = sextdFromIntInfToInt64
val sextdToIntInf: int64 -> intInf = sextdFromInt64ToIntInf
val castFromIntInf: intInf -> int64 = castFromIntInfToInt64
val castToIntInf: int64 -> intInf = castFromInt64ToIntInf
val zchckFromIntInf: intInf -> int64 = zchckFromIntInfToInt64
val zchckToIntInf: int64 -> intInf = zchckFromInt64ToIntInf
val schckFromIntInf: intInf -> int64 = schckFromIntInfToInt64
val schckToIntInf: int64 -> intInf = schckFromInt64ToIntInf
val zextdFromIntInf: intInf -> word8 = zextdFromIntInfToWord8
val zextdToIntInf: word8 -> intInf = zextdFromWord8ToIntInf
val sextdFromIntInf: intInf -> word8 = sextdFromIntInfToWord8
val sextdToIntInf: word8 -> intInf = sextdFromWord8ToIntInf
val castFromIntInf: intInf -> word8 = castFromIntInfToWord8
val castToIntInf: word8 -> intInf = castFromWord8ToIntInf
val zchckFromIntInf: intInf -> word8 = zchckFromIntInfToWord8
val zchckToIntInf: word8 -> intInf = zchckFromWord8ToIntInf
val schckFromIntInf: intInf -> word8 = schckFromIntInfToWord8
val schckToIntInf: word8 -> intInf = schckFromWord8ToIntInf
val zextdFromIntInf: intInf -> word16 = zextdFromIntInfToWord16
val zextdToIntInf: word16 -> intInf = zextdFromWord16ToIntInf
val sextdFromIntInf: intInf -> word16 = sextdFromIntInfToWord16
val sextdToIntInf: word16 -> intInf = sextdFromWord16ToIntInf
val castFromIntInf: intInf -> word16 = castFromIntInfToWord16
val castToIntInf: word16 -> intInf = castFromWord16ToIntInf
val zchckFromIntInf: intInf -> word16 = zchckFromIntInfToWord16
val zchckToIntInf: word16 -> intInf = zchckFromWord16ToIntInf
val schckFromIntInf: intInf -> word16 = schckFromIntInfToWord16
val schckToIntInf: word16 -> intInf = schckFromWord16ToIntInf
val zextdFromIntInf: intInf -> word32 = zextdFromIntInfToWord32
val zextdToIntInf: word32 -> intInf = zextdFromWord32ToIntInf
val sextdFromIntInf: intInf -> word32 = sextdFromIntInfToWord32
val sextdToIntInf: word32 -> intInf = sextdFromWord32ToIntInf
val castFromIntInf: intInf -> word32 = castFromIntInfToWord32
val castToIntInf: word32 -> intInf = castFromWord32ToIntInf
val zchckFromIntInf: intInf -> word32 = zchckFromIntInfToWord32
val zchckToIntInf: word32 -> intInf = zchckFromWord32ToIntInf
val schckFromIntInf: intInf -> word32 = schckFromIntInfToWord32
val schckToIntInf: word32 -> intInf = schckFromWord32ToIntInf
val zextdFromIntInf: intInf -> word64 = zextdFromIntInfToWord64
val zextdToIntInf: word64 -> intInf = zextdFromWord64ToIntInf
val sextdFromIntInf: intInf -> word64 = sextdFromIntInfToWord64
val sextdToIntInf: word64 -> intInf = sextdFromWord64ToIntInf
val castFromIntInf: intInf -> word64 = castFromIntInfToWord64
val castToIntInf: word64 -> intInf = castFromWord64ToIntInf
val zchckFromIntInf: intInf -> word64 = zchckFromIntInfToWord64
val zchckToIntInf: word64 -> intInf = zchckFromWord64ToIntInf
val schckFromIntInf: intInf -> word64 = schckFromIntInfToWord64
val schckToIntInf: word64 -> intInf = schckFromWord64ToIntInf
val zextdToIntInf_0: intInf -> intInf = zextdToIntInf (intInf)
val zextdFromIntInf_0: intInf -> intInf = zextdFromIntInf (intInf)
val zchckToIntInf_0: intInf -> intInf = zchckToIntInf (intInf)
val zchckFromIntInf_0: intInf -> intInf = zchckFromIntInf (intInf)
val sextdToIntInf_0: intInf -> intInf = sextdToIntInf (intInf)
val sextdFromIntInf_0: intInf -> intInf = sextdFromIntInf (intInf)
val schckToIntInf_0: intInf -> intInf = schckToIntInf (intInf)
val schckFromIntInf_0: intInf -> intInf = schckFromIntInf (intInf)
val precision_0: int32 Primitive.Option.t = precision (int32)
val castToIntInf_0: intInf -> intInf = castToIntInf (intInf)
val castFromIntInf_0: intInf -> intInf = castFromIntInf (intInf)
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt64: int64 -> int8 = zextdFromInt64
val fIntInf: intInf -> int8 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt64: int8 -> int64 = zextdToInt64
val fIntInf: int8 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt64: int64 -> int8 = sextdFromInt64
val fIntInf: intInf -> int8 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt64: int8 -> int64 = sextdToInt64
val fIntInf: int8 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt64: int64 -> int8 = castFromInt64
val fIntInf: intInf -> int8 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt64: int8 -> int64 = castToInt64
val fIntInf: int8 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt64: int64 -> int8 = zchckFromInt64
val fIntInf: intInf -> int8 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt64: int8 -> int64 = zchckToInt64
val fIntInf: int8 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt64: int64 -> int8 = schckFromInt64
val fIntInf: intInf -> int8 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt64: int8 -> int64 = schckToInt64
val fIntInf: int8 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt32: int32 -> int8 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt32: int8 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt32: int32 -> int8 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt32: int8 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt32: int32 -> int8 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt32: int8 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt32: int32 -> int8 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt32: int8 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt32: int32 -> int8 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt32: int8 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt32: int32 -> int8 = zextdFromInt32
val fInt64: int64 -> int8 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt32: int8 -> int32 = zextdToInt32
val fInt64: int8 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt32: int32 -> int8 = sextdFromInt32
val fInt64: int64 -> int8 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt32: int8 -> int32 = sextdToInt32
val fInt64: int8 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt32: int32 -> int8 = castFromInt32
val fInt64: int64 -> int8 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt32: int8 -> int32 = castToInt32
val fInt64: int8 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt32: int32 -> int8 = zchckFromInt32
val fInt64: int64 -> int8 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt32: int8 -> int32 = zchckToInt32
val fInt64: int8 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt32: int32 -> int8 = schckFromInt32
val fInt64: int64 -> int8 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt32: int8 -> int32 = schckToInt32
val fInt64: int8 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord64: word64 -> int8 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord64: int8 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord64: word64 -> int8 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord64: int8 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord64: word64 -> int8 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord64: int8 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord64: word64 -> int8 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord64: int8 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord64: word64 -> int8 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord64: int8 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord32: word32 -> int8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord32: int8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord32: word32 -> int8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord32: int8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord32: word32 -> int8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord32: int8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord32: word32 -> int8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord32: int8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord32: word32 -> int8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord32: int8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord32: word32 -> int8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord32: int8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord32: word32 -> int8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord32: int8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord32: word32 -> int8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord32: int8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord32: word32 -> int8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord32: int8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord32: word32 -> int8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord32: int8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt64: int64 -> int16 = zextdFromInt64
val fIntInf: intInf -> int16 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt64: int16 -> int64 = zextdToInt64
val fIntInf: int16 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt64: int64 -> int16 = sextdFromInt64
val fIntInf: intInf -> int16 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt64: int16 -> int64 = sextdToInt64
val fIntInf: int16 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt64: int64 -> int16 = castFromInt64
val fIntInf: intInf -> int16 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt64: int16 -> int64 = castToInt64
val fIntInf: int16 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt64: int64 -> int16 = zchckFromInt64
val fIntInf: intInf -> int16 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt64: int16 -> int64 = zchckToInt64
val fIntInf: int16 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt64: int64 -> int16 = schckFromInt64
val fIntInf: intInf -> int16 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt64: int16 -> int64 = schckToInt64
val fIntInf: int16 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt32: int32 -> int16 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt32: int16 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt32: int32 -> int16 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt32: int16 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt32: int32 -> int16 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt32: int16 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt32: int32 -> int16 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt32: int16 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt32: int32 -> int16 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt32: int16 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt32: int32 -> int16 = zextdFromInt32
val fInt64: int64 -> int16 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt32: int16 -> int32 = zextdToInt32
val fInt64: int16 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt32: int32 -> int16 = sextdFromInt32
val fInt64: int64 -> int16 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt32: int16 -> int32 = sextdToInt32
val fInt64: int16 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt32: int32 -> int16 = castFromInt32
val fInt64: int64 -> int16 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt32: int16 -> int32 = castToInt32
val fInt64: int16 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt32: int32 -> int16 = zchckFromInt32
val fInt64: int64 -> int16 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt32: int16 -> int32 = zchckToInt32
val fInt64: int16 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt32: int32 -> int16 = schckFromInt32
val fInt64: int64 -> int16 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt32: int16 -> int32 = schckToInt32
val fInt64: int16 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord64: word64 -> int16 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord64: int16 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord64: word64 -> int16 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord64: int16 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord64: word64 -> int16 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord64: int16 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord64: word64 -> int16 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord64: int16 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord64: word64 -> int16 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord64: int16 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord32: word32 -> int16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord32: int16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord32: word32 -> int16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord32: int16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord32: word32 -> int16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord32: int16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord32: word32 -> int16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord32: int16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord32: word32 -> int16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord32: int16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord32: word32 -> int16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord32: int16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord32: word32 -> int16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord32: int16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord32: word32 -> int16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord32: int16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord32: word32 -> int16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord32: int16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord32: word32 -> int16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord32: int16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt64: int64 -> int32 = zextdFromInt64
val fIntInf: intInf -> int32 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val fInt64: int32 -> int64 = zextdToInt64
val fIntInf: int32 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zextdToInt: int32 -> int32 = f
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt64: int64 -> int32 = sextdFromInt64
val fIntInf: intInf -> int32 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt64: int32 -> int64 = sextdToInt64
val fIntInf: int32 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt64: int64 -> int32 = castFromInt64
val fIntInf: intInf -> int32 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt64: int32 -> int64 = castToInt64
val fIntInf: int32 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt64: int64 -> int32 = zchckFromInt64
val fIntInf: intInf -> int32 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt64: int32 -> int64 = zchckToInt64
val fIntInf: int32 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val fInt64: int64 -> int32 = schckFromInt64
val fIntInf: intInf -> int32 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckFromInt: int32 -> int32 = f
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val fInt64: int32 -> int64 = schckToInt64
val fIntInf: int32 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckToInt: int32 -> int32 = f
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt32: int32 -> int32 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt32: int32 -> int32 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt32: int32 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt32: int32 -> int32 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt32: int32 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt32: int32 -> int32 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt32: int32 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt32: int32 -> int32 = zextdFromInt32
val fInt64: int64 -> int32 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val fInt64: int32 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt32: int32 -> int32 = sextdFromInt32
val fInt64: int64 -> int32 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt32: int32 -> int32 = sextdToInt32
val fInt64: int32 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt32: int32 -> int32 = castFromInt32
val fInt64: int64 -> int32 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt32: int32 -> int32 = castToInt32
val fInt64: int32 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt32: int32 -> int32 = zchckFromInt32
val fInt64: int64 -> int32 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt32: int32 -> int32 = zchckToInt32
val fInt64: int32 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val fInt64: int64 -> int32 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val fInt64: int32 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord64: word64 -> int32 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord64: int32 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord64: word64 -> int32 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord64: int32 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord64: word64 -> int32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord64: int32 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord64: word64 -> int32 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord64: int32 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord64: word64 -> int32 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord64: int32 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord32: word32 -> int32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord32: int32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord32: word32 -> int32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord32: int32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord32: word32 -> int32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord32: int32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord32: word32 -> int32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord32: int32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord32: word32 -> int32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord32: int32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord32: word32 -> int32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord32: int32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord32: word32 -> int32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord32: int32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord32: word32 -> int32 = castFromWord32
val fWord64: word64 -> int32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord32
val f: word64 -> int32 = fWord64
val castFromSysWord: word64 -> int32 = f
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord32: int32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord32: word32 -> int32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord32: int32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord32: word32 -> int32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord32: int32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt64: int64 -> int64 = zextdFromInt64
val fIntInf: intInf -> int64 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt64: int64 -> int64 = zextdToInt64
val fIntInf: int64 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt64: int64 -> int64 = sextdFromInt64
val fIntInf: intInf -> int64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt64: int64 -> int64 = sextdToInt64
val fIntInf: int64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt64: int64 -> int64 = castFromInt64
val fIntInf: intInf -> int64 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt64: int64 -> int64 = castToInt64
val fIntInf: int64 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt64: int64 -> int64 = zchckFromInt64
val fIntInf: intInf -> int64 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt64: int64 -> int64 = zchckToInt64
val fIntInf: int64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val fIntInf: intInf -> int64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val schckFromInt: int32 -> int64 = f
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckToInt: int64 -> int32 = f
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt32: int32 -> int64 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt32: int64 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt32: int32 -> int64 = castFromInt32
val fInt64: int64 -> int64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> int64 = fInt64
val castFromFixedInt: int64 -> int64 = f
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt32: int64 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt32: int32 -> int64 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt32: int64 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt32: int32 -> int64 = zextdFromInt32
val fInt64: int64 -> int64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt32: int64 -> int32 = zextdToInt32
val fInt64: int64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val fInt64: int64 -> int64 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val fInt64: int64 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt32: int32 -> int64 = castFromInt32
val fInt64: int64 -> int64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt32: int64 -> int32 = castToInt32
val fInt64: int64 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt32: int32 -> int64 = zchckFromInt32
val fInt64: int64 -> int64 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt32: int64 -> int32 = zchckToInt32
val fInt64: int64 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val f: int64 -> intInf = fIntInf
val schckToLargeInt: int64 -> intInf = f
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord64: word64 -> int64 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord64: int64 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord64: word64 -> int64 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord64: int64 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord64: word64 -> int64 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord64: int64 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord64: word64 -> int64 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord64: int64 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord64: word64 -> int64 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord64: int64 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord32: word32 -> int64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord32: int64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord32: word32 -> int64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord32: int64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord32: word32 -> int64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord32: int64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord32: word32 -> int64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord32: int64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord32: word32 -> int64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord32: int64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord32: word32 -> int64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord32: int64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord32: word32 -> int64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord32: int64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord32: word32 -> int64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord32: int64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord32: word32 -> int64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord32: int64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord32: word32 -> int64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord32: int64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt64: int64 -> intInf = zextdFromInt64
val fIntInf: intInf -> intInf = zextdFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt64: intInf -> int64 = zextdToInt64
val fIntInf: intInf -> intInf = zextdToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt64: int64 -> intInf = sextdFromInt64
val fIntInf: intInf -> intInf = sextdFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt64: intInf -> int64 = sextdToInt64
val fIntInf: intInf -> intInf = sextdToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt64: int64 -> intInf = castFromInt64
val fIntInf: intInf -> intInf = castFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt64: intInf -> int64 = castToInt64
val fIntInf: intInf -> intInf = castToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt64: int64 -> intInf = zchckFromInt64
val fIntInf: intInf -> intInf = zchckFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt64: intInf -> int64 = zchckToInt64
val fIntInf: intInf -> intInf = zchckToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt64: int64 -> intInf = schckFromInt64
val fIntInf: intInf -> intInf = schckFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt64: intInf -> int64 = schckToInt64
val fIntInf: intInf -> intInf = schckToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt32: int32 -> intInf = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt32: intInf -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt32: intInf -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt32: int32 -> intInf = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt32: intInf -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt32: int32 -> intInf = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt32: intInf -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt32: int32 -> intInf = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt32: intInf -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt32: int32 -> intInf = zextdFromInt32
val fInt64: int64 -> intInf = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt32: intInf -> int32 = zextdToInt32
val fInt64: intInf -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val fInt64: int64 -> intInf = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt32: intInf -> int32 = sextdToInt32
val fInt64: intInf -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt32: int32 -> intInf = castFromInt32
val fInt64: int64 -> intInf = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt32: intInf -> int32 = castToInt32
val fInt64: intInf -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt32: int32 -> intInf = zchckFromInt32
val fInt64: int64 -> intInf = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt32: intInf -> int32 = zchckToInt32
val fInt64: intInf -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt32: int32 -> intInf = schckFromInt32
val fInt64: int64 -> intInf = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt32: intInf -> int32 = schckToInt32
val fInt64: intInf -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord64: word64 -> intInf = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord64: intInf -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord64: word64 -> intInf = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord64: intInf -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord64: word64 -> intInf = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord64: intInf -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord64: word64 -> intInf = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord64: intInf -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord64: word64 -> intInf = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord64: intInf -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord32: word32 -> intInf = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord32: intInf -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord32: word32 -> intInf = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord32: intInf -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord32: word32 -> intInf = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord32: intInf -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord32: word32 -> intInf = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord32: intInf -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord32: word32 -> intInf = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord32: intInf -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord32: word32 -> intInf = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord32: intInf -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord32: word32 -> intInf = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord32: intInf -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord32: word32 -> intInf = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord32: intInf -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord32: word32 -> intInf = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord32: intInf -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord32: word32 -> intInf = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord32: intInf -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt64: int64 -> word8 = zextdFromInt64
val fIntInf: intInf -> word8 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt64: word8 -> int64 = zextdToInt64
val fIntInf: word8 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt64: int64 -> word8 = sextdFromInt64
val fIntInf: intInf -> word8 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt64: word8 -> int64 = sextdToInt64
val fIntInf: word8 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt64: int64 -> word8 = castFromInt64
val fIntInf: intInf -> word8 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt64: word8 -> int64 = castToInt64
val fIntInf: word8 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt64: int64 -> word8 = zchckFromInt64
val fIntInf: intInf -> word8 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt64: word8 -> int64 = zchckToInt64
val fIntInf: word8 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt64: int64 -> word8 = schckFromInt64
val fIntInf: intInf -> word8 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt64: word8 -> int64 = schckToInt64
val fIntInf: word8 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt32: int32 -> word8 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt32: word8 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt32: int32 -> word8 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt32: word8 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt32: int32 -> word8 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt32: word8 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt32: int32 -> word8 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt32: word8 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt32: int32 -> word8 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt32: word8 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt32: int32 -> word8 = zextdFromInt32
val fInt64: int64 -> word8 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt32: word8 -> int32 = zextdToInt32
val fInt64: word8 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt32: int32 -> word8 = sextdFromInt32
val fInt64: int64 -> word8 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt32: word8 -> int32 = sextdToInt32
val fInt64: word8 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt32: int32 -> word8 = castFromInt32
val fInt64: int64 -> word8 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt32: word8 -> int32 = castToInt32
val fInt64: word8 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt32: int32 -> word8 = zchckFromInt32
val fInt64: int64 -> word8 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt32: word8 -> int32 = zchckToInt32
val fInt64: word8 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt32: int32 -> word8 = schckFromInt32
val fInt64: int64 -> word8 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt32: word8 -> int32 = schckToInt32
val fInt64: word8 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord64: word64 -> word8 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord64: word8 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord64: word64 -> word8 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord64: word8 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord64: word64 -> word8 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord64: word8 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord64: word64 -> word8 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord64: word8 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord64: word64 -> word8 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord64: word8 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord32: word32 -> word8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord32: word8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord32: word32 -> word8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord32: word8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord32: word32 -> word8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord32: word8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord32: word32 -> word8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord32: word8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord32: word32 -> word8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord32: word8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord32: word32 -> word8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord32: word8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord32: word32 -> word8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord32: word8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord32: word32 -> word8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord32: word8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord32: word32 -> word8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord32: word8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord32: word32 -> word8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord32: word8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt64: int64 -> word16 = zextdFromInt64
val fIntInf: intInf -> word16 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt64: word16 -> int64 = zextdToInt64
val fIntInf: word16 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt64: int64 -> word16 = sextdFromInt64
val fIntInf: intInf -> word16 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt64: word16 -> int64 = sextdToInt64
val fIntInf: word16 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt64: int64 -> word16 = castFromInt64
val fIntInf: intInf -> word16 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt64: word16 -> int64 = castToInt64
val fIntInf: word16 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt64: int64 -> word16 = zchckFromInt64
val fIntInf: intInf -> word16 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt64: word16 -> int64 = zchckToInt64
val fIntInf: word16 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt64: int64 -> word16 = schckFromInt64
val fIntInf: intInf -> word16 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt64: word16 -> int64 = schckToInt64
val fIntInf: word16 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt32: int32 -> word16 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt32: word16 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt32: int32 -> word16 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt32: word16 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt32: int32 -> word16 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt32: word16 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt32: int32 -> word16 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt32: int32 -> word16 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt32: word16 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt32: int32 -> word16 = zextdFromInt32
val fInt64: int64 -> word16 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt32: word16 -> int32 = zextdToInt32
val fInt64: word16 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt32: int32 -> word16 = sextdFromInt32
val fInt64: int64 -> word16 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt32: word16 -> int32 = sextdToInt32
val fInt64: word16 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt32: int32 -> word16 = castFromInt32
val fInt64: int64 -> word16 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt32: word16 -> int32 = castToInt32
val fInt64: word16 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt32: int32 -> word16 = zchckFromInt32
val fInt64: int64 -> word16 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val fInt64: word16 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt32: int32 -> word16 = schckFromInt32
val fInt64: int64 -> word16 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt32: word16 -> int32 = schckToInt32
val fInt64: word16 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord64: word64 -> word16 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord64: word16 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord64: word64 -> word16 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord64: word16 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord64: word64 -> word16 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord64: word16 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord64: word64 -> word16 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord64: word16 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord64: word64 -> word16 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord64: word16 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord32: word32 -> word16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord32: word16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord32: word32 -> word16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord32: word16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord32: word32 -> word16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord32: word16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord32: word32 -> word16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord32: word16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord32: word32 -> word16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord32: word16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord32: word32 -> word16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord32: word16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord32: word32 -> word16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord32: word16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord32: word32 -> word16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord32: word16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord32: word32 -> word16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord32: word16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord32: word32 -> word16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord32: word16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt64: int64 -> word32 = zextdFromInt64
val fIntInf: intInf -> word32 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt64: word32 -> int64 = zextdToInt64
val fIntInf: word32 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val fInt64: int64 -> word32 = sextdFromInt64
val fIntInf: intInf -> word32 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> word32 = fInt32
val _ = fInt64
val _ = fIntInf
val sextdFromInt: int32 -> word32 = f
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt64: word32 -> int64 = sextdToInt64
val fIntInf: word32 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt64: int64 -> word32 = castFromInt64
val fIntInf: intInf -> word32 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt64: word32 -> int64 = castToInt64
val fIntInf: word32 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt64: int64 -> word32 = zchckFromInt64
val fIntInf: intInf -> word32 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val fInt64: word32 -> int64 = zchckToInt64
val fIntInf: word32 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val f: word32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zchckToInt: word32 -> int32 = f
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt64: int64 -> word32 = schckFromInt64
val fIntInf: intInf -> word32 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt64: word32 -> int64 = schckToInt64
val fIntInf: word32 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt32: int32 -> word32 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt32: word32 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt32: word32 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt32: int32 -> word32 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt32: word32 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt32: int32 -> word32 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt32: int32 -> word32 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt32: word32 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt32: int32 -> word32 = zextdFromInt32
val fInt64: int64 -> word32 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt32: word32 -> int32 = zextdToInt32
val fInt64: word32 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val fInt64: int64 -> word32 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt32: word32 -> int32 = sextdToInt32
val fInt64: word32 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt32: int32 -> word32 = castFromInt32
val fInt64: int64 -> word32 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt32: word32 -> int32 = castToInt32
val fInt64: word32 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt32: int32 -> word32 = zchckFromInt32
val fInt64: int64 -> word32 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val fInt64: word32 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt32: int32 -> word32 = schckFromInt32
val fInt64: int64 -> word32 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt32: word32 -> int32 = schckToInt32
val fInt64: word32 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val fWord64: word64 -> word32 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val f: word32 -> word32 = fWord32
val _ = fWord64
val zextdFromWord: word32 -> word32 = f
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val fWord64: word32 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val f: word32 -> word32 = fWord32
val _ = fWord64
val zextdToWord: word32 -> word32 = f
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord64: word64 -> word32 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord64: word32 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord64: word64 -> word32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord64: word32 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord64: word64 -> word32 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord64: word32 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord64: word64 -> word32 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord64: word32 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord32: word32 -> word32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord32: word32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord32: word32 -> word32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord32: word32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord32: word32 -> word32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord32: word32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord32: word32 -> word32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord32: word32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord32: word32 -> word32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord32: word32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord32: word32 -> word32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord32: word32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord32: word32 -> word32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord32: word32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord32: word32 -> word32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord32: word32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt64: int64 -> word64 = zextdFromInt64
val fIntInf: intInf -> word64 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt64: word64 -> int64 = zextdToInt64
val fIntInf: word64 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val fInt64: int64 -> word64 = sextdFromInt64
val fIntInf: intInf -> word64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> word64 = fInt32
val _ = fInt64
val _ = fIntInf
val sextdFromInt: int32 -> word64 = f
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt64: word64 -> int64 = sextdToInt64
val fIntInf: word64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt64: int64 -> word64 = castFromInt64
val fIntInf: intInf -> word64 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt64: word64 -> int64 = castToInt64
val fIntInf: word64 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt64: int64 -> word64 = zchckFromInt64
val fIntInf: intInf -> word64 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val fInt64: word64 -> int64 = zchckToInt64
val fIntInf: word64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val f: word64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zchckToInt: word64 -> int32 = f
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt64: int64 -> word64 = schckFromInt64
val fIntInf: intInf -> word64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt64: word64 -> int64 = schckToInt64
val fIntInf: word64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt32: word64 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt32: int32 -> word64 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt32: word64 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt32: int32 -> word64 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt32: int32 -> word64 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt32: word64 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val fInt64: word64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val fInt64: int64 -> word64 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt32: word64 -> int32 = sextdToInt32
val fInt64: word64 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt32: int32 -> word64 = castFromInt32
val fInt64: int64 -> word64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt32: word64 -> int32 = castToInt32
val fInt64: word64 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt32: int32 -> word64 = zchckFromInt32
val fInt64: int64 -> word64 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val fInt64: word64 -> int64 = zchckToInt64
val fIntInf: word64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val f: word64 -> intInf = fIntInf
val zchckToLargeInt: word64 -> intInf = f
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt32: int32 -> word64 = schckFromInt32
val fInt64: int64 -> word64 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt32: word64 -> int32 = schckToInt32
val fInt64: word64 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord64: word64 -> word64 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord64: word64 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord64: word64 -> word64 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord64: word64 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord64: word64 -> word64 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord64: word64 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord64: word64 -> word64 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord64: word64 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord64: word64 -> word64 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord64: word64 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord32: word32 -> word64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord32: word64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord32: word32 -> word64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord32: word64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord32: word32 -> word64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord32: word64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord32: word32 -> word64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord32: word64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord32: word32 -> word64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord32: word64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord32: word32 -> word64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord32: word64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord32: word32 -> word64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord32: word64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord32: word32 -> word64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord32: word64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
exception Chr
exception Fail of string
val 'a_2059 !: 'a_2059 ref -> 'a_2059 = deref ('a_2059)
val 'a_2060 :=: 'a_2060 ref * 'a_2060 -> unit = assign ('a_2060)
val rec ('a_2063, 'a_2062, 'a_2061)
   o: ('a_2063 -> 'a_2062) * ('a_2061 -> 'a_2063) -> 'a_2061 -> 'a_2062 = 
      (fn x_1123: ('a_2063 -> 'a_2062) * ('a_2061 -> 'a_2063) =>
       (fn x_1124: 'a_2061 =>
	case (x_1123, x_1124) of
	  ((f: 'a_2063 -> 'a_2062, g: 'a_2061 -> 'a_2063), x: 'a_2061) =>
	  (f (g x))))
val rec 'a_2064
   before: 'a_2064 * unit -> 'a_2064 = 
      (fn x_1125: 'a_2064 * unit =>
       case x_1125 of
	 ((x: 'a_2064, ())) => x)
val rec 'a_2065
   ignore: 'a_2065 -> unit = 
      (fn x_1126: 'a_2065 =>
       case x_1126 of
	 (_) => ())
val exnName: exn -> string = name
val messagers: (exn -> string Primitive.Option.t) list ref =
   (ref[(exn -> string Primitive.Option.t) list] [])
val addExnMessager: (exn -> string Primitive.Option.t) -> unit =
   (fn x_1127: exn -> string Primitive.Option.t =>
    case x_1127 of
      f: exn -> string Primitive.Option.t =>
      (:= ((exn -> string Primitive.Option.t) list) (messagers,
						     (::[exn
							 -> string Primitive.Option.t] (f,
											(! ((exn
											     -> string Primitive.Option.t) list) messagers))))))
val rec
   exnMessage: exn -> string = 
      (fn x_1128: exn =>
       case x_1128 of
	 e: exn =>
	 let val rec
		find: (exn -> string Primitive.Option.t) list -> string = 
		   (fn x_1129: (exn -> string Primitive.Option.t) list =>
		    case x_1129 of
		      [] => (exnName e)
		    | ::[exn -> string Primitive.Option.t] (m: exn
							       -> string Primitive.Option.t,
							    ms: (exn
								 -> string Primitive.Option.t) list) =>
		      case (m e) of
			NONE[string] => (find ms) | SOME[string] s: string => s)
	 in
	    (find (! ((exn -> string Primitive.Option.t) list) messagers))
	 end)
val ('a, 'c, 'b) o_0: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = o ('b, 'c, 'a)
val 'a ignore_0: 'a -> unit = ignore ('a)
val 'a before_0: 'a * unit -> 'a = before ('a)
val 'a :=_0: 'a ref * 'a -> unit = := ('a)
val 'a !_0: 'a ref -> 'a = ! ('a)
val ('a, 'c, 'b) o_1: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = o_0 ('a, 'c, 'b)
val 'a ignore_1: 'a -> unit = ignore_0 ('a)
val 'a before_1: 'a * unit -> 'a = before_0 ('a)
val 'a :=_1: 'a ref * 'a -> unit = :=_0 ('a)
val 'a !_1: 'a ref -> 'a = !_0 ('a)
datatype 'a One.t = T of {more: unit -> 'a, static: 'a, staticIsInUse: bool ref}
val rec 'a_2066
   make: (unit -> 'a_2066) -> 'a_2066 One.t = 
      (fn x_1130: unit -> 'a_2066 =>
       case x_1130 of
	 (f: unit -> 'a_2066) =>
	 (T['a_2066] {more = f,
		      static = (f ()),
		      staticIsInUse = (ref[bool] false)}))
val rec ('a_2068, 'a_2067)
   use: 'a_2068 One.t * ('a_2068 -> 'a_2067) -> 'a_2067 = 
      (fn x_1131: 'a_2068 One.t * ('a_2068 -> 'a_2067) =>
       case x_1131 of
	 ((T['a_2068] {more = more: unit -> 'a_2068,
		       static = static: 'a_2068,
		       staticIsInUse = staticIsInUse: bool ref},
	   f: 'a_2068 -> 'a_2067)) =>
	 let val () = (atomicBegin ())
	     val b: bool = (!_1 (bool) staticIsInUse)
	     val d: 'a_2068 =
		case b of
		  true => (atomicEnd ()) ;(more ())
		| false =>
		  (:=_1 (bool) (staticIsInUse, true)) ;(atomicEnd ()) ;static
	 in
	    (wind_0 ('a_2067) ((fn x_1133: unit =>
				case x_1133 of
				  () => (f d)),
			       (fn x_1132: unit =>
				case x_1132 of
				  () =>
				  case b of
				    true => ()
				  | false =>
				    (:=_1 (bool) (staticIsInUse, false)))))
	 end)
val ('b, 'a) use_0: 'a One.t * ('a -> 'b) -> 'b = use ('a, 'b)
val 'a make_0: (unit -> 'a) -> 'a One.t = make ('a)
exception Option
val rec ('a_2073, 'a_2072)
   map: ('a_2073 -> 'a_2072)
	-> 'a_2073 Primitive.Option.t -> 'a_2072 Primitive.Option.t = 
      (fn x_1134: 'a_2073 -> 'a_2072 =>
       case x_1134 of
	 (f: 'a_2073 -> 'a_2072) =>
	 (fn x_1135: 'a_2073 Primitive.Option.t =>
	  case x_1135 of
	    NONE['a_2073] => NONE['a_2072]
	  | SOME['a_2073] a: 'a_2073 => (SOME['a_2072] (f a))))
val 'a_2088 valOf: 'a_2088 Primitive.Option.t -> 'a_2088 =
   (fn x_1136: 'a_2088 Primitive.Option.t =>
    case x_1136 of
      NONE['a_2088] => raise Option | SOME['a_2088] v: 'a_2088 => v)
val 'a valOf_0: 'a Primitive.Option.t -> 'a = valOf ('a)
val ('b, 'a) map_0: ('a -> 'b) -> 'a Primitive.Option.t -> 'b Primitive.Option.t =
   map ('a, 'b)
val 'a valOf_1: 'a Primitive.Option.t -> 'a = valOf_0 ('a)
exception Empty
val rec ('a_2099, 'a_2098)
   foldl: ('a_2099 * 'a_2098 -> 'a_2098) -> 'a_2098 -> 'a_2099 list -> 'a_2098 = 
      (fn x_1137: 'a_2099 * 'a_2098 -> 'a_2098 =>
       (fn x_1138: 'a_2098 =>
	(fn x_1139: 'a_2099 list =>
	 case (x_1137, x_1138, x_1139) of
	   (f: 'a_2099 * 'a_2098 -> 'a_2098, b: 'a_2098, l: 'a_2099 list) =>
	   let val rec
		  loop: 'a_2099 list * 'a_2098 -> 'a_2098 = 
		     (fn x_1140: 'a_2099 list * 'a_2098 =>
		      case x_1140 of
			((l: 'a_2099 list, b: 'a_2098)) =>
			case l of
			  [] => b
			| ::['a_2099] (x: 'a_2099, l: 'a_2099 list) =>
			  (loop (l, (f (x, b)))))
	   in
	      (loop (l, b))
	   end)))
val rec 'a_2100
   length: 'a_2100 list -> int32 = 
      (fn x_1141: 'a_2100 list =>
       case x_1141 of
	 (l: 'a_2100 list) =>
	 (((foldl ('a_2100, int32) (fn x_1142: 'a_2100 * int32 =>
				    case x_1142 of
				      (_, n: int32) => (+? (n, 0x1)))) 0x0) l))
val rec 'a_2101
   appendRev: 'a_2101 list * 'a_2101 list -> 'a_2101 list = 
      (fn x_1143: 'a_2101 list * 'a_2101 list =>
       case x_1143 of
	 ((l1: 'a_2101 list, l2: 'a_2101 list)) =>
	 (((foldl ('a_2101, 'a_2101 list) ::['a_2101]) l2) l1))
val rec 'a_2103
   rev: 'a_2103 list -> 'a_2103 list = 
      (fn x_1144: 'a_2103 list =>
       case x_1144 of
	 (l: 'a_2103 list) => (appendRev ('a_2103) (l, [])))
val rec 'a_2108
   app: ('a_2108 -> unit) -> 'a_2108 list -> unit = 
      (fn x_1145: 'a_2108 -> unit =>
       case x_1145 of
	 (f: 'a_2108 -> unit) =>
	 ((foldl ('a_2108, unit) (o_1 ('a_2108 * unit, unit, 'a_2108) (f,
								       (fn x_1146: 'a_2108
										   * unit =>
									case x_1146 of
									  {1 = #: 'a_2108} =>
									  #)))) ()))
val rec ('a_2110, 'a_2109)
   map: ('a_2110 -> 'a_2109) -> 'a_2110 list -> 'a_2109 list = 
      (fn x_1147: 'a_2110 -> 'a_2109 =>
       (fn x_1148: 'a_2110 list =>
	case (x_1147, x_1148) of
	  (f: 'a_2110 -> 'a_2109, l: 'a_2110 list) =>
	  (rev ('a_2109) (((foldl ('a_2110, 'a_2109 list) (fn x_1149: 'a_2110
								      * 'a_2109 list =>
							   case x_1149 of
							     (x: 'a_2110,
							      l: 'a_2109 list) =>
							     (::['a_2109] ((f x),
									   l)))) []) l))))
val rec 'a_2115
   find: ('a_2115 -> bool) -> 'a_2115 list -> 'a_2115 Primitive.Option.t = 
      (fn x_1150: 'a_2115 -> bool =>
       case x_1150 of
	 (pred: 'a_2115 -> bool) =>
	 let val rec
		loop: 'a_2115 list -> 'a_2115 Primitive.Option.t = 
		   (fn x_1151: 'a_2115 list =>
		    case x_1151 of
		      [] => NONE['a_2115]
		    | ::['a_2115] (x: 'a_2115, l: 'a_2115 list) =>
		      case (pred x) of
			true => (SOME['a_2115] x) | false => (loop l))
	 in
	    loop
	 end)
val 'a rev_0: 'a list -> 'a list = rev ('a)
val ('b, 'a) map_1: ('a -> 'b) -> 'a list -> 'b list = map ('a, 'b)
val 'a length_4: 'a list -> int32 = length ('a)
val ('b, 'a) foldl_1: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b = foldl ('a, 'b)
val 'a find_0: ('a -> bool) -> 'a list -> 'a Primitive.Option.t = find ('a)
val 'a app_0: ('a -> unit) -> 'a list -> unit = app ('a)
val 'a rev_1: 'a list -> 'a list = rev_0 ('a)
val ('b, 'a) map_2: ('a -> 'b) -> 'a list -> 'b list = map_1 ('b, 'a)
val 'a app_1: ('a -> unit) -> 'a list -> unit = app_0 ('a)
exception UnequalLengths
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val fInt64: int64 -> int64 = sextdFromInt64
val fIntInf: intInf -> int64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val fromIntUnsafe: int32 -> int64 = f
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val fIntInf: intInf -> int64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val fromInt: int32 -> int64 = f
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val fInt64: int64 -> int64 = sextdToInt64
val fIntInf: int64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val toIntUnsafe: int64 -> int32 = f
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val toInt: int64 -> int32 = f
val 'a unsafeSub_3: 'a vector * int64 -> 'a = unsafeSub_0 ('a)
val ('a, 'b) unfoldi_2: int64 * 'b * (int64 * 'b -> 'a * 'b) -> 'a vector * 'b =
   unfoldi_0 ('a, 'b)
val ('a, 'b) unfold_2: int64 * 'b * ('b -> 'a * 'b) -> 'a vector * 'b =
   unfold_0 ('a, 'b)
val 'a length_5: 'a vector -> int64 = length ('a)
val 'a unsafeSubslice_2: 'a PrimSequence.Slice.t
			 * int64
			 * int64 Primitive.Option.t
			 -> 'a PrimSequence.Slice.t =
   unsafeSubslice_0 ('a)
val 'a unsafeSub_4: 'a PrimSequence.Slice.t * int64 -> 'a = unsafeSub_1 ('a)
val 'a taker_1: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   taker_0 ('a)
val 'a takel_1: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   takel_0 ('a)
val 'a subslice_2: 'a PrimSequence.Slice.t * int64 * int64 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t =
   subslice_0 ('a)
val 'a sub_2: 'a PrimSequence.Slice.t * int64 -> 'a = sub_0 ('a)
val 'a sequence_1: 'a PrimSequence.Slice.t -> 'a vector = sequence_0 ('a)
val 'a length_6: 'a PrimSequence.Slice.t -> int64 = length_1 ('a)
val 'a full_2: 'a vector -> 'a PrimSequence.Slice.t = full_0 ('a)
val ('b, 'a) foldl_2: ('a * 'b -> 'b) -> 'b -> 'a PrimSequence.Slice.t -> 'b =
   foldl_0 ('b, 'a)
val 'a exists_1: ('a -> bool) -> 'a PrimSequence.Slice.t -> bool = exists_0 ('a)
val 'a dropr_1: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   dropr_0 ('a)
val 'a base_2: 'a PrimSequence.Slice.t -> 'a vector * int64 * int64 =
   base_0 ('a)
val 'a append_1: 'a PrimSequence.Slice.t * 'a PrimSequence.Slice.t -> 'a vector =
   append_0 ('a)
val +?: int64 * int64 -> int64 = +?
val +!: int64 * int64 -> int64 = +!
val <=: int64 * int64 -> bool = <=
val >=: int64 * int64 -> bool = >=
val rec ('a_2331, 'a_2330)
   wrap2: (int32 * 'a_2331 -> 'a_2330) -> int64 * 'a_2331 -> 'a_2330 = 
      (fn x_1152: int32 * 'a_2331 -> 'a_2330 =>
       case x_1152 of
	 (f: int32 * 'a_2331 -> 'a_2330) =>
	 (fn x_1153: int64 * 'a_2331 =>
	  case x_1153 of
	    (i: int64, x: 'a_2331) => (f ((toIntUnsafe i), x))))
val rec
   fromIntForLength: int32 -> int64 = 
      (fn x_1154: int32 =>
       case x_1154 of
	 (n: int32) =>
	 case safe of
	   true =>
	   (fromInt n)
	   handle x_1155 => case x_1155 of
			      Overflow => raise Size
	 | false => (fromIntUnsafe n))
val rec 'a_2338
   length: 'a_2338 vector -> int32 = 
      (fn x_1156: 'a_2338 vector =>
       case x_1156 of
	 (s: 'a_2338 vector) =>
	 case safe of
	   true =>
	   (toInt (length_5 ('a_2338) s))
	   handle x_1157 => case x_1157 of
			      Overflow => raise (Fail "Sequence.length")
	 | false => (toIntUnsafe (length_5 ('a_2338) s)))
val rec ('a_2342, 'a_2341)
   unfoldi: int32 * 'a_2341 * (int32 * 'a_2341 -> 'a_2342 * 'a_2341)
	    -> 'a_2342 vector * 'a_2341 = 
      (fn x_1158: int32 * 'a_2341 * (int32 * 'a_2341 -> 'a_2342 * 'a_2341) =>
       case x_1158 of
	 ((n: int32, b: 'a_2341, f: int32 * 'a_2341 -> 'a_2342 * 'a_2341)) =>
	 (unfoldi_2 ('a_2342, 'a_2341) ((fromIntForLength n),
					b,
					(wrap2 ('a_2341, 'a_2342 * 'a_2341) f))))
val rec ('a_2344, 'a_2343)
   unfold: int32 * 'a_2343 * ('a_2343 -> 'a_2344 * 'a_2343)
	   -> 'a_2344 vector * 'a_2343 = 
      (fn x_1159: int32 * 'a_2343 * ('a_2343 -> 'a_2344 * 'a_2343) =>
       case x_1159 of
	 ((n: int32, b: 'a_2343, f: 'a_2343 -> 'a_2344 * 'a_2343)) =>
	 (unfold_2 ('a_2344, 'a_2343) ((fromIntForLength n), b, f)))
val rec 'a_2345
   seq0: unit -> 'a_2345 vector = 
      (fn x_1160: unit =>
       case x_1160 of
	 (()) =>
	 ((fn x_1161: 'a_2345 vector * unit =>
	   case x_1161 of
	     {1 = #: 'a_2345 vector} => #) (unfold ('a_2345, unit) (0x0,
						       (),
						       (fn x_1162: unit =>
							case x_1162 of
							  _ =>
							  raise (Fail "Sequence.seq0"))))))
val rec 'a_2346
   tabulate: int32 * (int32 -> 'a_2346) -> 'a_2346 vector = 
      (fn x_1163: int32 * (int32 -> 'a_2346) =>
       case x_1163 of
	 ((n: int32, f: int32 -> 'a_2346)) =>
	 ((fn x_1164: 'a_2346 vector * unit =>
	   case x_1164 of
	     {1 = #: 'a_2346 vector} => #) (unfoldi ('a_2346, unit) (n,
							(),
							(fn x_1165: int32 * unit =>
							 case x_1165 of
							   (i: int32, ()) =>
							   ((f i), ()))))))
val rec 'a_2347
   new: int32 * 'a_2347 -> 'a_2347 vector = 
      (fn x_1166: int32 * 'a_2347 =>
       case x_1166 of
	 ((n: int32, x: 'a_2347)) =>
	 ((fn x_1167: 'a_2347 vector * unit =>
	   case x_1167 of
	     {1 = #: 'a_2347 vector} => #) (unfold ('a_2347, unit) (n,
						       (),
						       (fn x_1168: unit =>
							case x_1168 of
							  () => (x, ()))))))
val rec 'a_2348
   fromList: 'a_2348 list -> 'a_2348 vector = 
      (fn x_1169: 'a_2348 list =>
       case x_1169 of
	 (l: 'a_2348 list) =>
	 ((fn x_1170: 'a_2348 vector * 'a_2348 list =>
	   case x_1170 of
	     {1 = #: 'a_2348 vector} => #) (unfold ('a_2348, 'a_2348 list) ((length_4 ('a_2348) l),
							       l,
							       (fn x_1171: 'a_2348 list =>
								case x_1171 of
								  l: 'a_2348 list =>
								  case l of
								    nil['a_2348] =>
								    raise (Fail "Sequence.fromList")
								  | ::['a_2348] (h: 'a_2348,
										 t: 'a_2348 list) =>
								    (h, t))))))
val rec 'a_2349
   length: 'a_2349 PrimSequence.Slice.t -> int32 = 
      (fn x_1172: 'a_2349 PrimSequence.Slice.t =>
       case x_1172 of
	 (sl: 'a_2349 PrimSequence.Slice.t) =>
	 case safe of
	   true =>
	   (toInt (length_6 ('a_2349) sl))
	   handle x_1173 => case x_1173 of
			      Overflow => raise (Fail "Sequence.Slice.length")
	 | false => (toIntUnsafe (length_6 ('a_2349) sl)))
val rec 'a_2350
   unsafeSub: 'a_2350 PrimSequence.Slice.t * int32 -> 'a_2350 = 
      (fn x_1174: 'a_2350 PrimSequence.Slice.t * int32 =>
       case x_1174 of
	 ((sl: 'a_2350 PrimSequence.Slice.t, i: int32)) =>
	 (unsafeSub_4 ('a_2350) (sl, (fromIntUnsafe i))))
val rec 'a_2351
   sub: 'a_2351 PrimSequence.Slice.t * int32 -> 'a_2351 = 
      (fn x_1175: 'a_2351 PrimSequence.Slice.t * int32 =>
       case x_1175 of
	 ((sl: 'a_2351 PrimSequence.Slice.t, i: int32)) =>
	 case safe of
	   true =>
	   let val i: int64 =
		  (fromInt i)
		  handle x_1176 => case x_1176 of
				     Overflow => raise Subscript
	   in
	      (sub_2 ('a_2351) (sl, i))
	   end
	 | false => (unsafeSub ('a_2351) (sl, i)))
val 'a_2354 full: 'a_2354 vector -> 'a_2354 PrimSequence.Slice.t =
   full_2 ('a_2354)
val rec 'a_2355
   unsafeSubslice: 'a_2355 PrimSequence.Slice.t
		   * int32
		   * int32 Primitive.Option.t
		   -> 'a_2355 PrimSequence.Slice.t = 
      (fn x_1177: 'a_2355 PrimSequence.Slice.t
		  * int32
		  * int32 Primitive.Option.t =>
       case x_1177 of
	 ((sl: 'a_2355 PrimSequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 (unsafeSubslice_2 ('a_2355) (sl,
				      (fromIntUnsafe start),
				      ((map_0 (int64, int32) fromIntUnsafe) len))))
val rec 'a_2357
   subslice: 'a_2357 PrimSequence.Slice.t * int32 * int32 Primitive.Option.t
	     -> 'a_2357 PrimSequence.Slice.t = 
      (fn x_1178: 'a_2357 PrimSequence.Slice.t
		  * int32
		  * int32 Primitive.Option.t =>
       case x_1178 of
	 ((sl: 'a_2357 PrimSequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 case safe of
	   true =>
	   (subslice_2 ('a_2357) (sl,
				  (fromInt start),
				  ((map_0 (int64, int32) fromInt) len)))
	   handle x_1179 => case x_1179 of
			      Overflow => raise Subscript
	 | false => (unsafeSubslice ('a_2357) (sl, start, len)))
val rec 'a
   slice: 'a vector * int32 * int32 Primitive.Option.t
	  -> 'a PrimSequence.Slice.t = 
      (fn x_1180: 'a vector * int32 * int32 Primitive.Option.t =>
       case x_1180 of
	 ((seq: 'a vector, start: int32, len: int32 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec 'a_2358
   base: 'a_2358 PrimSequence.Slice.t -> 'a_2358 vector * int32 * int32 = 
      (fn x_1181: 'a_2358 PrimSequence.Slice.t =>
       case x_1181 of
	 (sl: 'a_2358 PrimSequence.Slice.t) =>
	 let val (seq: 'a_2358 vector, start: int64, len: int64) =
		(base_2 ('a_2358) sl)
	 in
	    case safe of
	      true =>
	      (seq, (toInt start), (toInt len))
	      handle x_1182 => case x_1182 of
				 Overflow => raise (Fail "Sequence.Slice.base")
	    | false => (seq, (toIntUnsafe start), (toIntUnsafe len))
	 end)
val ('a_2366, 'a_2365) foldl: ('a_2365 * 'a_2366 -> 'a_2366)
			      -> 'a_2366
				 -> 'a_2365 PrimSequence.Slice.t -> 'a_2366 =
   foldl_2 ('a_2366, 'a_2365)
val 'a_2378 exists: ('a_2378 -> bool) -> 'a_2378 PrimSequence.Slice.t -> bool =
   exists_1 ('a_2378)
val 'a_2382 sequence: 'a_2382 PrimSequence.Slice.t -> 'a_2382 vector =
   sequence_1 ('a_2382)
val 'a_2383 append: 'a_2383 PrimSequence.Slice.t * 'a_2383 PrimSequence.Slice.t
		    -> 'a_2383 vector =
   append_1 ('a_2383)
val rec 'a
   concat: 'a PrimSequence.Slice.t list -> 'a vector = 
      (fn x_1183: 'a PrimSequence.Slice.t list =>
       case x_1183 of
	 (sls: 'a PrimSequence.Slice.t list) =>
	 case sls of
	   [] => (seq0 ('a) ())
	 | [sl: 'a PrimSequence.Slice.t] => (sequence ('a) sl)
	 | sls': 'a PrimSequence.Slice.t list as ::['a PrimSequence.Slice.t] (sl: 'a PrimSequence.Slice.t,
									      sls: 'a PrimSequence.Slice.t list) =>
	   let val add: 'a PrimSequence.Slice.t * int64 -> int64 =
		  case safe of
		    true =>
		    (fn x_1185: 'a PrimSequence.Slice.t * int64 =>
		     case x_1185 of
		       (sl: 'a PrimSequence.Slice.t, s: int64) =>
		       (+! (s, (length_6 ('a) sl)))
		       handle x_1186 => case x_1186 of
					  Overflow => raise Size)
		  | false =>
		    (fn x_1187: 'a PrimSequence.Slice.t * int64 =>
		     case x_1187 of
		       (sl: 'a PrimSequence.Slice.t, s: int64) =>
		       (+? (s, (length_6 ('a) sl))))
	       val n: int64 =
		  (((foldl_1 (int64, 'a PrimSequence.Slice.t) add) 0x0) sls')
	       val rec 'a_2384
		  loop: int64
			* 'a_2384 PrimSequence.Slice.t
			* 'a_2384 PrimSequence.Slice.t list
			-> 'a_2384
			   * (int64
			      * 'a_2384 PrimSequence.Slice.t
			      * 'a_2384 PrimSequence.Slice.t list) = 
		     (fn x_1184: int64
				 * 'a_2384 PrimSequence.Slice.t
				 * 'a_2384 PrimSequence.Slice.t list =>
		      case x_1184 of
			((i: int64,
			  sl: 'a_2384 PrimSequence.Slice.t,
			  sls: 'a_2384 PrimSequence.Slice.t list)) =>
			case (< (i, (length_6 ('a_2384) sl))) of
			  true =>
			  ((unsafeSub_4 ('a_2384) (sl, i)),
			   ((+? (i, 0x1)), sl, sls))
			| false =>
			  case sls of
			    [] => raise (Fail "Sequence.Slice.concat")
			  | ::['a_2384 PrimSequence.Slice.t] (sl: 'a_2384 PrimSequence.Slice.t,
							      sls: 'a_2384 PrimSequence.Slice.t list) =>
			    (loop ('a_2384) (0x0, sl, sls)))
	   in
	      ((fn x_1188: 'a vector
			   * (int64
			      * 'a PrimSequence.Slice.t
			      * 'a PrimSequence.Slice.t list) =>
		case x_1188 of
		  {1 = #: 'a vector} => #) (unfold_2 ('a,
				    int64
				    * 'a PrimSequence.Slice.t
				    * 'a PrimSequence.Slice.t list) (n,
								     (0x0,
								      sl,
								      sls),
								     loop ('a))))
	   end)
val rec 'a
   isPrefix: ('a * 'a -> bool) -> 'a vector -> 'a PrimSequence.Slice.t -> bool = 
      (fn x_1189: 'a * 'a -> bool =>
       (fn x_1190: 'a vector =>
	(fn x_1191: 'a PrimSequence.Slice.t =>
	 case (x_1189, x_1190, x_1191) of
	   (eq: 'a * 'a -> bool, seq: 'a vector, sl: 'a PrimSequence.Slice.t) =>
	   let val n: int64 = (length_5 ('a) seq)
	       val n': int64 = (length_6 ('a) sl)
	   in
	      case (<= (n, n')) of
		true =>
		let val rec
		       loop: int64 -> bool = 
			  (fn x_1192: int64 =>
			   case x_1192 of
			     (j: int64) =>
			     case (>= (j, n)) of
			       true => true
			     | false =>
			       case (eq ((unsafeSub_3 ('a) (seq, j)),
					 (unsafeSub_4 ('a) (sl, j)))) of
				 true => (loop (+? (j, 0x1))) | false => false)
		in
		   (loop 0x0)
		end
	      | false => false
	   end)))
val 'a_2391 dropr: ('a_2391 -> bool)
		   -> 'a_2391 PrimSequence.Slice.t
		      -> 'a_2391 PrimSequence.Slice.t =
   dropr_1 ('a_2391)
val 'a_2392 takel: ('a_2392 -> bool)
		   -> 'a_2392 PrimSequence.Slice.t
		      -> 'a_2392 PrimSequence.Slice.t =
   takel_1 ('a_2392)
val 'a_2393 taker: ('a_2393 -> bool)
		   -> 'a_2393 PrimSequence.Slice.t
		      -> 'a_2393 PrimSequence.Slice.t =
   taker_1 ('a_2393)
val rec ('a_2395, 'a)
   translate: ('a -> 'a_2395 vector)
	      -> 'a PrimSequence.Slice.t -> 'a_2395 vector = 
      (fn x_1193: 'a -> 'a_2395 vector =>
       (fn x_1194: 'a PrimSequence.Slice.t =>
	case (x_1193, x_1194) of
	  (f: 'a -> 'a_2395 vector, sl: 'a PrimSequence.Slice.t) =>
	  (concat ('a_2395) (rev_0 ('a_2395 PrimSequence.Slice.t) (((foldl ('a_2395 PrimSequence.Slice.t list,
									    'a) (fn x_1195: 'a
											    * 'a_2395 PrimSequence.Slice.t list =>
										 case x_1195 of
										   (c: 'a,
										    l: 'a_2395 PrimSequence.Slice.t list) =>
										   (::['a_2395 PrimSequence.Slice.t] ((full ('a_2395) (f c)),
														      l)))) []) sl)))))
val rec ('a_2401, 'a_2400)
   make: ('a_2401 PrimSequence.Slice.t -> 'a_2400) -> 'a_2401 vector -> 'a_2400 = 
      (fn x_1196: 'a_2401 PrimSequence.Slice.t -> 'a_2400 =>
       (fn x_1197: 'a_2401 vector =>
	case (x_1196, x_1197) of
	  (f: 'a_2401 PrimSequence.Slice.t -> 'a_2400, seq: 'a_2401 vector) =>
	  (f (full ('a_2401) seq))))
val rec ('a_2404, 'a_2403, 'a_2402)
   make2: ('a_2404 PrimSequence.Slice.t * 'a_2403 PrimSequence.Slice.t
	   -> 'a_2402)
	  -> 'a_2404 vector * 'a_2403 vector -> 'a_2402 = 
      (fn x_1198: 'a_2404 PrimSequence.Slice.t * 'a_2403 PrimSequence.Slice.t
		  -> 'a_2402 =>
       (fn x_1199: 'a_2404 vector * 'a_2403 vector =>
	case (x_1198, x_1199) of
	  (f: 'a_2404 PrimSequence.Slice.t * 'a_2403 PrimSequence.Slice.t
	      -> 'a_2402,
	   (seq1: 'a_2404 vector, seq2: 'a_2403 vector)) =>
	  (f ((full ('a_2404) seq1), (full ('a_2403) seq2)))))
val rec 'a_2405
   sub: 'a_2405 vector * int32 -> 'a_2405 = 
      (fn x_1200: 'a_2405 vector * int32 =>
       case x_1200 of
	 ((seq: 'a_2405 vector, i: int32)) =>
	 (sub ('a_2405) ((full ('a_2405) seq), i)))
val rec 'a_2409
   append: 'a_2409 vector * 'a_2409 vector -> 'a_2409 vector = 
      (fn x_1201: 'a_2409 vector * 'a_2409 vector =>
       case x_1201 of
	 (seqs: 'a_2409 vector * 'a_2409 vector) =>
	 ((make2 ('a_2409, 'a_2409, 'a_2409 vector) append ('a_2409)) seqs))
val rec 'a_2410
   concat: 'a_2410 vector list -> 'a_2410 vector = 
      (fn x_1202: 'a_2410 vector list =>
       case x_1202 of
	 (seqs: 'a_2410 vector list) =>
	 (concat ('a_2410) ((map_1 ('a_2410 PrimSequence.Slice.t, 'a_2410 vector) full ('a_2410)) seqs)))
val rec 'a_2428
   exists: ('a_2428 -> bool) -> 'a_2428 vector -> bool = 
      (fn x_1203: 'a_2428 -> bool =>
       case x_1203 of
	 (p: 'a_2428 -> bool) => (make ('a_2428, bool) (exists ('a_2428) p)))
val rec 'a_2433
   isPrefix: ('a_2433 * 'a_2433 -> bool)
	     -> 'a_2433 vector -> 'a_2433 vector -> bool = 
      (fn x_1204: 'a_2433 * 'a_2433 -> bool =>
       (fn x_1205: 'a_2433 vector =>
	case (x_1204, x_1205) of
	  (eq: 'a_2433 * 'a_2433 -> bool, seq: 'a_2433 vector) =>
	  (make ('a_2433, bool) ((isPrefix ('a_2433) eq) seq))))
val rec ('a_2437, 'a_2436)
   translate: ('a_2436 -> 'a_2437 vector) -> 'a_2436 vector -> 'a_2437 vector = 
      (fn x_1206: 'a_2436 -> 'a_2437 vector =>
       case x_1206 of
	 (f: 'a_2436 -> 'a_2437 vector) =>
	 (make ('a_2436, 'a_2437 vector) (translate ('a_2437, 'a_2436) f)))
val ('b, 'a) translate_0: ('a -> 'b vector) -> 'a vector -> 'b vector =
   translate ('b, 'a)
val 'a tabulate_1: int32 * (int32 -> 'a) -> 'a vector = tabulate ('a)
val 'a sub_3: 'a vector * int32 -> 'a = sub ('a)
val 'a new_0: int32 * 'a -> 'a vector = new ('a)
val 'a length_7: 'a vector -> int32 = length ('a)
val 'a isPrefix_0: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool =
   isPrefix ('a)
val 'a fromList_0: 'a list -> 'a vector = fromList ('a)
val 'a exists_2: ('a -> bool) -> 'a vector -> bool = exists ('a)
val 'a concat_0: 'a vector list -> 'a vector = concat ('a)
val 'a append_2: 'a vector * 'a vector -> 'a vector = append ('a)
val 'a taker_2: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   taker ('a)
val 'a takel_2: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   takel ('a)
val 'a sub_4: 'a PrimSequence.Slice.t * int32 -> 'a = sub ('a)
val 'a slice_1: 'a vector * int32 * int32 Primitive.Option.t
		-> 'a PrimSequence.Slice.t =
   slice ('a)
val 'a sequence_2: 'a PrimSequence.Slice.t -> 'a vector = sequence ('a)
val 'a length_8: 'a PrimSequence.Slice.t -> int32 = length ('a)
val 'a full_3: 'a vector -> 'a PrimSequence.Slice.t = full ('a)
val 'a dropr_2: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   dropr ('a)
val 'a base_3: 'a PrimSequence.Slice.t -> 'a vector * int32 * int32 = base ('a)
val 'a_2453 vector: 'a_2453 PrimSequence.Slice.t -> 'a_2453 vector =
   sequence_2 ('a_2453)
val 'a_2457 unsafeFromArray: 'a_2457 array -> 'a_2457 vector =
   fromArrayUnsafe ('a_2457)
val 'a_2458 vector: int32 * 'a_2458 -> 'a_2458 vector = new_0 ('a_2458)
val 'a vector_0: int32 * 'a -> 'a vector = vector ('a)
val 'a unsafeFromArray_0: 'a array -> 'a vector = unsafeFromArray ('a)
val ('b, 'a) translate_1: ('a -> 'b vector) -> 'a vector -> 'b vector =
   translate_0 ('b, 'a)
val 'a tabulate_2: int32 * (int32 -> 'a) -> 'a vector = tabulate_1 ('a)
val 'a sub_5: 'a vector * int32 -> 'a = sub_3 ('a)
val 'a length_9: 'a vector -> int32 = length_7 ('a)
val 'a isPrefix_1: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool =
   isPrefix_0 ('a)
val 'a fromList_1: 'a list -> 'a vector = fromList_0 ('a)
val 'a exists_3: ('a -> bool) -> 'a vector -> bool = exists_2 ('a)
val 'a concat_1: 'a vector list -> 'a vector = concat_0 ('a)
val 'a append_3: 'a vector * 'a vector -> 'a vector = append_2 ('a)
val 'a vector_1: 'a PrimSequence.Slice.t -> 'a vector = vector ('a)
val 'a taker_3: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   taker_2 ('a)
val 'a takel_3: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   takel_2 ('a)
val 'a sub_6: 'a PrimSequence.Slice.t * int32 -> 'a = sub_4 ('a)
val 'a slice_2: 'a vector * int32 * int32 Primitive.Option.t
		-> 'a PrimSequence.Slice.t =
   slice_1 ('a)
val 'a length_10: 'a PrimSequence.Slice.t -> int32 = length_8 ('a)
val 'a full_4: 'a vector -> 'a PrimSequence.Slice.t = full_3 ('a)
val 'a dropr_3: ('a -> bool)
		-> 'a PrimSequence.Slice.t -> 'a PrimSequence.Slice.t =
   dropr_2 ('a)
val 'a base_4: 'a PrimSequence.Slice.t -> 'a vector * int32 * int32 =
   base_3 ('a)
val 'a base_5: 'a PrimSequence.Slice.t -> 'a vector * int32 * int32 =
   base_4 ('a)
val ('a, 'b) unfoldi_3: int64 * 'b * (int64 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi_1 ('a, 'b)
val ('a, 'b) unfold_3: int64 * 'b * ('b -> 'a * 'b) -> 'a array * 'b =
   unfold_1 ('a, 'b)
val 'a newUninit_1: int64 -> 'a array = newUninit_0 ('a)
val 'a length_11: 'a array -> int64 = length ('a)
val 'a updateMk_1: ('a array * int64 * 'a -> unit)
		   -> 'a PrimSequence.Slice.t * int64 * 'a -> unit =
   updateMk_0 ('a)
val 'a unsafeUpdateMk_1: ('a array * int64 * 'a -> unit)
			 -> 'a PrimSequence.Slice.t * int64 * 'a -> unit =
   unsafeUpdateMk_0 ('a)
val 'a unsafeSubslice_3: 'a PrimSequence.Slice.t
			 * int64
			 * int64 Primitive.Option.t
			 -> 'a PrimSequence.Slice.t =
   unsafeSubslice_1 ('a)
val 'a unsafeSub_5: 'a PrimSequence.Slice.t * int64 -> 'a = unsafeSub_2 ('a)
val 'a subslice_3: 'a PrimSequence.Slice.t * int64 * int64 Primitive.Option.t
		   -> 'a PrimSequence.Slice.t =
   subslice_1 ('a)
val 'a sub_7: 'a PrimSequence.Slice.t * int64 -> 'a = sub_1 ('a)
val 'a full_5: 'a array -> 'a PrimSequence.Slice.t = full_1 ('a)
val ('b, 'a) foldri_1: (int64 * 'a * 'b -> 'b)
		       -> 'b -> 'a PrimSequence.Slice.t -> 'b =
   foldri_0 ('b, 'a)
val 'a base_6: 'a PrimSequence.Slice.t -> 'a array * int64 * int64 = base_1 ('a)
val rec ('a_2485, 'a_2484)
   wrap2: (int32 * 'a_2485 -> 'a_2484) -> int64 * 'a_2485 -> 'a_2484 = 
      (fn x_1207: int32 * 'a_2485 -> 'a_2484 =>
       case x_1207 of
	 (f: int32 * 'a_2485 -> 'a_2484) =>
	 (fn x_1208: int64 * 'a_2485 =>
	  case x_1208 of
	    (i: int64, x: 'a_2485) => (f ((toIntUnsafe i), x))))
val rec ('a_2488, 'a_2487, 'a_2486)
   wrap3: (int32 * 'a_2488 * 'a_2487 -> 'a_2486)
	  -> int64 * 'a_2488 * 'a_2487 -> 'a_2486 = 
      (fn x_1209: int32 * 'a_2488 * 'a_2487 -> 'a_2486 =>
       case x_1209 of
	 (f: int32 * 'a_2488 * 'a_2487 -> 'a_2486) =>
	 (fn x_1210: int64 * 'a_2488 * 'a_2487 =>
	  case x_1210 of
	    (i: int64, x: 'a_2488, y: 'a_2487) => (f ((toIntUnsafe i), x, y))))
val rec
   fromIntForLength: int32 -> int64 = 
      (fn x_1211: int32 =>
       case x_1211 of
	 (n: int32) =>
	 case safe of
	   true =>
	   (fromInt n)
	   handle x_1212 => case x_1212 of
			      Overflow => raise Size
	 | false => (fromIntUnsafe n))
val rec 'a_2492
   length: 'a_2492 array -> int32 = 
      (fn x_1213: 'a_2492 array =>
       case x_1213 of
	 (s: 'a_2492 array) =>
	 case safe of
	   true =>
	   (toInt (length_11 ('a_2492) s))
	   handle x_1214 => case x_1214 of
			      Overflow => raise (Fail "Sequence.length")
	 | false => (toIntUnsafe (length_11 ('a_2492) s)))
val rec 'a_2493
   newUninit: int32 -> 'a_2493 array = 
      (fn x_1215: int32 =>
       case x_1215 of
	 (n: int32) => (newUninit_1 ('a_2493) (fromIntForLength n)))
val rec ('a_2496, 'a_2495)
   unfoldi: int32 * 'a_2495 * (int32 * 'a_2495 -> 'a_2496 * 'a_2495)
	    -> 'a_2496 array * 'a_2495 = 
      (fn x_1216: int32 * 'a_2495 * (int32 * 'a_2495 -> 'a_2496 * 'a_2495) =>
       case x_1216 of
	 ((n: int32, b: 'a_2495, f: int32 * 'a_2495 -> 'a_2496 * 'a_2495)) =>
	 (unfoldi_3 ('a_2496, 'a_2495) ((fromIntForLength n),
					b,
					(wrap2 ('a_2495, 'a_2496 * 'a_2495) f))))
val rec ('a_2498, 'a_2497)
   unfold: int32 * 'a_2497 * ('a_2497 -> 'a_2498 * 'a_2497)
	   -> 'a_2498 array * 'a_2497 = 
      (fn x_1217: int32 * 'a_2497 * ('a_2497 -> 'a_2498 * 'a_2497) =>
       case x_1217 of
	 ((n: int32, b: 'a_2497, f: 'a_2497 -> 'a_2498 * 'a_2497)) =>
	 (unfold_3 ('a_2498, 'a_2497) ((fromIntForLength n), b, f)))
val rec 'a_2500
   tabulate: int32 * (int32 -> 'a_2500) -> 'a_2500 array = 
      (fn x_1218: int32 * (int32 -> 'a_2500) =>
       case x_1218 of
	 ((n: int32, f: int32 -> 'a_2500)) =>
	 ((fn x_1219: 'a_2500 array * unit =>
	   case x_1219 of
	     {1 = #: 'a_2500 array} => #) (unfoldi ('a_2500, unit) (n,
						       (),
						       (fn x_1220: int32 * unit =>
							case x_1220 of
							  (i: int32, ()) =>
							  ((f i), ()))))))
val rec 'a_2501
   new: int32 * 'a_2501 -> 'a_2501 array = 
      (fn x_1221: int32 * 'a_2501 =>
       case x_1221 of
	 ((n: int32, x: 'a_2501)) =>
	 ((fn x_1222: 'a_2501 array * unit =>
	   case x_1222 of
	     {1 = #: 'a_2501 array} => #) (unfold ('a_2501, unit) (n,
						      (),
						      (fn x_1223: unit =>
						       case x_1223 of
							 () => (x, ()))))))
val rec 'a_2504
   unsafeSub: 'a_2504 PrimSequence.Slice.t * int32 -> 'a_2504 = 
      (fn x_1224: 'a_2504 PrimSequence.Slice.t * int32 =>
       case x_1224 of
	 ((sl: 'a_2504 PrimSequence.Slice.t, i: int32)) =>
	 (unsafeSub_5 ('a_2504) (sl, (fromIntUnsafe i))))
val rec 'a_2505
   sub: 'a_2505 PrimSequence.Slice.t * int32 -> 'a_2505 = 
      (fn x_1225: 'a_2505 PrimSequence.Slice.t * int32 =>
       case x_1225 of
	 ((sl: 'a_2505 PrimSequence.Slice.t, i: int32)) =>
	 case safe of
	   true =>
	   let val i: int64 =
		  (fromInt i)
		  handle x_1226 => case x_1226 of
				     Overflow => raise Subscript
	   in
	      (sub_7 ('a_2505) (sl, i))
	   end
	 | false => (unsafeSub ('a_2505) (sl, i)))
val rec 'a_2506
   unsafeUpdateMk: ('a_2506 array * int64 * 'a_2506 -> unit)
		   -> 'a_2506 PrimSequence.Slice.t * int32 * 'a_2506 -> unit = 
      (fn x_1227: 'a_2506 array * int64 * 'a_2506 -> unit =>
       (fn x_1228: 'a_2506 PrimSequence.Slice.t * int32 * 'a_2506 =>
	case (x_1227, x_1228) of
	  (updateUnsafe: 'a_2506 array * int64 * 'a_2506 -> unit,
	   (sl: 'a_2506 PrimSequence.Slice.t, i: int32, x: 'a_2506)) =>
	  ((unsafeUpdateMk_1 ('a_2506) updateUnsafe) (sl, (fromIntUnsafe i), x))))
val rec 'a_2507
   updateMk: ('a_2507 array * int64 * 'a_2507 -> unit)
	     -> 'a_2507 PrimSequence.Slice.t * int32 * 'a_2507 -> unit = 
      (fn x_1229: 'a_2507 array * int64 * 'a_2507 -> unit =>
       (fn x_1230: 'a_2507 PrimSequence.Slice.t * int32 * 'a_2507 =>
	case (x_1229, x_1230) of
	  (updateUnsafe: 'a_2507 array * int64 * 'a_2507 -> unit,
	   (sl: 'a_2507 PrimSequence.Slice.t, i: int32, x: 'a_2507)) =>
	  case safe of
	    true =>
	    let val i: int64 =
		   (fromInt i)
		   handle x_1231 => case x_1231 of
				      Overflow => raise Subscript
	    in
	       ((updateMk_1 ('a_2507) updateUnsafe) (sl, i, x))
	    end
	  | false => ((unsafeUpdateMk ('a_2507) updateUnsafe) (sl, i, x))))
val 'a_2508 full: 'a_2508 array -> 'a_2508 PrimSequence.Slice.t =
   full_5 ('a_2508)
val rec 'a_2509
   unsafeSubslice: 'a_2509 PrimSequence.Slice.t
		   * int32
		   * int32 Primitive.Option.t
		   -> 'a_2509 PrimSequence.Slice.t = 
      (fn x_1232: 'a_2509 PrimSequence.Slice.t
		  * int32
		  * int32 Primitive.Option.t =>
       case x_1232 of
	 ((sl: 'a_2509 PrimSequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 (unsafeSubslice_3 ('a_2509) (sl,
				      (fromIntUnsafe start),
				      ((map_0 (int64, int32) fromIntUnsafe) len))))
val rec 'a_2511
   subslice: 'a_2511 PrimSequence.Slice.t * int32 * int32 Primitive.Option.t
	     -> 'a_2511 PrimSequence.Slice.t = 
      (fn x_1233: 'a_2511 PrimSequence.Slice.t
		  * int32
		  * int32 Primitive.Option.t =>
       case x_1233 of
	 ((sl: 'a_2511 PrimSequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 case safe of
	   true =>
	   (subslice_3 ('a_2511) (sl,
				  (fromInt start),
				  ((map_0 (int64, int32) fromInt) len)))
	   handle x_1234 => case x_1234 of
			      Overflow => raise Subscript
	 | false => (unsafeSubslice ('a_2511) (sl, start, len)))
val rec 'a
   slice: 'a array * int32 * int32 Primitive.Option.t -> 'a PrimSequence.Slice.t = 
      (fn x_1235: 'a array * int32 * int32 Primitive.Option.t =>
       case x_1235 of
	 ((seq: 'a array, start: int32, len: int32 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec 'a_2512
   base: 'a_2512 PrimSequence.Slice.t -> 'a_2512 array * int32 * int32 = 
      (fn x_1236: 'a_2512 PrimSequence.Slice.t =>
       case x_1236 of
	 (sl: 'a_2512 PrimSequence.Slice.t) =>
	 let val (seq: 'a_2512 array, start: int64, len: int64) =
		(base_6 ('a_2512) sl)
	 in
	    case safe of
	      true =>
	      (seq, (toInt start), (toInt len))
	      handle x_1237 => case x_1237 of
				 Overflow => raise (Fail "Sequence.Slice.base")
	    | false => (seq, (toIntUnsafe start), (toIntUnsafe len))
	 end)
val rec ('a_2518, 'a_2517)
   foldri: (int32 * 'a_2518 * 'a_2517 -> 'a_2517)
	   -> 'a_2517 -> 'a_2518 PrimSequence.Slice.t -> 'a_2517 = 
      (fn x_1238: int32 * 'a_2518 * 'a_2517 -> 'a_2517 =>
       (fn x_1239: 'a_2517 =>
	(fn x_1240: 'a_2518 PrimSequence.Slice.t =>
	 case (x_1238, x_1239, x_1240) of
	   (f: int32 * 'a_2518 * 'a_2517 -> 'a_2517,
	    b: 'a_2517,
	    sl: 'a_2518 PrimSequence.Slice.t) =>
	   (((foldri_1 ('a_2517, 'a_2518) (wrap3 ('a_2518, 'a_2517, 'a_2517) f)) b) sl))))
val rec ('a_2555, 'a_2554)
   make: ('a_2555 PrimSequence.Slice.t -> 'a_2554) -> 'a_2555 array -> 'a_2554 = 
      (fn x_1241: 'a_2555 PrimSequence.Slice.t -> 'a_2554 =>
       (fn x_1242: 'a_2555 array =>
	case (x_1241, x_1242) of
	  (f: 'a_2555 PrimSequence.Slice.t -> 'a_2554, seq: 'a_2555 array) =>
	  (f (full ('a_2555) seq))))
val rec 'a_2559
   sub: 'a_2559 array * int32 -> 'a_2559 = 
      (fn x_1243: 'a_2559 array * int32 =>
       case x_1243 of
	 ((seq: 'a_2559 array, i: int32)) =>
	 (sub ('a_2559) ((full ('a_2559) seq), i)))
val rec 'a_2561
   updateMk: ('a_2561 array * int64 * 'a_2561 -> unit)
	     -> 'a_2561 array * int32 * 'a_2561 -> unit = 
      (fn x_1244: 'a_2561 array * int64 * 'a_2561 -> unit =>
       (fn x_1245: 'a_2561 array * int32 * 'a_2561 =>
	case (x_1244, x_1245) of
	  (updateUnsafe: 'a_2561 array * int64 * 'a_2561 -> unit,
	   (seq: 'a_2561 array, i: int32, x: 'a_2561)) =>
	  ((updateMk ('a_2561) updateUnsafe) ((full ('a_2561) seq), i, x))))
val rec ('a_2576, 'a_2575)
   foldri: (int32 * 'a_2576 * 'a_2575 -> 'a_2575)
	   -> 'a_2575 -> 'a_2576 array -> 'a_2575 = 
      (fn x_1246: int32 * 'a_2576 * 'a_2575 -> 'a_2575 =>
       (fn x_1247: 'a_2575 =>
	case (x_1246, x_1247) of
	  (f: int32 * 'a_2576 * 'a_2575 -> 'a_2575, b: 'a_2575) =>
	  (make ('a_2576, 'a_2575) ((foldri ('a_2576, 'a_2575) f) b))))
val 'a updateMk_2: ('a array * int64 * 'a -> unit)
		   -> 'a array * int32 * 'a -> unit =
   updateMk ('a)
val ('a, 'b) unfoldi_4: int32 * 'b * (int32 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi ('a, 'b)
val 'a tabulate_3: int32 * (int32 -> 'a) -> 'a array = tabulate ('a)
val 'a sub_8: 'a array * int32 -> 'a = sub ('a)
val 'a newUninit_2: int32 -> 'a array = newUninit ('a)
val 'a new_1: int32 * 'a -> 'a array = new ('a)
val 'a length_12: 'a array -> int32 = length ('a)
val ('b, 'a) foldri_2: (int32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b =
   foldri ('a, 'b)
val 'a slice_3: 'a array * int32 * int32 Primitive.Option.t
		-> 'a PrimSequence.Slice.t =
   slice ('a)
val 'a full_6: 'a array -> 'a PrimSequence.Slice.t = full ('a)
val 'a base_7: 'a PrimSequence.Slice.t -> 'a array * int32 * int32 = base ('a)
val rec ('a_2611, 'a_2610, 'a_2609)
   wrapCopy: ({di: int64, dst: 'a_2610, src: 'a_2611} -> 'a_2609)
	     -> {di: int32, dst: 'a_2610, src: 'a_2611} -> 'a_2609 = 
      (fn x_1248: {di: int64, dst: 'a_2610, src: 'a_2611} -> 'a_2609 =>
       case x_1248 of
	 (f: {di: int64, dst: 'a_2610, src: 'a_2611} -> 'a_2609) =>
	 (fn x_1249: {di: int32, dst: 'a_2610, src: 'a_2611} =>
	  case x_1249 of
	    {src = src: 'a_2611, dst = dst: 'a_2610, di = di: int32} =>
	    (f {src = src, dst = dst, di = (fromInt di)})
	    handle x_1250 => case x_1250 of
			       Overflow => raise Subscript))
val 'a_2612 vector: 'a_2612 PrimSequence.Slice.t -> 'a_2612 vector =
   vector ('a_2612)
val 'a_2618 arrayUninit: int32 -> 'a_2618 array = newUninit_2 ('a_2618)
val 'a_2619 array: int32 * 'a_2619 -> 'a_2619 array = new_1 ('a_2619)
val rec 'a_2621
   update: 'a_2621 array * int32 * 'a_2621 -> unit = 
      (fn x_1251: 'a_2621 array * int32 * 'a_2621 =>
       case x_1251 of
	 (x: 'a_2621 array * int32 * 'a_2621) =>
	 ((updateMk_2 ('a_2621) updateUnsafe ('a_2621)) x))
val rec 'a_2624
   copyVec: {di: int32, dst: 'a_2624 array, src: 'a_2624 vector} -> unit = 
      (fn x_1252: {di: int32, dst: 'a_2624 array, src: 'a_2624 vector} =>
       case x_1252 of
	 (arg: {di: int32, dst: 'a_2624 array, src: 'a_2624 vector}) =>
	 ((wrapCopy ('a_2624 vector, 'a_2624 array, unit) copyVec ('a_2624)) arg))
val 'a update_0: 'a array * int32 * 'a -> unit = update ('a)
val ('a, 'b) unfoldi_5: int32 * 'b * (int32 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi_4 ('a, 'b)
val 'a tabulate_4: int32 * (int32 -> 'a) -> 'a array = tabulate_3 ('a)
val 'a sub_9: 'a array * int32 -> 'a = sub_8 ('a)
val 'a length_13: 'a array -> int32 = length_12 ('a)
val ('b, 'a) foldri_3: (int32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b =
   foldri_2 ('b, 'a)
val 'a copyVec_0: {di: int32, dst: 'a array, src: 'a vector} -> unit =
   copyVec ('a)
val 'a arrayUninit_0: int32 -> 'a array = arrayUninit ('a)
val 'a array_0: int32 * 'a -> 'a array = array ('a)
val 'a vector_2: 'a PrimSequence.Slice.t -> 'a vector = vector ('a)
val 'a slice_4: 'a array * int32 * int32 Primitive.Option.t
		-> 'a PrimSequence.Slice.t =
   slice_3 ('a)
val 'a full_7: 'a array -> 'a PrimSequence.Slice.t = full_6 ('a)
val 'a base_8: 'a PrimSequence.Slice.t -> 'a array * int32 * int32 = base_7 ('a)
val 'a vector_3: 'a PrimSequence.Slice.t -> 'a vector = vector_2 ('a)
val 'a slice_5: 'a array * int32 * int32 Primitive.Option.t
		-> 'a PrimSequence.Slice.t =
   slice_4 ('a)
val 'a base_9: 'a PrimSequence.Slice.t -> 'a array * int32 * int32 = base_8 ('a)
datatype Array2.traversal = RowMajor
			    | ColMajor
val 'a_2767 toPoly: 'a_2767 -> 'a_2767 =
   (fn x_1253: 'a_2767 =>
    case x_1253 of
      s: 'a_2767 => s)
val vector_4: int32 * char8 -> string = vector_0 (char8)
val unsafeFromArray_1: char8 array -> string = unsafeFromArray_0 (char8)
val translate_2: (char8 -> string) -> string -> string =
   translate_1 (char8, char8)
val tabulate_5: int32 * (int32 -> char8) -> string = tabulate_2 (char8)
val sub_10: string * int32 -> char8 = sub_5 (char8)
val length_14: string -> int32 = length_9 (char8)
val isPrefix_2: (char8 * char8 -> bool) -> string -> string -> bool =
   isPrefix_1 (char8)
val fromList_2: char8 list -> string = fromList_1 (char8)
val exists_4: (char8 -> bool) -> string -> bool = exists_3 (char8)
val concat_2: string list -> string = concat_1 (char8)
val append_4: string * string -> string = append_3 (char8)
val vector_5: char8 PrimSequence.Slice.t -> string = vector_1 (char8)
val toPoly_0: char8 PrimSequence.Slice.t -> char8 PrimSequence.Slice.t =
   toPoly (char8 PrimSequence.Slice.t)
val taker_4: (char8 -> bool)
	     -> char8 PrimSequence.Slice.t -> char8 PrimSequence.Slice.t =
   taker_3 (char8)
val takel_4: (char8 -> bool)
	     -> char8 PrimSequence.Slice.t -> char8 PrimSequence.Slice.t =
   takel_3 (char8)
val sub_11: char8 PrimSequence.Slice.t * int32 -> char8 = sub_6 (char8)
val slice_6: string * int32 * int32 Primitive.Option.t
	     -> char8 PrimSequence.Slice.t =
   slice_2 (char8)
val length_15: char8 PrimSequence.Slice.t -> int32 = length_10 (char8)
val full_8: string -> char8 PrimSequence.Slice.t = full_4 (char8)
val dropr_4: (char8 -> bool)
	     -> char8 PrimSequence.Slice.t -> char8 PrimSequence.Slice.t =
   dropr_3 (char8)
val base_10: char8 PrimSequence.Slice.t -> string * int32 * int32 =
   base_4 (char8)
val 'a_2768 fromPoly: 'a_2768 -> 'a_2768 =
   (fn x_1254: 'a_2768 =>
    case x_1254 of
      a: 'a_2768 => a)
val 'a_2770 toPoly: 'a_2770 -> 'a_2770 =
   (fn x_1255: 'a_2770 =>
    case x_1255 of
      s: 'a_2770 => s)
val update_1: char8 array * int32 * char8 -> unit = update_0 (char8)
val tabulate_6: int32 * (int32 -> char8) -> char8 array = tabulate_4 (char8)
val length_16: char8 array -> int32 = length_13 (char8)
val fromPoly_0: char8 array -> char8 array = fromPoly (char8 array)
val copyVec_1: {di: int32, dst: char8 array, src: string} -> unit =
   copyVec_0 (char8)
val array_1: int32 * char8 -> char8 array = array_0 (char8)
val vector_6: char8 PrimSequence.Slice.t -> string = vector_2 (char8)
val toPoly_1: char8 PrimSequence.Slice.t -> char8 PrimSequence.Slice.t =
   toPoly (char8 PrimSequence.Slice.t)
val slice_7: char8 array * int32 * int32 Primitive.Option.t
	     -> char8 PrimSequence.Slice.t =
   slice_4 (char8)
val full_9: char8 array -> char8 PrimSequence.Slice.t = full_7 (char8)
val base_11: char8 PrimSequence.Slice.t -> char8 array * int32 * int32 =
   base_8 (char8)
val size: string -> int32 = length_14
val implode: char8 list -> string = fromList_2
val fChar8: {chrUnsafe: int32 -> char8,
	     maxChar: char8,
	     minChar: char8,
	     numChars: int32,
	     ord: char8 -> int32} =
   {chrUnsafe = (o_1 (int32, char8, word8) (idFromWord8, sextdToWord8)),
    ord = (o_1 (char8, int32, word8) (zextdFromWord8, idToWord8)),
    minChar = 0x0,
    maxChar = 0xFF,
    numChars = 0x100}
val fChar16: {chrUnsafe: int32 -> char16,
	      maxChar: char16,
	      minChar: char16,
	      numChars: int32,
	      ord: char16 -> int32} =
   {chrUnsafe = (o_1 (int32, char16, word16) (idFromWord16, sextdToWord16)),
    ord = (o_1 (char16, int32, word16) (zextdFromWord16, idToWord16)),
    minChar = 0x0,
    maxChar = 0xFFFF,
    numChars = 0x10000}
val fChar32: {chrUnsafe: int32 -> char32,
	      maxChar: char32,
	      minChar: char32,
	      numChars: int32,
	      ord: char32 -> int32} =
   {chrUnsafe = (o_1 (int32, char32, word32) (idFromWord32, sextdToWord32)),
    ord = (o_1 (char32, int32, word32) (zextdFromWord32, idToWord32)),
    minChar = 0x0,
    maxChar = 0x10FFFF,
    numChars = 0x110000}
val f: {chrUnsafe: int32 -> char8,
	maxChar: char8,
	minChar: char8,
	numChars: int32,
	ord: char8 -> int32} =
   fChar8
val _ = fChar16
val _ = fChar32
val {chrUnsafe = chrUnsafe: int32 -> char8,
     ord = ord: char8 -> int32,
     minChar = minChar: char8,
     maxChar = maxChar: char8,
     numChars = numChars: int32} =
   f
val _ = fChar8
val _ = fChar16
val rec ('b, 'a)
   readerN: ('b -> ('a * 'b) Primitive.Option.t) * int32
	    -> 'b -> ('a list * 'b) Primitive.Option.t = 
      (fn x_1256: ('b -> ('a * 'b) Primitive.Option.t) * int32 =>
       case x_1256 of
	 ((reader: 'b -> ('a * 'b) Primitive.Option.t, n: int32)) =>
	 (fn x_1257: 'b =>
	  case x_1257 of
	    state: 'b =>
	    let val rec
		   loop: int32 * 'b * 'a list
			 -> ('a list * 'b) Primitive.Option.t = 
		      (fn x_1258: int32 * 'b * 'a list =>
		       case x_1258 of
			 ((n: int32, state: 'b, accum: 'a list)) =>
			 case (<= (n, 0x0)) of
			   true =>
			   (SOME['a list * 'b] ((rev_1 ('a) accum), state))
			 | false =>
			   case (reader state) of
			     NONE['a * 'b] => NONE['a list * 'b]
			   | SOME['a * 'b] (x: 'a, state: 'b) =>
			     (loop ((- (n, 0x1)), state, (::['a] (x, accum)))))
	    in
	       (loop (n, state, []))
	    end))
val rec ('a_2826, 'a_2825)
   ignore: ('a_2826 -> bool)
	   -> ('a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t)
	      -> 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t = 
      (fn x_1259: 'a_2826 -> bool =>
       (fn x_1260: 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t =>
	case (x_1259, x_1260) of
	  (f: 'a_2826 -> bool,
	   reader: 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t) =>
	  let val rec
		 loop: 'a_2825 -> ('a_2826 * 'a_2825) Primitive.Option.t = 
		    (fn x_1261: 'a_2825 =>
		     case x_1261 of
		       (state: 'a_2825) =>
		       case (reader state) of
			 NONE['a_2826 * 'a_2825] => NONE['a_2826 * 'a_2825]
		       | SOME['a_2826 * 'a_2825] (x: 'a_2826, state: 'a_2825) =>
			 case (f x) of
			   true => (loop state)
			 | false => (SOME['a_2826 * 'a_2825] (x, state)))
	  in
	     loop
	  end))
val ('a_2828, 'a_2827) _ = ignore ('a_2828, 'a_2827)
val rec ('b, 'c, 'a)
   map: ('a -> 'c)
	-> ('b -> ('a * 'b) Primitive.Option.t)
	   -> 'b -> ('c * 'b) Primitive.Option.t = 
      (fn x_1262: 'a -> 'c =>
       (fn x_1263: 'b -> ('a * 'b) Primitive.Option.t =>
	case (x_1262, x_1263) of
	  (f: 'a -> 'c, reader: 'b -> ('a * 'b) Primitive.Option.t) =>
	  (fn x_1264: 'b =>
	   case x_1264 of
	     b: 'b =>
	     case (reader b) of
	       NONE['a * 'b] => NONE['c * 'b]
	     | SOME['a * 'b] (a: 'a, b: 'b) => (SOME['c * 'b] ((f a), b)))))
val rec ('a_2830, 'a_2829)
   reader2: ('a_2830 -> ('a_2829 * 'a_2830) Primitive.Option.t)
	    -> 'a_2830 -> (('a_2829 * 'a_2829) * 'a_2830) Primitive.Option.t = 
      (fn x_1265: 'a_2830 -> ('a_2829 * 'a_2830) Primitive.Option.t =>
       case x_1265 of
	 (reader: 'a_2830 -> ('a_2829 * 'a_2830) Primitive.Option.t) =>
	 ((map ('a_2830, 'a_2829 * 'a_2829, 'a_2829 list) (fn x_1266: 'a_2829 list =>
							   case x_1266 of
							     [y: 'a_2829,
							      z: 'a_2829] =>
							     (y, z)
							   | _ =>
							     raise (Fail "Reader.reader2"))) (readerN ('a_2830,
												       'a_2829) (reader,
														 0x2))))
val ('a_2832, 'a_2831) _ = reader2 ('a_2832, 'a_2831)
datatype StringCvt.radix = BIN
			   | OCT
			   | DEC
			   | HEX
val radixToInt: StringCvt.radix -> int32 =
   (fn x_1267: StringCvt.radix =>
    case x_1267 of
      BIN => 0x2 | OCT => 0x8 | DEC => 0xA | HEX => 0x10)
datatype StringCvt.realfmt = SCI of int32 Primitive.Option.t
			     | FIX of int32 Primitive.Option.t
			     | GEN of int32 Primitive.Option.t
			     | EXACT
val rec 'a_2839
   splitl: (char8 -> bool)
	   -> ('a_2839 -> (char8 * 'a_2839) Primitive.Option.t)
	      -> 'a_2839 -> string * 'a_2839 = 
      (fn x_1268: char8 -> bool =>
       (fn x_1269: 'a_2839 -> (char8 * 'a_2839) Primitive.Option.t =>
	(fn x_1270: 'a_2839 =>
	 case (x_1268, x_1269, x_1270) of
	   (p: char8 -> bool,
	    f: 'a_2839 -> (char8 * 'a_2839) Primitive.Option.t,
	    src: 'a_2839) =>
	   let val rec
		  done: char8 list -> string = 
		     (fn x_1272: char8 list =>
		      case x_1272 of
			(chars: char8 list) => (implode (rev_1 (char8) chars)))
	       val rec
		  loop: 'a_2839 * char8 list -> string * 'a_2839 = 
		     (fn x_1271: 'a_2839 * char8 list =>
		      case x_1271 of
			((src: 'a_2839, chars: char8 list)) =>
			case (f src) of
			  NONE[char8 * 'a_2839] => ((done chars), src)
			| SOME[char8 * 'a_2839] (c: char8, src': 'a_2839) =>
			  case (p c) of
			    true => (loop (src', (::[char8] (c, chars))))
			  | false => ((done chars), src))
	   in
	      (loop (src, []))
	   end)))
val rec 'a_2841
   dropl: (char8 -> bool)
	  -> ('a_2841 -> (char8 * 'a_2841) Primitive.Option.t)
	     -> 'a_2841 -> 'a_2841 = 
      (fn x_1273: char8 -> bool =>
       (fn x_1274: 'a_2841 -> (char8 * 'a_2841) Primitive.Option.t =>
	(fn x_1275: 'a_2841 =>
	 case (x_1273, x_1274, x_1275) of
	   (p: char8 -> bool,
	    f: 'a_2841 -> (char8 * 'a_2841) Primitive.Option.t,
	    s: 'a_2841) =>
	   ((fn x_1276: string * 'a_2841 =>
	     case x_1276 of
	       {2 = #: 'a_2841} => #) (((splitl ('a_2841) p) f) s)))))
val rec
   stringReader: string -> int32 -> (char8 * int32) Primitive.Option.t = 
      (fn x_1277: string =>
       case x_1277 of
	 (s: string) =>
	 (fn x_1278: int32 =>
	  case x_1278 of
	    i: int32 =>
	    case (>= (i, (size s))) of
	      true => NONE[char8 * int32]
	    | false => (SOME[char8 * int32] ((sub_10 (s, i)), (+ (i, 0x1))))))
val rec 'a
   scanString: ((int32 -> (char8 * int32) Primitive.Option.t)
		-> int32 -> ('a * int32) Primitive.Option.t)
	       -> string -> 'a Primitive.Option.t = 
      (fn x_1279: (int32 -> (char8 * int32) Primitive.Option.t)
		  -> int32 -> ('a * int32) Primitive.Option.t =>
       (fn x_1280: string =>
	case (x_1279, x_1280) of
	  (f: (int32 -> (char8 * int32) Primitive.Option.t)
	      -> int32 -> ('a * int32) Primitive.Option.t,
	   s: string) =>
	  case ((f (stringReader s)) 0x0) of
	    NONE['a * int32] => NONE['a]
	  | SOME['a * int32] (a: 'a, _) => (SOME['a] a)))
val rec 'a
   memoize: (char8 -> 'a) -> char8 -> 'a = 
      (fn x_1281: char8 -> 'a =>
       case x_1281 of
	 (f: char8 -> 'a) =>
	 let val a: 'a array =
		(tabulate_4 ('a) (numChars,
				  (o_1 (int32, 'a, char8) (f, chrUnsafe))))
	 in
	    (fn x_1282: char8 =>
	     case x_1282 of
	       c: char8 => (sub_9 ('a) (a, (ord c))))
	 end)
val rec
   range: int32 * char8 * char8 -> char8 -> int32 Primitive.Option.t = 
      (fn x_1283: int32 * char8 * char8 =>
       case x_1283 of
	 ((add: int32, cmin: char8, cmax: char8)) =>
	 let val min: int32 = (ord cmin)
	 in
	    (fn x_1284: char8 =>
	     case x_1284 of
	       c: char8 =>
	       case case (<= (cmin, c)) of
		      true => (<= (c, cmax)) | false => false of
		 true => (SOME[int32] (-? ((+? (add, (ord c))), min)))
	       | false => NONE[int32])
	 end)
val rec 'a
   combine: (char8 -> 'a Primitive.Option.t) list
	    -> char8 -> 'a Primitive.Option.t = 
      (fn x_1285: (char8 -> 'a Primitive.Option.t) list =>
       case x_1285 of
	 (ds: (char8 -> 'a Primitive.Option.t) list) =>
	 (memoize ('a Primitive.Option.t) (fn x_1286: char8 =>
					   case x_1286 of
					     c: char8 =>
					     let val rec 'a_2842
						    loop: (char8
							   -> 'a_2842 Primitive.Option.t) list
							  -> 'a_2842 Primitive.Option.t = 
						       (fn x_1287: (char8
								    -> 'a_2842 Primitive.Option.t) list =>
							case x_1287 of
							  [] => NONE['a_2842]
							| ::[char8
							     -> 'a_2842 Primitive.Option.t] (d: char8
												-> 'a_2842 Primitive.Option.t,
											     ds: (char8
												  -> 'a_2842 Primitive.Option.t) list) =>
							  case (d c) of
							    NONE['a_2842] =>
							    (loop ('a_2842) ds)
							  | z: 'a_2842 Primitive.Option.t =>
							    z)
					     in
						(loop ('a) ds)
					     end)))
val bin: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x31)))
val oct: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x37)))
val dec: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x39)))
val hex: char8 -> int32 Primitive.Option.t =
   (combine (int32) [(range (0x0, 0x30, 0x39)),
		     (range (0xA, 0x61, 0x66)),
		     (range (0xA, 0x41, 0x46))])
val rec
   isSpace: char8 -> bool = 
      (fn x_1288: char8 =>
       case x_1288 of
	 (c: char8) =>
	 case case case case case (= (char8) (c, 0x20)) of
			       true => true | false => (= (char8) (c, 0x9)) of
			  true => true | false => (= (char8) (c, 0xD)) of
		     true => true | false => (= (char8) (c, 0xA)) of
		true => true | false => (= (char8) (c, 0xB)) of
	   true => true | false => (= (char8) (c, 0xC)))
val isSpace: char8 -> bool = (memoize (bool) isSpace)
val rec 'a_2843
   skipWS: ('a_2843 -> (char8 * 'a_2843) Primitive.Option.t)
	   -> 'a_2843 -> 'a_2843 = 
      (fn x_1289: 'a_2843 -> (char8 * 'a_2843) Primitive.Option.t =>
       case x_1289 of
	 (x: 'a_2843 -> (char8 * 'a_2843) Primitive.Option.t) =>
	 ((dropl ('a_2843) isSpace) x))
val rec
   charToDigit: StringCvt.radix -> char8 -> int32 Primitive.Option.t = 
      (fn x_1290: StringCvt.radix =>
       case x_1290 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => bin | OCT => oct | DEC => dec | HEX => hex)
val rec
   digitToChar: int32 -> char8 = 
      (fn x_1291: int32 =>
       case x_1291 of
	 (n: int32) => (sub_10 ("0123456789ABCDEF", n)))
val 'a skipWS_0: ('a -> (char8 * 'a) Primitive.Option.t) -> 'a -> 'a =
   skipWS ('a)
val 'a scanString_0: ((int32 -> (char8 * int32) Primitive.Option.t)
		      -> int32 -> ('a * int32) Primitive.Option.t)
		     -> string -> 'a Primitive.Option.t =
   scanString ('a)
val not: bool -> bool = not
val precision': int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: int8 * word32 -> int8 = 
      (fn x_1292: int8 * word32 =>
       case x_1292 of
	 ((i: int8, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: int8 * word32 -> int8 = 
      (fn x_1293: int8 * word32 =>
       case x_1293 of
	 ((i: int8, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val precision': int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: int16 * word32 -> int16 = 
      (fn x_1294: int16 * word32 =>
       case x_1294 of
	 ((i: int16, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: int16 * word32 -> int16 = 
      (fn x_1295: int16 * word32 =>
       case x_1295 of
	 ((i: int16, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val precision': int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: int32 * word32 -> int32 = 
      (fn x_1296: int32 * word32 =>
       case x_1296 of
	 ((i: int32, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: int32 * word32 -> int32 = 
      (fn x_1297: int32 * word32 =>
       case x_1297 of
	 ((i: int32, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val fromInt: int32 -> int32 = schckFromInt
val toInt: int32 -> int32 = schckToInt
val maxNumDigits: int32 = (+ (precision', 0x1))
val oneBuf: char8 array One.t =
   (make_0 (char8 array) (fn x_1298: unit =>
			  case x_1298 of
			    () => (array_1 (maxNumDigits, 0x0))))
val rec
   fmt: StringCvt.radix -> int32 -> string = 
      (fn x_1299: StringCvt.radix =>
       (fn x_1300: int32 =>
	case (x_1299, x_1300) of
	  (radix: StringCvt.radix, n: int32) =>
	  (use_0 (string, char8 array) (oneBuf,
					(fn x_1301: char8 array =>
					 case x_1301 of
					   buf: char8 array =>
					   let val radix: int32 =
						  (fromInt (radixToInt radix))
					       val rec
						  loop: int32 * int32 -> string = 
						     (fn x_1302: int32 * int32 =>
						      case x_1302 of
							((q: int32, i: int32)) =>
							let val _ =
							       (update_1 (buf,
									  i,
									  (digitToChar (toInt (~? (rem (q,
													radix)))))))
							    val q: int32 =
							       (quot (q, radix))
							in
							   case (= (int32) (q,
									    zero)) of
							     true =>
							     let val start: int32 =
								    case (< (n,
									     zero)) of
								      true =>
								      let val i: int32 =
									     (- (i,
										 0x1))
									  val () =
									     (update_1 (buf,
											i,
											0x7E))
								      in
									 i
								      end
								    | false => i
							     in
								(vector_6 (slice_7 (buf,
										    start,
										    NONE[int32])))
							     end
							   | false =>
							     (loop (q,
								    (- (i, 0x1))))
							end)
					   in
					      (loop (case (< (n, zero)) of
						       true => n
						     | false => (~? n),
						     (- (maxNumDigits, 0x1))))
					   end)))))
val toString: int32 -> string = (fmt DEC)
val rec 'a_2855
   scan: StringCvt.radix
	 -> ('a_2855 -> (char8 * 'a_2855) Primitive.Option.t)
	    -> 'a_2855 -> (int32 * 'a_2855) Primitive.Option.t = 
      (fn x_1303: StringCvt.radix =>
       (fn x_1304: 'a_2855 -> (char8 * 'a_2855) Primitive.Option.t =>
	(fn x_1305: 'a_2855 =>
	 case (x_1303, x_1304, x_1305) of
	   (radix: StringCvt.radix,
	    reader: 'a_2855 -> (char8 * 'a_2855) Primitive.Option.t,
	    s: 'a_2855) =>
	   let val s: 'a_2855 = ((skipWS_0 ('a_2855) reader) s)
	       val rec
		  charToDigit: char8 -> int32 Primitive.Option.t = 
		     (fn x_1309: char8 =>
		      case x_1309 of
			(c: char8) =>
			case ((charToDigit radix) c) of
			  NONE[int32] => NONE[int32]
			| SOME[int32] n: int32 => (SOME[int32] (fromInt n)))
	       val radixInt: int32 = (fromInt (radixToInt radix))
	       val rec
		  finishNum: 'a_2855 * int32
			     -> (int32 * 'a_2855) Primitive.Option.t = 
		     (fn x_1308: 'a_2855 * int32 =>
		      case x_1308 of
			((s: 'a_2855, n: int32)) =>
			case (reader s) of
			  NONE[char8 * 'a_2855] =>
			  (SOME[int32 * 'a_2855] (n, s))
			| SOME[char8 * 'a_2855] (c: char8, s': 'a_2855) =>
			  case (charToDigit c) of
			    NONE[int32] => (SOME[int32 * 'a_2855] (n, s))
			  | SOME[int32] n': int32 =>
			    (finishNum (s', (- ((* (n, radixInt)), n')))))
	       val rec
		  num: 'a_2855 -> (int32 * 'a_2855) Primitive.Option.t = 
		     (fn x_1307: 'a_2855 =>
		      case x_1307 of
			(s: 'a_2855) =>
			case ((reader s), radix) of
			  (NONE[char8 * 'a_2855], _) => NONE[int32 * 'a_2855]
			| (SOME[char8 * 'a_2855] (0x30, s: 'a_2855), HEX) =>
			  case (reader s) of
			    NONE[char8 * 'a_2855] =>
			    (SOME[int32 * 'a_2855] (zero, s))
			  | SOME[char8 * 'a_2855] (c: char8, s': 'a_2855) =>
			    case case (= (char8) (c, 0x78)) of
				   true => true | false => (= (char8) (c, 0x58)) of
			      true =>
			      case (reader s') of
				NONE[char8 * 'a_2855] =>
				(SOME[int32 * 'a_2855] (zero, s))
			      | SOME[char8 * 'a_2855] (c: char8, s': 'a_2855) =>
				case (charToDigit c) of
				  NONE[int32] =>
				  (SOME[int32 * 'a_2855] (zero, s))
				| SOME[int32] n: int32 =>
				  (finishNum (s', (~? n)))
			    | false =>
			      case (charToDigit c) of
				NONE[int32] => (SOME[int32 * 'a_2855] (zero, s))
			      | SOME[int32] n: int32 => (finishNum (s', (~? n)))
			| (SOME[char8 * 'a_2855] (c: char8, s: 'a_2855), _) =>
			  case (charToDigit c) of
			    NONE[int32] => NONE[int32 * 'a_2855]
			  | SOME[int32] n: int32 => (finishNum (s, (~? n))))
	       val rec
		  negate: 'a_2855 -> (int32 * 'a_2855) Primitive.Option.t = 
		     (fn x_1306: 'a_2855 =>
		      case x_1306 of
			(s: 'a_2855) =>
			case (num s) of
			  NONE[int32 * 'a_2855] => NONE[int32 * 'a_2855]
			| SOME[int32 * 'a_2855] (n: int32, s: 'a_2855) =>
			  (SOME[int32 * 'a_2855] ((~ n), s)))
	   in
	      case (reader s) of
		NONE[char8 * 'a_2855] => NONE[int32 * 'a_2855]
	      | SOME[char8 * 'a_2855] (c: char8, s': 'a_2855) =>
		case c of
		  0x7E => (num s')
		| 0x2D => (num s') | 0x2B => (negate s') | _ => (negate s)
	   end)))
val fromString: string -> int32 Primitive.Option.t =
   (scanString_0 (int32) (scan (int32) DEC))
val precision': int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: int64 * word32 -> int64 = 
      (fn x_1310: int64 * word32 =>
       case x_1310 of
	 ((i: int64, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: int64 * word32 -> int64 = 
      (fn x_1311: int64 * word32 =>
       case x_1311 of
	 ((i: int64, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val fromInt: int32 -> int64 = schckFromInt
val toInt: int64 -> int32 = schckToInt
val toLargeInt: int64 -> intInf = schckToLargeInt
val maxNumDigits: int32 = (+ (precision', 0x1))
val oneBuf: char8 array One.t =
   (make_0 (char8 array) (fn x_1312: unit =>
			  case x_1312 of
			    () => (array_1 (maxNumDigits, 0x0))))
val rec
   fmt: StringCvt.radix -> int64 -> string = 
      (fn x_1313: StringCvt.radix =>
       (fn x_1314: int64 =>
	case (x_1313, x_1314) of
	  (radix: StringCvt.radix, n: int64) =>
	  (use_0 (string, char8 array) (oneBuf,
					(fn x_1315: char8 array =>
					 case x_1315 of
					   buf: char8 array =>
					   let val radix: int64 =
						  (fromInt (radixToInt radix))
					       val rec
						  loop: int64 * int32 -> string = 
						     (fn x_1316: int64 * int32 =>
						      case x_1316 of
							((q: int64, i: int32)) =>
							let val _ =
							       (update_1 (buf,
									  i,
									  (digitToChar (toInt (~? (rem (q,
													radix)))))))
							    val q: int64 =
							       (quot (q, radix))
							in
							   case (= (int64) (q,
									    zero)) of
							     true =>
							     let val start: int32 =
								    case (< (n,
									     zero)) of
								      true =>
								      let val i: int32 =
									     (- (i,
										 0x1))
									  val () =
									     (update_1 (buf,
											i,
											0x7E))
								      in
									 i
								      end
								    | false => i
							     in
								(vector_6 (slice_7 (buf,
										    start,
										    NONE[int32])))
							     end
							   | false =>
							     (loop (q,
								    (- (i, 0x1))))
							end)
					   in
					      (loop (case (< (n, zero)) of
						       true => n
						     | false => (~? n),
						     (- (maxNumDigits, 0x1))))
					   end)))))
val wordSize: int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: word8 * word32 -> word8 = 
      (fn x_1317: word8 * word32 =>
       case x_1317 of
	 ((i: word8, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: word8 * word32 -> word8 = 
      (fn x_1318: word8 * word32 =>
       case x_1318 of
	 ((i: word8, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val wordSize: int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: word16 * word32 -> word16 = 
      (fn x_1319: word16 * word32 =>
       case x_1319 of
	 ((i: word16, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: word16 * word32 -> word16 = 
      (fn x_1320: word16 * word32 =>
       case x_1320 of
	 ((i: word16, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val wordSize: int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: word32 * word32 -> word32 = 
      (fn x_1321: word32 * word32 =>
       case x_1321 of
	 ((i: word32, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: word32 * word32 -> word32 = 
      (fn x_1322: word32 * word32 =>
       case x_1322 of
	 ((i: word32, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val rec
   st: word32 * word32 * word32 -> word32 * word32 * word32 = 
      (fn x_1323: word32 * word32 * word32 =>
       case x_1323 of
	 ((w: word32, msk: word32, sft: word32)) =>
	 let val odd: word32 = (andb (w, msk))
	     val evn: word32 = (xorb (w, odd))
	 in
	    ((xorb ((<<? (odd, sft)), (>>? (evn, sft)))),
	     (xorb (msk, (<<? (msk, (>>? (sft, 0x1)))))),
	     (>>? (sft, 0x1)))
	 end)
val (f: word32 * word32 * word32 -> word32 * word32 * word32, sft: word32) =
   case sizeInBitsWord of
     0x8 =>
     ((fn x_1324: word32 * word32 * word32 =>
       case x_1324 of
	 x: word32 * word32 * word32 => x),
      0x4)
   | 0x10 => (st, 0x8)
   | 0x20 =>
     ((o_1 (word32 * word32 * word32,
	    word32 * word32 * word32,
	    word32 * word32 * word32) (st, st)),
      0x10)
   | 0x40 =>
     ((o_1 (word32 * word32 * word32,
	    word32 * word32 * word32,
	    word32 * word32 * word32) ((o_1 (word32 * word32 * word32,
				 word32 * word32 * word32,
				 word32 * word32 * word32) (st, st)),
			   st)),
      0x20)
   | _ => raise (Fail "Word.bswap")
val rec
   bswap: word32 -> word32 = 
      (fn x_1325: word32 =>
       case x_1325 of
	 (w: word32) =>
	 ((fn x_1326: word32 * word32 * word32 =>
	   case x_1326 of
	     {1 = #: word32} => #) (f (w, (- ((<<? (one, sft)), one)), sft))))
val fromInt: int32 -> word32 = sextdFromInt
val rec
   toInt: word32 -> int32 = 
      (fn x_1327: word32 =>
       case x_1327 of
	 (w: word32) =>
	 let val i: int32 = (zchckToInt w)
	 in
	    case case case detectOverflow of
			true =>
			case precision of
			  NONE[int32] => false
			| SOME[int32] precision: int32 =>
			  (<= (precision, sizeInBits))
		      | false => false of
		   true => (< (i, 0x0)) | false => false of
	      true => raise Overflow | false => i
	 end)
val wordSize: int32 = (zextdToInt sizeInBits)
val sizeInBitsWord: word32 = (zextdToWord sizeInBitsWord)
val rec
   <<: word64 * word32 -> word64 = 
      (fn x_1328: word64 * word32 =>
       case x_1328 of
	 ((i: word64, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (<<? (i, (zextdFromWord n))))
val rec
   >>: word64 * word32 -> word64 = 
      (fn x_1329: word64 * word32 =>
       case x_1329 of
	 ((i: word64, n: word32)) =>
	 case (>= (n, sizeInBitsWord)) of
	   true => zero | false => (>>? (i, (zextdFromWord n))))
val fromInt: int32 -> word64 = sextdFromInt
val rec
   toInt: word64 -> int32 = 
      (fn x_1330: word64 =>
       case x_1330 of
	 (w: word64) =>
	 let val i: int32 = (zchckToInt w)
	 in
	    case case case detectOverflow of
			true =>
			case precision of
			  NONE[int32] => false
			| SOME[int32] precision: int32 =>
			  (<= (precision, sizeInBits))
		      | false => false of
		   true => (< (i, 0x0)) | false => false of
	      true => raise Overflow | false => i
	 end)
val rec
   toLargeInt: word64 -> intInf = 
      (fn x_1331: word64 =>
       case x_1331 of
	 (w: word64) =>
	 let val i: intInf = (zchckToLargeInt w)
	 in
	    case case case detectOverflow of
			true =>
			case precision_0 of
			  NONE[int32] => false
			| SOME[int32] precision: int32 =>
			  (<= (precision, sizeInBits))
		      | false => false of
		   true => (< (i, 0)) | false => false of
	      true => raise Overflow | false => i
	 end)
val binCvt: intInf -> string = (mkCvt {base = 0x2, smallCvt = (fmt BIN)})
val octCvt: intInf -> string = (mkCvt {base = 0x8, smallCvt = (fmt OCT)})
val decCvt: intInf -> string = (mkCvt {base = 0xA, smallCvt = (fmt DEC)})
val hexCvt: intInf -> string = (mkCvt {base = 0x10, smallCvt = (fmt HEX)})
val rec
   fmt: StringCvt.radix -> intInf -> string = 
      (fn x_1332: StringCvt.radix =>
       case x_1332 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => binCvt | OCT => octCvt | DEC => decCvt | HEX => hexCvt)
val toString: intInf -> string = (fmt DEC)
val rec
   binDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1333: char8 =>
       case x_1333 of
	 (ch: char8) =>
	 case ch of
	   0x30 => (SOME[word64] 0x0)
	 | 0x31 => (SOME[word64] 0x1) | _ => NONE[word64])
val <=: char8 * char8 -> bool = <=
val rec
   octDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1334: char8 =>
       case x_1334 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x37)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false => NONE[word64])
val rec
   decDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1335: char8 =>
       case x_1335 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x39)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false => NONE[word64])
val rec
   hexDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1336: char8 =>
       case x_1336 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x39)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false =>
	   case case (<= (0x61, ch)) of
		  true => (<= (ch, 0x66)) | false => false of
	     true =>
	     (SOME[word64] (fromInt (- ((ord ch), (- ((ord 0x61), 0xA))))))
	   | false =>
	     case case (<= (0x41, ch)) of
		    true => (<= (ch, 0x46)) | false => false of
	       true =>
	       (SOME[word64] (fromInt (- ((ord ch), (- ((ord 0x41), 0xA))))))
	     | false => NONE[word64])
val rec 'a
   toDigR: (char8 -> word64 Primitive.Option.t)
	   * ('a -> (char8 * 'a) Primitive.Option.t)
	   -> 'a -> (word64 * 'a) Primitive.Option.t = 
      (fn x_1337: (char8 -> word64 Primitive.Option.t)
		  * ('a -> (char8 * 'a) Primitive.Option.t) =>
       (fn x_1338: 'a =>
	case (x_1337, x_1338) of
	  ((charToDig: char8 -> word64 Primitive.Option.t,
	    cread: 'a -> (char8 * 'a) Primitive.Option.t),
	   s: 'a) =>
	  case (cread s) of
	    NONE[char8 * 'a] => NONE[word64 * 'a]
	  | SOME[char8 * 'a] (ch: char8, s': 'a) =>
	    case (charToDig ch) of
	      NONE[word64] => NONE[word64 * 'a]
	    | SOME[word64] dig: word64 => (SOME[word64 * 'a] (dig, s'))))
val rec 'a
   toChunkR: word64 * ('a -> (word64 * 'a) Primitive.Option.t)
	     -> 'a
		-> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t = 
      (fn x_1339: word64 * ('a -> (word64 * 'a) Primitive.Option.t) =>
       case x_1339 of
	 ((base: word64, dread: 'a -> (word64 * 'a) Primitive.Option.t)) =>
	 let val rec
		loop: {chunk: word64, left: int32, s: 'a, shift: word64}
		      -> {chunk: word64, more: bool, shift: word64} * 'a = 
		   (fn x_1341: {chunk: word64, left: int32, s: 'a, shift: word64} =>
		    case x_1341 of
		      ({left = left: int32,
			shift = shift: word64,
			chunk = chunk: word64,
			s = s: 'a}) =>
		      case (<= (left, 0x0)) of
			true => ({more = true, shift = shift, chunk = chunk}, s)
		      | false =>
			case (dread s) of
			  NONE[word64 * 'a] =>
			  ({more = false, shift = shift, chunk = chunk}, s)
			| SOME[word64 * 'a] (dig: word64, s': 'a) =>
			  (loop {left = (- (left, 0x1)),
				 shift = (* (base, shift)),
				 chunk = (+ ((* (base, chunk)), dig)),
				 s = s'}))
	     val digitsPerChunk: int32 =
		case (wordSize, base) of
		  (0x40, 0x10) => 0xF
		| (0x40, 0xA) => 0x12
		| (0x40, 0x8) => 0x14
		| (0x40, 0x2) => 0x3D
		| (0x20, 0x10) => 0x7
		| (0x20, 0xA) => 0x8
		| (0x20, 0x8) => 0x9
		| (0x20, 0x2) => 0x1D
		| _ => raise (Fail "IntInf.scan:digitsPerChunk")
	     val rec
		reader: 'a
			-> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t = 
		   (fn x_1340: 'a =>
		    case x_1340 of
		      (s: 'a) =>
		      case (dread s) of
			NONE[word64 * 'a] =>
			NONE[{chunk: word64, more: bool, shift: word64} * 'a]
		      | SOME[word64 * 'a] (dig: word64, next: 'a) =>
			(SOME[{chunk: word64, more: bool, shift: word64} * 'a] (loop {left = (- (digitsPerChunk,
												 0x1)),
										      shift = base,
										      chunk = dig,
										      s = next})))
	 in
	    reader
	 end)
val rec 'a
   toUnsR: ('a
	    -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1342: 'a
		  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t =>
       case x_1342 of
	 (ckread: 'a
		  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t) =>
	 let val rec
		loop: bool * intInf * 'a -> intInf * 'a = 
		   (fn x_1344: bool * intInf * 'a =>
		    case x_1344 of
		      ((more: bool, acc: intInf, s: 'a)) =>
		      case more of
			true =>
			case (ckread s) of
			  NONE[{chunk: word64, more: bool, shift: word64} * 'a] =>
			  (acc, s)
			| SOME[{chunk: word64, more: bool, shift: word64} * 'a] ({more = more: bool,
										  shift = shift: word64,
										  chunk = chunk: word64},
										 s': 'a) =>
			  (loop (more,
				 (+ ((* ((toLargeInt shift), acc)),
				     (toLargeInt chunk))),
				 s'))
		      | false => (acc, s))
	     val rec
		reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		   (fn x_1343: 'a =>
		    case x_1343 of
		      (s: 'a) =>
		      case (ckread s) of
			NONE[{chunk: word64, more: bool, shift: word64} * 'a] =>
			NONE[intInf * 'a]
		      | SOME[{chunk: word64, more: bool, shift: word64} * 'a] ({more = more: bool,
										chunk = chunk: word64},
									       s': 'a) =>
			(SOME[intInf * 'a] (loop (more, (toLargeInt chunk), s'))))
	 in
	    reader
	 end)
val rec 'a
   toHexR: ('a -> (char8 * 'a) Primitive.Option.t)
	   * ('a -> (intInf * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1345: ('a -> (char8 * 'a) Primitive.Option.t)
		  * ('a -> (intInf * 'a) Primitive.Option.t) =>
       (fn x_1346: 'a =>
	case (x_1345, x_1346) of
	  ((cread: 'a -> (char8 * 'a) Primitive.Option.t,
	    uread: 'a -> (intInf * 'a) Primitive.Option.t),
	   s: 'a) =>
	  case (cread s) of
	    NONE[char8 * 'a] => NONE[intInf * 'a]
	  | SOME[char8 * 'a] (c1: char8, s1: 'a) =>
	    case (= (char8) (c1, 0x30)) of
	      true =>
	      case (cread s1) of
		NONE[char8 * 'a] => (SOME[intInf * 'a] (zero, s1))
	      | SOME[char8 * 'a] (c2: char8, s2: 'a) =>
		case case (= (char8) (c2, 0x78)) of
		       true => true | false => (= (char8) (c2, 0x58)) of
		  true =>
		  case (uread s2) of
		    NONE[intInf * 'a] => (SOME[intInf * 'a] (zero, s1))
		  | SOME[intInf * 'a] x: intInf * 'a => (SOME[intInf * 'a] x)
		| false => (uread s)
	    | false => (uread s)))
val rec 'a
   toSign: ('a -> (char8 * 'a) Primitive.Option.t)
	   * ('a -> (intInf * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1347: ('a -> (char8 * 'a) Primitive.Option.t)
		  * ('a -> (intInf * 'a) Primitive.Option.t) =>
       case x_1347 of
	 ((cread: 'a -> (char8 * 'a) Primitive.Option.t,
	   uread: 'a -> (intInf * 'a) Primitive.Option.t)) =>
	 let val rec
		reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		   (fn x_1348: 'a =>
		    case x_1348 of
		      (s: 'a) =>
		      let val s: 'a = ((skipWS_0 ('a) cread) s)
		      in
			 case (cread s) of
			   NONE[char8 * 'a] => NONE[intInf * 'a]
			 | SOME[char8 * 'a] (ch: char8, s': 'a) =>
			   let val (isNeg: bool, s'': 'a) =
				  case ch of
				    0x2B => (false, s')
				  | 0x2D => (true, s')
				  | 0x7E => (true, s')
				  | _ => (false, s)
			   in
			      case isNeg of
				true =>
				case (uread s'') of
				  NONE[intInf * 'a] => NONE[intInf * 'a]
				| SOME[intInf * 'a] (abs: intInf, s''': 'a) =>
				  (SOME[intInf * 'a] ((~ abs), s'''))
			      | false => (uread s'')
			   end
		      end)
	 in
	    reader
	 end)
val rec 'a
   reader: word64 * (char8 -> word64 Primitive.Option.t)
	   -> ('a -> (char8 * 'a) Primitive.Option.t)
	      -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1349: word64 * (char8 -> word64 Primitive.Option.t) =>
       (fn x_1350: 'a -> (char8 * 'a) Primitive.Option.t =>
	case (x_1349, x_1350) of
	  ((base: word64, dig: char8 -> word64 Primitive.Option.t),
	   cread: 'a -> (char8 * 'a) Primitive.Option.t) =>
	  let val dread: 'a -> (word64 * 'a) Primitive.Option.t =
		 (toDigR ('a) (dig, cread))
	      val ckread: 'a
			  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t =
		 (toChunkR ('a) (base, dread))
	      val uread: 'a -> (intInf * 'a) Primitive.Option.t =
		 (toUnsR ('a) ckread)
	      val hread: 'a -> (intInf * 'a) Primitive.Option.t =
		 case (= (word64) (base, 0x10)) of
		   true => (toHexR ('a) (cread, uread)) | false => uread
	      val reader: 'a -> (intInf * 'a) Primitive.Option.t =
		 (toSign ('a) (cread, hread))
	  in
	     reader
	  end))
val rec 'a_3028
   binReader: ('a_3028 -> (char8 * 'a_3028) Primitive.Option.t)
	      -> 'a_3028 -> (intInf * 'a_3028) Primitive.Option.t = 
      (fn x_1351: 'a_3028 -> (char8 * 'a_3028) Primitive.Option.t =>
       case x_1351 of
	 (z: 'a_3028 -> (char8 * 'a_3028) Primitive.Option.t) =>
	 ((reader ('a_3028) (0x2, binDig)) z))
val rec 'a_3029
   octReader: ('a_3029 -> (char8 * 'a_3029) Primitive.Option.t)
	      -> 'a_3029 -> (intInf * 'a_3029) Primitive.Option.t = 
      (fn x_1352: 'a_3029 -> (char8 * 'a_3029) Primitive.Option.t =>
       case x_1352 of
	 (z: 'a_3029 -> (char8 * 'a_3029) Primitive.Option.t) =>
	 ((reader ('a_3029) (0x8, octDig)) z))
val rec 'a_3030
   decReader: ('a_3030 -> (char8 * 'a_3030) Primitive.Option.t)
	      -> 'a_3030 -> (intInf * 'a_3030) Primitive.Option.t = 
      (fn x_1353: 'a_3030 -> (char8 * 'a_3030) Primitive.Option.t =>
       case x_1353 of
	 (z: 'a_3030 -> (char8 * 'a_3030) Primitive.Option.t) =>
	 ((reader ('a_3030) (0xA, decDig)) z))
val rec 'a_3031
   hexReader: ('a_3031 -> (char8 * 'a_3031) Primitive.Option.t)
	      -> 'a_3031 -> (intInf * 'a_3031) Primitive.Option.t = 
      (fn x_1354: 'a_3031 -> (char8 * 'a_3031) Primitive.Option.t =>
       case x_1354 of
	 (z: 'a_3031 -> (char8 * 'a_3031) Primitive.Option.t) =>
	 ((reader ('a_3031) (0x10, hexDig)) z))
val rec 'a_3032
   scan: StringCvt.radix
	 -> ('a_3032 -> (char8 * 'a_3032) Primitive.Option.t)
	    -> 'a_3032 -> (intInf * 'a_3032) Primitive.Option.t = 
      (fn x_1355: StringCvt.radix =>
       case x_1355 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => binReader ('a_3032)
	 | OCT => octReader ('a_3032)
	 | DEC => decReader ('a_3032)
	 | HEX => hexReader ('a_3032))
val fromString: string -> intInf Primitive.Option.t =
   (scanString_0 (intInf) (scan (int32) DEC))
val +: int32 * int32 -> int32 = +
val -: int32 * int32 -> int32 = -
val <: int32 * int32 -> bool = <
val <=: int32 * int32 -> bool = <=
val >: int32 * int32 -> bool = >
val >=: int32 * int32 -> bool = >=
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val fWord8: word8 array * int64 -> word8 = subArr
val fWord16: word8 array * int64 -> word16 = subArr
val fWord64: word8 array * int64 -> word64 = subArr
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 vector * int64 -> word8 = subVec
val fWord16: word8 vector * int64 -> word16 = subVec
val fWord64: word8 vector * int64 -> word64 = subVec
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 array * int64 * word8 -> unit = update
val fWord16: word8 array * int64 * word16 -> unit = update
val fWord64: word8 array * int64 * word64 -> unit = update
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 array * int64 -> word8 = subArr
val fWord16: word8 array * int64 -> word16 = subArr
val fWord32: word8 array * int64 -> word32 = subArr
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 vector * int64 -> word8 = subVec
val fWord16: word8 vector * int64 -> word16 = subVec
val fWord32: word8 vector * int64 -> word32 = subVec
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 array * int64 * word8 -> unit = update
val fWord16: word8 array * int64 * word16 -> unit = update
val fWord32: word8 array * int64 * word32 -> unit = update
val _ = fWord8
val _ = fWord16
val _ = fWord32
val maxOrd: int32 = (- (numChars, 0x1))
val rec
   chrOpt: int32 -> char8 Primitive.Option.t = 
      (fn x_1356: int32 =>
       case x_1356 of
	 (c: int32) =>
	 case case safe of
		true => (gtu (c, maxOrd)) | false => false of
	   true => NONE[char8] | false => (SOME[char8] (chrUnsafe c)))
val rec
   chr: int32 -> char8 = 
      (fn x_1357: int32 =>
       case x_1357 of
	 (c: int32) =>
	 case (chrOpt c) of
	   NONE[char8] => raise Chr | SOME[char8] c: char8 => c)
val new: int32 * char8 -> string = vector_4
val rec
   str: char8 -> string = 
      (fn x_1358: char8 =>
       case x_1358 of
	 (c: char8) => (new (0x1, c)))
val size: string -> int32 = length_14
val ^: string * string -> string = append_4
val implode: char8 list -> string = fromList_2
val rec
   extract: string * int32 * int32 Primitive.Option.t -> string = 
      (fn x_1359: string * int32 * int32 Primitive.Option.t =>
       case x_1359 of
	 ((s: string, start: int32, len: int32 Primitive.Option.t)) =>
	 (vector_5 (slice_6 (s, start, len))))
val rec
   substring: string * int32 * int32 -> string = 
      (fn x_1360: string * int32 * int32 =>
       case x_1360 of
	 ((s: string, start: int32, len: int32)) =>
	 (extract (s, start, (SOME[int32] len))))
val rec 'a_3438
   make: ((char8 * char8 -> bool) -> 'a_3438) -> 'a_3438 = 
      (fn x_1361: (char8 * char8 -> bool) -> 'a_3438 =>
       case x_1361 of
	 (f: (char8 * char8 -> bool) -> 'a_3438) => (f = (char8)))
val isPrefix: string -> string -> bool =
   (make (string -> string -> bool) isPrefix_2)
val null: string = (str (chr 0x0))
val rec
   nullTerm: string -> string = 
      (fn x_1362: string =>
       case x_1362 of
	 (s: string) => (^ (s, null)))
val string: char8 PrimSequence.Slice.t -> string = vector_5
val _ =
   (addExnMessager (fn x_1363: exn =>
		    case x_1363 of
		      e: exn =>
		      case e of
			Fail s: string =>
			(SOME[string] (concat_2 ["Fail: ", s]))
		      | _ => NONE[string]))
val nullTerm: string -> string =
   (o_1 (string, string, string) (fromString, nullTerm))
val rec ('a_3451, 'a_3450)
   makeLength: ('a_3450 * int32 -> 'a_3451) * ('a_3451 -> bool)
	       -> 'a_3450 -> int32 = 
      (fn x_1364: ('a_3450 * int32 -> 'a_3451) * ('a_3451 -> bool) =>
       (fn x_1365: 'a_3450 =>
	case (x_1364, x_1365) of
	  ((sub: 'a_3450 * int32 -> 'a_3451, term: 'a_3451 -> bool), p: 'a_3450) =>
	  let val rec
		 loop: int32 -> int32 = 
		    (fn x_1366: int32 =>
		     case x_1366 of
		       (i: int32) =>
		       case (term (sub (p, i))) of
			 true => i | false => (loop (+? (i, 0x1))))
	  in
	     (loop 0x0)
	  end))
val rec ('b, 'a)
   toArrayOfLength: 'a * ('a * int32 -> 'b) * int32 -> 'b array = 
      (fn x_1367: 'a * ('a * int32 -> 'b) * int32 =>
       case x_1367 of
	 ((s: 'a, sub: 'a * int32 -> 'b, n: int32)) =>
	 let val (a: 'b array, _) =
		(unfoldi_5 ('b, unit) (n,
				       (),
				       (fn x_1368: int32 * unit =>
					case x_1368 of
					  (i: int32, ()) => ((sub (s, i)), ()))))
	 in
	    a
	 end)
val rec
   sub: word64 * int32 -> char8 = 
      (fn x_1369: word64 * int32 =>
       case x_1369 of
	 ((cs: word64, i: int32)) =>
	 (idFromWord8 (getWord8 ((fromWord cs), (fromInt i)))))
val length: word64 -> int32 =
   (makeLength (char8, word64) (sub,
				(fn x_1370: char8 =>
				 case x_1370 of
				   0x0 => true | _ => false)))
val rec
   toCharArrayOfLength: word64 * int32 -> char8 array = 
      (fn x_1371: word64 * int32 =>
       case x_1371 of
	 ((cs: word64, n: int32)) =>
	 (toArrayOfLength (char8, word64) (cs, sub, n)))
val rec
   toStringOfLength: word64 * int32 -> string = 
      (fn x_1372: word64 * int32 =>
       case x_1372 of
	 ((cs: word64, n: int32)) =>
	 (unsafeFromArray_1 (fromPoly_0 (toCharArrayOfLength (cs, n)))))
val rec
   toString: word64 -> string = 
      (fn x_1373: word64 =>
       case x_1373 of
	 (cs: word64) => (toStringOfLength (cs, (length cs))))
val rec
   new: unit -> (unit -> unit) list ref = 
      (fn x_1374: unit =>
       case x_1374 of
	 (()) => (ref[(unit -> unit) list] []))
val rec 'a_3452
   addNew: 'a_3452 list ref * 'a_3452 -> unit = 
      (fn x_1375: 'a_3452 list ref * 'a_3452 =>
       case x_1375 of
	 ((cs: 'a_3452 list ref, f: 'a_3452)) =>
	 (:=_1 ('a_3452 list) (cs, (::['a_3452] (f, (!_1 ('a_3452 list) cs))))))
val rec
   clean: (unit -> unit) list ref -> unit = 
      (fn x_1376: (unit -> unit) list ref =>
       case x_1376 of
	 (cs: (unit -> unit) list ref) =>
	 ((app_1 (unit -> unit) (fn x_1377: unit -> unit =>
				 case x_1377 of
				   c: unit -> unit =>
				   (c ())
				   handle x_1378 => case x_1378 of
						      _ => ())) (!_1 ((unit -> unit) list) cs)))
val atExit: (unit -> unit) list ref = (new ())
val atLoadWorld: (unit -> unit) list ref = (new ())
val addNew_0: (unit -> unit) list ref * (unit -> unit) -> unit =
   addNew (unit -> unit)
val fromRep: int32 -> int32 = (fn x_1379: int32 => case x_1379 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1380: int32 => case x_1380 of x: int32 => x)
val fromRep: int32 -> int32 = (fn x_1381: int32 => case x_1381 of x: int32 => x)
val fromRep: int32 -> int32 = (fn x_1382: int32 => case x_1382 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1383: int32 => case x_1383 of x: int32 => x)
val fromRep: word32 -> word32 =
   (fn x_1384: word32 =>
    case x_1384 of
      x: word32 => x)
val fromRep: int32 -> int32 = (fn x_1385: int32 => case x_1385 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1386: int32 => case x_1386 of x: int32 => x)
val fromRep: word32 -> word32 =
   (fn x_1387: word32 =>
    case x_1387 of
      x: word32 => x)
val acces: int32 = (fromRep EACCES)
val addrinuse: int32 = (fromRep EADDRINUSE)
val addrnotavail: int32 = (fromRep EADDRNOTAVAIL)
val afnosupport: int32 = (fromRep EAFNOSUPPORT)
val again: int32 = (fromRep EAGAIN)
val already: int32 = (fromRep EALREADY)
val badf: int32 = (fromRep EBADF)
val badmsg: int32 = (fromRep EBADMSG)
val busy: int32 = (fromRep EBUSY)
val canceled: int32 = (fromRep ECANCELED)
val child: int32 = (fromRep ECHILD)
val connaborted: int32 = (fromRep ECONNABORTED)
val connrefused: int32 = (fromRep ECONNREFUSED)
val connreset: int32 = (fromRep ECONNRESET)
val deadlk: int32 = (fromRep EDEADLK)
val destaddrreq: int32 = (fromRep EDESTADDRREQ)
val dom: int32 = (fromRep EDOM)
val dquot: int32 = (fromRep EDQUOT)
val exist: int32 = (fromRep EEXIST)
val fault: int32 = (fromRep EFAULT)
val fbig: int32 = (fromRep EFBIG)
val hostunreach: int32 = (fromRep EHOSTUNREACH)
val idrm: int32 = (fromRep EIDRM)
val ilseq: int32 = (fromRep EILSEQ)
val inprogress: int32 = (fromRep EINPROGRESS)
val intr: int32 = (fromRep EINTR)
val inval: int32 = (fromRep EINVAL)
val io: int32 = (fromRep EIO)
val isconn: int32 = (fromRep EISCONN)
val isdir: int32 = (fromRep EISDIR)
val loop: int32 = (fromRep ELOOP)
val mfile: int32 = (fromRep EMFILE)
val mlink: int32 = (fromRep EMLINK)
val msgsize: int32 = (fromRep EMSGSIZE)
val multihop: int32 = (fromRep EMULTIHOP)
val nametoolong: int32 = (fromRep ENAMETOOLONG)
val netdown: int32 = (fromRep ENETDOWN)
val netreset: int32 = (fromRep ENETRESET)
val netunreach: int32 = (fromRep ENETUNREACH)
val nfile: int32 = (fromRep ENFILE)
val nobufs: int32 = (fromRep ENOBUFS)
val nodata: int32 = (fromRep ENODATA)
val nodev: int32 = (fromRep ENODEV)
val noent: int32 = (fromRep ENOENT)
val noexec: int32 = (fromRep ENOEXEC)
val nolck: int32 = (fromRep ENOLCK)
val nolink: int32 = (fromRep ENOLINK)
val nomem: int32 = (fromRep ENOMEM)
val nomsg: int32 = (fromRep ENOMSG)
val noprotoopt: int32 = (fromRep ENOPROTOOPT)
val nospc: int32 = (fromRep ENOSPC)
val nosr: int32 = (fromRep ENOSR)
val nostr: int32 = (fromRep ENOSTR)
val nosys: int32 = (fromRep ENOSYS)
val notconn: int32 = (fromRep ENOTCONN)
val notdir: int32 = (fromRep ENOTDIR)
val notempty: int32 = (fromRep ENOTEMPTY)
val notsock: int32 = (fromRep ENOTSOCK)
val notsup: int32 = (fromRep ENOTSUP)
val notty: int32 = (fromRep ENOTTY)
val nxio: int32 = (fromRep ENXIO)
val opnotsupp: int32 = (fromRep EOPNOTSUPP)
val overflow: int32 = (fromRep EOVERFLOW)
val perm: int32 = (fromRep EPERM)
val pipe: int32 = (fromRep EPIPE)
val proto: int32 = (fromRep EPROTO)
val protonosupport: int32 = (fromRep EPROTONOSUPPORT)
val prototype: int32 = (fromRep EPROTOTYPE)
val range: int32 = (fromRep ERANGE)
val rofs: int32 = (fromRep EROFS)
val spipe: int32 = (fromRep ESPIPE)
val srch: int32 = (fromRep ESRCH)
val stale: int32 = (fromRep ESTALE)
val time: int32 = (fromRep ETIME)
val timedout: int32 = (fromRep ETIMEDOUT)
val toobig: int32 = (fromRep E2BIG)
val txtbsy: int32 = (fromRep ETXTBSY)
val wouldblock: int32 = (fromRep EWOULDBLOCK)
val xdev: int32 = (fromRep EXDEV)
val rec 'a_3453
   ::?: (int32 * 'a_3453) * (int32 * 'a_3453) list -> (int32 * 'a_3453) list = 
      (fn x_1388: (int32 * 'a_3453) * (int32 * 'a_3453) list =>
       case x_1388 of
	 (((n: int32, s: 'a_3453), l: (int32 * 'a_3453) list)) =>
	 case (= (int32) (n, (fromRep 0xFFFFFFFF))) of
	   true => l | false => (::[int32 * 'a_3453] ((n, s), l)))
val errorNames: (int32 * string) list =
   (::? (string) ((acces, "acces"),
		  (::? (string) ((addrinuse, "addrinuse"),
				 (::? (string) ((addrnotavail, "addrnotavail"),
						(::? (string) ((afnosupport,
								"afnosupport"),
							       (::? (string) ((again,
									       "again"),
									      (::? (string) ((already,
											      "already"),
											     (::? (string) ((badf,
													     "badf"),
													    (::? (string) ((badmsg,
															    "badmsg"),
															   (::? (string) ((busy,
																	   "busy"),
																	  (::? (string) ((canceled,
																			  "canceled"),
																			 (::? (string) ((child,
																					 "child"),
																					(::? (string) ((connaborted,
																							"connaborted"),
																						       (::? (string) ((connrefused,
																								       "connrefused"),
																								      (::? (string) ((connreset,
																										      "connreset"),
																										     (::? (string) ((deadlk,
																												     "deadlk"),
																												    (::? (string) ((destaddrreq,
																														    "destaddrreq"),
																														   (::? (string) ((dom,
																																   "dom"),
																																  (::? (string) ((dquot,
																																		  "dquot"),
																																		 (::? (string) ((exist,
																																				 "exist"),
																																				(::? (string) ((fault,
																																						"fault"),
																																					       (::? (string) ((fbig,
																																							       "fbig"),
																																							      (::? (string) ((hostunreach,
																																									      "hostunreach"),
																																									     (::? (string) ((idrm,
																																											     "idrm"),
																																											    (::? (string) ((ilseq,
																																													    "ilseq"),
																																													   (::? (string) ((inprogress,
																																															   "inprogress"),
																																															  (::? (string) ((intr,
																																																	  "intr"),
																																																	 (::? (string) ((inval,
																																																			 "inval"),
																																																			(::? (string) ((io,
																																																					"io"),
																																																				       (::? (string) ((isconn,
																																																						       "isconn"),
																																																						      (::? (string) ((isdir,
																																																								      "isdir"),
																																																								     (::? (string) ((loop,
																																																										     "loop"),
																																																										    (::? (string) ((mfile,
																																																												    "mfile"),
																																																												   (::? (string) ((mlink,
																																																														   "mlink"),
																																																														  (::? (string) ((msgsize,
																																																																  "msgsize"),
																																																																 (::? (string) ((multihop,
																																																																		 "multihop"),
																																																																		(::? (string) ((nametoolong,
																																																																				"nametoolong"),
																																																																			       (::? (string) ((netdown,
																																																																					       "netdown"),
																																																																					      (::? (string) ((netreset,
																																																																							      "netreset"),
																																																																							     (::? (string) ((netunreach,
																																																																									     "netunreach"),
																																																																									    (::? (string) ((nfile,
																																																																											    "nfile"),
																																																																											   (::? (string) ((nobufs,
																																																																													   "nobufs"),
																																																																													  (::? (string) ((nodata,
																																																																															  "nodata"),
																																																																															 (::? (string) ((nodev,
																																																																																	 "nodev"),
																																																																																	(::? (string) ((noent,
																																																																																			"noent"),
																																																																																		       (::? (string) ((noexec,
																																																																																				       "noexec"),
																																																																																				      (::? (string) ((nolck,
																																																																																						      "nolck"),
																																																																																						     (::? (string) ((nolink,
																																																																																								     "nolink"),
																																																																																								    (::? (string) ((nomem,
																																																																																										    "nomem"),
																																																																																										   (::? (string) ((nomsg,
																																																																																												   "nomsg"),
																																																																																												  (::? (string) ((noprotoopt,
																																																																																														  "noprotoopt"),
																																																																																														 (::? (string) ((nospc,
																																																																																																 "nospc"),
																																																																																																(::? (string) ((nosr,
																																																																																																		"nosr"),
																																																																																																	       (::? (string) ((nostr,
																																																																																																			       "nostr"),
																																																																																																			      (::? (string) ((nosys,
																																																																																																					      "nosys"),
																																																																																																					     (::? (string) ((notconn,
																																																																																																							     "notconn"),
																																																																																																							    (::? (string) ((notdir,
																																																																																																									    "notdir"),
																																																																																																									   (::? (string) ((notempty,
																																																																																																											   "notempty"),
																																																																																																											  (::? (string) ((notsock,
																																																																																																													  "notsock"),
																																																																																																													 (::? (string) ((notsup,
																																																																																																															 "notsup"),
																																																																																																															(::? (string) ((notty,
																																																																																																																	"notty"),
																																																																																																																       (::? (string) ((nxio,
																																																																																																																		       "nxio"),
																																																																																																																		      (::? (string) ((opnotsupp,
																																																																																																																				      "opnotsupp"),
																																																																																																																				     (::? (string) ((overflow,
																																																																																																																						     "overflow"),
																																																																																																																						    (::? (string) ((perm,
																																																																																																																								    "perm"),
																																																																																																																								   (::? (string) ((pipe,
																																																																																																																										   "pipe"),
																																																																																																																										  (::? (string) ((proto,
																																																																																																																												  "proto"),
																																																																																																																												 (::? (string) ((protonosupport,
																																																																																																																														 "protonosupport"),
																																																																																																																														(::? (string) ((prototype,
																																																																																																																																"prototype"),
																																																																																																																															       (::? (string) ((range,
																																																																																																																																	       "range"),
																																																																																																																																	      (::? (string) ((rofs,
																																																																																																																																			      "rofs"),
																																																																																																																																			     (::? (string) ((spipe,
																																																																																																																																					     "spipe"),
																																																																																																																																					    (::? (string) ((srch,
																																																																																																																																							    "srch"),
																																																																																																																																							   (::? (string) ((stale,
																																																																																																																																									   "stale"),
																																																																																																																																									  (::? (string) ((time,
																																																																																																																																											  "time"),
																																																																																																																																											 (::? (string) ((timedout,
																																																																																																																																													 "timedout"),
																																																																																																																																													(::? (string) ((toobig,
																																																																																																																																															"toobig"),
																																																																																																																																														       (::? (string) ((txtbsy,
																																																																																																																																																       "txtbsy"),
																																																																																																																																																      (::? (string) ((wouldblock,
																																																																																																																																																		      "wouldblock"),
																																																																																																																																																		     (::? (string) ((xdev,
																																																																																																																																																				     "xdev"),
																																																																																																																																																				    []))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
exception SysErr of string * int32 Primitive.Option.t
val rec
   errorName: int32 -> string = 
      (fn x_1389: int32 =>
       case x_1389 of
	 (n: int32) =>
	 case ((find_0 (int32 * string) (fn x_1390: int32 * string =>
					 case x_1390 of
					   (m: int32, _) => (= (int32) (n, m)))) errorNames) of
	   NONE[int32 * string] => "<UNKNOWN>"
	 | SOME[int32 * string] (_, s: string) => s)
val _ =
   (addExnMessager (fn x_1391: exn =>
		    case x_1391 of
		      e: exn =>
		      case e of
			SysErr (s: string, eo: int32 Primitive.Option.t) =>
			(SOME[string] (concat_2 ["SysErr: ",
						 s,
						 case eo of
						   NONE[int32] => ""
						 | SOME[int32] e: int32 =>
						   (concat_2 [" [",
							      (errorName e),
							      "]"])]))
		      | _ => NONE[string]))
val rec
   errorMsg: int32 -> string = 
      (fn x_1392: int32 =>
       case x_1392 of
	 (n: int32) =>
	 let val cs: word64 = (strError (toRep n))
	 in
	    case (isNull (fromWord cs)) of
	      true => "Unknown error" | false => (toString cs)
	 end)
val rec 'a_3454
   raiseSys: int32 -> 'a_3454 = 
      (fn x_1393: int32 =>
       case x_1393 of
	 (n: int32) => raise (SysErr ((errorMsg n), (SOME[int32] n))))
val rec 'a_3455
   raiseSysWithMsg: int32 * string -> 'a_3455 = 
      (fn x_1394: int32 * string =>
       case x_1394 of
	 ((n: int32, msg: string)) =>
	 raise (SysErr ((^ ((^ ((errorMsg n), ": ")), msg)), (SOME[int32] n))))
val blocker: (unit -> unit -> unit) ref =
   (ref[unit -> unit -> unit] (fn x_1395: unit =>
			       case x_1395 of
				 () =>
				 (fn x_1396: unit =>
				  case x_1396 of
				    () => ())))
val restartFlag: bool ref = (ref[bool] true)
val ('b, ''a) syscallErr: {clear: bool, errVal: ''a, restart: bool}
			  * (unit
			     -> {handlers: (int32 * (unit -> 'b)) list,
				 post: ''a -> 'b,
				 return: ''a})
			  -> 'b =
   (fn x_1397: {clear: bool, errVal: ''a, restart: bool}
	       * (unit
		  -> {handlers: (int32 * (unit -> 'b)) list,
		      post: ''a -> 'b,
		      return: ''a}) =>
    case x_1397 of
      ({clear = clear: bool, restart = restart: bool, errVal = errVal: ''a},
       f: unit
	  -> {handlers: (int32 * (unit -> 'b)) list,
	      post: ''a -> 'b,
	      return: ''a}) =>
      let val rec
	     call: ({errno: int32, handlers: (int32 * (unit -> 'b)) list} -> 'b)
		   -> 'b = 
		(fn x_1405: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			    -> 'b =>
		 case x_1405 of
		   (err: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			 -> 'b) =>
		   let val () = (atomicBegin ())
		       val () =
			  case clear of
			    true => (clearErrno ()) | false => ()
		       val {return = return: ''a,
			    post = post: ''a -> 'b,
			    handlers = handlers: (int32 * (unit -> 'b)) list} =
			  (f ())
			  handle x_1406 => case x_1406 of
					     exn: exn =>
					     (atomicEnd ()) ;raise exn
		       val return: ''a = (check_0 (''a) return)
		   in
		      case (= (''a) (errVal, return)) of
			true =>
			let val e: int32 = (fromRep (getErrno ()))
			    val () = (atomicEnd ())
			in
			   (err {errno = e, handlers = handlers})
			end
		      | false =>
			(wind_0 ('b) ((fn x_1407: unit =>
				       case x_1407 of
					 () => (post return)),
				      atomicEnd))
		   end)
	  val rec
	     err: {default: unit -> 'b,
		   errno: int32,
		   handlers: (int32 * (unit -> 'b)) list}
		  -> 'b = 
		(fn x_1403: {default: unit -> 'b,
			     errno: int32,
			     handlers: (int32 * (unit -> 'b)) list} =>
		 case x_1403 of
		   ({default = default: unit -> 'b,
		     errno = errno: int32,
		     handlers = handlers: (int32 * (unit -> 'b)) list}) =>
		   case ((find_0 (int32 * (unit -> 'b)) (fn x_1404: int32
								    * (unit
								       -> 'b) =>
							 case x_1404 of
							   (e': int32, _) =>
							   (= (int32) (errno, e')))) handlers) of
		     NONE[int32 * (unit -> 'b)] => (default ())
		   | SOME[int32 * (unit -> 'b)] (_, handler: unit -> 'b) =>
		     (handler ()))
	  val rec
	     errBlocked: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			 -> 'b = 
		(fn x_1401: {errno: int32, handlers: (int32 * (unit -> 'b)) list} =>
		 case x_1401 of
		   ({errno = errno: int32,
		     handlers = handlers: (int32 * (unit -> 'b)) list}) =>
		   (err {default = (fn x_1402: unit =>
				    case x_1402 of
				      () => (raiseSys ('b) errno)),
			 errno = errno,
			 handlers = handlers}))
	  val rec
	     errUnblocked: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			   -> 'b = 
		(fn x_1398: {errno: int32, handlers: (int32 * (unit -> 'b)) list} =>
		 case x_1398 of
		   ({errno = errno: int32,
		     handlers = handlers: (int32 * (unit -> 'b)) list}) =>
		   (err {default = (fn x_1399: unit =>
				    case x_1399 of
				      () =>
				      case case case restart of
						  true =>
						  (= (int32) (errno, intr))
						| false => false of
					     true => (!_1 (bool) restartFlag)
					   | false => false of
					true =>
					case (= (word32) ((atomicState ()), 0x0)) of
					  true => (call errUnblocked)
					| false =>
					  let val finish: unit -> unit =
						 ((!_1 (unit -> unit -> unit) blocker) ())
					  in
					     (wind_0 ('b) ((fn x_1400: unit =>
							    case x_1400 of
							      () =>
							      (call errBlocked)),
							   finish))
					  end
				      | false => (raiseSys ('b) errno)),
			 errno = errno,
			 handlers = handlers}))
      in
	 (call errUnblocked)
      end)
val ''a_3456 simpleResultAux: {errVal: ''a_3456, restart: bool}
			      * (unit -> ''a_3456)
			      -> ''a_3456 =
   (fn x_1408: {errVal: ''a_3456, restart: bool} * (unit -> ''a_3456) =>
    case x_1408 of
      ({restart = restart: bool, errVal = errVal: ''a_3456}, f: unit -> ''a_3456) =>
      (syscallErr (''a_3456, ''a_3456) ({clear = false,
					 restart = restart,
					 errVal = errVal},
					(fn x_1409: unit =>
					 case x_1409 of
					   () =>
					   let val return: ''a_3456 = (f ())
					   in
					      {return = return,
					       post = (fn x_1410: ''a_3456 =>
						       case x_1410 of
							 ret: ''a_3456 => ret),
					       handlers = []}
					   end))))
val simpleResultRestart: (unit -> int32) -> int32 =
   (fn x_1411: unit -> int32 =>
    case x_1411 of
      f: unit -> int32 =>
      (simpleResultAux (int32) ({restart = true, errVal = (fromInt 0xFFFFFFFF)},
				f)))
val ''a_3457 simpleResultRestart': {errVal: ''a_3457} * (unit -> ''a_3457)
				   -> ''a_3457 =
   (fn x_1412: {errVal: ''a_3457} * (unit -> ''a_3457) =>
    case x_1412 of
      ({errVal = errVal: ''a_3457}, f: unit -> ''a_3457) =>
      (simpleResultAux (''a_3457) ({restart = true, errVal = errVal}, f)))
val ''a_3458 simpleResult': {errVal: ''a_3458} * (unit -> ''a_3458) -> ''a_3458 =
   (fn x_1413: {errVal: ''a_3458} * (unit -> ''a_3458) =>
    case x_1413 of
      ({errVal = errVal: ''a_3458}, f: unit -> ''a_3458) =>
      (simpleResultAux (''a_3458) ({restart = false, errVal = errVal}, f)))
val simpleRestart: (unit -> int32) -> unit =
   (o_1 (unit -> int32, unit, int32) (ignore_1 (int32), simpleResultRestart))
val ('a_3464, ''a_3463) syscall': {errVal: ''a_3463}
				  * (unit -> ''a_3463 * (''a_3463 -> 'a_3464))
				  -> 'a_3464 =
   (fn x_1414: {errVal: ''a_3463} * (unit -> ''a_3463 * (''a_3463 -> 'a_3464)) =>
    case x_1414 of
      ({errVal = errVal: ''a_3463}, f: unit -> ''a_3463 * (''a_3463 -> 'a_3464)) =>
      (syscallErr ('a_3464, ''a_3463) ({clear = false,
					restart = false,
					errVal = errVal},
				       (fn x_1415: unit =>
					case x_1415 of
					  () =>
					  let val (return: ''a_3463,
						   post: ''a_3463 -> 'a_3464) =
						 (f ())
					  in
					     {return = return,
					      post = post,
					      handlers = []}
					  end))))
val 'a_3466 syscall: (unit -> int32 * (int32 -> 'a_3466)) -> 'a_3466 =
   (fn x_1416: unit -> int32 * (int32 -> 'a_3466) =>
    case x_1416 of
      f: unit -> int32 * (int32 -> 'a_3466) =>
      (syscall' ('a_3466, int32) ({errVal = (fromInt 0xFFFFFFFF)}, f)))
val 'a raiseSysWithMsg_0: int32 * string -> 'a = raiseSysWithMsg ('a)
val 'a raiseSys_0: int32 -> 'a = raiseSys ('a)
val 'a syscall_0: (unit -> int32 * (int32 -> 'a)) -> 'a = syscall ('a)
val ''a simpleResultRestart'_0: {errVal: ''a} * (unit -> ''a) -> ''a =
   simpleResultRestart' (''a)
val ''a simpleResult'_0: {errVal: ''a} * (unit -> ''a) -> ''a =
   simpleResult' (''a)
exception Unordered
datatype IEEEReal.real_order = LESS
			       | EQUAL
			       | GREATER
			       | UNORDERED
datatype IEEEReal.float_class = INF
				| NAN
				| NORMAL
				| SUBNORMAL
				| ZERO
datatype IEEEReal.RoundingMode.t = TO_NEAREST
				   | TO_NEGINF
				   | TO_POSINF
				   | TO_ZERO
val rec
   fromInt: int32 -> IEEEReal.RoundingMode.t = 
      (fn x_1417: int32 =>
       case x_1417 of
	 (i: int32) =>
	 let 
	 in
	    case (= (int32) (i, FE_TONEAREST)) of
	      true => TO_NEAREST
	    | false =>
	      case (= (int32) (i, FE_DOWNWARD)) of
		true => TO_NEGINF
	      | false =>
		case (= (int32) (i, FE_UPWARD)) of
		  true => TO_POSINF
		| false =>
		  case (= (int32) (i, FE_TOWARDZERO)) of
		    true => TO_ZERO
		  | false => raise (Fail "IEEEReal.RoundingMode.fromInt")
	 end)
val rec
   toInt: IEEEReal.RoundingMode.t -> int32 = 
      (fn x_1418: IEEEReal.RoundingMode.t =>
       case x_1418 of
	 (m: IEEEReal.RoundingMode.t) =>
	 let val i: int32 =
		case m of
		  TO_NEAREST => FE_TONEAREST
		| TO_NEGINF => FE_DOWNWARD
		| TO_POSINF => FE_UPWARD
		| TO_ZERO => FE_TOWARDZERO
	 in
	    case (= (int32) (i, FE_NOSUPPORT)) of
	      true => raise (Fail "IEEEReal rounding mode not supported")
	    | false => i
	 end)
val rec
   setRoundingMode: IEEEReal.RoundingMode.t -> unit = 
      (fn x_1419: IEEEReal.RoundingMode.t =>
       case x_1419 of
	 (m: IEEEReal.RoundingMode.t) =>
	 case (= (int32) ((setRoundingMode (toInt m)), 0x0)) of
	   true => () | false => raise (raiseSys_0 (exn) inval))
val getRoundingMode: unit -> IEEEReal.RoundingMode.t =
   (o_1 (unit, IEEEReal.RoundingMode.t, int32) (fromInt, getRoundingMode))
val rec 'a
   withRoundingMode: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a = 
      (fn x_1420: IEEEReal.RoundingMode.t * (unit -> 'a) =>
       case x_1420 of
	 ((m: IEEEReal.RoundingMode.t, th: unit -> 'a)) =>
	 let val m': IEEEReal.RoundingMode.t = (getRoundingMode ())
	     val _ = (setRoundingMode m)
	     val res: 'a = (th ())
	     val _ = (setRoundingMode m')
	 in
	    res
	 end)
val rec
   toString: {class: IEEEReal.float_class,
	      digits: int32 list,
	      exp: int32,
	      sign: bool}
	     -> string = 
      (fn x_1421: {class: IEEEReal.float_class,
		   digits: int32 list,
		   exp: int32,
		   sign: bool} =>
       case x_1421 of
	 ({class = class: IEEEReal.float_class,
	   sign = sign: bool,
	   digits = digits: int32 list,
	   exp = exp: int32}) =>
	 let val rec
		digitStr: unit -> string = 
		   (fn x_1423: unit =>
		    case x_1423 of
		      (()) =>
		      (implode ((map_2 (char8, int32) digitToChar) digits)))
	     val rec
		norm: unit -> string = 
		   (fn x_1422: unit =>
		    case x_1422 of
		      (()) =>
		      let val num: string = (^ ("0.", (digitStr ())))
		      in
			 case (= (int32) (exp, 0x0)) of
			   true => num
			 | false => (concat_2 [num, "E", (toString exp)])
		      end)
	     val num: string =
		case class of
		  ZERO => "0.0"
		| NORMAL => (norm ())
		| SUBNORMAL => (norm ())
		| INF => "inf"
		| NAN => "nan"
	 in
	    case sign of
	      true => (^ ("~", num)) | false => num
	 end)
val 'a withRoundingMode_0: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a =
   withRoundingMode ('a)
val castToWord: real32 -> word32 = castToWord
val castFromWord: word32 -> real32 = castFromWord
val realSize: int32 = (toInt realSize)
val exponentBias: int32 = (toInt exponentBias)
val precision: int32 = (toInt precision)
val signBits: word32 = one
val exponentSignificandBits: word32 = (- ((fromInt realSize), signBits))
val significandBits: word32 = (- ((fromInt precision), one))
val exponentBits: word32 = (- (exponentSignificandBits, significandBits))
val mkMask: word32 -> word32 =
   (fn x_1424: word32 =>
    case x_1424 of
      b: word32 => (notb (<< ((notb zero), b))))
val signMask: word32 = (<< ((mkMask signBits), exponentSignificandBits))
val exponentMask: word32 = (<< ((mkMask exponentBits), significandBits))
val significandMask: word32 = (mkMask significandBits)
val class: real32 -> IEEEReal.float_class =
   (fn x_1425: real32 =>
    case x_1425 of
      r: real32 =>
      let val w: word32 = (castToWord r)
      in
	 case (= (word32) ((andb (w, exponentMask)), exponentMask)) of
	   true =>
	   case (= (word32) ((andb (w, significandMask)), zero)) of
	     true => INF | false => NAN
	 | false =>
	   case (= (word32) ((andb (w, exponentMask)), zero)) of
	     true =>
	     case (= (word32) ((andb (w, significandMask)), zero)) of
	       true => ZERO | false => SUBNORMAL
	   | false => NORMAL
      end)
val toBits: real32 -> {exponent: word32, sign: bool, significand: word32} =
   (fn x_1426: real32 =>
    case x_1426 of
      r: real32 =>
      let val w: word32 = (castToWord r)
	  val significand: word32 = (andb (w, significandMask))
	  val exponent: word32 =
	     (>> ((andb (w, exponentMask)), significandBits))
	  val sign: bool = (= (word32) ((andb (w, signMask)), signMask))
      in
	 {sign = sign, exponent = exponent, significand = significand}
      end)
val +: real32 * real32 -> real32 = +
val -: real32 * real32 -> real32 = -
val <: real32 * real32 -> bool = <
val <=: real32 * real32 -> bool = <=
val >: real32 * real32 -> bool = >
val >=: real32 * real32 -> bool = >=
val ~: real32 -> real32 = ~
val rec 'a
   make: {fromRealUnsafe: 'a -> real32,
	  other: {precision: int32},
	  toRealUnsafe: real32 -> 'a}
	 -> (IEEEReal.RoundingMode.t -> 'a -> real32) * (real32 -> 'a) = 
      (fn x_1427: {fromRealUnsafe: 'a -> real32,
		   other: {precision: int32},
		   toRealUnsafe: real32 -> 'a} =>
       case x_1427 of
	 ({fromRealUnsafe = fromRealUnsafe: 'a -> real32,
	   toRealUnsafe = toRealUnsafe: real32 -> 'a,
	   other = other: {precision: int32}}) =>
	 case (= (int32) (precision,
			  ((fn x_1432: {precision: int32} =>
			    case x_1432 of
			      {precision = #: int32} => #) other))) of
	   true =>
	   ((fn x_1428: IEEEReal.RoundingMode.t =>
	     case x_1428 of
	       _ => fromRealUnsafe),
	    toRealUnsafe)
	 | false =>
	   ((fn x_1429: IEEEReal.RoundingMode.t =>
	     case x_1429 of
	       m: IEEEReal.RoundingMode.t =>
	       (fn x_1430: 'a =>
		case x_1430 of
		  r: 'a =>
		  (withRoundingMode_0 (real32) (m,
						(fn x_1431: unit =>
						 case x_1431 of
						   () => (fromRealUnsafe r)))))),
	    toRealUnsafe))
val (fromReal32: IEEEReal.RoundingMode.t -> real32 -> real32,
     toReal32: real32 -> real32) =
   (make (real32) {fromRealUnsafe = fromReal32Unsafe,
		   toRealUnsafe = toReal32Unsafe,
		   other = {precision = precision}})
val fReal32: real32 -> real32 = toReal32
val _ = fReal32
val fReal32: IEEEReal.RoundingMode.t -> real32 -> real32 = fromReal32
val _ = fReal32
val zero: real32 = (castFromWord zero)
val half: real32 =
   (castFromWord (<< ((- ((fromInt exponentBias), one)), significandBits)))
val one: real32 = (castFromWord (<< ((fromInt exponentBias), significandBits)))
val signBit: real32 -> bool =
   (o_1 (real32, bool, {exponent: word32, sign: bool, significand: word32}) ((fn x_1433: {exponent: word32,
											  sign: bool,
											  significand: word32} =>
									      case x_1433 of
										{sign = #: bool} =>
										#),
									     toBits))
val realCeil: real32 -> real32 = realCeil
val realFloor: real32 -> real32 = realFloor
val realTrunc: real32 -> real32 = realTrunc
val realRound: real32 -> real32 =
   (fn x_1434: real32 =>
    case x_1434 of
      r: real32 =>
      (withRoundingMode_0 (real32) (TO_NEAREST,
				    (fn x_1435: unit =>
				     case x_1435 of
				       () => (round r)))))
val rec
   strtor: string * IEEEReal.RoundingMode.t -> real32 = 
      (fn x_1436: string * IEEEReal.RoundingMode.t =>
       case x_1436 of
	 ((str: string, rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (strtor (str, rounding))
	 end)
exception Bad
datatype Real.mode = Fix
		     | Gen
		     | Sci
val one: int32 ref One.t =
   (make_0 (int32 ref) (fn x_1437: unit =>
			case x_1437 of
			  () => (ref[int32] 0x0)))
val rec
   gdtoa: real32 * Real.mode * int32 * IEEEReal.RoundingMode.t -> word64 * int32 = 
      (fn x_1438: real32 * Real.mode * int32 * IEEEReal.RoundingMode.t =>
       case x_1438 of
	 ((x: real32,
	   mode: Real.mode,
	   ndig: int32,
	   rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val mode: int32 = case mode of Fix => 0x3 | Gen => 0x0 | Sci => 0x2
	     val ndig: int32 = (fromInt ndig)
	     val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (use_0 (word64 * int32, int32 ref) (one,
						(fn x_1439: int32 ref =>
						 case x_1439 of
						   decpt: int32 ref =>
						   ((gdtoa (x,
							    mode,
							    ndig,
							    rounding,
							    decpt)),
						    (toInt (!_1 (int32) decpt))))))
	 end)
val rec
   toDecimal: real32
	      -> {class: IEEEReal.float_class,
		  digits: int32 list,
		  exp: int32,
		  sign: bool} = 
      (fn x_1440: real32 =>
       case x_1440 of
	 (x: real32) =>
	 case (class x) of
	   INF => {class = INF, digits = [], exp = 0x0, sign = (< (x, zero))}
	 | NAN => {class = NAN, digits = [], exp = 0x0, sign = (signBit x)}
	 | ZERO => {class = ZERO, digits = [], exp = 0x0, sign = (signBit x)}
	 | c: IEEEReal.float_class =>
	   let val (cs: word64, exp: int32) = (gdtoa (x, Gen, 0x0, TO_NEAREST))
	       val rec
		  loop: int32 * int32 list -> int32 list = 
		     (fn x_1441: int32 * int32 list =>
		      case x_1441 of
			((i: int32, ac: int32 list)) =>
			case (< (i, 0x0)) of
			  true => ac
			| false =>
			  (loop ((- (i, 0x1)),
				 (::[int32] ((- ((ord (sub (cs, i))), (ord 0x30))),
					     ac)))))
	       val digits: int32 list = (loop ((- ((length cs), 0x1)), []))
	   in
	      {class = c, digits = digits, exp = exp, sign = (< (x, zero))}
	   end)
val rec
   fix: string * word64 * int32 * int32 -> string = 
      (fn x_1442: string * word64 * int32 * int32 =>
       case x_1442 of
	 ((sign: string, cs: word64, decpt: int32, ndig: int32)) =>
	 let val length: int32 = (length cs)
	 in
	    case (< (decpt, 0x0)) of
	      true =>
	      (concat_2 [sign,
			 "0.",
			 (new ((~ decpt), 0x30)),
			 (toString cs),
			 (new ((+ ((- (ndig, length)), decpt)), 0x30))])
	    | false =>
	      let val whole: string =
		     case (= (int32) (decpt, 0x0)) of
		       true => "0"
		     | false =>
		       (tabulate_5 (decpt,
				    (fn x_1443: int32 =>
				     case x_1443 of
				       i: int32 =>
				       case (< (i, length)) of
					 true => (sub (cs, i)) | false => 0x30)))
	      in
		 case (= (int32) (0x0, ndig)) of
		   true => (concat_2 [sign, whole])
		 | false =>
		   let val frac: string =
			  (tabulate_5 (ndig,
				       (fn x_1444: int32 =>
					case x_1444 of
					  i: int32 =>
					  let val j: int32 = (+ (i, decpt))
					  in
					     case (< (j, length)) of
					       true => (sub (cs, j))
					     | false => 0x30
					  end)))
		   in
		      (concat_2 [sign, whole, ".", frac])
		   end
	      end
	 end)
val rec
   sci: real32 * int32 -> string = 
      (fn x_1445: real32 * int32 =>
       case x_1445 of
	 ((x: real32, ndig: int32)) =>
	 let val sign: string = case (< (x, zero)) of true => "~" | false => ""
	     val (cs: word64, decpt: int32) =
		(gdtoa (x, Sci, (+ (0x1, ndig)), (getRoundingMode ())))
	     val length: int32 = (length cs)
	     val whole: string =
		(tabulate_5 (0x1,
			     (fn x_1447: int32 =>
			      case x_1447 of
				_ => (sub (cs, 0x0)))))
	     val frac: string =
		case (= (int32) (0x0, ndig)) of
		  true => ""
		| false =>
		  (concat_2 [".",
			     (tabulate_5 (ndig,
					  (fn x_1446: int32 =>
					   case x_1446 of
					     i: int32 =>
					     let val j: int32 = (+ (i, 0x1))
					     in
						case (< (j, length)) of
						  true => (sub (cs, j))
						| false => 0x30
					     end)))])
	     val exp: int32 = (- (decpt, 0x1))
	     val exp: string =
		let val (exp: int32, sign: string) =
		       case (< (exp, 0x0)) of
			 true => ((~ exp), "~") | false => (exp, "")
		in
		   (concat_2 [sign, (toString exp)])
		end
	 in
	    (concat_2 [sign, whole, frac, "E", exp])
	 end)
val rec
   gen: real32 * int32 -> string = 
      (fn x_1448: real32 * int32 =>
       case x_1448 of
	 ((x: real32, n: int32)) =>
	 let val (prefix: string, x: real32) =
		case (< (x, zero)) of
		  true => ("~", (~ x)) | false => ("", x)
	     val ss: char8 PrimSequence.Slice.t =
		(full_8 (sci (x, (- (n, 0x1)))))
	     val rec
		isE: char8 -> bool = 
		   (fn x_1455: char8 =>
		    case x_1455 of
		      (c: char8) => (= (char8) (c, 0x45)))
	     val rec
		isZero: char8 -> bool = 
		   (fn x_1454: char8 =>
		    case x_1454 of
		      (c: char8) => (= (char8) (c, 0x30)))
	     val expS: string =
		(string ((taker_4 (o_1 (char8, bool, bool) (not, isE))) ss))
	     val exp: int32 = (valOf_1 (int32) (fromString expS))
	     val man: string =
		((translate_2 (fn x_1453: char8 =>
			       case x_1453 of
				 0x2E => "" | c: char8 => (str c))) (string ((dropr_4 isZero) ((takel_4 (o_1 (char8,
									     bool,
									     bool) (not,
										    isE))) ss))))
	     val manSize: int32 = (size man)
	     val rec
		zeros: int32 -> string = 
		   (fn x_1451: int32 =>
		    case x_1451 of
		      (i: int32) =>
		      (tabulate_5 (i,
				   (fn x_1452: int32 =>
				    case x_1452 of
				      _ => 0x30))))
	     val rec
		dotAt: int32 -> string = 
		   (fn x_1450: int32 =>
		    case x_1450 of
		      (i: int32) =>
		      (concat_2 [(substring (man, 0x0, i)),
				 ".",
				 (extract (man, i, NONE[int32]))]))
	     val rec
		sci: unit -> string = 
		   (fn x_1449: unit =>
		    case x_1449 of
		      (()) =>
		      (concat_2 [prefix,
				 case (= (int32) (manSize, 0x1)) of
				   true => man | false => (dotAt 0x1),
				 "E",
				 expS]))
	     val -: int32 * int32 -> int32 = -
	     val +: int32 * int32 -> int32 = +
	     val ~: int32 -> int32 = ~
	     val >=: int32 * int32 -> bool = >=
	 in
	    case (>= (exp,
		      case (= (int32) (manSize, 0x1)) of
			true => 0x3 | false => (+ (manSize, 0x3)))) of
	      true => (sci ())
	    | false =>
	      case (>= (exp, (- (manSize, 0x1)))) of
		true =>
		(concat_2 [prefix, man, (zeros (- (exp, (- (manSize, 0x1)))))])
	      | false =>
		case (>= (exp, 0x0)) of
		  true => (concat_2 [prefix, (dotAt (+ (exp, 0x1)))])
		| false =>
		  case (>= (exp,
			    case (= (int32) (manSize, 0x1)) of
			      true => 0xFFFFFFFE | false => 0xFFFFFFFD)) of
		    true =>
		    (concat_2 [prefix, "0.", (zeros (- ((~ exp), 0x1))), man])
		  | false => (sci ())
	 end)
val rec
   fmt: StringCvt.realfmt -> real32 -> string = 
      (fn x_1456: StringCvt.realfmt =>
       case x_1456 of
	 (spec: StringCvt.realfmt) =>
	 let val doit: real32 -> string =
		case spec of
		  EXACT =>
		  (o_1 (real32,
			string,
			{class: IEEEReal.float_class,
			 digits: int32 list,
			 exp: int32,
			 sign: bool}) (toString, toDecimal))
		| FIX opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1457: real32 =>
		      case x_1457 of
			x: real32 =>
			let val sign: string =
			       case (< (x, zero)) of
				 true => "~" | false => ""
			    val (cs: word64, decpt: int32) =
			       (gdtoa (x, Fix, n, (getRoundingMode ())))
			in
			   (fix (sign, cs, decpt, n))
			end)
		  end
		| GEN opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0xC
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x1)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1458: real32 =>
		      case x_1458 of
			x: real32 => (gen (x, n)))
		  end
		| SCI opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1459: real32 =>
		      case x_1459 of
			x: real32 => (sci (x, n)))
		  end
	 in
	    (fn x_1460: real32 =>
	     case x_1460 of
	       x: real32 =>
	       case (class x) of
		 NAN => "nan"
	       | INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	       | _ => (doit x))
	 end)
val rec 'a_3490
   safeConvert: IEEEReal.RoundingMode.t * (real32 -> 'a_3490) * real32
		-> 'a_3490 = 
      (fn x_1461: IEEEReal.RoundingMode.t * (real32 -> 'a_3490) * real32 =>
       case x_1461 of
	 ((m: IEEEReal.RoundingMode.t, cvt: real32 -> 'a_3490, x: real32)) =>
	 case m of
	   TO_POSINF => (cvt (realCeil x))
	 | TO_NEGINF => (cvt (realFloor x))
	 | TO_NEAREST => (cvt (realRound x))
	 | TO_ZERO => (cvt (realTrunc x)))
val rec 'a
   make: {fromIntUnsafe: 'a -> real32,
	  other: {maxInt': word32 -> 'a, minInt': 'a, precision': int32},
	  toIntUnsafe: real32 -> 'a}
	 -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
      (fn x_1462: {fromIntUnsafe: 'a -> real32,
		   other: {maxInt': word32 -> 'a, minInt': 'a, precision': int32},
		   toIntUnsafe: real32 -> 'a} =>
       case x_1462 of
	 ({fromIntUnsafe = fromIntUnsafe: 'a -> real32,
	   toIntUnsafe = toIntUnsafe: real32 -> 'a,
	   other = other: {maxInt': word32 -> 'a, minInt': 'a, precision': int32}}) =>
	 (fromIntUnsafe,
	  case (< (precision,
		   ((fn x_1472: {maxInt': word32 -> 'a,
				 minInt': 'a,
				 precision': int32} =>
		     case x_1472 of
		       {precision' = #: int32} => #) other))) of
	    true =>
	    let val trim: int32 =
		   (- ((- (((fn x_1465: {maxInt': word32 -> 'a,
					 minInt': 'a,
					 precision': int32} =>
			     case x_1465 of
			       {precision' = #: int32} => #) other),
			   precision)),
		       0x1))
		val maxInt': 'a =
		   (((fn x_1464: {maxInt': word32 -> 'a,
				  minInt': 'a,
				  precision': int32} =>
		      case x_1464 of
			{maxInt' = #: word32 -> 'a} => #) other) (fromInt trim))
		val minInt': 'a =
		   ((fn x_1463: {maxInt': word32 -> 'a,
				 minInt': 'a,
				 precision': int32} =>
		     case x_1463 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real32 = (fromIntUnsafe maxInt')
		val minInt: real32 = (fromIntUnsafe minInt')
	    in
	       (fn x_1466: IEEEReal.RoundingMode.t =>
		case x_1466 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1467: real32 =>
		   case x_1467 of
		     x: real32 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (safeConvert ('a) (m, toIntUnsafe, x))
		       | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true => raise Overflow | false => raise Domain))
	    end
	  | false =>
	    let val maxInt': 'a =
		   (((fn x_1469: {maxInt': word32 -> 'a,
				  minInt': 'a,
				  precision': int32} =>
		      case x_1469 of
			{maxInt' = #: word32 -> 'a} => #) other) 0x0)
		val minInt': 'a =
		   ((fn x_1468: {maxInt': word32 -> 'a,
				 minInt': 'a,
				 precision': int32} =>
		     case x_1468 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real32 = (fromIntUnsafe maxInt')
		val minInt: real32 = (fromIntUnsafe minInt')
	    in
	       (fn x_1470: IEEEReal.RoundingMode.t =>
		case x_1470 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1471: real32 =>
		   case x_1471 of
		     x: real32 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (safeConvert ('a) (m, toIntUnsafe, x))
		       | false =>
			 case (< (x, (+ (maxInt, one)))) of
			   true =>
			   case m of
			     TO_NEGINF => maxInt'
			   | TO_POSINF => raise Overflow
			   | TO_ZERO => maxInt'
			   | TO_NEAREST =>
			     case (>= ((- (x, maxInt)), half)) of
			       true => raise Overflow | false => maxInt'
			 | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true =>
			 case (< ((- (minInt, one)), x)) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => minInt'
			   | TO_ZERO => minInt'
			   | TO_NEAREST =>
			     case (< ((- (x, minInt)), (~ half))) of
			       true => raise Overflow | false => minInt'
			 | false => raise Overflow
		       | false => raise Domain))
	    end))
val (fromInt8: int8 -> real32, toInt8: IEEEReal.RoundingMode.t -> real32 -> int8) =
   (make (int8) {fromIntUnsafe = fromInt8Unsafe,
		 toIntUnsafe = toInt8Unsafe,
		 other = {maxInt' = (fn x_1473: word32 =>
				     case x_1473 of
				       w: word32 => (<< ((>> (maxInt', w)), w))),
			  minInt' = minInt',
			  precision' = precision'}})
val (fromInt16: int16 -> real32,
     toInt16: IEEEReal.RoundingMode.t -> real32 -> int16) =
   (make (int16) {fromIntUnsafe = fromInt16Unsafe,
		  toIntUnsafe = toInt16Unsafe,
		  other = {maxInt' = (fn x_1474: word32 =>
				      case x_1474 of
					w: word32 => (<< ((>> (maxInt', w)), w))),
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt32: int32 -> real32,
     toInt32: IEEEReal.RoundingMode.t -> real32 -> int32) =
   (make (int32) {fromIntUnsafe = fromInt32Unsafe,
		  toIntUnsafe = toInt32Unsafe,
		  other = {maxInt' = (fn x_1475: word32 =>
				      case x_1475 of
					w: word32 => (<< ((>> (maxInt', w)), w))),
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt64: int64 -> real32,
     toInt64: IEEEReal.RoundingMode.t -> real32 -> int64) =
   (make (int64) {fromIntUnsafe = fromInt64Unsafe,
		  toIntUnsafe = toInt64Unsafe,
		  other = {maxInt' = (fn x_1476: word32 =>
				      case x_1476 of
					w: word32 => (<< ((>> (maxInt', w)), w))),
			   minInt' = minInt',
			   precision' = precision'}})
val fromIntInf: intInf -> real32 =
   (fn x_1477: intInf =>
    case x_1477 of
      i: intInf =>
      let val str: string =
	     case (< (i, 0)) of
	       true => (^ ("-", (toString (~ i)))) | false => (toString i)
	  val x: real32 = (strtor ((nullTerm str), (getRoundingMode ())))
      in
	 x
      end)
val toIntInf: IEEEReal.RoundingMode.t -> real32 -> intInf =
   (fn x_1478: IEEEReal.RoundingMode.t =>
    case x_1478 of
      mode: IEEEReal.RoundingMode.t =>
      (fn x_1479: real32 =>
       case x_1479 of
	 x: real32 =>
	 case (class x) of
	   INF => raise Overflow
	 | NAN => raise Domain
	 | ZERO => 0
	 | _ =>
	   let val x: real32 =
		  case mode of
		    TO_POSINF => (realCeil x)
		  | TO_NEGINF => (realFloor x)
		  | TO_NEAREST => (realRound x)
		  | TO_ZERO => (realTrunc x)
	   in
	      case (class x) of
		INF => raise Overflow
	      | _ =>
		(valOf_1 (intInf) (fromString ((fmt (FIX (SOME[int32] 0x0))) x)))
	   end))
val fInt8: int8 -> real32 = fromInt8
val fInt16: int16 -> real32 = fromInt16
val fInt64: int64 -> real32 = fromInt64
val fIntInf: intInf -> real32 = fromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> real32 = fromInt8
val fInt16: int16 -> real32 = fromInt16
val fInt32: int32 -> real32 = fromInt32
val fInt64: int64 -> real32 = fromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: IEEEReal.RoundingMode.t -> real32 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real32 -> int16 = toInt16
val fInt64: IEEEReal.RoundingMode.t -> real32 -> int64 = toInt64
val fIntInf: IEEEReal.RoundingMode.t -> real32 -> intInf = toIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: IEEEReal.RoundingMode.t -> real32 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real32 -> int16 = toInt16
val fInt32: IEEEReal.RoundingMode.t -> real32 -> int32 = toInt32
val fInt64: IEEEReal.RoundingMode.t -> real32 -> int64 = toInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val rec 'a
   make: {fromWordUnsafe: 'a -> real32,
	  other: {maxWord': word32 -> 'a, wordSize: int32, zeroWord: 'a},
	  toWordUnsafe: real32 -> 'a}
	 -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
      (fn x_1480: {fromWordUnsafe: 'a -> real32,
		   other: {maxWord': word32 -> 'a, wordSize: int32, zeroWord: 'a},
		   toWordUnsafe: real32 -> 'a} =>
       case x_1480 of
	 ({fromWordUnsafe = fromWordUnsafe: 'a -> real32,
	   toWordUnsafe = toWordUnsafe: real32 -> 'a,
	   other = other: {maxWord': word32 -> 'a, wordSize: int32, zeroWord: 'a}}) =>
	 (fromWordUnsafe,
	  case (<= (precision,
		    ((fn x_1490: {maxWord': word32 -> 'a,
				  wordSize: int32,
				  zeroWord: 'a} =>
		      case x_1490 of
			{wordSize = #: int32} => #) other))) of
	    true =>
	    let val trim: int32 =
		   (- (((fn x_1483: {maxWord': word32 -> 'a,
				     wordSize: int32,
				     zeroWord: 'a} =>
			 case x_1483 of
			   {wordSize = #: int32} => #) other),
		       precision))
		val maxWord': 'a =
		   (((fn x_1482: {maxWord': word32 -> 'a,
				  wordSize: int32,
				  zeroWord: 'a} =>
		      case x_1482 of
			{maxWord' = #: word32 -> 'a} => #) other) (fromInt trim))
		val maxWord: real32 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1481: {maxWord': word32 -> 'a,
				 wordSize: int32,
				 zeroWord: 'a} =>
		     case x_1481 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1484: IEEEReal.RoundingMode.t =>
		case x_1484 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1485: real32 =>
		   case x_1485 of
		     x: real32 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (safeConvert ('a) (m, toWordUnsafe, x))
			 | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end
	  | false =>
	    let val maxWord': 'a =
		   (((fn x_1487: {maxWord': word32 -> 'a,
				  wordSize: int32,
				  zeroWord: 'a} =>
		      case x_1487 of
			{maxWord' = #: word32 -> 'a} => #) other) 0x0)
		val maxWord: real32 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1486: {maxWord': word32 -> 'a,
				 wordSize: int32,
				 zeroWord: 'a} =>
		     case x_1486 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1488: IEEEReal.RoundingMode.t =>
		case x_1488 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1489: real32 =>
		   case x_1489 of
		     x: real32 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (safeConvert ('a) (m, toWordUnsafe, x))
			 | false =>
			   case (< (x, (+ (maxWord, one)))) of
			     true =>
			     case m of
			       TO_NEGINF => maxWord'
			     | TO_POSINF => raise Overflow
			     | TO_ZERO => maxWord'
			     | TO_NEAREST =>
			       case (>= ((- (x, maxWord)), half)) of
				 true => raise Overflow | false => maxWord'
			   | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end))
val (fromWord8: word8 -> real32,
     toWord8: IEEEReal.RoundingMode.t -> real32 -> word8) =
   (make (word8) {fromWordUnsafe = fromWord8Unsafe,
		  toWordUnsafe = toWord8Unsafe,
		  other = {maxWord' = (fn x_1491: word32 =>
				       case x_1491 of
					 w: word32 =>
					 (<< ((>> (maxWord', w)), w))),
			   wordSize = wordSize,
			   zeroWord = zero}})
val (fromWord16: word16 -> real32,
     toWord16: IEEEReal.RoundingMode.t -> real32 -> word16) =
   (make (word16) {fromWordUnsafe = fromWord16Unsafe,
		   toWordUnsafe = toWord16Unsafe,
		   other = {maxWord' = (fn x_1492: word32 =>
					case x_1492 of
					  w: word32 =>
					  (<< ((>> (maxWord', w)), w))),
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord32: word32 -> real32,
     toWord32: IEEEReal.RoundingMode.t -> real32 -> word32) =
   (make (word32) {fromWordUnsafe = fromWord32Unsafe,
		   toWordUnsafe = toWord32Unsafe,
		   other = {maxWord' = (fn x_1493: word32 =>
					case x_1493 of
					  w: word32 =>
					  (<< ((>> (maxWord', w)), w))),
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord64: word64 -> real32,
     toWord64: IEEEReal.RoundingMode.t -> real32 -> word64) =
   (make (word64) {fromWordUnsafe = fromWord64Unsafe,
		   toWordUnsafe = toWord64Unsafe,
		   other = {maxWord' = (fn x_1494: word32 =>
					case x_1494 of
					  w: word32 =>
					  (<< ((>> (maxWord', w)), w))),
			    wordSize = wordSize,
			    zeroWord = zero}})
val fWord8: word8 -> real32 = fromWord8
val fWord16: word16 -> real32 = fromWord16
val fWord64: word64 -> real32 = fromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> real32 = fromWord8
val fWord16: word16 -> real32 = fromWord16
val fWord32: word32 -> real32 = fromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: IEEEReal.RoundingMode.t -> real32 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real32 -> word16 = toWord16
val fWord64: IEEEReal.RoundingMode.t -> real32 -> word64 = toWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: IEEEReal.RoundingMode.t -> real32 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real32 -> word16 = toWord16
val fWord32: IEEEReal.RoundingMode.t -> real32 -> word32 = toWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val castToWord: real64 -> word64 = castToWord
val castFromWord: word64 -> real64 = castFromWord
val realSize: int32 = (toInt realSize)
val exponentBias: int32 = (toInt exponentBias)
val precision: int32 = (toInt precision)
val signBits: word32 = one
val exponentSignificandBits: word32 = (- ((fromInt realSize), signBits))
val significandBits: word32 = (- ((fromInt precision), one))
val exponentBits: word32 = (- (exponentSignificandBits, significandBits))
val mkMask: word32 -> word64 =
   (fn x_1495: word32 =>
    case x_1495 of
      b: word32 => (notb (<< ((notb zero), b))))
val signMask: word64 = (<< ((mkMask signBits), exponentSignificandBits))
val exponentMask: word64 = (<< ((mkMask exponentBits), significandBits))
val significandMask: word64 = (mkMask significandBits)
val class: real64 -> IEEEReal.float_class =
   (fn x_1496: real64 =>
    case x_1496 of
      r: real64 =>
      let val w: word64 = (castToWord r)
      in
	 case (= (word64) ((andb (w, exponentMask)), exponentMask)) of
	   true =>
	   case (= (word64) ((andb (w, significandMask)), zero)) of
	     true => INF | false => NAN
	 | false =>
	   case (= (word64) ((andb (w, exponentMask)), zero)) of
	     true =>
	     case (= (word64) ((andb (w, significandMask)), zero)) of
	       true => ZERO | false => SUBNORMAL
	   | false => NORMAL
      end)
val toBits: real64 -> {exponent: word64, sign: bool, significand: word64} =
   (fn x_1497: real64 =>
    case x_1497 of
      r: real64 =>
      let val w: word64 = (castToWord r)
	  val significand: word64 = (andb (w, significandMask))
	  val exponent: word64 =
	     (>> ((andb (w, exponentMask)), significandBits))
	  val sign: bool = (= (word64) ((andb (w, signMask)), signMask))
      in
	 {sign = sign, exponent = exponent, significand = significand}
      end)
val +: real64 * real64 -> real64 = +
val -: real64 * real64 -> real64 = -
val <: real64 * real64 -> bool = <
val <=: real64 * real64 -> bool = <=
val >: real64 * real64 -> bool = >
val >=: real64 * real64 -> bool = >=
val ~: real64 -> real64 = ~
val rec 'a
   make: {fromRealUnsafe: 'a -> real64,
	  other: {precision: int32},
	  toRealUnsafe: real64 -> 'a}
	 -> (IEEEReal.RoundingMode.t -> 'a -> real64) * (real64 -> 'a) = 
      (fn x_1498: {fromRealUnsafe: 'a -> real64,
		   other: {precision: int32},
		   toRealUnsafe: real64 -> 'a} =>
       case x_1498 of
	 ({fromRealUnsafe = fromRealUnsafe: 'a -> real64,
	   toRealUnsafe = toRealUnsafe: real64 -> 'a,
	   other = other: {precision: int32}}) =>
	 case (= (int32) (precision,
			  ((fn x_1503: {precision: int32} =>
			    case x_1503 of
			      {precision = #: int32} => #) other))) of
	   true =>
	   ((fn x_1499: IEEEReal.RoundingMode.t =>
	     case x_1499 of
	       _ => fromRealUnsafe),
	    toRealUnsafe)
	 | false =>
	   ((fn x_1500: IEEEReal.RoundingMode.t =>
	     case x_1500 of
	       m: IEEEReal.RoundingMode.t =>
	       (fn x_1501: 'a =>
		case x_1501 of
		  r: 'a =>
		  (withRoundingMode_0 (real64) (m,
						(fn x_1502: unit =>
						 case x_1502 of
						   () => (fromRealUnsafe r)))))),
	    toRealUnsafe))
val (fromReal32: IEEEReal.RoundingMode.t -> real32 -> real64,
     toReal32: real64 -> real32) =
   (make (real32) {fromRealUnsafe = fromReal32Unsafe,
		   toRealUnsafe = toReal32Unsafe,
		   other = {precision = precision}})
val fReal32: real64 -> real32 = toReal32
val _ = fReal32
val fReal32: IEEEReal.RoundingMode.t -> real32 -> real64 = fromReal32
val _ = fReal32
val zero: real64 = (castFromWord zero)
val half: real64 =
   (castFromWord (<< ((- ((fromInt exponentBias), one)), significandBits)))
val one: real64 = (castFromWord (<< ((fromInt exponentBias), significandBits)))
val signBit: real64 -> bool =
   (o_1 (real64, bool, {exponent: word64, sign: bool, significand: word64}) ((fn x_1504: {exponent: word64,
											  sign: bool,
											  significand: word64} =>
									      case x_1504 of
										{sign = #: bool} =>
										#),
									     toBits))
val realCeil: real64 -> real64 = realCeil
val realFloor: real64 -> real64 = realFloor
val realTrunc: real64 -> real64 = realTrunc
val realRound: real64 -> real64 =
   (fn x_1505: real64 =>
    case x_1505 of
      r: real64 =>
      (withRoundingMode_0 (real64) (TO_NEAREST,
				    (fn x_1506: unit =>
				     case x_1506 of
				       () => (round r)))))
val rec
   strtor: string * IEEEReal.RoundingMode.t -> real64 = 
      (fn x_1507: string * IEEEReal.RoundingMode.t =>
       case x_1507 of
	 ((str: string, rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (strtor (str, rounding))
	 end)
exception Bad
datatype Real.mode = Fix
		     | Gen
		     | Sci
val one: int32 ref One.t =
   (make_0 (int32 ref) (fn x_1508: unit =>
			case x_1508 of
			  () => (ref[int32] 0x0)))
val rec
   gdtoa: real64 * Real.mode * int32 * IEEEReal.RoundingMode.t -> word64 * int32 = 
      (fn x_1509: real64 * Real.mode * int32 * IEEEReal.RoundingMode.t =>
       case x_1509 of
	 ((x: real64,
	   mode: Real.mode,
	   ndig: int32,
	   rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val mode: int32 = case mode of Fix => 0x3 | Gen => 0x0 | Sci => 0x2
	     val ndig: int32 = (fromInt ndig)
	     val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (use_0 (word64 * int32, int32 ref) (one,
						(fn x_1510: int32 ref =>
						 case x_1510 of
						   decpt: int32 ref =>
						   ((gdtoa (x,
							    mode,
							    ndig,
							    rounding,
							    decpt)),
						    (toInt (!_1 (int32) decpt))))))
	 end)
val rec
   toDecimal: real64
	      -> {class: IEEEReal.float_class,
		  digits: int32 list,
		  exp: int32,
		  sign: bool} = 
      (fn x_1511: real64 =>
       case x_1511 of
	 (x: real64) =>
	 case (class x) of
	   INF => {class = INF, digits = [], exp = 0x0, sign = (< (x, zero))}
	 | NAN => {class = NAN, digits = [], exp = 0x0, sign = (signBit x)}
	 | ZERO => {class = ZERO, digits = [], exp = 0x0, sign = (signBit x)}
	 | c: IEEEReal.float_class =>
	   let val (cs: word64, exp: int32) = (gdtoa (x, Gen, 0x0, TO_NEAREST))
	       val rec
		  loop: int32 * int32 list -> int32 list = 
		     (fn x_1512: int32 * int32 list =>
		      case x_1512 of
			((i: int32, ac: int32 list)) =>
			case (< (i, 0x0)) of
			  true => ac
			| false =>
			  (loop ((- (i, 0x1)),
				 (::[int32] ((- ((ord (sub (cs, i))), (ord 0x30))),
					     ac)))))
	       val digits: int32 list = (loop ((- ((length cs), 0x1)), []))
	   in
	      {class = c, digits = digits, exp = exp, sign = (< (x, zero))}
	   end)
val rec
   fix: string * word64 * int32 * int32 -> string = 
      (fn x_1513: string * word64 * int32 * int32 =>
       case x_1513 of
	 ((sign: string, cs: word64, decpt: int32, ndig: int32)) =>
	 let val length: int32 = (length cs)
	 in
	    case (< (decpt, 0x0)) of
	      true =>
	      (concat_2 [sign,
			 "0.",
			 (new ((~ decpt), 0x30)),
			 (toString cs),
			 (new ((+ ((- (ndig, length)), decpt)), 0x30))])
	    | false =>
	      let val whole: string =
		     case (= (int32) (decpt, 0x0)) of
		       true => "0"
		     | false =>
		       (tabulate_5 (decpt,
				    (fn x_1514: int32 =>
				     case x_1514 of
				       i: int32 =>
				       case (< (i, length)) of
					 true => (sub (cs, i)) | false => 0x30)))
	      in
		 case (= (int32) (0x0, ndig)) of
		   true => (concat_2 [sign, whole])
		 | false =>
		   let val frac: string =
			  (tabulate_5 (ndig,
				       (fn x_1515: int32 =>
					case x_1515 of
					  i: int32 =>
					  let val j: int32 = (+ (i, decpt))
					  in
					     case (< (j, length)) of
					       true => (sub (cs, j))
					     | false => 0x30
					  end)))
		   in
		      (concat_2 [sign, whole, ".", frac])
		   end
	      end
	 end)
val rec
   sci: real64 * int32 -> string = 
      (fn x_1516: real64 * int32 =>
       case x_1516 of
	 ((x: real64, ndig: int32)) =>
	 let val sign: string = case (< (x, zero)) of true => "~" | false => ""
	     val (cs: word64, decpt: int32) =
		(gdtoa (x, Sci, (+ (0x1, ndig)), (getRoundingMode ())))
	     val length: int32 = (length cs)
	     val whole: string =
		(tabulate_5 (0x1,
			     (fn x_1518: int32 =>
			      case x_1518 of
				_ => (sub (cs, 0x0)))))
	     val frac: string =
		case (= (int32) (0x0, ndig)) of
		  true => ""
		| false =>
		  (concat_2 [".",
			     (tabulate_5 (ndig,
					  (fn x_1517: int32 =>
					   case x_1517 of
					     i: int32 =>
					     let val j: int32 = (+ (i, 0x1))
					     in
						case (< (j, length)) of
						  true => (sub (cs, j))
						| false => 0x30
					     end)))])
	     val exp: int32 = (- (decpt, 0x1))
	     val exp: string =
		let val (exp: int32, sign: string) =
		       case (< (exp, 0x0)) of
			 true => ((~ exp), "~") | false => (exp, "")
		in
		   (concat_2 [sign, (toString exp)])
		end
	 in
	    (concat_2 [sign, whole, frac, "E", exp])
	 end)
val rec
   gen: real64 * int32 -> string = 
      (fn x_1519: real64 * int32 =>
       case x_1519 of
	 ((x: real64, n: int32)) =>
	 let val (prefix: string, x: real64) =
		case (< (x, zero)) of
		  true => ("~", (~ x)) | false => ("", x)
	     val ss: char8 PrimSequence.Slice.t =
		(full_8 (sci (x, (- (n, 0x1)))))
	     val rec
		isE: char8 -> bool = 
		   (fn x_1526: char8 =>
		    case x_1526 of
		      (c: char8) => (= (char8) (c, 0x45)))
	     val rec
		isZero: char8 -> bool = 
		   (fn x_1525: char8 =>
		    case x_1525 of
		      (c: char8) => (= (char8) (c, 0x30)))
	     val expS: string =
		(string ((taker_4 (o_1 (char8, bool, bool) (not, isE))) ss))
	     val exp: int32 = (valOf_1 (int32) (fromString expS))
	     val man: string =
		((translate_2 (fn x_1524: char8 =>
			       case x_1524 of
				 0x2E => "" | c: char8 => (str c))) (string ((dropr_4 isZero) ((takel_4 (o_1 (char8,
									     bool,
									     bool) (not,
										    isE))) ss))))
	     val manSize: int32 = (size man)
	     val rec
		zeros: int32 -> string = 
		   (fn x_1522: int32 =>
		    case x_1522 of
		      (i: int32) =>
		      (tabulate_5 (i,
				   (fn x_1523: int32 =>
				    case x_1523 of
				      _ => 0x30))))
	     val rec
		dotAt: int32 -> string = 
		   (fn x_1521: int32 =>
		    case x_1521 of
		      (i: int32) =>
		      (concat_2 [(substring (man, 0x0, i)),
				 ".",
				 (extract (man, i, NONE[int32]))]))
	     val rec
		sci: unit -> string = 
		   (fn x_1520: unit =>
		    case x_1520 of
		      (()) =>
		      (concat_2 [prefix,
				 case (= (int32) (manSize, 0x1)) of
				   true => man | false => (dotAt 0x1),
				 "E",
				 expS]))
	     val -: int32 * int32 -> int32 = -
	     val +: int32 * int32 -> int32 = +
	     val ~: int32 -> int32 = ~
	     val >=: int32 * int32 -> bool = >=
	 in
	    case (>= (exp,
		      case (= (int32) (manSize, 0x1)) of
			true => 0x3 | false => (+ (manSize, 0x3)))) of
	      true => (sci ())
	    | false =>
	      case (>= (exp, (- (manSize, 0x1)))) of
		true =>
		(concat_2 [prefix, man, (zeros (- (exp, (- (manSize, 0x1)))))])
	      | false =>
		case (>= (exp, 0x0)) of
		  true => (concat_2 [prefix, (dotAt (+ (exp, 0x1)))])
		| false =>
		  case (>= (exp,
			    case (= (int32) (manSize, 0x1)) of
			      true => 0xFFFFFFFE | false => 0xFFFFFFFD)) of
		    true =>
		    (concat_2 [prefix, "0.", (zeros (- ((~ exp), 0x1))), man])
		  | false => (sci ())
	 end)
val rec
   fmt: StringCvt.realfmt -> real64 -> string = 
      (fn x_1527: StringCvt.realfmt =>
       case x_1527 of
	 (spec: StringCvt.realfmt) =>
	 let val doit: real64 -> string =
		case spec of
		  EXACT =>
		  (o_1 (real64,
			string,
			{class: IEEEReal.float_class,
			 digits: int32 list,
			 exp: int32,
			 sign: bool}) (toString, toDecimal))
		| FIX opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1528: real64 =>
		      case x_1528 of
			x: real64 =>
			let val sign: string =
			       case (< (x, zero)) of
				 true => "~" | false => ""
			    val (cs: word64, decpt: int32) =
			       (gdtoa (x, Fix, n, (getRoundingMode ())))
			in
			   (fix (sign, cs, decpt, n))
			end)
		  end
		| GEN opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0xC
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x1)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1529: real64 =>
		      case x_1529 of
			x: real64 => (gen (x, n)))
		  end
		| SCI opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1530: real64 =>
		      case x_1530 of
			x: real64 => (sci (x, n)))
		  end
	 in
	    (fn x_1531: real64 =>
	     case x_1531 of
	       x: real64 =>
	       case (class x) of
		 NAN => "nan"
	       | INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	       | _ => (doit x))
	 end)
val rec 'a_3512
   safeConvert: IEEEReal.RoundingMode.t * (real64 -> 'a_3512) * real64
		-> 'a_3512 = 
      (fn x_1532: IEEEReal.RoundingMode.t * (real64 -> 'a_3512) * real64 =>
       case x_1532 of
	 ((m: IEEEReal.RoundingMode.t, cvt: real64 -> 'a_3512, x: real64)) =>
	 case m of
	   TO_POSINF => (cvt (realCeil x))
	 | TO_NEGINF => (cvt (realFloor x))
	 | TO_NEAREST => (cvt (realRound x))
	 | TO_ZERO => (cvt (realTrunc x)))
val rec 'a
   make: {fromIntUnsafe: 'a -> real64,
	  other: {maxInt': word32 -> 'a, minInt': 'a, precision': int32},
	  toIntUnsafe: real64 -> 'a}
	 -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
      (fn x_1533: {fromIntUnsafe: 'a -> real64,
		   other: {maxInt': word32 -> 'a, minInt': 'a, precision': int32},
		   toIntUnsafe: real64 -> 'a} =>
       case x_1533 of
	 ({fromIntUnsafe = fromIntUnsafe: 'a -> real64,
	   toIntUnsafe = toIntUnsafe: real64 -> 'a,
	   other = other: {maxInt': word32 -> 'a, minInt': 'a, precision': int32}}) =>
	 (fromIntUnsafe,
	  case (< (precision,
		   ((fn x_1543: {maxInt': word32 -> 'a,
				 minInt': 'a,
				 precision': int32} =>
		     case x_1543 of
		       {precision' = #: int32} => #) other))) of
	    true =>
	    let val trim: int32 =
		   (- ((- (((fn x_1536: {maxInt': word32 -> 'a,
					 minInt': 'a,
					 precision': int32} =>
			     case x_1536 of
			       {precision' = #: int32} => #) other),
			   precision)),
		       0x1))
		val maxInt': 'a =
		   (((fn x_1535: {maxInt': word32 -> 'a,
				  minInt': 'a,
				  precision': int32} =>
		      case x_1535 of
			{maxInt' = #: word32 -> 'a} => #) other) (fromInt trim))
		val minInt': 'a =
		   ((fn x_1534: {maxInt': word32 -> 'a,
				 minInt': 'a,
				 precision': int32} =>
		     case x_1534 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real64 = (fromIntUnsafe maxInt')
		val minInt: real64 = (fromIntUnsafe minInt')
	    in
	       (fn x_1537: IEEEReal.RoundingMode.t =>
		case x_1537 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1538: real64 =>
		   case x_1538 of
		     x: real64 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (safeConvert ('a) (m, toIntUnsafe, x))
		       | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true => raise Overflow | false => raise Domain))
	    end
	  | false =>
	    let val maxInt': 'a =
		   (((fn x_1540: {maxInt': word32 -> 'a,
				  minInt': 'a,
				  precision': int32} =>
		      case x_1540 of
			{maxInt' = #: word32 -> 'a} => #) other) 0x0)
		val minInt': 'a =
		   ((fn x_1539: {maxInt': word32 -> 'a,
				 minInt': 'a,
				 precision': int32} =>
		     case x_1539 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real64 = (fromIntUnsafe maxInt')
		val minInt: real64 = (fromIntUnsafe minInt')
	    in
	       (fn x_1541: IEEEReal.RoundingMode.t =>
		case x_1541 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1542: real64 =>
		   case x_1542 of
		     x: real64 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (safeConvert ('a) (m, toIntUnsafe, x))
		       | false =>
			 case (< (x, (+ (maxInt, one)))) of
			   true =>
			   case m of
			     TO_NEGINF => maxInt'
			   | TO_POSINF => raise Overflow
			   | TO_ZERO => maxInt'
			   | TO_NEAREST =>
			     case (>= ((- (x, maxInt)), half)) of
			       true => raise Overflow | false => maxInt'
			 | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true =>
			 case (< ((- (minInt, one)), x)) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => minInt'
			   | TO_ZERO => minInt'
			   | TO_NEAREST =>
			     case (< ((- (x, minInt)), (~ half))) of
			       true => raise Overflow | false => minInt'
			 | false => raise Overflow
		       | false => raise Domain))
	    end))
val (fromInt8: int8 -> real64, toInt8: IEEEReal.RoundingMode.t -> real64 -> int8) =
   (make (int8) {fromIntUnsafe = fromInt8Unsafe,
		 toIntUnsafe = toInt8Unsafe,
		 other = {maxInt' = (fn x_1544: word32 =>
				     case x_1544 of
				       w: word32 => (<< ((>> (maxInt', w)), w))),
			  minInt' = minInt',
			  precision' = precision'}})
val (fromInt16: int16 -> real64,
     toInt16: IEEEReal.RoundingMode.t -> real64 -> int16) =
   (make (int16) {fromIntUnsafe = fromInt16Unsafe,
		  toIntUnsafe = toInt16Unsafe,
		  other = {maxInt' = (fn x_1545: word32 =>
				      case x_1545 of
					w: word32 => (<< ((>> (maxInt', w)), w))),
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt32: int32 -> real64,
     toInt32: IEEEReal.RoundingMode.t -> real64 -> int32) =
   (make (int32) {fromIntUnsafe = fromInt32Unsafe,
		  toIntUnsafe = toInt32Unsafe,
		  other = {maxInt' = (fn x_1546: word32 =>
				      case x_1546 of
					w: word32 => (<< ((>> (maxInt', w)), w))),
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt64: int64 -> real64,
     toInt64: IEEEReal.RoundingMode.t -> real64 -> int64) =
   (make (int64) {fromIntUnsafe = fromInt64Unsafe,
		  toIntUnsafe = toInt64Unsafe,
		  other = {maxInt' = (fn x_1547: word32 =>
				      case x_1547 of
					w: word32 => (<< ((>> (maxInt', w)), w))),
			   minInt' = minInt',
			   precision' = precision'}})
val fromIntInf: intInf -> real64 =
   (fn x_1548: intInf =>
    case x_1548 of
      i: intInf =>
      let val str: string =
	     case (< (i, 0)) of
	       true => (^ ("-", (toString (~ i)))) | false => (toString i)
	  val x: real64 = (strtor ((nullTerm str), (getRoundingMode ())))
      in
	 x
      end)
val toIntInf: IEEEReal.RoundingMode.t -> real64 -> intInf =
   (fn x_1549: IEEEReal.RoundingMode.t =>
    case x_1549 of
      mode: IEEEReal.RoundingMode.t =>
      (fn x_1550: real64 =>
       case x_1550 of
	 x: real64 =>
	 case (class x) of
	   INF => raise Overflow
	 | NAN => raise Domain
	 | ZERO => 0
	 | _ =>
	   let val x: real64 =
		  case mode of
		    TO_POSINF => (realCeil x)
		  | TO_NEGINF => (realFloor x)
		  | TO_NEAREST => (realRound x)
		  | TO_ZERO => (realTrunc x)
	   in
	      case (class x) of
		INF => raise Overflow
	      | _ =>
		(valOf_1 (intInf) (fromString ((fmt (FIX (SOME[int32] 0x0))) x)))
	   end))
val fInt8: int8 -> real64 = fromInt8
val fInt16: int16 -> real64 = fromInt16
val fInt64: int64 -> real64 = fromInt64
val fIntInf: intInf -> real64 = fromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> real64 = fromInt8
val fInt16: int16 -> real64 = fromInt16
val fInt32: int32 -> real64 = fromInt32
val fInt64: int64 -> real64 = fromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: IEEEReal.RoundingMode.t -> real64 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real64 -> int16 = toInt16
val fInt64: IEEEReal.RoundingMode.t -> real64 -> int64 = toInt64
val fIntInf: IEEEReal.RoundingMode.t -> real64 -> intInf = toIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: IEEEReal.RoundingMode.t -> real64 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real64 -> int16 = toInt16
val fInt32: IEEEReal.RoundingMode.t -> real64 -> int32 = toInt32
val fInt64: IEEEReal.RoundingMode.t -> real64 -> int64 = toInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val rec 'a
   make: {fromWordUnsafe: 'a -> real64,
	  other: {maxWord': word32 -> 'a, wordSize: int32, zeroWord: 'a},
	  toWordUnsafe: real64 -> 'a}
	 -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
      (fn x_1551: {fromWordUnsafe: 'a -> real64,
		   other: {maxWord': word32 -> 'a, wordSize: int32, zeroWord: 'a},
		   toWordUnsafe: real64 -> 'a} =>
       case x_1551 of
	 ({fromWordUnsafe = fromWordUnsafe: 'a -> real64,
	   toWordUnsafe = toWordUnsafe: real64 -> 'a,
	   other = other: {maxWord': word32 -> 'a, wordSize: int32, zeroWord: 'a}}) =>
	 (fromWordUnsafe,
	  case (<= (precision,
		    ((fn x_1561: {maxWord': word32 -> 'a,
				  wordSize: int32,
				  zeroWord: 'a} =>
		      case x_1561 of
			{wordSize = #: int32} => #) other))) of
	    true =>
	    let val trim: int32 =
		   (- (((fn x_1554: {maxWord': word32 -> 'a,
				     wordSize: int32,
				     zeroWord: 'a} =>
			 case x_1554 of
			   {wordSize = #: int32} => #) other),
		       precision))
		val maxWord': 'a =
		   (((fn x_1553: {maxWord': word32 -> 'a,
				  wordSize: int32,
				  zeroWord: 'a} =>
		      case x_1553 of
			{maxWord' = #: word32 -> 'a} => #) other) (fromInt trim))
		val maxWord: real64 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1552: {maxWord': word32 -> 'a,
				 wordSize: int32,
				 zeroWord: 'a} =>
		     case x_1552 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1555: IEEEReal.RoundingMode.t =>
		case x_1555 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1556: real64 =>
		   case x_1556 of
		     x: real64 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (safeConvert ('a) (m, toWordUnsafe, x))
			 | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end
	  | false =>
	    let val maxWord': 'a =
		   (((fn x_1558: {maxWord': word32 -> 'a,
				  wordSize: int32,
				  zeroWord: 'a} =>
		      case x_1558 of
			{maxWord' = #: word32 -> 'a} => #) other) 0x0)
		val maxWord: real64 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1557: {maxWord': word32 -> 'a,
				 wordSize: int32,
				 zeroWord: 'a} =>
		     case x_1557 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1559: IEEEReal.RoundingMode.t =>
		case x_1559 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1560: real64 =>
		   case x_1560 of
		     x: real64 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (safeConvert ('a) (m, toWordUnsafe, x))
			 | false =>
			   case (< (x, (+ (maxWord, one)))) of
			     true =>
			     case m of
			       TO_NEGINF => maxWord'
			     | TO_POSINF => raise Overflow
			     | TO_ZERO => maxWord'
			     | TO_NEAREST =>
			       case (>= ((- (x, maxWord)), half)) of
				 true => raise Overflow | false => maxWord'
			   | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end))
val (fromWord8: word8 -> real64,
     toWord8: IEEEReal.RoundingMode.t -> real64 -> word8) =
   (make (word8) {fromWordUnsafe = fromWord8Unsafe,
		  toWordUnsafe = toWord8Unsafe,
		  other = {maxWord' = (fn x_1562: word32 =>
				       case x_1562 of
					 w: word32 =>
					 (<< ((>> (maxWord', w)), w))),
			   wordSize = wordSize,
			   zeroWord = zero}})
val (fromWord16: word16 -> real64,
     toWord16: IEEEReal.RoundingMode.t -> real64 -> word16) =
   (make (word16) {fromWordUnsafe = fromWord16Unsafe,
		   toWordUnsafe = toWord16Unsafe,
		   other = {maxWord' = (fn x_1563: word32 =>
					case x_1563 of
					  w: word32 =>
					  (<< ((>> (maxWord', w)), w))),
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord32: word32 -> real64,
     toWord32: IEEEReal.RoundingMode.t -> real64 -> word32) =
   (make (word32) {fromWordUnsafe = fromWord32Unsafe,
		   toWordUnsafe = toWord32Unsafe,
		   other = {maxWord' = (fn x_1564: word32 =>
					case x_1564 of
					  w: word32 =>
					  (<< ((>> (maxWord', w)), w))),
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord64: word64 -> real64,
     toWord64: IEEEReal.RoundingMode.t -> real64 -> word64) =
   (make (word64) {fromWordUnsafe = fromWord64Unsafe,
		   toWordUnsafe = toWord64Unsafe,
		   other = {maxWord' = (fn x_1565: word32 =>
					case x_1565 of
					  w: word32 =>
					  (<< ((>> (maxWord', w)), w))),
			    wordSize = wordSize,
			    zeroWord = zero}})
val fWord8: word8 -> real64 = fromWord8
val fWord16: word16 -> real64 = fromWord16
val fWord64: word64 -> real64 = fromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> real64 = fromWord8
val fWord16: word16 -> real64 = fromWord16
val fWord32: word32 -> real64 = fromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: IEEEReal.RoundingMode.t -> real64 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real64 -> word16 = toWord16
val fWord64: IEEEReal.RoundingMode.t -> real64 -> word64 = toWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: IEEEReal.RoundingMode.t -> real64 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real64 -> word16 = toWord16
val fWord32: IEEEReal.RoundingMode.t -> real64 -> word32 = toWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val bswap: word32 -> word32 = bswap
val subArrRev: word8 array * int64 -> real32 =
   (o_1 (word8 array * int64, real32, word32) ((o_1 (word32, real32, word32) (castFromWord,
									      bswap)),
					       subArr))
val subVecRev: word8 vector * int64 -> real32 =
   (o_1 (word8 vector * int64, real32, word32) ((o_1 (word32, real32, word32) (castFromWord,
									       bswap)),
						subVec))
val rec
   updateRev: word8 array * int64 * real32 -> unit = 
      (fn x_1566: word8 array * int64 * real32 =>
       case x_1566 of
	 ((a: word8 array, i: int64, r: real32)) =>
	 (update (a, i, (bswap (castToWord r)))))
val subArr: word8 array * int64 -> real32 =
   (o_1 (word8 array * int64, real32, word32) (castFromWord, subArr))
val subVec: word8 vector * int64 -> real32 =
   (o_1 (word8 vector * int64, real32, word32) (castFromWord, subVec))
val update: word8 array * int64 * real32 -> unit =
   (fn x_1567: word8 array * int64 * real32 =>
    case x_1567 of
      (a: word8 array, i: int64, r: real32) => (update (a, i, (castToWord r))))
val fReal32: int32 = realSize
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArr
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVec
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = update
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArrRev
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVecRev
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = updateRev
val _ = fReal32
val fReal32: int32 = realSize
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArr
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVec
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = update
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArrRev
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVecRev
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = updateRev
val _ = fReal32
val ticksPerSecond: intInf = 1000000000
datatype Time.time = T of intInf
exception Time
val rec
   make: intInf -> (intInf -> Time.time) * (Time.time -> intInf) = 
      (fn x_1568: intInf =>
       case x_1568 of
	 (ticksPer: intInf) =>
	 let val d: intInf = (quot (ticksPerSecond, ticksPer))
	 in
	    ((fn x_1570: intInf =>
	      case x_1570 of
		i: intInf => (T (* (i, d)))),
	     (fn x_1569: Time.time =>
	      case x_1569 of
		T i: intInf => (quot (i, d))))
	 end)
val (fromSeconds: intInf -> Time.time, toSeconds: Time.time -> intInf) =
   (make 1)
datatype Date.weekday = Mon
			| Tue
			| Wed
			| Thu
			| Fri
			| Sat
			| Sun
datatype Date.month = Jan
		      | Feb
		      | Mar
		      | Apr
		      | May
		      | Jun
		      | Jul
		      | Aug
		      | Sep
		      | Oct
		      | Nov
		      | Dec
datatype Date.t = T of {day: int32,
			hour: int32,
			isDst: bool Primitive.Option.t,
			minute: int32,
			month: Date.month,
			offset: int32 Primitive.Option.t,
			second: int32,
			weekDay: Date.weekday,
			year: int32,
			yearDay: int32}
exception Date
exception BlockingNotSupported
exception ClosedStream
exception Io of {cause: exn, function: string, name: string}
val _ =
   (addExnMessager (fn x_1571: exn =>
		    case x_1571 of
		      e: exn =>
		      case e of
			Io {cause = cause: exn,
			    function = function: string,
			    name = name: string} =>
			(SOME[string] (concat_2 ["Io: ",
						 function,
						 " \"",
						 name,
						 "\" failed with ",
						 (exnMessage cause)]))
		      | _ => NONE[string]))
exception NonblockingNotSupported
exception RandomAccessNotSupported
datatype IO.buffer_mode = NO_BUF
			  | LINE_BUF
			  | BLOCK_BUF
datatype PrimIO.reader = RD of {avail: unit -> int32 Primitive.Option.t,
				block: (unit -> unit) Primitive.Option.t,
				canInput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				readArr: (word8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
				readArrNB: (word8 PrimSequence.Slice.t
					    -> int32 Primitive.Option.t) Primitive.Option.t,
				readVec: (int32 -> word8 vector) Primitive.Option.t,
				readVecNB: (int32
					    -> word8 vector Primitive.Option.t) Primitive.Option.t,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t}
datatype PrimIO.writer = WR of {block: (unit -> unit) Primitive.Option.t,
				canOutput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t,
				writeArr: (word8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
				writeArrNB: (word8 PrimSequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t,
				writeVec: (word8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
				writeVecNB: (word8 PrimSequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t}
datatype PrimIO.reader = RD of {avail: unit -> int32 Primitive.Option.t,
				block: (unit -> unit) Primitive.Option.t,
				canInput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				readArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
				readArrNB: (char8 PrimSequence.Slice.t
					    -> int32 Primitive.Option.t) Primitive.Option.t,
				readVec: (int32 -> string) Primitive.Option.t,
				readVecNB: (int32 -> string Primitive.Option.t) Primitive.Option.t,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t}
datatype PrimIO.writer = WR of {block: (unit -> unit) Primitive.Option.t,
				canOutput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t,
				writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
				writeArrNB: (char8 PrimSequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t,
				writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
				writeVecNB: (char8 PrimSequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t}
val rec
   augmentWriter: PrimIO.writer -> PrimIO.writer = 
      (fn x_1572: PrimIO.writer =>
       case x_1572 of
	 (WR {name = name: string,
	      chunkSize = chunkSize: int32,
	      writeVec = writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
	      writeArr = writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
	      writeVecNB = writeVecNB: (char8 PrimSequence.Slice.t
					-> int32 Primitive.Option.t) Primitive.Option.t,
	      writeArrNB = writeArrNB: (char8 PrimSequence.Slice.t
					-> int32 Primitive.Option.t) Primitive.Option.t,
	      block = block: (unit -> unit) Primitive.Option.t,
	      canOutput = canOutput: (unit -> bool) Primitive.Option.t,
	      getPos = getPos: (unit -> int64) Primitive.Option.t,
	      setPos = setPos: (int64 -> unit) Primitive.Option.t,
	      endPos = endPos: (unit -> int64) Primitive.Option.t,
	      verifyPos = verifyPos: (unit -> int64) Primitive.Option.t,
	      close = close: unit -> unit,
	      ioDesc = ioDesc: int32 Primitive.Option.t}) =>
	 let val rec 'a_3878
		augmentWrite: (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
			      * (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
			      -> (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
				 * (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t = 
		   (fn x_1576: (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t
			       * (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t =>
		    case x_1576 of
		      ((writeVec: (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t,
			writeArr: (char8 PrimSequence.Slice.t -> 'a_3878) Primitive.Option.t)) =>
		      case (writeVec, writeArr) of
			(SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeVec: char8 PrimSequence.Slice.t
									       -> 'a_3878,
			 SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeArr: char8 PrimSequence.Slice.t
									       -> 'a_3878) =>
			((SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeVec),
			 (SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeArr))
		      | (NONE[char8 PrimSequence.Slice.t -> 'a_3878],
			 SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeArr: char8 PrimSequence.Slice.t
									       -> 'a_3878) =>
			((SOME[char8 PrimSequence.Slice.t -> 'a_3878] (fn x_1577: char8 PrimSequence.Slice.t =>
								       case x_1577 of
									 sl: char8 PrimSequence.Slice.t =>
									 (writeArr (full_9 (tabulate_6 ((length_15 sl),
													(fn x_1578: int32 =>
													 case x_1578 of
													   i: int32 =>
													   (sub_11 (sl,
														    i))))))))),
			 (SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeArr))
		      | (SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeVec: char8 PrimSequence.Slice.t
									       -> 'a_3878,
			 NONE[char8 PrimSequence.Slice.t -> 'a_3878]) =>
			((SOME[char8 PrimSequence.Slice.t -> 'a_3878] writeVec),
			 (SOME[char8 PrimSequence.Slice.t -> 'a_3878] (fn x_1579: char8 PrimSequence.Slice.t =>
								       case x_1579 of
									 sl: char8 PrimSequence.Slice.t =>
									 (writeVec (full_8 (vector_6 sl))))))
		      | (NONE[char8 PrimSequence.Slice.t -> 'a_3878],
			 NONE[char8 PrimSequence.Slice.t -> 'a_3878]) =>
			(NONE[char8 PrimSequence.Slice.t -> 'a_3878],
			 NONE[char8 PrimSequence.Slice.t -> 'a_3878]))
	     val rec ('a_3880, 'a_3879)
		augmentSeq: ('a_3880 -> 'a_3879) Primitive.Option.t
			    * ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t
			    -> ('a_3880 -> 'a_3879) Primitive.Option.t
			       * ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t = 
		   (fn x_1573: ('a_3880 -> 'a_3879) Primitive.Option.t
			       * ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t =>
		    case x_1573 of
		      ((writeSeq: ('a_3880 -> 'a_3879) Primitive.Option.t,
			writeSeqNB: ('a_3880 -> 'a_3879 Primitive.Option.t) Primitive.Option.t)) =>
		      case (writeSeq, writeSeqNB) of
			(SOME['a_3880 -> 'a_3879] writeSeq: 'a_3880 -> 'a_3879,
			 SOME['a_3880 -> 'a_3879 Primitive.Option.t] writeSeqNB: 'a_3880
										 -> 'a_3879 Primitive.Option.t) =>
			((SOME['a_3880 -> 'a_3879] writeSeq),
			 (SOME['a_3880 -> 'a_3879 Primitive.Option.t] writeSeqNB))
		      | (NONE['a_3880 -> 'a_3879],
			 SOME['a_3880 -> 'a_3879 Primitive.Option.t] writeSeqNB: 'a_3880
										 -> 'a_3879 Primitive.Option.t) =>
			(case block of
			   NONE[unit -> unit] => NONE['a_3880 -> 'a_3879]
			 | SOME[unit -> unit] block: unit -> unit =>
			   (SOME['a_3880 -> 'a_3879] (fn x_1574: 'a_3880 =>
						      case x_1574 of
							x: 'a_3880 =>
							(block ())
							;(valOf_1 ('a_3879) (writeSeqNB x)))),
			 (SOME['a_3880 -> 'a_3879 Primitive.Option.t] writeSeqNB))
		      | (SOME['a_3880 -> 'a_3879] writeSeq: 'a_3880 -> 'a_3879,
			 NONE['a_3880 -> 'a_3879 Primitive.Option.t]) =>
			((SOME['a_3880 -> 'a_3879] writeSeq),
			 case canOutput of
			   NONE[unit -> bool] =>
			   NONE['a_3880 -> 'a_3879 Primitive.Option.t]
			 | SOME[unit -> bool] canOutput: unit -> bool =>
			   (SOME['a_3880 -> 'a_3879 Primitive.Option.t] (fn x_1575: 'a_3880 =>
									 case x_1575 of
									   x: 'a_3880 =>
									   case (canOutput ()) of
									     true =>
									     (SOME['a_3879] (writeSeq x))
									   | false =>
									     NONE['a_3879])))
		      | (NONE['a_3880 -> 'a_3879],
			 NONE['a_3880 -> 'a_3879 Primitive.Option.t]) =>
			(NONE['a_3880 -> 'a_3879],
			 NONE['a_3880 -> 'a_3879 Primitive.Option.t]))
	     val ((writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		   writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t),
		  (writeVecNB: (char8 PrimSequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t,
		   writeArrNB: (char8 PrimSequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t)) =
		((augmentWrite (int32) (writeVec, writeArr)),
		 (augmentWrite (int32 Primitive.Option.t) (writeVecNB,
							   writeArrNB)))
	     val ((writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		   writeVecNB: (char8 PrimSequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t),
		  (writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		   writeArrNB: (char8 PrimSequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t)) =
		((augmentSeq (char8 PrimSequence.Slice.t, int32) (writeVec,
								  writeVecNB)),
		 (augmentSeq (char8 PrimSequence.Slice.t, int32) (writeArr,
								  writeArrNB)))
	 in
	    (WR {name = name,
		 chunkSize = chunkSize,
		 writeVec = writeVec,
		 writeArr = writeArr,
		 writeVecNB = writeVecNB,
		 writeArrNB = writeArrNB,
		 block = block,
		 canOutput = canOutput,
		 getPos = getPos,
		 setPos = setPos,
		 endPos = endPos,
		 verifyPos = verifyPos,
		 close = close,
		 ioDesc = ioDesc})
	 end)
val ('b, 'a) stub: string * ('a -> 'b) -> 'a -> 'b =
   (fn x_1580: string * ('a -> 'b) =>
    case x_1580 of
      (msg: string, f: 'a -> 'b) =>
      case let 
	   in
	      (= (Primitive.MLton.Platform.OS.t) (MinGW, host))
	   end of
	true =>
	(fn x_1581: 'a =>
	 case x_1581 of
	   _ =>
	   case true of
	     true => () | false => (print msg) ;(print "\n")
	   ;(raiseSysWithMsg_0 ('b) (nosys, msg)))
      | false => f)
val fcntl3: int32 * int32 * int32 -> int32 =
   (stub (int32, int32 * int32 * int32) ("fcntl3", fcntl3))
val rec
   isatty: int32 -> bool = 
      (fn x_1582: int32 =>
       case x_1582 of
	 (fd: int32) => (<> (int32) ((isatty (toRep fd)), zero)))
val fromSeconds: int64 -> Time.time =
   (o_1 (int64, Time.time, intInf) (fromSeconds, toLargeInt))
val fdToIOD: int32 -> int32 = (o_1 (int32, int32, int32) (fromRep, toRep))
datatype PosixFileSys.dirstream = DS of word64 Primitive.Option.t ref
val stdout: int32 = (fromRep 0x1)
val stderr: int32 = (fromRep 0x2)
val empty: int32 = (castFromSysWord 0x0)
val flags: int32 list -> int32 = ((foldl_1 (int32, int32) orb) empty)
val append: int32 = APPEND
val nonblock: int32 = NONBLOCK
datatype PosixFileSys.open_mode = O_RDONLY
				  | O_WRONLY
				  | O_RDWR
datatype PosixFileSys.ST.stat = T of {atime: Time.time,
				      ctime: Time.time,
				      dev: word64,
				      gid: word32,
				      ino: word64,
				      mode: word32,
				      mtime: Time.time,
				      nlink: int32,
				      size: int64,
				      uid: word32}
val rec
   fromC: unit -> PosixFileSys.ST.stat = 
      (fn x_1583: unit =>
       case x_1583 of
	 (()) =>
	 (T {dev = (getDev ()),
	     ino = (getINo ()),
	     mode = (getMode ()),
	     nlink = (toInt (getNLink ())),
	     uid = (fromRep (getUId ())),
	     gid = (fromRep (getGId ())),
	     size = (getSize ()),
	     atime = (fromSeconds (getATime ())),
	     mtime = (fromSeconds (getMTime ())),
	     ctime = (fromSeconds (getCTime ()))}))
val rec 'a_3886
   make: ({atime: Time.time,
	   ctime: Time.time,
	   dev: word64,
	   gid: word32,
	   ino: word64,
	   mode: word32,
	   mtime: Time.time,
	   nlink: int32,
	   size: int64,
	   uid: word32}
	  -> 'a_3886)
	 -> PosixFileSys.ST.stat -> 'a_3886 = 
      (fn x_1584: {atime: Time.time,
		   ctime: Time.time,
		   dev: word64,
		   gid: word32,
		   ino: word64,
		   mode: word32,
		   mtime: Time.time,
		   nlink: int32,
		   size: int64,
		   uid: word32}
		  -> 'a_3886 =>
       (fn x_1585: PosixFileSys.ST.stat =>
	case (x_1584, x_1585) of
	  (sel: {atime: Time.time,
		 ctime: Time.time,
		 dev: word64,
		 gid: word32,
		 ino: word64,
		 mode: word32,
		 mtime: Time.time,
		 nlink: int32,
		 size: int64,
		 uid: word32}
		-> 'a_3886,
	   T r: {atime: Time.time,
		 ctime: Time.time,
		 dev: word64,
		 gid: word32,
		 ino: word64,
		 mode: word32,
		 mtime: Time.time,
		 nlink: int32,
		 size: int64,
		 uid: word32}) =>
	  (sel r)))
val mode: PosixFileSys.ST.stat -> word32 =
   (make (word32) (fn x_1586: {atime: Time.time,
			       ctime: Time.time,
			       dev: word64,
			       gid: word32,
			       ino: word64,
			       mode: word32,
			       mtime: Time.time,
			       nlink: int32,
			       size: int64,
			       uid: word32} =>
		   case x_1586 of
		     {mode = #: word32} => #))
val size: PosixFileSys.ST.stat -> int64 =
   (make (int64) (fn x_1587: {atime: Time.time,
			      ctime: Time.time,
			      dev: word64,
			      gid: word32,
			      ino: word64,
			      mode: word32,
			      mtime: Time.time,
			      nlink: int32,
			      size: int64,
			      uid: word32} =>
		  case x_1587 of
		    {size = #: int64} => #))
val rec
   make: (word32 -> int32) -> PosixFileSys.ST.stat -> bool = 
      (fn x_1588: word32 -> int32 =>
       (fn x_1589: PosixFileSys.ST.stat =>
	case (x_1588, x_1589) of
	  (prim: word32 -> int32, s: PosixFileSys.ST.stat) =>
	  (<> (int32) ((prim (mode s)), zero))))
val isReg: PosixFileSys.ST.stat -> bool = (make isReg)
val rec 'a_3887
   make: ('a_3887 -> int32) -> 'a_3887 -> PosixFileSys.ST.stat = 
      (fn x_1590: 'a_3887 -> int32 =>
       (fn x_1591: 'a_3887 =>
	case (x_1590, x_1591) of
	  (prim: 'a_3887 -> int32, arg: 'a_3887) =>
	  (syscall_0 (PosixFileSys.ST.stat) (fn x_1592: unit =>
					     case x_1592 of
					       () =>
					       ((prim arg),
						(fn x_1593: int32 =>
						 case x_1593 of
						   _ => (fromC ())))))))
val fstat: int32 -> PosixFileSys.ST.stat =
   (o_1 (int32, PosixFileSys.ST.stat, int32) ((make (int32) fstat), toRep))
datatype PosixFileSys.access_mode = A_READ
				    | A_WRITE
				    | A_EXEC
val rec
   close: int32 -> unit = 
      (fn x_1594: int32 =>
       case x_1594 of
	 (fd: int32) =>
	 (simpleRestart (fn x_1595: unit =>
			 case x_1595 of
			   () => (close (toRep fd)))))
val rec
   setfl: int32 * int32 -> unit = 
      (fn x_1596: int32 * int32 =>
       case x_1596 of
	 ((fd: int32, flags: int32)) =>
	 (simpleRestart (fn x_1597: unit =>
			 case x_1597 of
			   () => (fcntl3 ((toRep fd), F_SETFL, flags)))))
datatype PosixIO.whence = SEEK_SET
			  | SEEK_CUR
			  | SEEK_END
val whenceToInt: PosixIO.whence -> int32 =
   (fn x_1598: PosixIO.whence =>
    case x_1598 of
      SEEK_SET => SEEK_SET | SEEK_CUR => SEEK_CUR | SEEK_END => SEEK_END)
val rec
   lseek: int32 * int64 * PosixIO.whence -> int64 = 
      (fn x_1599: int32 * int64 * PosixIO.whence =>
       case x_1599 of
	 ((fd: int32, n: int64, w: PosixIO.whence)) =>
	 (simpleResult'_0 (int64) ({errVal = (fromInt 0xFFFFFFFF)},
				   (fn x_1600: unit =>
				    case x_1600 of
				      () =>
				      (lseek ((toRep fd), n, (whenceToInt w)))))))
datatype PosixIO.lock_type = F_RDLCK
			     | F_WRLCK
			     | F_UNLCK
val pos0: int64 = (fromInt 0x0)
val rec
   isReg: int32 -> bool = 
      (fn x_1601: int32 =>
       case x_1601 of
	 (fd: int32) => (isReg (fstat fd)))
val rec
   posFns: bool ref * int32
	   -> {endPos: (unit -> int64) Primitive.Option.t,
	       getPos: (unit -> int64) Primitive.Option.t,
	       pos: int64 ref,
	       setPos: (int64 -> unit) Primitive.Option.t,
	       verifyPos: (unit -> int64) Primitive.Option.t} = 
      (fn x_1602: bool ref * int32 =>
       case x_1602 of
	 ((closed: bool ref, fd: int32)) =>
	 case (isReg fd) of
	   true =>
	   let val pos: int64 ref = (ref[int64] pos0)
	       val rec
		  getPos: unit -> int64 = 
		     (fn x_1606: unit =>
		      case x_1606 of
			(()) => (!_1 (int64) pos))
	       val rec
		  setPos: int64 -> unit = 
		     (fn x_1605: int64 =>
		      case x_1605 of
			(p: int64) =>
			case (!_1 (bool) closed) of
			  true => raise ClosedStream | false => ()
			;(:=_1 (int64) (pos, (lseek (fd, p, SEEK_SET)))))
	       val rec
		  endPos: unit -> int64 = 
		     (fn x_1604: unit =>
		      case x_1604 of
			(()) =>
			case (!_1 (bool) closed) of
			  true => raise ClosedStream | false => ()
			;(size (fstat fd)))
	       val rec
		  verifyPos: unit -> int64 = 
		     (fn x_1603: unit =>
		      case x_1603 of
			(()) =>
			let val curPos: int64 = (lseek (fd, pos0, SEEK_CUR))
			in
			   (:=_1 (int64) (pos, curPos)) ;curPos
			end)
	       val _ = (verifyPos ())
	   in
	      {pos = pos,
	       getPos = (SOME[unit -> int64] getPos),
	       setPos = (SOME[int64 -> unit] setPos),
	       endPos = (SOME[unit -> int64] endPos),
	       verifyPos = (SOME[unit -> int64] verifyPos)}
	   end
	 | false =>
	   {pos = (ref[int64] pos0),
	    getPos = NONE[unit -> int64],
	    setPos = NONE[int64 -> unit],
	    endPos = NONE[unit -> int64],
	    verifyPos = NONE[unit -> int64]})
val rec ('a_3912,
	 'a_3911,
	 'a_3910,
	 'a_3909,
	 'a_3908,
	 'a_3907,
	 'a_3906,
	 'a_3905,
	 'a_3904,
	 'a_3903,
	 'a_3902,
	 'a_3901,
	 'a_3900,
	 'a_3899)
   make: {RD: {avail: unit -> int32 Primitive.Option.t,
	       block: 'a_3908 Primitive.Option.t,
	       canInput: 'a_3909 Primitive.Option.t,
	       chunkSize: int32,
	       close: unit -> unit,
	       endPos: (unit -> int64) Primitive.Option.t,
	       getPos: (unit -> int64) Primitive.Option.t,
	       ioDesc: int32 Primitive.Option.t,
	       name: 'a_3906,
	       readArr: ('a_3903 -> int32) Primitive.Option.t,
	       readArrNB: ('a_3903 -> int32 Primitive.Option.t) Primitive.Option.t,
	       readVec: (int32 -> 'a_3907) Primitive.Option.t,
	       readVecNB: (int32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t,
	       setPos: (int64 -> unit) Primitive.Option.t,
	       verifyPos: (unit -> int64) Primitive.Option.t}
	      -> 'a_3910,
	  WR: {block: 'a_3901 Primitive.Option.t,
	       canOutput: 'a_3902 Primitive.Option.t,
	       chunkSize: 'a_3900,
	       close: unit -> unit,
	       endPos: (unit -> int64) Primitive.Option.t,
	       getPos: (unit -> int64) Primitive.Option.t,
	       ioDesc: int32 Primitive.Option.t,
	       name: 'a_3899,
	       setPos: (int64 -> unit) Primitive.Option.t,
	       verifyPos: (unit -> int64) Primitive.Option.t,
	       writeArr: ('a_3903 -> int32) Primitive.Option.t,
	       writeArrNB: ('a_3903 -> int32 Primitive.Option.t) Primitive.Option.t,
	       writeVec: ('a_3904 -> int32) Primitive.Option.t,
	       writeVecNB: ('a_3904 -> int32 Primitive.Option.t) Primitive.Option.t}
	      -> 'a_3905,
	  fromVector: 'a_3912 vector -> 'a_3907,
	  readArr: int32 * 'a_3912 array * int32 * word64 -> int64,
	  setMode: int32 -> unit,
	  toArraySlice: 'a_3903 -> 'a_3912 PrimSequence.Slice.t,
	  toVectorSlice: 'a_3904 -> 'a_3911 PrimSequence.Slice.t,
	  vectorLength: 'a_3907 -> int32,
	  writeArr: int32 * 'a_3912 array * int32 * word64 -> int64,
	  writeVec: int32 * 'a_3911 vector * int32 * word64 -> int64}
	 -> {mkReader: {fd: int32, initBlkMode: bool, name: 'a_3906} -> 'a_3910,
	     mkWriter: {appendMode: bool,
			chunkSize: 'a_3900,
			fd: int32,
			initBlkMode: bool,
			name: 'a_3899}
		       -> 'a_3905,
	     readArr: int32 * 'a_3903 -> int32,
	     readVec: int32 * int32 -> 'a_3907,
	     writeArr: int32 * 'a_3903 -> int32,
	     writeVec: int32 * 'a_3904 -> int32} = 
      (fn x_1607: {RD: {avail: unit -> int32 Primitive.Option.t,
			block: 'a_3908 Primitive.Option.t,
			canInput: 'a_3909 Primitive.Option.t,
			chunkSize: int32,
			close: unit -> unit,
			endPos: (unit -> int64) Primitive.Option.t,
			getPos: (unit -> int64) Primitive.Option.t,
			ioDesc: int32 Primitive.Option.t,
			name: 'a_3906,
			readArr: ('a_3903 -> int32) Primitive.Option.t,
			readArrNB: ('a_3903 -> int32 Primitive.Option.t) Primitive.Option.t,
			readVec: (int32 -> 'a_3907) Primitive.Option.t,
			readVecNB: (int32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t,
			setPos: (int64 -> unit) Primitive.Option.t,
			verifyPos: (unit -> int64) Primitive.Option.t}
		       -> 'a_3910,
		   WR: {block: 'a_3901 Primitive.Option.t,
			canOutput: 'a_3902 Primitive.Option.t,
			chunkSize: 'a_3900,
			close: unit -> unit,
			endPos: (unit -> int64) Primitive.Option.t,
			getPos: (unit -> int64) Primitive.Option.t,
			ioDesc: int32 Primitive.Option.t,
			name: 'a_3899,
			setPos: (int64 -> unit) Primitive.Option.t,
			verifyPos: (unit -> int64) Primitive.Option.t,
			writeArr: ('a_3903 -> int32) Primitive.Option.t,
			writeArrNB: ('a_3903 -> int32 Primitive.Option.t) Primitive.Option.t,
			writeVec: ('a_3904 -> int32) Primitive.Option.t,
			writeVecNB: ('a_3904 -> int32 Primitive.Option.t) Primitive.Option.t}
		       -> 'a_3905,
		   fromVector: 'a_3912 vector -> 'a_3907,
		   readArr: int32 * 'a_3912 array * int32 * word64 -> int64,
		   setMode: int32 -> unit,
		   toArraySlice: 'a_3903 -> 'a_3912 PrimSequence.Slice.t,
		   toVectorSlice: 'a_3904 -> 'a_3911 PrimSequence.Slice.t,
		   vectorLength: 'a_3907 -> int32,
		   writeArr: int32 * 'a_3912 array * int32 * word64 -> int64,
		   writeVec: int32 * 'a_3911 vector * int32 * word64 -> int64} =>
       case x_1607 of
	 ({RD = RD: {avail: unit -> int32 Primitive.Option.t,
		     block: 'a_3908 Primitive.Option.t,
		     canInput: 'a_3909 Primitive.Option.t,
		     chunkSize: int32,
		     close: unit -> unit,
		     endPos: (unit -> int64) Primitive.Option.t,
		     getPos: (unit -> int64) Primitive.Option.t,
		     ioDesc: int32 Primitive.Option.t,
		     name: 'a_3906,
		     readArr: ('a_3903 -> int32) Primitive.Option.t,
		     readArrNB: ('a_3903 -> int32 Primitive.Option.t) Primitive.Option.t,
		     readVec: (int32 -> 'a_3907) Primitive.Option.t,
		     readVecNB: (int32 -> 'a_3907 Primitive.Option.t) Primitive.Option.t,
		     setPos: (int64 -> unit) Primitive.Option.t,
		     verifyPos: (unit -> int64) Primitive.Option.t}
		    -> 'a_3910,
	   WR = WR: {block: 'a_3901 Primitive.Option.t,
		     canOutput: 'a_3902 Primitive.Option.t,
		     chunkSize: 'a_3900,
		     close: unit -> unit,
		     endPos: (unit -> int64) Primitive.Option.t,
		     getPos: (unit -> int64) Primitive.Option.t,
		     ioDesc: int32 Primitive.Option.t,
		     name: 'a_3899,
		     setPos: (int64 -> unit) Primitive.Option.t,
		     verifyPos: (unit -> int64) Primitive.Option.t,
		     writeArr: ('a_3903 -> int32) Primitive.Option.t,
		     writeArrNB: ('a_3903 -> int32 Primitive.Option.t) Primitive.Option.t,
		     writeVec: ('a_3904 -> int32) Primitive.Option.t,
		     writeVecNB: ('a_3904 -> int32 Primitive.Option.t) Primitive.Option.t}
		    -> 'a_3905,
	   fromVector = fromVector: 'a_3912 vector -> 'a_3907,
	   readArr = readArr: int32 * 'a_3912 array * int32 * word64 -> int64,
	   setMode = setMode: int32 -> unit,
	   toArraySlice = toArraySlice: 'a_3903 -> 'a_3912 PrimSequence.Slice.t,
	   toVectorSlice = toVectorSlice: 'a_3904
					  -> 'a_3911 PrimSequence.Slice.t,
	   vectorLength = vectorLength: 'a_3907 -> int32,
	   writeArr = writeArr: int32 * 'a_3912 array * int32 * word64 -> int64,
	   writeVec = writeVec: int32 * 'a_3911 vector * int32 * word64 -> int64}) =>
	 let val primReadArr: int32 * 'a_3912 array * int32 * int32 -> int64 =
		(fn x_1647: int32 * 'a_3912 array * int32 * int32 =>
		 case x_1647 of
		   (fd: int32, buf: 'a_3912 array, i: int32, sz: int32) =>
		   (readArr ((toRep fd), buf, (fromInt i), (fromInt sz))))
	     val primWriteArr: int32 * 'a_3912 array * int32 * int32 -> int64 =
		(fn x_1646: int32 * 'a_3912 array * int32 * int32 =>
		 case x_1646 of
		   (fd: int32, buf: 'a_3912 array, i: int32, sz: int32) =>
		   (writeArr ((toRep fd), buf, (fromInt i), (fromInt sz))))
	     val primWriteVec: int32 * 'a_3911 vector * int32 * int32 -> int64 =
		(fn x_1645: int32 * 'a_3911 vector * int32 * int32 =>
		 case x_1645 of
		   (fd: int32, buf: 'a_3911 vector, i: int32, sz: int32) =>
		   (writeVec ((toRep fd), buf, (fromInt i), (fromInt sz))))
	     val setMode: int32 -> unit =
		(fn x_1644: int32 =>
		 case x_1644 of
		   fd: int32 =>
		   case let 
			in
			   case host of
			     MinGW => true | _ => false
			end of
		     true => (setMode (toRep fd)) | false => ())
	     val rec
		readArr: int32 * 'a_3903 -> int32 = 
		   (fn x_1642: int32 * 'a_3903 =>
		    case x_1642 of
		      ((fd: int32, sl: 'a_3903)) =>
		      let val (buf: 'a_3912 array, i: int32, sz: int32) =
			     (base_9 ('a_3912) (toArraySlice sl))
			  val bytesRead: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1643: unit =>
							       case x_1643 of
								 () =>
								 (primReadArr (fd,
									       buf,
									       i,
									       sz)))))
			  val bytesRead: int32 = (toInt bytesRead)
		      in
			 bytesRead
		      end)
	     val rec
		readVec: int32 * int32 -> 'a_3907 = 
		   (fn x_1640: int32 * int32 =>
		    case x_1640 of
		      ((fd: int32, n: int32)) =>
		      let val buf: 'a_3912 array = (arrayUninit_0 ('a_3912) n)
			  val bytesRead: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1641: unit =>
							       case x_1641 of
								 () =>
								 (primReadArr (fd,
									       buf,
									       0x0,
									       n)))))
			  val bytesRead: int32 = (toInt bytesRead)
		      in
			 (fromVector case (= (int32) (n, bytesRead)) of
				       true => (unsafeFromArray_0 ('a_3912) buf)
				     | false =>
				       (vector_3 ('a_3912) (slice_5 ('a_3912) (buf,
									       0x0,
									       (SOME[int32] bytesRead)))))
		      end)
	     val rec
		writeArr: int32 * 'a_3903 -> int32 = 
		   (fn x_1638: int32 * 'a_3903 =>
		    case x_1638 of
		      ((fd: int32, sl: 'a_3903)) =>
		      let val (buf: 'a_3912 array, i: int32, sz: int32) =
			     (base_9 ('a_3912) (toArraySlice sl))
			  val bytesWrote: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1639: unit =>
							       case x_1639 of
								 () =>
								 (primWriteArr (fd,
										buf,
										i,
										sz)))))
			  val bytesWrote: int32 = (toInt bytesWrote)
		      in
			 bytesWrote
		      end)
	     val rec
		writeVec: int32 * 'a_3904 -> int32 = 
		   (fn x_1636: int32 * 'a_3904 =>
		    case x_1636 of
		      ((fd: int32, sl: 'a_3904)) =>
		      let val (buf: 'a_3911 vector, i: int32, sz: int32) =
			     (base_5 ('a_3911) (toVectorSlice sl))
			  val bytesWrote: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1637: unit =>
							       case x_1637 of
								 () =>
								 (primWriteVec (fd,
										buf,
										i,
										sz)))))
			  val bytesWrote: int32 = (toInt bytesWrote)
		      in
			 bytesWrote
		      end)
	     val rec
		mkReader: {fd: int32, initBlkMode: bool, name: 'a_3906}
			  -> 'a_3910 = 
		   (fn x_1621: {fd: int32, initBlkMode: bool, name: 'a_3906} =>
		    case x_1621 of
		      ({fd = fd: int32,
			name = name: 'a_3906,
			initBlkMode = initBlkMode: bool}) =>
		      let val closed: bool ref = (ref[bool] false)
			  val {pos = pos: int64 ref,
			       getPos = getPos: (unit -> int64) Primitive.Option.t,
			       setPos = setPos: (int64 -> unit) Primitive.Option.t,
			       endPos = endPos: (unit -> int64) Primitive.Option.t,
			       verifyPos = verifyPos: (unit -> int64) Primitive.Option.t} =
			     (posFns (closed, fd))
			  val blocking: bool ref = (ref[bool] initBlkMode)
			  val rec
			     blockingOn: unit -> unit = 
				(fn x_1635: unit =>
				 case x_1635 of
				   (()) =>
				   (setfl (fd, (flags [])))
				   ;(:=_1 (bool) (blocking, true)))
			  val rec
			     blockingOff: unit -> unit = 
				(fn x_1634: unit =>
				 case x_1634 of
				   (()) =>
				   (setfl (fd, nonblock))
				   ;(:=_1 (bool) (blocking, false)))
			  val rec
			     ensureOpen: unit -> unit = 
				(fn x_1633: unit =>
				 case x_1633 of
				   (()) =>
				   case (!_1 (bool) closed) of
				     true => raise ClosedStream | false => ())
			  val rec
			     incPos: int32 -> unit = 
				(fn x_1632: int32 =>
				 case x_1632 of
				   (k: int32) =>
				   (:=_1 (int64) (pos,
						  (+ ((!_1 (int64) pos),
						      (fromInt k))))))
			  val readVec: int32 -> 'a_3907 =
			     (fn x_1631: int32 =>
			      case x_1631 of
				n: int32 =>
				let val v: 'a_3907 = (readVec (fd, n))
				in
				   (incPos (vectorLength v)) ;v
				end)
			  val readArr: 'a_3903 -> int32 =
			     (fn x_1630: 'a_3903 =>
			      case x_1630 of
				x: 'a_3903 =>
				let val k: int32 = (readArr (fd, x))
				in
				   (incPos k) ;k
				end)
			  val rec ('a_3892, 'a_3891)
			     blockWrap: ('a_3891 -> 'a_3892)
					-> 'a_3891 -> 'a_3892 = 
				(fn x_1628: 'a_3891 -> 'a_3892 =>
				 (fn x_1629: 'a_3891 =>
				  case (x_1628, x_1629) of
				    (f: 'a_3891 -> 'a_3892, x: 'a_3891) =>
				    (ensureOpen ())
				    ;case (!_1 (bool) blocking) of
				       true => () | false => (blockingOn ())
				    ;(f x)))
			  val rec ('a_3894, 'a_3893)
			     noBlockWrap: ('a_3893 -> 'a_3894)
					  -> 'a_3893
					     -> 'a_3894 Primitive.Option.t = 
				(fn x_1625: 'a_3893 -> 'a_3894 =>
				 (fn x_1626: 'a_3893 =>
				  case (x_1625, x_1626) of
				    (f: 'a_3893 -> 'a_3894, x: 'a_3893) =>
				    (ensureOpen ())
				    ;case (!_1 (bool) blocking) of
				       true => (blockingOff ()) | false => ()
				    ;(SOME['a_3894] (f x))
				     handle x_1627 => case x_1627 of
							e: exn as SysErr (_,
									  SOME[int32] cause: int32) =>
							case (= (int32) (cause,
									 again)) of
							  true => NONE['a_3894]
							| false => raise e))
			  val close: unit -> unit =
			     (fn x_1624: unit =>
			      case x_1624 of
				() =>
				case (!_1 (bool) closed) of
				  true => ()
				| false =>
				  (:=_1 (bool) (closed, true)) ;(close fd))
			  val avail: unit -> int32 Primitive.Option.t =
			     case (isReg fd) of
			       true =>
			       (fn x_1622: unit =>
				case x_1622 of
				  () =>
				  case (!_1 (bool) closed) of
				    true => (SOME[int32] 0x0)
				  | false =>
				    (SOME[int32] (toInt (- ((size (fstat fd)),
							    (!_1 (int64) pos))))))
			     | false =>
			       (fn x_1623: unit =>
				case x_1623 of
				  () =>
				  case (!_1 (bool) closed) of
				    true => (SOME[int32] 0x0)
				  | false => NONE[int32])
			  val () = (setMode fd)
		      in
			 (RD {avail = avail,
			      block = NONE['a_3908],
			      canInput = NONE['a_3909],
			      chunkSize = (toInt bufSize),
			      close = close,
			      endPos = endPos,
			      getPos = getPos,
			      ioDesc = (SOME[int32] (fdToIOD fd)),
			      name = name,
			      readArr = (SOME['a_3903 -> int32] (blockWrap (int32,
									    'a_3903) readArr)),
			      readArrNB = (SOME['a_3903
						-> int32 Primitive.Option.t] (noBlockWrap (int32,
											   'a_3903) readArr)),
			      readVec = (SOME[int32 -> 'a_3907] (blockWrap ('a_3907,
									    int32) readVec)),
			      readVecNB = (SOME[int32
						-> 'a_3907 Primitive.Option.t] (noBlockWrap ('a_3907,
											     int32) readVec)),
			      setPos = setPos,
			      verifyPos = verifyPos})
		      end)
	     val rec
		mkWriter: {appendMode: bool,
			   chunkSize: 'a_3900,
			   fd: int32,
			   initBlkMode: bool,
			   name: 'a_3899}
			  -> 'a_3905 = 
		   (fn x_1608: {appendMode: bool,
				chunkSize: 'a_3900,
				fd: int32,
				initBlkMode: bool,
				name: 'a_3899} =>
		    case x_1608 of
		      ({fd = fd: int32,
			name = name: 'a_3899,
			initBlkMode = initBlkMode: bool,
			appendMode = appendMode: bool,
			chunkSize = chunkSize: 'a_3900}) =>
		      let val closed: bool ref = (ref[bool] false)
			  val {pos = pos: int64 ref,
			       getPos = getPos: (unit -> int64) Primitive.Option.t,
			       setPos = setPos: (int64 -> unit) Primitive.Option.t,
			       endPos = endPos: (unit -> int64) Primitive.Option.t,
			       verifyPos = verifyPos: (unit -> int64) Primitive.Option.t} =
			     (posFns (closed, fd))
			  val rec
			     incPos: int32 -> int32 = 
				(fn x_1620: int32 =>
				 case x_1620 of
				   (k: int32) =>
				   (:=_1 (int64) (pos,
						  (+ ((!_1 (int64) pos),
						      (fromInt k)))))
				   ;k)
			  val blocking: bool ref = (ref[bool] initBlkMode)
			  val appendFlgs: int32 =
			     (flags case appendMode of
				      true => [append] | false => [])
			  val rec
			     updateStatus: unit -> unit = 
				(fn x_1619: unit =>
				 case x_1619 of
				   (()) =>
				   let val flgs: int32 =
					  case (!_1 (bool) blocking) of
					    true => appendFlgs
					  | false =>
					    (flags [nonblock, appendFlgs])
				   in
				      (setfl (fd, flgs))
				   end)
			  val rec
			     ensureOpen: unit -> unit = 
				(fn x_1618: unit =>
				 case x_1618 of
				   (()) =>
				   case (!_1 (bool) closed) of
				     true => raise ClosedStream | false => ())
			  val rec
			     ensureBlock: bool -> unit = 
				(fn x_1617: bool =>
				 case x_1617 of
				   (x: bool) =>
				   case (!_1 (bool) blocking) of
				     true => ()
				   | false =>
				     (:=_1 (bool) (blocking, x))
				     ;(updateStatus ()))
			  val rec
			     putV: int32 * 'a_3904 -> int32 = 
				(fn x_1616: int32 * 'a_3904 =>
				 case x_1616 of
				   (x: int32 * 'a_3904) => (incPos (writeVec x)))
			  val rec
			     putA: int32 * 'a_3903 -> int32 = 
				(fn x_1615: int32 * 'a_3903 =>
				 case x_1615 of
				   (x: int32 * 'a_3903) => (incPos (writeArr x)))
			  val rec ('a_3896, 'a_3895)
			     write: (int32 * 'a_3895 -> 'a_3896) * bool
				    -> 'a_3895 -> 'a_3896 = 
				(fn x_1613: (int32 * 'a_3895 -> 'a_3896) * bool =>
				 (fn x_1614: 'a_3895 =>
				  case (x_1613, x_1614) of
				    ((put: int32 * 'a_3895 -> 'a_3896,
				      block: bool),
				     arg: 'a_3895) =>
				    (ensureOpen ())
				    ;(ensureBlock block)
				    ;(put (fd, arg))))
			  val rec ('a_3898, 'a_3897)
			     handleBlock: ('a_3897 -> 'a_3898)
					  -> 'a_3897
					     -> 'a_3898 Primitive.Option.t = 
				(fn x_1610: 'a_3897 -> 'a_3898 =>
				 (fn x_1611: 'a_3897 =>
				  case (x_1610, x_1611) of
				    (writer: 'a_3897 -> 'a_3898, arg: 'a_3897) =>
				    (SOME['a_3898] (writer arg))
				    handle x_1612 => case x_1612 of
						       e: exn as SysErr (_,
									 SOME[int32] cause: int32) =>
						       case (= (int32) (cause,
									again)) of
							 true => NONE['a_3898]
						       | false => raise e))
			  val close: unit -> unit =
			     (fn x_1609: unit =>
			      case x_1609 of
				() =>
				case (!_1 (bool) closed) of
				  true => ()
				| false =>
				  (:=_1 (bool) (closed, true)) ;(close fd))
			  val () = (setMode fd)
		      in
			 (WR {block = NONE['a_3901],
			      canOutput = NONE['a_3902],
			      chunkSize = chunkSize,
			      close = close,
			      endPos = endPos,
			      getPos = getPos,
			      ioDesc = (SOME[int32] (fdToIOD fd)),
			      name = name,
			      setPos = setPos,
			      verifyPos = verifyPos,
			      writeArr = (SOME['a_3903 -> int32] (write (int32,
									 'a_3903) (putA,
										   true))),
			      writeArrNB = (SOME['a_3903
						 -> int32 Primitive.Option.t] (handleBlock (int32,
											    'a_3903) (write (int32,
													     'a_3903) (putA,
														       false)))),
			      writeVec = (SOME['a_3904 -> int32] (write (int32,
									 'a_3904) (putV,
										   true))),
			      writeVecNB = (SOME['a_3904
						 -> int32 Primitive.Option.t] (handleBlock (int32,
											    'a_3904) (write (int32,
													     'a_3904) (putV,
														       false))))})
		      end)
	 in
	    {mkReader = mkReader,
	     mkWriter = mkWriter,
	     readArr = readArr,
	     readVec = readVec,
	     writeArr = writeArr,
	     writeVec = writeVec}
	 end)
val {mkReader = mkTextReader: {fd: int32, initBlkMode: bool, name: string}
			      -> PrimIO.reader,
     mkWriter = mkTextWriter: {appendMode: bool,
			       chunkSize: int32,
			       fd: int32,
			       initBlkMode: bool,
			       name: string}
			      -> PrimIO.writer} =
   (make (char8,
	  char8,
	  PrimIO.reader,
	  unit -> bool,
	  unit -> unit,
	  string,
	  string,
	  PrimIO.writer,
	  char8 PrimSequence.Slice.t,
	  char8 PrimSequence.Slice.t,
	  unit -> bool,
	  unit -> unit,
	  int32,
	  string) {RD = RD,
		   WR = WR,
		   fromVector = (fn x_1648: string =>
				 case x_1648 of
				   v: string => v),
		   readArr = readChar8,
		   setMode = settext,
		   toArraySlice = toPoly_1,
		   toVectorSlice = toPoly_0,
		   vectorLength = length_14,
		   writeArr = writeChar8Arr,
		   writeVec = writeChar8Vec})
datatype PosixProcess.waitpid_arg = W_ANY_CHILD
				    | W_CHILD of int32
				    | W_SAME_GROUP
				    | W_GROUP of int32
datatype PosixProcess.exit_status = W_EXITED
				    | W_EXITSTATUS of word8
				    | W_SIGNALED of int32
				    | W_STOPPED of int32
datatype PosixProcess.killpid_arg = K_PROC of int32
				    | K_SAME_GROUP
				    | K_GROUP of int32
datatype StreamIOExtra.buf = Buf of {array: word8 array, size: int32 ref}
datatype StreamIOExtra.bufferMode = NO_BUF
				    | LINE_BUF of StreamIOExtra.buf
				    | BLOCK_BUF of StreamIOExtra.buf
datatype StreamIOExtra.state = Active
			       | Terminated
			       | Closed
datatype StreamIOExtra.outstream = Out of {augmented_writer: PrimIO.writer,
					   bufferMode: StreamIOExtra.bufferMode ref,
					   state: StreamIOExtra.state ref,
					   writer: PrimIO.writer}
datatype StreamIOExtra.out_pos = OutPos of {outstream: StreamIOExtra.outstream,
					    pos: int64}
datatype StreamIOExtra.state = Link of {buf: StreamIOExtra.buf}
			       | Eos of {buf: StreamIOExtra.buf}
			       | End
			       | Truncated
			       | Closed
	 StreamIOExtra.buf = Buf of {base: int64 Primitive.Option.t,
				     inp: word8 vector,
				     next: StreamIOExtra.state ref}
datatype StreamIOExtra.instream = In of {buf: StreamIOExtra.buf,
					 common: {augmented_reader: PrimIO.reader,
						  reader: PrimIO.reader,
						  tail: StreamIOExtra.state ref ref},
					 pos: int32}
datatype StreamIOExtra.Close.t = T of {close: unit -> unit,
				       name: string,
				       tail: StreamIOExtra.state ref ref}
datatype ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
datatype ImperativeIOExtra.state = Closed
				   | Open of {eos: bool}
				   | Stream of StreamIOExtra.instream
datatype ImperativeIOExtra.instream = In of {augmentedReader: PrimIO.reader,
					     buf: word8 array,
					     first: int32 ref,
					     last: int32 ref,
					     reader: PrimIO.reader,
					     state: ImperativeIOExtra.state ref}
val chunkSize: int32 = (toInt bufSize)
val line: {isLine: char8 -> bool, lineElem: char8} Primitive.Option.t =
   (SOME[{isLine: char8 -> bool, lineElem: char8}] {isLine = (fn x_1649: char8 =>
							      case x_1649 of
								c: char8 =>
								(= (char8) (c,
									    0xA))),
						    lineElem = 0xA})
val mkWriter: {appendMode: bool,
	       chunkSize: int32,
	       fd: int32,
	       initBlkMode: bool,
	       name: string}
	      -> PrimIO.writer =
   mkTextWriter
val someElem: char8 = 0x0
val rec 'a_3950
   liftExn: string -> string -> exn -> 'a_3950 = 
      (fn x_1650: string =>
       (fn x_1651: string =>
	(fn x_1652: exn =>
	 case (x_1650, x_1651, x_1652) of
	   (name: string, function: string, cause: exn) =>
	   raise (Io {name = name, function = function, cause = cause}))))
datatype StreamIOExtra.buf = Buf of {array: char8 array, size: int32 ref}
datatype StreamIOExtra.bufferMode = NO_BUF
				    | LINE_BUF of StreamIOExtra.buf
				    | BLOCK_BUF of StreamIOExtra.buf
val rec
   newLineBuf: int32 -> StreamIOExtra.bufferMode = 
      (fn x_1653: int32 =>
       case x_1653 of
	 (bufSize: int32) =>
	 (LINE_BUF (Buf {size = (ref[int32] 0x0),
			 array = (array_1 (bufSize, someElem))})))
val rec
   newBlockBuf: int32 -> StreamIOExtra.bufferMode = 
      (fn x_1654: int32 =>
       case x_1654 of
	 (bufSize: int32) =>
	 (BLOCK_BUF (Buf {size = (ref[int32] 0x0),
			  array = (array_1 (bufSize, someElem))})))
datatype StreamIOExtra.state = Active
			       | Terminated
			       | Closed
val rec
   active: StreamIOExtra.state -> bool = 
      (fn x_1655: StreamIOExtra.state =>
       case x_1655 of
	 (state: StreamIOExtra.state) =>
	 case state of
	   Active => true | _ => false)
val rec
   terminated: StreamIOExtra.state -> bool = 
      (fn x_1656: StreamIOExtra.state =>
       case x_1656 of
	 (state: StreamIOExtra.state) => (not (active state)))
val rec
   closed: StreamIOExtra.state -> bool = 
      (fn x_1657: StreamIOExtra.state =>
       case x_1657 of
	 (state: StreamIOExtra.state) =>
	 case state of
	   Closed => true | _ => false)
datatype StreamIOExtra.outstream = Out of {augmented_writer: PrimIO.writer,
					   bufferMode: StreamIOExtra.bufferMode ref,
					   state: StreamIOExtra.state ref,
					   writer: PrimIO.writer}
val rec 'a_3951
   outstreamSel: StreamIOExtra.outstream
		 * ({augmented_writer: PrimIO.writer,
		     bufferMode: StreamIOExtra.bufferMode ref,
		     state: StreamIOExtra.state ref,
		     writer: PrimIO.writer}
		    -> 'a_3951)
		 -> 'a_3951 = 
      (fn x_1658: StreamIOExtra.outstream
		  * ({augmented_writer: PrimIO.writer,
		      bufferMode: StreamIOExtra.bufferMode ref,
		      state: StreamIOExtra.state ref,
		      writer: PrimIO.writer}
		     -> 'a_3951) =>
       case x_1658 of
	 ((Out v: {augmented_writer: PrimIO.writer,
		   bufferMode: StreamIOExtra.bufferMode ref,
		   state: StreamIOExtra.state ref,
		   writer: PrimIO.writer},
	   sel: {augmented_writer: PrimIO.writer,
		 bufferMode: StreamIOExtra.bufferMode ref,
		 state: StreamIOExtra.state ref,
		 writer: PrimIO.writer}
		-> 'a_3951)) =>
	 (sel v))
val rec
   outstreamWriter: StreamIOExtra.outstream -> PrimIO.writer = 
      (fn x_1659: StreamIOExtra.outstream =>
       case x_1659 of
	 (os: StreamIOExtra.outstream) =>
	 (outstreamSel (PrimIO.writer) (os,
					(fn x_1660: {augmented_writer: PrimIO.writer,
						     bufferMode: StreamIOExtra.bufferMode ref,
						     state: StreamIOExtra.state ref,
						     writer: PrimIO.writer} =>
					 case x_1660 of
					   {writer = #: PrimIO.writer} => #))))
val rec 'a_3952
   writerSel: PrimIO.writer
	      * ({block: (unit -> unit) Primitive.Option.t,
		  canOutput: (unit -> bool) Primitive.Option.t,
		  chunkSize: int32,
		  close: unit -> unit,
		  endPos: (unit -> int64) Primitive.Option.t,
		  getPos: (unit -> int64) Primitive.Option.t,
		  ioDesc: int32 Primitive.Option.t,
		  name: string,
		  setPos: (int64 -> unit) Primitive.Option.t,
		  verifyPos: (unit -> int64) Primitive.Option.t,
		  writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		  writeArrNB: (char8 PrimSequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t,
		  writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		  writeVecNB: (char8 PrimSequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t}
		 -> 'a_3952)
	      -> 'a_3952 = 
      (fn x_1661: PrimIO.writer
		  * ({block: (unit -> unit) Primitive.Option.t,
		      canOutput: (unit -> bool) Primitive.Option.t,
		      chunkSize: int32,
		      close: unit -> unit,
		      endPos: (unit -> int64) Primitive.Option.t,
		      getPos: (unit -> int64) Primitive.Option.t,
		      ioDesc: int32 Primitive.Option.t,
		      name: string,
		      setPos: (int64 -> unit) Primitive.Option.t,
		      verifyPos: (unit -> int64) Primitive.Option.t,
		      writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		      writeArrNB: (char8 PrimSequence.Slice.t
				   -> int32 Primitive.Option.t) Primitive.Option.t,
		      writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		      writeVecNB: (char8 PrimSequence.Slice.t
				   -> int32 Primitive.Option.t) Primitive.Option.t}
		     -> 'a_3952) =>
       case x_1661 of
	 ((WR v: {block: (unit -> unit) Primitive.Option.t,
		  canOutput: (unit -> bool) Primitive.Option.t,
		  chunkSize: int32,
		  close: unit -> unit,
		  endPos: (unit -> int64) Primitive.Option.t,
		  getPos: (unit -> int64) Primitive.Option.t,
		  ioDesc: int32 Primitive.Option.t,
		  name: string,
		  setPos: (int64 -> unit) Primitive.Option.t,
		  verifyPos: (unit -> int64) Primitive.Option.t,
		  writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		  writeArrNB: (char8 PrimSequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t,
		  writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		  writeVecNB: (char8 PrimSequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t},
	   sel: {block: (unit -> unit) Primitive.Option.t,
		 canOutput: (unit -> bool) Primitive.Option.t,
		 chunkSize: int32,
		 close: unit -> unit,
		 endPos: (unit -> int64) Primitive.Option.t,
		 getPos: (unit -> int64) Primitive.Option.t,
		 ioDesc: int32 Primitive.Option.t,
		 name: string,
		 setPos: (int64 -> unit) Primitive.Option.t,
		 verifyPos: (unit -> int64) Primitive.Option.t,
		 writeArr: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		 writeArrNB: (char8 PrimSequence.Slice.t
			      -> int32 Primitive.Option.t) Primitive.Option.t,
		 writeVec: (char8 PrimSequence.Slice.t -> int32) Primitive.Option.t,
		 writeVecNB: (char8 PrimSequence.Slice.t
			      -> int32 Primitive.Option.t) Primitive.Option.t}
		-> 'a_3952)) =>
	 (sel v))
val rec
   outstreamName: StreamIOExtra.outstream -> string = 
      (fn x_1662: StreamIOExtra.outstream =>
       case x_1662 of
	 (os: StreamIOExtra.outstream) =>
	 (writerSel (string) ((outstreamWriter os),
			      (fn x_1663: {block: (unit -> unit) Primitive.Option.t,
					   canOutput: (unit -> bool) Primitive.Option.t,
					   chunkSize: int32,
					   close: unit -> unit,
					   endPos: (unit -> int64) Primitive.Option.t,
					   getPos: (unit -> int64) Primitive.Option.t,
					   ioDesc: int32 Primitive.Option.t,
					   name: string,
					   setPos: (int64 -> unit) Primitive.Option.t,
					   verifyPos: (unit -> int64) Primitive.Option.t,
					   writeArr: (char8 PrimSequence.Slice.t
						      -> int32) Primitive.Option.t,
					   writeArrNB: (char8 PrimSequence.Slice.t
							-> int32 Primitive.Option.t) Primitive.Option.t,
					   writeVec: (char8 PrimSequence.Slice.t
						      -> int32) Primitive.Option.t,
					   writeVecNB: (char8 PrimSequence.Slice.t
							-> int32 Primitive.Option.t) Primitive.Option.t} =>
			       case x_1663 of
				 {name = #: string} => #))))
val rec ('b, 'a)
   flushGen: ('a -> int32)
	     * ('a -> 'b * int32 * int32)
	     * ('b * int32 * int32 Primitive.Option.t -> 'a)
	     * 'a
	     -> unit = 
      (fn x_1664: ('a -> int32)
		  * ('a -> 'b * int32 * int32)
		  * ('b * int32 * int32 Primitive.Option.t -> 'a)
		  * 'a =>
       case x_1664 of
	 ((write: 'a -> int32,
	   base: 'a -> 'b * int32 * int32,
	   slice: 'b * int32 * int32 Primitive.Option.t -> 'a,
	   a: 'a)) =>
	 let val (b: 'b, i: int32, sz: int32) = (base a)
	     val max: int32 = (+ (i, sz))
	     val rec
		loop: int32 -> unit = 
		   (fn x_1665: int32 =>
		    case x_1665 of
		      (i: int32) =>
		      case (= (int32) (i, max)) of
			true => ()
		      | false =>
			let val j: int32 =
			       (write (slice (b, i, (SOME[int32] (- (max, i))))))
			in
			   case (= (int32) (j, 0x0)) of
			     true => raise (Fail "partial write")
			   | false => (loop (+ (i, j)))
			end)
	 in
	    (loop i)
	 end)
val rec
   flushVec: PrimIO.writer * char8 PrimSequence.Slice.t -> unit = 
      (fn x_1666: PrimIO.writer * char8 PrimSequence.Slice.t =>
       case x_1666 of
	 ((writer: PrimIO.writer, x: char8 PrimSequence.Slice.t)) =>
	 case (writerSel ((char8 PrimSequence.Slice.t -> int32) Primitive.Option.t) (writer,
										     (fn x_1667: {block: (unit
													  -> unit) Primitive.Option.t,
												  canOutput: (unit
													      -> bool) Primitive.Option.t,
												  chunkSize: int32,
												  close: unit
													 -> unit,
												  endPos: (unit
													   -> int64) Primitive.Option.t,
												  getPos: (unit
													   -> int64) Primitive.Option.t,
												  ioDesc: int32 Primitive.Option.t,
												  name: string,
												  setPos: (int64
													   -> unit) Primitive.Option.t,
												  verifyPos: (unit
													      -> int64) Primitive.Option.t,
												  writeArr: (char8 PrimSequence.Slice.t
													     -> int32) Primitive.Option.t,
												  writeArrNB: (char8 PrimSequence.Slice.t
													       -> int32 Primitive.Option.t) Primitive.Option.t,
												  writeVec: (char8 PrimSequence.Slice.t
													     -> int32) Primitive.Option.t,
												  writeVecNB: (char8 PrimSequence.Slice.t
													       -> int32 Primitive.Option.t) Primitive.Option.t} =>
										      case x_1667 of
											{writeVec = #: (char8 PrimSequence.Slice.t
													-> int32) Primitive.Option.t} =>
											#))) of
	   NONE[char8 PrimSequence.Slice.t -> int32] =>
	   raise BlockingNotSupported
	 | SOME[char8 PrimSequence.Slice.t -> int32] writeVec: char8 PrimSequence.Slice.t
							       -> int32 =>
	   (flushGen (string, char8 PrimSequence.Slice.t) (writeVec,
							   base_10,
							   slice_6,
							   x)))
val rec
   flushArr: PrimIO.writer * char8 PrimSequence.Slice.t -> unit = 
      (fn x_1668: PrimIO.writer * char8 PrimSequence.Slice.t =>
       case x_1668 of
	 ((writer: PrimIO.writer, x: char8 PrimSequence.Slice.t)) =>
	 case (writerSel ((char8 PrimSequence.Slice.t -> int32) Primitive.Option.t) (writer,
										     (fn x_1669: {block: (unit
													  -> unit) Primitive.Option.t,
												  canOutput: (unit
													      -> bool) Primitive.Option.t,
												  chunkSize: int32,
												  close: unit
													 -> unit,
												  endPos: (unit
													   -> int64) Primitive.Option.t,
												  getPos: (unit
													   -> int64) Primitive.Option.t,
												  ioDesc: int32 Primitive.Option.t,
												  name: string,
												  setPos: (int64
													   -> unit) Primitive.Option.t,
												  verifyPos: (unit
													      -> int64) Primitive.Option.t,
												  writeArr: (char8 PrimSequence.Slice.t
													     -> int32) Primitive.Option.t,
												  writeArrNB: (char8 PrimSequence.Slice.t
													       -> int32 Primitive.Option.t) Primitive.Option.t,
												  writeVec: (char8 PrimSequence.Slice.t
													     -> int32) Primitive.Option.t,
												  writeVecNB: (char8 PrimSequence.Slice.t
													       -> int32 Primitive.Option.t) Primitive.Option.t} =>
										      case x_1669 of
											{writeArr = #: (char8 PrimSequence.Slice.t
													-> int32) Primitive.Option.t} =>
											#))) of
	   NONE[char8 PrimSequence.Slice.t -> int32] =>
	   raise BlockingNotSupported
	 | SOME[char8 PrimSequence.Slice.t -> int32] writeArr: char8 PrimSequence.Slice.t
							       -> int32 =>
	   (flushGen (char8 array, char8 PrimSequence.Slice.t) (writeArr,
								base_11,
								slice_7,
								x)))
val rec
   flushBuf': PrimIO.writer * int32 ref * char8 array -> unit = 
      (fn x_1670: PrimIO.writer * int32 ref * char8 array =>
       case x_1670 of
	 ((writer: PrimIO.writer, size: int32 ref, array: char8 array)) =>
	 let val size': int32 = (!_1 (int32) size)
	 in
	    (:=_1 (int32) (size, 0x0))
	    ;(flushArr (writer, (slice_7 (array, 0x0, (SOME[int32] size')))))
	 end)
val rec
   flushBuf: PrimIO.writer * StreamIOExtra.buf -> unit = 
      (fn x_1671: PrimIO.writer * StreamIOExtra.buf =>
       case x_1671 of
	 ((writer: PrimIO.writer,
	   Buf {size = size: int32 ref, array = array: char8 array})) =>
	 (flushBuf' (writer, size, array)))
val rec
   output: StreamIOExtra.outstream * string -> unit = 
      (fn x_1672: StreamIOExtra.outstream * string =>
       case x_1672 of
	 ((os: StreamIOExtra.outstream as Out {augmented_writer = augmented_writer: PrimIO.writer,
					       state = state: StreamIOExtra.state ref,
					       bufferMode = bufferMode: StreamIOExtra.bufferMode ref},
	   v: string)) =>
	 case (terminated (!_1 (StreamIOExtra.state) state)) of
	   true => (((liftExn (unit) (outstreamName os)) "output") ClosedStream)
	 | false =>
	   let val rec
		  put: unit -> unit = 
		     (fn x_1675: unit =>
		      case x_1675 of
			(()) => (flushVec (augmented_writer, (full_8 v))))
	       val rec
		  doit: StreamIOExtra.buf * (unit -> bool) -> unit = 
		     (fn x_1674: StreamIOExtra.buf * (unit -> bool) =>
		      case x_1674 of
			((buf: StreamIOExtra.buf as Buf {size = size: int32 ref,
							 array = array: char8 array},
			  maybe: unit -> bool)) =>
			let val curSize: int32 = (!_1 (int32) size)
			    val newSize: int32 = (+ (curSize, (length_14 v)))
			in
			   case case (>= (newSize, (length_16 array))) of
				  true => true | false => (maybe ()) of
			     true =>
			     (flushBuf (augmented_writer, buf)) ;(put ())
			   | false =>
			     (copyVec_1 {src = v, dst = array, di = curSize})
			     ;(:=_1 (int32) (size, newSize))
			end)
	   in
	      case (!_1 (StreamIOExtra.bufferMode) bufferMode) of
		NO_BUF => (put ())
	      | LINE_BUF buf: StreamIOExtra.buf =>
		(doit (buf,
		       (fn x_1676: unit =>
			case x_1676 of
			  () =>
			  case line of
			    NONE[{isLine: char8 -> bool, lineElem: char8}] =>
			    false
			  | SOME[{isLine: char8 -> bool, lineElem: char8}] {isLine = isLine: char8
											     -> bool,
									    lineElem = lineElem: char8} =>
			    ((exists_4 isLine) v))))
	      | BLOCK_BUF buf: StreamIOExtra.buf =>
		(doit (buf, (fn x_1677: unit => case x_1677 of () => false)))
	   end
	   handle x_1673 => case x_1673 of
			      exn: exn =>
			      (((liftExn (unit) (outstreamName os)) "output") exn))
val rec
   flushOut: StreamIOExtra.outstream -> unit = 
      (fn x_1678: StreamIOExtra.outstream =>
       case x_1678 of
	 (os: StreamIOExtra.outstream as Out {augmented_writer = augmented_writer: PrimIO.writer,
					      state = state: StreamIOExtra.state ref,
					      bufferMode = bufferMode: StreamIOExtra.bufferMode ref}) =>
	 case (terminated (!_1 (StreamIOExtra.state) state)) of
	   true => ()
	 | false =>
	   case (!_1 (StreamIOExtra.bufferMode) bufferMode) of
	     NO_BUF => ()
	   | LINE_BUF buf: StreamIOExtra.buf =>
	     (flushBuf (augmented_writer, buf))
	   | BLOCK_BUF buf: StreamIOExtra.buf =>
	     (flushBuf (augmented_writer, buf))
	     handle x_1679 => case x_1679 of
				exn: exn =>
				(((liftExn (unit) (outstreamName os)) "flushOut") exn))
val rec
   makeTerminated: StreamIOExtra.outstream -> unit = 
      (fn x_1680: StreamIOExtra.outstream =>
       case x_1680 of
	 (Out {bufferMode = bufferMode: StreamIOExtra.bufferMode ref}) =>
	 let val rec
		doit: StreamIOExtra.buf -> unit = 
		   (fn x_1681: StreamIOExtra.buf =>
		    case x_1681 of
		      (Buf {array = array: char8 array, size = size: int32 ref}) =>
		      (:=_1 (int32) (size, (length_16 array))))
	 in
	    case (!_1 (StreamIOExtra.bufferMode) bufferMode) of
	      BLOCK_BUF b: StreamIOExtra.buf => (doit b)
	    | LINE_BUF b: StreamIOExtra.buf => (doit b) | NO_BUF => ()
	 end)
val rec
   closeOut: StreamIOExtra.outstream -> unit = 
      (fn x_1682: StreamIOExtra.outstream =>
       case x_1682 of
	 (os: StreamIOExtra.outstream as Out {state = state: StreamIOExtra.state ref}) =>
	 case (closed (!_1 (StreamIOExtra.state) state)) of
	   true => ()
	 | false =>
	   (flushOut os)
	   ;case (terminated (!_1 (StreamIOExtra.state) state)) of
	      true => ()
	    | false =>
	      ((writerSel (unit -> unit) ((outstreamWriter os),
					  (fn x_1684: {block: (unit -> unit) Primitive.Option.t,
						       canOutput: (unit -> bool) Primitive.Option.t,
						       chunkSize: int32,
						       close: unit -> unit,
						       endPos: (unit -> int64) Primitive.Option.t,
						       getPos: (unit -> int64) Primitive.Option.t,
						       ioDesc: int32 Primitive.Option.t,
						       name: string,
						       setPos: (int64 -> unit) Primitive.Option.t,
						       verifyPos: (unit -> int64) Primitive.Option.t,
						       writeArr: (char8 PrimSequence.Slice.t
								  -> int32) Primitive.Option.t,
						       writeArrNB: (char8 PrimSequence.Slice.t
								    -> int32 Primitive.Option.t) Primitive.Option.t,
						       writeVec: (char8 PrimSequence.Slice.t
								  -> int32) Primitive.Option.t,
						       writeVecNB: (char8 PrimSequence.Slice.t
								    -> int32 Primitive.Option.t) Primitive.Option.t} =>
					   case x_1684 of
					     {close = #: unit -> unit} => #))) ())
	   ;(:=_1 (StreamIOExtra.state) (state, Closed))
	   ;(makeTerminated os)
	   handle x_1683 => case x_1683 of
			      exn: exn =>
			      (((liftExn (unit) (outstreamName os)) "closeOut") exn))
val rec
   mkOutstream': {bufferMode: IO.buffer_mode,
		  closed: bool,
		  writer: PrimIO.writer}
		 -> StreamIOExtra.outstream = 
      (fn x_1685: {bufferMode: IO.buffer_mode,
		   closed: bool,
		   writer: PrimIO.writer} =>
       case x_1685 of
	 ({writer = writer: PrimIO.writer,
	   closed = closed: bool,
	   bufferMode = bufferMode: IO.buffer_mode}) =>
	 let val bufSize: int32 =
		(writerSel (int32) (writer,
				    (fn x_1686: {block: (unit -> unit) Primitive.Option.t,
						 canOutput: (unit -> bool) Primitive.Option.t,
						 chunkSize: int32,
						 close: unit -> unit,
						 endPos: (unit -> int64) Primitive.Option.t,
						 getPos: (unit -> int64) Primitive.Option.t,
						 ioDesc: int32 Primitive.Option.t,
						 name: string,
						 setPos: (int64 -> unit) Primitive.Option.t,
						 verifyPos: (unit -> int64) Primitive.Option.t,
						 writeArr: (char8 PrimSequence.Slice.t
							    -> int32) Primitive.Option.t,
						 writeArrNB: (char8 PrimSequence.Slice.t
							      -> int32 Primitive.Option.t) Primitive.Option.t,
						 writeVec: (char8 PrimSequence.Slice.t
							    -> int32) Primitive.Option.t,
						 writeVecNB: (char8 PrimSequence.Slice.t
							      -> int32 Primitive.Option.t) Primitive.Option.t} =>
				     case x_1686 of
				       {chunkSize = #: int32} => #)))
	 in
	    (Out {writer = writer,
		  augmented_writer = (augmentWriter writer),
		  state = (ref[StreamIOExtra.state] case closed of
						      true => Closed
						    | false => Active),
		  bufferMode = (ref[StreamIOExtra.bufferMode] case bufferMode of
								NO_BUF => NO_BUF
							      | LINE_BUF =>
								(newLineBuf bufSize)
							      | BLOCK_BUF =>
								(newBlockBuf bufSize))})
	 end)
datatype StreamIOExtra.out_pos = OutPos of {outstream: StreamIOExtra.outstream,
					    pos: int64}
datatype StreamIOExtra.state = Link of {buf: StreamIOExtra.buf}
			       | Eos of {buf: StreamIOExtra.buf}
			       | End
			       | Truncated
			       | Closed
	 StreamIOExtra.buf = Buf of {base: int64 Primitive.Option.t,
				     inp: string,
				     next: StreamIOExtra.state ref}
datatype StreamIOExtra.instream = In of {buf: StreamIOExtra.buf,
					 common: {augmented_reader: PrimIO.reader,
						  reader: PrimIO.reader,
						  tail: StreamIOExtra.state ref ref},
					 pos: int32}
datatype StreamIOExtra.Close.t = T of {close: unit -> unit,
				       name: string,
				       tail: StreamIOExtra.state ref ref}
val openOutstreams: (StreamIOExtra.outstream * {close: bool}) list ref =
   (ref[(StreamIOExtra.outstream * {close: bool}) list] [])
val mkOutstream'': {bufferMode: IO.buffer_mode,
		    closeAtExit: bool,
		    closed: bool,
		    writer: PrimIO.writer}
		   -> StreamIOExtra.outstream =
   let val _ =
	  (addNew_0 (atExit,
		     (fn x_1687: unit =>
		      case x_1687 of
			() =>
			((app_0 (StreamIOExtra.outstream * {close: bool}) (fn x_1688: StreamIOExtra.outstream
										      * {close: bool} =>
									   case x_1688 of
									     (os: StreamIOExtra.outstream,
									      {close = close: bool}) =>
									     case close of
									       true =>
									       (closeOut os)
									     | false =>
									       (flushOut os))) (!_1 ((StreamIOExtra.outstream
												      * {close: bool}) list) openOutstreams)))))
   in
      (fn x_1689: {bufferMode: IO.buffer_mode,
		   closeAtExit: bool,
		   closed: bool,
		   writer: PrimIO.writer} =>
       case x_1689 of
	 {bufferMode = bufferMode: IO.buffer_mode,
	  closeAtExit = closeAtExit: bool,
	  closed = closed: bool,
	  writer = writer: PrimIO.writer} =>
	 let val os: StreamIOExtra.outstream =
		(mkOutstream' {bufferMode = bufferMode,
			       closed = closed,
			       writer = writer})
	     val _ =
		case closed of
		  true => ()
		| false =>
		  (:=_1 ((StreamIOExtra.outstream * {close: bool}) list) (openOutstreams,
									  (::[StreamIOExtra.outstream
									      * {close: bool}] ((os,
												 {close = closeAtExit}),
												(!_1 ((StreamIOExtra.outstream
												       * {close: bool}) list) openOutstreams)))))
	 in
	    os
	 end)
   end
datatype ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
val rec
   get: ImperativeIOExtra.Outstream.t -> StreamIOExtra.outstream = 
      (fn x_1690: ImperativeIOExtra.Outstream.t =>
       case x_1690 of
	 (T r: StreamIOExtra.outstream ref) => (!_1 (StreamIOExtra.outstream) r))
val rec
   make: StreamIOExtra.outstream -> ImperativeIOExtra.Outstream.t = 
      (fn x_1691: StreamIOExtra.outstream =>
       case x_1691 of
	 (s: StreamIOExtra.outstream) => (T (ref[StreamIOExtra.outstream] s)))
val rec
   output: ImperativeIOExtra.Outstream.t * string -> unit = 
      (fn x_1692: ImperativeIOExtra.Outstream.t * string =>
       case x_1692 of
	 ((os: ImperativeIOExtra.Outstream.t, v: string)) =>
	 (output ((get os), v)))
val rec
   flushOut: ImperativeIOExtra.Outstream.t -> unit = 
      (fn x_1693: ImperativeIOExtra.Outstream.t =>
       case x_1693 of
	 (os: ImperativeIOExtra.Outstream.t) => (flushOut (get os)))
val mkOutstream: StreamIOExtra.outstream -> ImperativeIOExtra.Outstream.t = make
val rec
   newOut: {appendMode: bool,
	    bufferMode: IO.buffer_mode,
	    closeAtExit: bool,
	    fd: int32,
	    name: string}
	   -> ImperativeIOExtra.Outstream.t = 
      (fn x_1694: {appendMode: bool,
		   bufferMode: IO.buffer_mode,
		   closeAtExit: bool,
		   fd: int32,
		   name: string} =>
       case x_1694 of
	 ({appendMode = appendMode: bool,
	   bufferMode = bufferMode: IO.buffer_mode,
	   closeAtExit = closeAtExit: bool,
	   fd = fd: int32,
	   name = name: string}) =>
	 let val writer: PrimIO.writer =
		(mkWriter {appendMode = appendMode,
			   chunkSize = chunkSize,
			   fd = fd,
			   initBlkMode = true,
			   name = name})
	     val outstream: StreamIOExtra.outstream =
		(mkOutstream'' {bufferMode = bufferMode,
				closeAtExit = closeAtExit,
				closed = false,
				writer = writer})
	 in
	    (mkOutstream outstream)
	 end)
val stdErr: ImperativeIOExtra.Outstream.t =
   (newOut {appendMode = true,
	    bufferMode = NO_BUF,
	    closeAtExit = false,
	    fd = stderr,
	    name = "<stderr>"})
val newOut: {appendMode: bool, closeAtExit: bool, fd: int32, name: string}
	    -> ImperativeIOExtra.Outstream.t =
   (fn x_1695: {appendMode: bool, closeAtExit: bool, fd: int32, name: string} =>
    case x_1695 of
      {appendMode = appendMode: bool,
       closeAtExit = closeAtExit: bool,
       fd = fd: int32,
       name = name: string} =>
      (newOut {appendMode = appendMode,
	       bufferMode = case (isatty fd) of
			      true => LINE_BUF | false => BLOCK_BUF,
	       closeAtExit = closeAtExit,
	       fd = fd,
	       name = name}))
val stdOut: ImperativeIOExtra.Outstream.t =
   (newOut {appendMode = true,
	    closeAtExit = false,
	    fd = stdout,
	    name = "<stdout>"})
datatype ImperativeIOExtra.state = Closed
				   | Open of {eos: bool}
				   | Stream of StreamIOExtra.instream
datatype ImperativeIOExtra.instream = In of {augmentedReader: PrimIO.reader,
					     buf: char8 array,
					     first: int32 ref,
					     last: int32 ref,
					     reader: PrimIO.reader,
					     state: ImperativeIOExtra.state ref}
val rec
   print: string -> unit = 
      (fn x_1696: string =>
       case x_1696 of
	 (s: string) => (output (stdOut, s)) ;(flushOut stdOut))
exception Path
exception InvalidArc
datatype OS_FileSys.file_id = FID of {dev: word64, ino: word64}
exception Sqrt
exception Ln
exception Ord
exception Io of string
exception Interrupt
val rec ('a_3966, 'a_3965)
   wrap: ('a_3966 * int64 -> 'a_3965) -> 'a_3966 * int32 -> 'a_3965 = 
      (fn x_1697: 'a_3966 * int64 -> 'a_3965 =>
       (fn x_1698: 'a_3966 * int32 =>
	case (x_1697, x_1698) of
	  (f: 'a_3966 * int64 -> 'a_3965, (p: 'a_3966, i: int32)) =>
	  (f (p, (fromInt i)))))
val getCPointer: cpointer * int32 -> cpointer =
   (wrap (cpointer, cpointer) getCPointer)
val getInt32: cpointer * int32 -> int32 = (wrap (cpointer, int32) getInt32)
val getWord32: cpointer * int32 -> word32 = (wrap (cpointer, word32) getWord32)
val getPointer: cpointer * int32 -> cpointer = getCPointer
val gcState: cpointer = gcState
val current: unit -> Primitive.MLton.CallStack.t =
   (fn x_1699: unit =>
    case x_1699 of
      () =>
      case (not keep) of
	true => (T (array_0 (word32) (0x0, 0x0)))
      | false =>
	let val a: word32 array =
	       (arrayUninit_0 (word32) (toInt (numStackFrames gcState)))
	    val () = (callStack (gcState, a))
	in
	   (T a)
	end)
val toStrings: Primitive.MLton.CallStack.t -> string list =
   (fn x_1700: Primitive.MLton.CallStack.t =>
    case x_1700 of
      T a: word32 array =>
      case (not keep) of
	true => []
      | false =>
	let val skip: int32 = (- ((length_13 (word32) a), 0x1))
	in
	   (((foldri_3 (string list, word32) (fn x_1701: int32
							 * word32
							 * string list =>
					      case x_1701 of
						(i: int32,
						 frameIndex: word32,
						 ac: string list) =>
						case (>= (i, skip)) of
						  true => ac
						| false =>
						  let val p: cpointer =
							 (frameIndexSourceSeq (gcState,
									       frameIndex))
						      val max: int32 =
							 (toInt (getInt32 (p,
									   0x0)))
						      val rec
							 loop: int32
							       * string list
							       -> string list = 
							    (fn x_1702: int32
									* string list =>
							     case x_1702 of
							       ((j: int32,
								 ac: string list)) =>
							       case (> (j, max)) of
								 true => ac
							       | false =>
								 (loop ((+ (j,
									    0x1)),
									(::[string] ((toString (sourceName (gcState,
													    (getWord32 (p,
															j))))),
										     ac)))))
						  in
						     (loop (0x1, ac))
						  end)) []) a)
	end)
val fromInt: int32 -> int32 = (o_1 (int32, int32, int32) (fromRep, fromInt))
val toInt: int32 -> int32 = (o_1 (int32, int32, int32) (toInt, toRep))
val failure: int32 = (fromInt 0x1)
val success: int32 = (fromInt 0x0)
val exiting: bool ref = (ref[bool] false)
val rec
   halt: int32 -> unit = 
      (fn x_1703: int32 =>
       case x_1703 of
	 (status: int32) => (halt (toRep status)))
val rec 'a
   exit: int32 -> 'a = 
      (fn x_1704: int32 =>
       case x_1704 of
	 (status: int32) =>
	 case (!_1 (bool) exiting) of
	   true => raise (Fail "MLton.Exit.exit")
	 | false =>
	   let val _ = (:=_1 (bool) (exiting, true))
	       val i: int32 = (toInt status)
	   in
	      case case (<= (0x0, i)) of
		     true => (< (i, 0x100)) | false => false of
		true =>
		let 
		in
		   (clean atExit)
		end
		;(halt status)
		;raise (Fail "MLton.Exit.exit")
	      | false =>
		raise (Fail (concat_2 ["MLton.Exit.exit(",
				       (toString i),
				       "): ",
				       "exit must have 0 <= status < 256"]))
	   end)
val message: string -> unit = print
val rec 'a
   wrapSuffix: (unit -> unit) -> unit -> 'a = 
      (fn x_1705: unit -> unit =>
       (fn x_1706: unit =>
	case (x_1705, x_1706) of
	  (suffix: unit -> unit, ()) =>
	  (suffix ())
	  ;(message "Top-level suffix returned.\n")
	  ;(exit ('a) failure)
	  handle x_1707 => case x_1707 of
			     _ =>
			     (message "Top-level suffix raised exception.\n")
			     ;(halt failure)
			     ;raise (Fail "MLton.Exit.wrapSuffix")))
val rec
   suffixArchiveOrLibrary: unit -> unit = 
      (fn x_1708: unit =>
       case x_1708 of
	 (()) =>
	 let val () = (returnToC ())
	     val _ = (:=_1 (bool) (exiting, true))
	     val () = let  in (clean atExit) end
	     val () = (returnToC ())
	 in
	    ()
	 end)
val rec 'a_3972
   suffixExecutable: unit -> 'a_3972 = 
      (fn x_1709: unit =>
       case x_1709 of
	 (()) => (exit ('a_3972) success))
val defaultSuffix: unit -> unit =
   let 
   in
      case host of
	Archive => suffixArchiveOrLibrary
      | Executable => suffixExecutable (unit)
      | LibArchive => suffixArchiveOrLibrary
      | Library => suffixArchiveOrLibrary
   end
val rec 'a
   defaultTopLevelSuffix: unit -> 'a = 
      (fn x_1710: unit =>
       case x_1710 of
	 (()) => ((wrapSuffix ('a) defaultSuffix) ()))
val history: exn -> string list =
   case keepHistory of
     true =>
     (setExtendExtra (fn x_1711: Primitive.MLton.CallStack.t Primitive.Option.t =>
		      case x_1711 of
			e: Primitive.MLton.CallStack.t Primitive.Option.t =>
			case e of
			  NONE[Primitive.MLton.CallStack.t] =>
			  (SOME[Primitive.MLton.CallStack.t] (current ()))
			| SOME[Primitive.MLton.CallStack.t] _ => e))
     ;(fn x_1712: exn =>
       case x_1712 of
	 e: exn =>
	 case (extra e) of
	   NONE[Primitive.MLton.CallStack.t] => []
	 | SOME[Primitive.MLton.CallStack.t] cs: Primitive.MLton.CallStack.t =>
	   let val rec
		  loop: string list -> string list = 
		     (fn x_1713: string list =>
		      case x_1713 of
			(xs: string list) =>
			case xs of
			  [] => []
			| ::[string] (x: string, xs: string list) =>
			  case ((isPrefix "MLtonExn.fn ") x) of
			    true => xs | false => (loop xs))
	   in
	      (loop (toStrings cs))
	   end)
   | false => (fn x_1714: exn => case x_1714 of _ => [])
val message: string -> unit = print
val rec 'a
   wrapHandler: (exn -> unit) -> exn -> 'a = 
      (fn x_1715: exn -> unit =>
       (fn x_1716: exn =>
	case (x_1715, x_1716) of
	  (handler: exn -> unit, exn: exn) =>
	  (handler exn)
	  ;(message "Top-level handler returned.\n")
	  ;(exit ('a) failure)
	  handle x_1717 => case x_1717 of
			     _ =>
			     (message "Top-level handler raised exception.\n")
			     ;(halt failure)
			     ;raise (Fail "MLton.Exn.wrapHandler")))
val 'a_3973 defaultHandler: exn -> 'a_3973 =
   (fn x_1718: exn =>
    case x_1718 of
      exn: exn =>
      (message (concat_2 ["unhandled exception: ", (exnMessage exn), "\n"]))
      ;case (history exn) of
	 [] => ()
       | l: string list =>
	 (message "with history:\n")
	 ;((app_0 (string) (fn x_1719: string =>
			    case x_1719 of
			      s: string => (message (concat_2 ["\t", s, "\n"])))) l)
      ;(exit ('a_3973) failure))
val getTopLevelHandler: unit -> exn -> unit = getHandler
val rec 'a
   defaultTopLevelHandler: exn -> 'a = 
      (fn x_1720: exn =>
       case x_1720 of
	 (exn: exn) => ((wrapHandler ('a) defaultHandler (unit)) exn))
val rec 'a
   topLevelHandler: exn -> 'a = 
      (fn x_1721: exn =>
       case x_1721 of
	 (exn: exn) =>
	 ((getTopLevelHandler ()) exn) ;raise (Fail "MLton.Exn.topLevelHandler"))
val rec 'a
   die: string -> 'a = 
      (fn x_1722: string =>
       case x_1722 of
	 (s: string) =>
	 (print s) ;(exit 0x1) ;let exception DieFailed in raise DieFailed end)
val gcState: cpointer = gcState
datatype MLtonThread.AtomicState.t = NonAtomic
				     | Atomic of int32
val atomicBegin: unit -> unit = atomicBegin
val atomicEnd: unit -> unit = atomicEnd
datatype 'a MLtonThread.thread = Dead
				 | Interrupted of thread
				 | New of 'a -> unit
				 | Paused of ((unit -> 'a) -> unit) * thread
datatype 'a MLtonThread.t = T of 'a MLtonThread.thread ref
val rec ('b, 'a)
   prepend: 'a MLtonThread.t * ('b -> 'a) -> 'b MLtonThread.t = 
      (fn x_1723: 'a MLtonThread.t * ('b -> 'a) =>
       case x_1723 of
	 ((T['a] r: 'a MLtonThread.thread ref, f: 'b -> 'a)) =>
	 let val t: 'b MLtonThread.thread =
		case (!_1 ('a MLtonThread.thread) r) of
		  Dead['a] => raise (Fail "prepend to a Dead thread")
		| Interrupted['a] _ =>
		  raise (Fail "prepend to a Interrupted thread")
		| New['a] g: 'a -> unit => (New['b] (o_1 ('b, unit, 'a) (g, f)))
		| Paused['a] (g: (unit -> 'a) -> unit, t: thread) =>
		  (Paused['b] ((fn x_1724: unit -> 'b =>
				case x_1724 of
				  h: unit -> 'b =>
				  (g (o_1 (unit, 'a, 'b) (f, h)))),
			       t))
	 in
	    (:=_1 ('a MLtonThread.thread) (r, Dead['a]))
	    ;(T['b] (ref['b MLtonThread.thread] t))
	 end)
val rec 'a
   prepare: 'a MLtonThread.t * 'a -> unit MLtonThread.t = 
      (fn x_1725: 'a MLtonThread.t * 'a =>
       case x_1725 of
	 ((t: 'a MLtonThread.t, v: 'a)) =>
	 (prepend (unit, 'a) (t, (fn x_1726: unit => case x_1726 of () => v))))
val rec 'a_3975
   new: ('a_3975 -> unit) -> 'a_3975 MLtonThread.t = 
      (fn x_1727: 'a_3975 -> unit =>
       case x_1727 of
	 (f: 'a_3975 -> unit) =>
	 (T['a_3975] (ref['a_3975 MLtonThread.thread] (New['a_3975] f))))
val func: (unit -> unit) Primitive.Option.t ref =
   (ref[(unit -> unit) Primitive.Option.t] NONE[unit -> unit])
val base: thread =
   let val () = (copyCurrent ())
   in
      case (!_1 ((unit -> unit) Primitive.Option.t) func) of
	NONE[unit -> unit] => (savedPre gcState)
      | SOME[unit -> unit] x: unit -> unit =>
	let val () =
	       (:=_1 ((unit -> unit) Primitive.Option.t) (func,
							  NONE[unit -> unit]))
	    val () = (atomicEnd ())
	in
	   (x ())
	   handle x_1728 => case x_1728 of
			      e: exn => (topLevelHandler (unit) e)
	   ;(die (thread) "Thread didn't exit properly.\n")
	end
   end
val rec
   newThread: (unit -> unit) -> thread = 
      (fn x_1729: unit -> unit =>
       case x_1729 of
	 (f: unit -> unit) =>
	 let val () =
		(:=_1 ((unit -> unit) Primitive.Option.t) (func,
							   (SOME[unit -> unit] f)))
	 in
	    (copy base)
	 end)
val switching: bool ref = (ref[bool] false)
val rec 'a
   atomicSwitch: ('a MLtonThread.t -> unit MLtonThread.t) -> 'a = 
      (fn x_1730: 'a MLtonThread.t -> unit MLtonThread.t =>
       case x_1730 of
	 (f: 'a MLtonThread.t -> unit MLtonThread.t) =>
	 case (!_1 (bool) switching) of
	   true =>
	   let val () = (atomicEnd ())
	   in
	      raise (Fail "nested Thread.switch")
	   end
	 | false =>
	   let val _ = (:=_1 (bool) (switching, true))
	       val r: (unit -> 'a) ref =
		  (ref[unit -> 'a] (fn x_1735: unit =>
				    case x_1735 of
				      () =>
				      (die ('a) "Thread.atomicSwitch didn't set r.\n")))
	       val t: 'a MLtonThread.thread ref =
		  (ref['a MLtonThread.thread] (Paused['a] ((fn x_1734: unit
								       -> 'a =>
							    case x_1734 of
							      x: unit -> 'a =>
							      (:=_1 (unit -> 'a) (r,
										  x))),
							   (current gcState))))
	       val rec 'a_3976
		  fail: exn -> 'a_3976 = 
		     (fn x_1733: exn =>
		      case x_1733 of
			(e: exn) =>
			(:=_1 ('a MLtonThread.thread) (t, Dead['a]))
			;(:=_1 (bool) (switching, false))
			;(atomicEnd ())
			;raise e)
	       val T[unit] t': unit MLtonThread.thread ref =
		  (f (T['a] t))
		  handle x_1732 => case x_1732 of
				     e: exn => (fail (unit MLtonThread.t) e)
	       val primThread: thread =
		  case (before_1 (unit MLtonThread.thread) ((!_1 (unit MLtonThread.thread) t'),
							    (:=_1 (unit MLtonThread.thread) (t',
											     Dead[unit])))) of
		    Dead[unit] =>
		    (fail (thread) (Fail "switch to a Dead thread"))
		  | Interrupted[unit] t: thread => t
		  | New[unit] g: unit -> unit => (atomicBegin ()) ;(newThread g)
		  | Paused[unit] (f: (unit -> unit) -> unit, t: thread) =>
		    (f (fn x_1731: unit => case x_1731 of () => ())) ;t
	       val _ = (:=_1 (bool) (switching, false))
	       val _ = (switchTo primThread)
	   in
	      ((!_1 (unit -> 'a) r) ())
	   end)
val rec 'a_3977
   switch: ('a_3977 MLtonThread.t -> unit MLtonThread.t) -> 'a_3977 = 
      (fn x_1736: 'a_3977 MLtonThread.t -> unit MLtonThread.t =>
       case x_1736 of
	 (f: 'a_3977 MLtonThread.t -> unit MLtonThread.t) =>
	 (atomicBegin ()) ;(atomicSwitch ('a_3977) f))
val rec
   toPrimitive: unit MLtonThread.t -> thread = 
      (fn x_1737: unit MLtonThread.t =>
       case x_1737 of
	 (t: unit MLtonThread.t as T[unit] r: unit MLtonThread.thread ref) =>
	 case (!_1 (unit MLtonThread.thread) r) of
	   Dead[unit] => (die (thread) "Thread.toPrimitive saw Dead.\n")
	 | Interrupted[unit] t: thread =>
	   (:=_1 (unit MLtonThread.thread) (r, Dead[unit])) ;t
	 | New[unit] _ =>
	   (switch (thread) (fn x_1738: thread MLtonThread.t =>
			     case x_1738 of
			       cur: thread MLtonThread.t =>
			       (prepare (unit) ((prepend (unit, unit) (t,
								       (fn x_1739: unit =>
									case x_1739 of
									  () =>
									  (switch (unit) (fn x_1740: unit MLtonThread.t =>
											  case x_1740 of
											    t': unit MLtonThread.t =>
											    (prepare (thread) (cur,
													       (toPrimitive t')))))))),
						()))))
	 | Paused[unit] (f: (unit -> unit) -> unit, t: thread) =>
	   (:=_1 (unit MLtonThread.thread) (r, Dead[unit]))
	   ;(f (fn x_1741: unit =>
		case x_1741 of
		  () => ()))
	   ;t)
datatype MLtonThread.state = Normal
			     | InHandler
val register: int32 * (cpointer -> unit) -> unit =
   let val exports: (cpointer -> unit) array =
	  (array_0 (cpointer -> unit) ((toInt numExports),
				       (fn x_1746: cpointer =>
					case x_1746 of
					  _ => raise (Fail "undefined export"))))
       val worker: (thread * thread Primitive.Option.t ref) Primitive.Option.t ref =
	  (ref[(thread * thread Primitive.Option.t ref) Primitive.Option.t] NONE[thread
										 * thread Primitive.Option.t ref])
       val rec
	  mkWorker: unit -> thread * thread Primitive.Option.t ref = 
	     (fn x_1743: unit =>
	      case x_1743 of
		(()) =>
		let val thisWorker: (thread * thread Primitive.Option.t ref) Primitive.Option.t ref =
		       (ref[(thread * thread Primitive.Option.t ref) Primitive.Option.t] NONE[thread
											      * thread Primitive.Option.t ref])
		    val savedRef: thread Primitive.Option.t ref =
		       (ref[thread Primitive.Option.t] NONE[thread])
		    val rec 'a_3978
		       workerLoop: unit -> 'a_3978 = 
			  (fn x_1744: unit =>
			   case x_1744 of
			     (()) =>
			     let val p: cpointer = (getOpArgsResPtr ())
				 val _ = (atomicEnd ())
				 val i: int32 =
				    (getInt32 ((getPointer (p, 0x0)), 0x0))
				 val _ =
				    ((sub_9 (cpointer -> unit) (exports,
								(toInt i))) p)
				    handle x_1745 => case x_1745 of
						       e: exn =>
						       (output (stdErr,
								"Call from C to SML raised exception.\n"))
						       ;(topLevelHandler (unit) e)
				 val _ = (atomicBegin ())
				 val _ =
				    (:=_1 ((thread
					    * thread Primitive.Option.t ref) Primitive.Option.t) (worker,
												  (!_1 ((thread
													 * thread Primitive.Option.t ref) Primitive.Option.t) thisWorker)))
				 val _ =
				    (setSaved (gcState,
					       (valOf_1 (thread) (!_1 (thread Primitive.Option.t) savedRef))))
				 val _ =
				    (:=_1 (thread Primitive.Option.t) (savedRef,
								       NONE[thread]))
				 val _ = (returnToC ())
			     in
				(workerLoop ('a_3978) ())
			     end)
		    val workerThread: thread =
		       (toPrimitive (new (unit) workerLoop (unit)))
		    val _ =
		       (:=_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) (thisWorker,
											    (SOME[thread
												  * thread Primitive.Option.t ref] (workerThread,
																    savedRef))))
		in
		   (workerThread, savedRef)
		end)
       val rec
	  handlerLoop: unit -> unit = 
	     (fn x_1742: unit =>
	      case x_1742 of
		(()) =>
		let val saved: thread = (saved gcState)
		    val (workerThread: thread,
			 savedRef: thread Primitive.Option.t ref) =
		       case (!_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) worker) of
			 NONE[thread * thread Primitive.Option.t ref] =>
			 (mkWorker ())
		       | SOME[thread * thread Primitive.Option.t ref] (workerThread: thread,
								       savedRef: thread Primitive.Option.t ref) =>
			 (:=_1 ((thread * thread Primitive.Option.t ref) Primitive.Option.t) (worker,
											      NONE[thread
												   * thread Primitive.Option.t ref]))
			 ;(workerThread, savedRef)
		    val _ =
		       (:=_1 (thread Primitive.Option.t) (savedRef,
							  (SOME[thread] saved)))
		    val _ = (switchTo workerThread)
		in
		   (handlerLoop ())
		end)
       val handlerThread: thread = (toPrimitive (new (unit) handlerLoop))
       val _ = (setCallFromCHandler (gcState, handlerThread))
   in
      (fn x_1747: int32 * (cpointer -> unit) =>
       case x_1747 of
	 (i: int32, f: cpointer -> unit) =>
	 (update_0 (cpointer -> unit) (exports, i, f)))
   end
datatype MLtonSignal.Mask.t = AllBut of int32 list
			      | Some of int32 list
datatype MLtonSignal.Handler.t = Default
				 | Handler of unit MLtonThread.t
					      -> unit MLtonThread.t
				 | Ignore
				 | InvalidSignal
exception MisuseOfForget
exception DoublyRedirected
datatype 'use MLtonProcess.Child.childt = FileDesc of int32
					  | Stream of 'use * ('use -> unit)
					  | Term
datatype ('use, 'dir) MLtonProcess.Param.t = File of string
					     | FileDesc of int32
					     | Pipe
					     | Self
datatype ('stdin, 'stdout, 'stderr) MLtonProcess.t = T of {pid: int32,
							   status: PosixProcess.exit_status Primitive.Option.t ref,
							   stderr: 'stderr MLtonProcess.Child.childt ref,
							   stdin: 'stdin MLtonProcess.Child.childt ref,
							   stdout: 'stdout MLtonProcess.Child.childt ref}
datatype OS_IO.iodesc_kind = K of string
datatype OS_IO.poll_desc = PollDesc of int32 * {pri: bool, rd: bool, wr: bool}
datatype OS_IO.poll_info = PollInfo of int32 * {pri: bool, rd: bool, wr: bool}
exception Poll
datatype Timer.SysUsr.t = T of {sys: Time.time, usr: Time.time}
val hton: word16 -> word16 = htons
val ntoh: word16 -> word16 = ntohs
val hton: int16 -> int16 =
   (o_1 (int16, int16, word16) ((o_1 (word16, int16, word16) (idFromWord16ToInt16,
							      hton)),
				idFromInt16ToWord16))
val ntoh: int16 -> int16 =
   (o_1 (int16, int16, word16) ((o_1 (word16, int16, word16) (idFromWord16ToInt16,
							      ntoh)),
				idFromInt16ToWord16))
val ('a_4120, 'a_4119) fInt8: 'a_4120 -> 'a_4119 =
   (fn x_1748: 'a_4120 =>
    case x_1748 of
      _ => raise (Fail "Net.C_Int.hton: fInt8"))
val fInt16: int16 -> int16 = hton
val ('a_4122, 'a_4121) fInt64: 'a_4122 -> 'a_4121 =
   (fn x_1749: 'a_4122 =>
    case x_1749 of
      _ => raise (Fail "Net.C_Int.hton: fInt64"))
val fInt8_0: int8 -> int8 = fInt8 (int8, int8)
val fInt64_0: int64 -> int64 = fInt64 (int64, int64)
val _ = fInt8_0
val _ = fInt16
val _ = fInt64_0
val ('a_4126, 'a_4125) fInt8: 'a_4126 -> 'a_4125 =
   (fn x_1750: 'a_4126 =>
    case x_1750 of
      _ => raise (Fail "Net.C_Int.ntoh: fInt8"))
val fInt16: int16 -> int16 = ntoh
val ('a_4128, 'a_4127) fInt64: 'a_4128 -> 'a_4127 =
   (fn x_1751: 'a_4128 =>
    case x_1751 of
      _ => raise (Fail "Net.C_Int.ntoh: fInt64"))
val fInt8_1: int8 -> int8 = fInt8 (int8, int8)
val fInt64_1: int64 -> int64 = fInt64 (int64, int64)
val _ = fInt8_1
val _ = fInt16
val _ = fInt64_1
datatype NetHostDB.entry = T of {addrType: int32,
				 addrs: word8 vector list,
				 aliases: string list,
				 name: string}
datatype NetProtDB.entry = T of {aliases: string list,
				 name: string,
				 protocol: int32}
datatype NetServDB.entry = T of {aliases: string list,
				 name: string,
				 port: int32,
				 protocol: string}
datatype Socket.sock_addr = SA of word8 vector
datatype Socket.dgram = DGRAM
datatype Socket.stream = MODE
datatype Socket.passive = PASSIVE
datatype Socket.active = ACTIVE
datatype Socket.shutdown_mode = NO_RECVS
				| NO_SENDS
				| NO_RECVS_OR_SENDS
datatype INetSock.inet = INET
datatype UnixSock.unix = UNIX
datatype MLtonItimer.t = Prof
			 | Real
			 | Virtual
val register: int32 * (cpointer -> unit) -> unit = register
val rec
   thread_main: unit -> unit = 
      (fn x_1752: unit =>
       case x_1752 of
	 (()) => (print "hihi\n"))
val () =
   ((fn x_1753: unit -> unit =>
     case x_1753 of
       f: unit -> unit =>
       (register (0x0,
		  (fn x_1754: cpointer =>
		   case x_1754 of
		     p: cpointer =>
		     let val res: unit = (f ())
			 val none: unit = res
		     in
			()
		     end)))) thread_main)
val gcState: cpointer = gcState
val isOn: bool = isOn
datatype MLtonProfile.Data.t = T of {isCurrent: bool ref,
				     isFreed: bool ref,
				     raw: cpointer}
val all: MLtonProfile.Data.t list ref = (ref[MLtonProfile.Data.t list] [])
val rec 'a_4211
   make: ({isCurrent: bool ref, isFreed: bool ref, raw: cpointer} -> 'a_4211)
	 -> MLtonProfile.Data.t -> 'a_4211 = 
      (fn x_1755: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer}
		  -> 'a_4211 =>
       (fn x_1756: MLtonProfile.Data.t =>
	case (x_1755, x_1756) of
	  (f: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer} -> 'a_4211,
	   T r: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer}) =>
	  (f r)))
val raw: MLtonProfile.Data.t -> cpointer =
   (make (cpointer) (fn x_1757: {isCurrent: bool ref,
				 isFreed: bool ref,
				 raw: cpointer} =>
		     case x_1757 of
		       {raw = #: cpointer} => #))
val rec
   make: cpointer -> MLtonProfile.Data.t = 
      (fn x_1758: cpointer =>
       case x_1758 of
	 (raw: cpointer) =>
	 (T {isCurrent = (ref[bool] false),
	     isFreed = (ref[bool] false),
	     raw = raw}))
val rec
   write: MLtonProfile.Data.t * string -> unit = 
      (fn x_1759: MLtonProfile.Data.t * string =>
       case x_1759 of
	 ((T {isFreed = isFreed: bool ref, raw = raw: cpointer}, file: string)) =>
	 case (not isOn) of
	   true => ()
	 | false =>
	   case (!_1 (bool) isFreed) of
	     true => raise (Fail "write of freed profile data")
	   | false => (write (gcState, raw, (fromString (nullTerm file)))))
val r: MLtonProfile.Data.t ref = (ref[MLtonProfile.Data.t] (make dummy))
val rec
   current: unit -> MLtonProfile.Data.t = 
      (fn x_1760: unit =>
       case x_1760 of
	 (()) => (!_1 (MLtonProfile.Data.t) r))
val rec
   setCurrent: MLtonProfile.Data.t -> unit = 
      (fn x_1761: MLtonProfile.Data.t =>
       case x_1761 of
	 (d: MLtonProfile.Data.t as T {isCurrent = isCurrent: bool ref,
				       isFreed = isFreed: bool ref,
				       raw = raw: cpointer}) =>
	 case (not isOn) of
	   true => ()
	 | false =>
	   case (!_1 (bool) isFreed) of
	     true => raise (Fail "setCurrent of freed profile data")
	   | false =>
	     let val T {isCurrent = ic: bool ref} = (current ())
		 val _ = (:=_1 (bool) (ic, false))
		 val _ = (:=_1 (bool) (isCurrent, true))
		 val _ = (:=_1 (MLtonProfile.Data.t) (r, d))
		 val _ = (setCurrent (gcState, raw))
	     in
		()
	     end)
val rec
   init: unit -> unit = 
      (fn x_1762: unit =>
       case x_1762 of
	 (()) => (setCurrent (make (getCurrent gcState))))
val _ =
   case (not isOn) of
     true => ()
   | false =>
     let val _ =
	    (addNew_0 (atExit,
		       (fn x_1764: unit =>
			case x_1764 of
			  () =>
			  (done gcState)
			  ;(write ((current ()), "mlmon.out"))
			  ;((app_0 (MLtonProfile.Data.t) (fn x_1765: MLtonProfile.Data.t =>
							  case x_1765 of
							    d: MLtonProfile.Data.t =>
							    (free (gcState,
								   (raw d))))) (!_1 (MLtonProfile.Data.t list) all)))))
	 val _ =
	    (addNew_0 (atLoadWorld,
		       (fn x_1763: unit =>
			case x_1763 of
			  () =>
			  (:=_1 (MLtonProfile.Data.t list) (all, [])) ;(init ()))))
     in
	(init ())
     end
datatype 'a MLtonFinalizable.t = T of {afters: (unit -> unit) list ref,
				       finalizers: ('a -> unit) list ref,
				       value: 'a ref}
datatype MLtonWorld.status = Clone
			     | Original
val _ =
   (setHandler defaultTopLevelHandler (unit))
   ;(setSuffix defaultTopLevelSuffix (unit))
exception UNKNOWN
datatype SMLofNJ.SysInfo.os_kind = BEOS
				   | MACOS
				   | OS2
				   | UNIX
				   | WIN32
val a: int32 = 0x2468
